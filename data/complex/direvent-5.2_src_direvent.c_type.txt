const	O
char	O
*	O
program_name	*(char)
;	O
const	O
char	O
*	O
conffile	*(char)
=	O
DEFAULT_CONFFILE	O
;	O
int	O
foreground	int
;	O
char	O
*	O
self_test_prog	*(char)
;	O
char	O
*	O
tag	*(char)
;	O
int	O
facility	int
=	O
-	O
1	int
;	O
int	O
syslog_include_prio	int
;	O
int	O
debug_level	int
;	O
char	O
*	O
pidfile	*(char)
=	O
NULL	O
;	O
char	O
*	O
user	*(char)
=	O
NULL	O
;	O
int	O
log_to_stderr	int
=	O
LOG_DEBUG	int
;	O
const	O
char	O
*	O
severity	(int)->(*(char))
(	O
int	O
prio	int
)	O
{	O
switch	O
(	O
prio	int
)	O
{	O
case	O
LOG_EMERG	int
:	O
return	O
"EMERG"	*(char)
;	O
case	O
LOG_ALERT	int
:	O
return	O
"ALERT"	*(char)
;	O
case	O
LOG_CRIT	int
:	O
return	O
"CRIT"	*(char)
;	O
case	O
LOG_ERR	int
:	O
return	O
"ERROR"	*(char)
;	O
case	O
LOG_WARNING	int
:	O
return	O
"WARNING"	*(char)
;	O
case	O
LOG_NOTICE	int
:	O
return	O
"NOTICE"	*(char)
;	O
case	O
LOG_INFO	int
:	O
return	O
"INFO"	*(char)
;	O
case	O
LOG_DEBUG	int
:	O
return	O
"DEBUG"	*(char)
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
vdiag	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
int	O
prio	int
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
const	O
char	O
*	O
s	*(char)
;	O
va_list	array(struct(int,int,*(void),*(void)))
tmp	array(struct(int,int,*(void),*(void)))
;	O
if	O
(	O
log_to_stderr	int
>=	O
prio	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
program_name	*(char)
)	O
;	O
s	*(char)
=	O
severity	(int)->(*(char))
(	O
prio	int
)	O
;	O
if	O
(	O
s	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"[%s] "	*(char)
,	O
s	*(char)
)	O
;	O
va_copy	O
(	O
tmp	array(struct(int,int,*(void),*(void)))
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
tmp	array(struct(int,int,*(void),*(void)))
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
va_end	O
(	O
tmp	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
if	O
(	O
facility	int
>	O
0	int
)	O
{	O
if	O
(	O
syslog_include_prio	int
&&	O
(	O
s	*(char)
=	O
severity	(int)->(*(char))
(	O
prio	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
static	O
char	O
*	O
fmtbuf	*(char)
;	O
static	O
size_t	long
fmtsize	long
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
fmt	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
+	O
4	int
;	O
char	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
if	O
(	O
len	long
>	O
fmtsize	long
)	O
{	O
fmtbuf	*(char)
=	O
erealloc	(*(void),long)->(*(void))
(	O
fmtbuf	*(char)
,	O
len	long
)	O
;	O
fmtsize	long
=	O
len	long
;	O
}	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
fmtbuf	*(char)
;	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
++	O
=	O
'['	O
;	O
while	O
(	O
*	O
s	*(char)
)	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
++	O
=	O
*	O
s	*(char)
++	O
;	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
++	O
=	O
']'	O
;	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
++	O
=	O
' '	O
;	O
while	O
(	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
++	O
=	O
*	O
fmt	*(char)
++	O
)	O
;	O
vsyslog	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
prio	int
,	O
fmtbuf	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
else	O
vsyslog	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
prio	int
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
}	O
void	O
diag	(int,*(char))->(void)
(	O
int	O
prio	int
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vdiag	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
prio	int
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
debugprt	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vdiag	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
LOG_DEBUG	int
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
*	O
emalloc	(long)->(*(void))
(	O
size_t	long
size	long
)	O
{	O
void	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
!	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
_	O
(	O
"not enough memory"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
return	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
}	O
void	O
*	O
ecalloc	(long,long)->(*(void))
(	O
size_t	long
nmemb	long
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
calloc	(long,long)->(*(void))
(	O
nmemb	long
,	O
size	long
)	O
;	O
if	O
(	O
!	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
"not enough memory"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
return	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
}	O
void	O
*	O
erealloc	(*(void),long)->(*(void))
(	O
void	O
*	O
ptr	*(void)
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
realloc	(*(void),long)->(*(void))
(	O
ptr	*(void)
,	O
size	long
)	O
;	O
if	O
(	O
!	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
_	O
(	O
"not enough memory"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
return	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
}	O
char	O
*	O
estrdup	(*(char))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
;	O
char	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
emalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
,	O
str	*(char)
,	O
len	long
)	O
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
[	O
len	long
]	O
=	O
0	int
;	O
return	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
}	O
char	O
*	O
mkfilename	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
dir	*(char)
,	O
const	O
char	O
*	O
file	*(char)
)	O
{	O
char	O
*	O
tmp	array(struct(int,int,*(void),*(void)))
;	O
size_t	long
dirlen	long
=	O
strlen	(*(char))->(long)
(	O
dir	*(char)
)	O
;	O
size_t	long
fillen	long
=	O
strlen	(*(char))->(long)
(	O
file	*(char)
)	O
;	O
size_t	long
len	long
;	O
if	O
(	O
!	O
file	*(char)
||	O
file	*(char)
[	O
0	int
]	O
==	O
0	int
)	O
return	O
strdup	(*(char))->(*(char))
(	O
dir	*(char)
)	O
;	O
while	O
(	O
dirlen	long
>	O
0	int
&&	O
dir	*(char)
[	O
dirlen	long
-	O
1	int
]	O
==	O
'/'	O
)	O
dirlen	long
--	O
;	O
len	long
=	O
dirlen	long
+	O
(	O
dir	*(char)
[	O
0	int
]	O
?	O
1	int
:	O
0	int
)	O
+	O
fillen	long
;	O
tmp	array(struct(int,int,*(void),*(void)))
=	O
malloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
tmp	array(struct(int,int,*(void),*(void)))
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tmp	array(struct(int,int,*(void),*(void)))
,	O
dir	*(char)
,	O
dirlen	long
)	O
;	O
if	O
(	O
dir	*(char)
[	O
0	int
]	O
)	O
tmp	array(struct(int,int,*(void),*(void)))
[	O
dirlen	long
++	O
]	O
=	O
'/'	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tmp	array(struct(int,int,*(void),*(void)))
+	O
dirlen	long
,	O
file	*(char)
,	O
fillen	long
)	O
;	O
tmp	array(struct(int,int,*(void),*(void)))
[	O
len	long
]	O
=	O
0	int
;	O
}	O
return	O
tmp	array(struct(int,int,*(void),*(void)))
;	O
}	O
int	O
trans_strtotok	(*(struct(*(char),int)),*(char),*(int))->(int)
(	O
struct	O
transtab	struct(*(char),int)
*	O
tab	*(struct(*(char),int))
,	O
const	O
char	O
*	O
str	*(char)
,	O
int	O
*	O
ret	*(int)
)	O
{	O
for	O
(	O
;	O
tab	*(struct(*(char),int))
->	O
name	*(char)
;	O
tab	*(struct(*(char),int))
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tab	*(struct(*(char),int))
->	O
name	*(char)
,	O
str	*(char)
)	O
==	O
0	int
)	O
{	O
*	O
ret	*(int)
=	O
tab	*(struct(*(char),int))
->	O
tok	int
;	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
char	O
*	O
trans_toktostr	(*(struct(*(char),int)),int)->(*(char))
(	O
struct	O
transtab	struct(*(char),int)
*	O
tab	*(struct(*(char),int))
,	O
int	O
tok	int
)	O
{	O
for	O
(	O
;	O
tab	*(struct(*(char),int))
->	O
name	*(char)
;	O
tab	*(struct(*(char),int))
++	O
)	O
if	O
(	O
tab	*(struct(*(char),int))
->	O
tok	int
==	O
tok	int
)	O
return	O
tab	*(struct(*(char),int))
->	O
name	*(char)
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
trans_toknext	(*(struct(*(char),int)),int,*(int))->(*(char))
(	O
struct	O
transtab	struct(*(char),int)
*	O
tab	*(struct(*(char),int))
,	O
int	O
tok	int
,	O
int	O
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
tab	*(struct(*(char),int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
tab	*(struct(*(char),int))
[	O
i	int
]	O
.	O
tok	int
&	O
tok	int
)	O
{	O
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
i	int
+	O
1	int
;	O
return	O
tab	*(struct(*(char),int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
}	O
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
i	int
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
trans_tokfirst	(*(struct(*(char),int)),int,*(int))->(*(char))
(	O
struct	O
transtab	struct(*(char),int)
*	O
tab	*(struct(*(char),int))
,	O
int	O
tok	int
,	O
int	O
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
{	O
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
0	int
;	O
return	O
trans_toknext	(*(struct(*(char),int)),int,*(int))->(*(char))
(	O
tab	*(struct(*(char),int))
,	O
tok	int
,	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
;	O
}	O
static	O
void	O
set_program_name	(*(char))->(void)
(	O
const	O
char	O
*	O
arg	*(char)
)	O
{	O
char	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
strrchr	(*(char),int)->(*(char))
(	O
arg	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
program_name	*(char)
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
+	O
1	int
;	O
else	O
program_name	*(char)
=	O
arg	*(char)
;	O
}	O
void	O
signal_setup	(*((int)->(void)))->(void)
(	O
void	O
(	O
*	O
sf	*((int)->(void))
)	O
(	O
int	O
)	O
)	O
{	O
static	O
int	O
sigv	*(int)
[	O
]	O
=	O
{	O
SIGTERM	int
,	O
SIGQUIT	int
,	O
SIGINT	int
,	O
SIGHUP	int
,	O
SIGALRM	int
,	O
SIGUSR1	int
,	O
SIGUSR1	int
,	O
SIGCHLD	int
}	O
;	O
sigv_set_all	(*((int)->(void)),int,*(int),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(int)
(	O
sf	*((int)->(void))
,	O
NITEMS	O
(	O
sigv	*(int)
)	O
,	O
sigv	*(int)
,	O
NULL	O
)	O
;	O
}	O
void	O
storepid	(*(char))->(void)
(	O
const	O
char	O
*	O
pidfile	*(char)
)	O
{	O
FILE	struct
*	O
fp	*(struct)
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pidfile	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
fp	*(struct)
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
_	O
(	O
"cannot open pidfile %s for writing: %s"	*(char)
)	O
,	O
pidfile	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct)
,	O
"%lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
getpid	()->(int)
(	O
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct)
)	O
;	O
}	O
}	O
static	O
int	O
membergid	(int,long,*(int))->(int)
(	O
gid_t	int
gid	int
,	O
size_t	long
gc	long
,	O
gid_t	int
*	O
gv	*(int)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gc	long
;	O
i	int
++	O
)	O
if	O
(	O
gv	*(int)
[	O
i	int
]	O
==	O
gid	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
get_user_groups	(int,*(long),*(*(int)))->(void)
(	O
uid_t	int
uid	int
,	O
size_t	long
*	O
pgidc	*(long)
,	O
gid_t	int
*	O
*	O
pgidv	*(*(int))
)	O
{	O
size_t	long
gidc	long
=	O
0	int
,	O
n	long
=	O
0	int
;	O
gid_t	int
*	O
gidv	*(int)
=	O
NULL	O
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
struct	O
group	struct(*(char),*(char),int,*(*(char)))
*	O
gr	*(struct(*(char),*(char),int,*(*(char))))
;	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
uid	int
)	O
;	O
if	O
(	O
!	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
0	int
,	O
_	O
(	O
"no user with UID %lu"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
uid	int
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
n	long
=	O
32	int
;	O
gidv	*(int)
=	O
ecalloc	(long,long)->(*(void))
(	O
n	long
,	O
sizeof	O
(	O
gidv	*(int)
[	O
0	int
]	O
)	O
)	O
;	O
gidv	*(int)
[	O
0	int
]	O
=	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_gid	int
;	O
gidc	long
=	O
1	int
;	O
setgrent	()->(void)
(	O
)	O
;	O
while	O
(	O
gr	*(struct(*(char),*(char),int,*(*(char))))
=	O
getgrent	()->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
)	O
)	O
{	O
char	O
*	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
for	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
gr	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_mem	*(*(char))
;	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
,	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
n	long
==	O
gidc	long
)	O
{	O
n	long
+=	O
32	int
;	O
gidv	*(int)
=	O
erealloc	(*(void),long)->(*(void))
(	O
gidv	*(int)
,	O
n	long
*	O
sizeof	O
(	O
gidv	*(int)
[	O
0	int
]	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
membergid	(int,long,*(int))->(int)
(	O
gr	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_gid	int
,	O
gidc	long
,	O
gidv	*(int)
)	O
)	O
gidv	*(int)
[	O
gidc	long
++	O
]	O
=	O
gr	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_gid	int
;	O
}	O
}	O
endgrent	()->(void)
(	O
)	O
;	O
*	O
pgidc	*(long)
=	O
gidc	long
;	O
*	O
pgidv	*(*(int))
=	O
gidv	*(int)
;	O
}	O
void	O
setuser	(*(char))->(void)
(	O
const	O
char	O
*	O
user	*(char)
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
size_t	long
gidc	long
;	O
gid_t	int
*	O
gidv	*(int)
;	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
user	*(char)
)	O
;	O
if	O
(	O
!	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
"getpwnam(%s): %s"	*(char)
,	O
user	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
if	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
==	O
0	int
)	O
return	O
;	O
get_user_groups	(int,*(long),*(*(int)))->(void)
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
,	O
&	O
gidc	long
,	O
&	O
gidv	*(int)
)	O
;	O
if	O
(	O
setgroups	(long,*(int))->(int)
(	O
gidc	long
,	O
gidv	*(int)
)	O
<	O
0	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
"setgroups: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
free	(*(void))->(void)
(	O
gidv	*(int)
)	O
;	O
if	O
(	O
setgid	(int)->(int)
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_gid	int
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
"setgid(%lu): %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_gid	int
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
if	O
(	O
setuid	(int)->(int)
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
"setuid(%lu): %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
}	O
void	O
ev_log	(int,*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
int	O
flags	int
,	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
dp	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
{	O
int	O
i	int
;	O
char	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
if	O
(	O
debug_level	int
>	O
0	int
)	O
{	O
for	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
trans_tokfirst	(*(struct(*(char),int)),int,*(int))->(*(char))
(	O
sysev_transtab	array(struct(*(char),int))
,	O
flags	int
,	O
&	O
i	int
)	O
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
trans_toknext	(*(struct(*(char),int)),int,*(int))->(*(char))
(	O
sysev_transtab	array(struct(*(char),int))
,	O
flags	int
,	O
&	O
i	int
)	O
)	O
debug	O
(	O
1	int
,	O
(	O
"%s: %s"	*(char)
,	O
dp	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
)	O
;	O
}	O
}	O
void	O
genev_init	()->(void)
(	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
genev_xlat	array(struct(int,int))
[	O
i	int
]	O
.	O
gen_mask	int
;	O
i	int
++	O
)	O
defevt	(*(char),*(struct(int,int)),int)->(int)
(	O
trans_toktostr	(*(struct(*(char),int)),int)->(*(char))
(	O
genev_transtab	array(struct(*(char),int))
,	O
genev_xlat	array(struct(int,int))
[	O
i	int
]	O
.	O
gen_mask	int
)	O
,	O
&	O
genev_xlat	array(struct(int,int))
[	O
i	int
]	O
,	O
0	int
)	O
;	O
}	O
int	O
signo	int
=	O
0	int
;	O
int	O
stop	int
=	O
0	int
;	O
pid_t	int
self_test_pid	int
;	O
int	O
exit_code	int
=	O
0	int
;	O
void	O
sigmain	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
signo	int
=	O
sig	int
;	O
switch	O
(	O
signo	int
)	O
{	O
case	O
SIGCHLD	int
:	O
case	O
SIGALRM	int
:	O
break	O
;	O
default	O
:	O
stop	int
=	O
1	int
;	O
}	O
}	O
void	O
self_test	()->(void)
(	O
)	O
{	O
pid_t	int
pid	int
;	O
char	O
*	O
args	array(*(char))
[	O
4	int
]	O
;	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
(	O
pid_t	int
)	O
-	O
1	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
_	O
(	O
"cannot run `%s': fork failed: %s"	*(char)
)	O
,	O
self_test_prog	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
if	O
(	O
pid	int
!=	O
0	int
)	O
{	O
self_test_pid	int
=	O
pid	int
;	O
return	O
;	O
}	O
args	array(*(char))
[	O
0	int
]	O
=	O
"/bin/sh"	*(char)
;	O
args	array(*(char))
[	O
1	int
]	O
=	O
"-c"	*(char)
;	O
args	array(*(char))
[	O
2	int
]	O
=	O
self_test_prog	*(char)
;	O
args	array(*(char))
[	O
3	int
]	O
=	O
NULL	O
;	O
execv	(*(char),array(*(char)))->(int)
(	O
args	array(*(char))
[	O
0	int
]	O
,	O
args	array(*(char))
)	O
;	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"execv: %s: %s"	*(char)
,	O
self_test_prog	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
_exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
static	O
int	O
opt_debug_level	int
=	O
0	int
;	O
static	O
int	O
opt_foreground	int
=	O
0	int
;	O
static	O
char	O
*	O
opt_pidfile	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
opt_user	*(char)
=	O
NULL	O
;	O
static	O
int	O
opt_facility	int
=	O
-	O
1	int
;	O
static	O
int	O
lint_only	int
=	O
0	int
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
i	int
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
tag	*(char)
=	O
estrdup	(*(char))->(*(char))
(	O
program_name	*(char)
)	O
;	O
genev_init	()->(void)
(	O
)	O
;	O
config_init	()->(void)
(	O
)	O
;	O
parse_options	(int,array(*(char)),*(int))->(void)
(	O
argc	int
,	O
argv	*(*(char))
,	O
&	O
i	int
)	O
;	O
argc	int
-=	O
i	int
;	O
argv	*(*(char))
+=	O
i	int
;	O
switch	O
(	O
argc	int
)	O
{	O
default	O
:	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
case	O
1	int
:	O
conffile	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
}	O
config_parse	(*(char))->(void)
(	O
conffile	*(char)
)	O
;	O
if	O
(	O
lint_only	int
)	O
return	O
0	int
;	O
if	O
(	O
opt_debug_level	int
)	O
debug_level	int
+=	O
opt_debug_level	int
;	O
if	O
(	O
opt_foreground	int
)	O
foreground	int
=	O
opt_foreground	int
;	O
if	O
(	O
opt_pidfile	*(char)
)	O
pidfile	*(char)
=	O
opt_pidfile	*(char)
;	O
if	O
(	O
opt_facility	int
!=	O
-	O
1	int
)	O
facility	int
=	O
opt_facility	int
;	O
if	O
(	O
!	O
foreground	int
&&	O
facility	int
<=	O
0	int
)	O
facility	int
=	O
LOG_DAEMON	O
;	O
if	O
(	O
opt_user	*(char)
)	O
user	*(char)
=	O
opt_user	*(char)
;	O
if	O
(	O
facility	int
>	O
0	int
)	O
{	O
openlog	(*(char),int,int)->(void)
(	O
tag	*(char)
,	O
LOG_PID	int
,	O
facility	int
)	O
;	O
grecs_log_to_stderr	int
=	O
0	int
;	O
}	O
if	O
(	O
foreground	int
)	O
setup_watchers	()->(void)
(	O
)	O
;	O
else	O
{	O
if	O
(	O
detach	(*(()->(void)))->(int)
(	O
setup_watchers	()->(void)
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
"daemon: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
log_to_stderr	int
=	O
-	O
1	int
;	O
}	O
diag	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
_	O
(	O
"%s %s started"	*(char)
)	O
,	O
program_name	*(char)
,	O
VERSION	*(char)
)	O
;	O
if	O
(	O
pidfile	*(char)
)	O
storepid	(*(char))->(void)
(	O
pidfile	*(char)
)	O
;	O
if	O
(	O
user	*(char)
&&	O
getuid	()->(int)
(	O
)	O
==	O
0	int
)	O
setuser	(*(char))->(void)
(	O
user	*(char)
)	O
;	O
signal_setup	(*((int)->(void)))->(void)
(	O
sigmain	(int)->(void)
)	O
;	O
if	O
(	O
self_test_prog	*(char)
)	O
self_test	()->(void)
(	O
)	O
;	O
while	O
(	O
!	O
stop	int
&&	O
sysev_select	()->(int)
(	O
)	O
==	O
0	int
)	O
{	O
process_timeouts	()->(void)
(	O
)	O
;	O
process_cleanup	(int)->(void)
(	O
0	int
)	O
;	O
watchpoint_gc	()->(void)
(	O
)	O
;	O
}	O
shutdown_watchers	()->(void)
(	O
)	O
;	O
diag	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
_	O
(	O
"%s %s stopped"	*(char)
)	O
,	O
program_name	*(char)
,	O
VERSION	*(char)
)	O
;	O
if	O
(	O
pidfile	*(char)
)	O
unlink	(*(char))->(int)
(	O
pidfile	*(char)
)	O
;	O
return	O
exit_code	int
;	O
}	O
