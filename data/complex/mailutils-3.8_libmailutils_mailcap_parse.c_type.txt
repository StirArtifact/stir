static	O
int	O
create_entry	(*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*`,int,int),struct(*`,int,int)))),*(char),*(*(struct(*(char),*(char),*(struct`),*(struct`)))))->(int)
(	O
mu_mailcap_t	*(struct)
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
,	O
char	O
*	O
input	*(char)
,	O
mu_mailcap_entry_t	*(struct)
*	O
pent	*(*(struct))
)	O
{	O
mu_mailcap_entry_t	*(struct)
ent	*(struct)
;	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
int	O
rc	int
;	O
size_t	long
i	long
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_delim	*(char)
=	O
";"	*(char)
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_escape	array(*(char))
[	O
0	int
]	O
=	O
";\\"	*(char)
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_escape	array(*(char))
[	O
1	int
]	O
=	O
""	*(char)
;	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
input	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_DELIM	O
|	O
MU_WRDSF_NOCMD	O
|	O
MU_WRDSF_NOVAR	O
|	O
MU_WRDSF_WS	O
|	O
MU_WRDSF_ESCAPE	O
)	O
)	O
{	O
if	O
(	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
.	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
)	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
.	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
(	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
.	O
data	*(void)
,	O
&	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
return	O
MU_ERR_FAILURE	O
;	O
}	O
if	O
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
<	O
2	int
)	O
{	O
if	O
(	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
.	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
)	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
.	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
(	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
.	O
data	*(void)
,	O
&	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"not enough fields"	*(char)
)	O
)	O
;	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
return	O
MU_ERR_PARSE	O
;	O
}	O
rc	int
=	O
mu_mailcap_entry_create	(*(*(struct)),*(char),*(char))->(int)
(	O
&	O
ent	*(struct)
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
for	O
(	O
i	long
=	O
2	int
;	O
i	long
<	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	long
]	O
,	O
'='	O
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
*	O
p	*(char)
++	O
=	O
0	int
;	O
rc	int
=	O
mu_mailcap_entry_set_string	(*(struct),*(char),*(char))->(int)
(	O
ent	*(struct)
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	long
]	O
,	O
p	*(char)
)	O
;	O
}	O
else	O
rc	int
=	O
mu_mailcap_entry_set_bool	(*(struct),*(char))->(int)
(	O
ent	*(struct)
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	long
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
}	O
}	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
flags	int
&	O
MU_MAILCAP_FLAG_LOCUS	int
)	O
{	O
ent	*(struct)
->	O
lrp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
ent	*(struct)
->	O
lrp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
ent	*(struct)
->	O
lrp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
mu_locus_range_init	(*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
ent	*(struct)
->	O
lrp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
rc	int
=	O
mu_locus_range_copy	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
ent	*(struct)
->	O
lrp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
&	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
else	O
rc	int
=	O
errno	O
;	O
}	O
}	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
.	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
)	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
.	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
(	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
error	*((*(void),*(struct(struct(*`,int,int),struct(*`,int,int))),*(char))->(void))
.	O
data	*(void)
,	O
&	O
mp	*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*(char),int,int),struct(*(char),int,int))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_mailcap_entry_destroy	(*(*(struct)))->(void)
(	O
&	O
ent	*(struct)
)	O
;	O
}	O
else	O
*	O
pent	*(*(struct))
=	O
ent	*(struct)
;	O
return	O
rc	int
;	O
}	O
int	O
mu_mailcap_parse	(*(struct),*(struct),*(struct(*(char),int,int)))->(int)
(	O
mu_mailcap_t	*(struct)
mailcap	*(struct)
,	O
mu_stream_t	*(struct)
input	*(char)
,	O
struct	O
mu_locus_point	struct(*(char),int,int)
const	O
*	O
pt	*(struct(*(char),int,int))
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
buffer	*(char)
=	O
NULL	O
;	O
size_t	long
bufsize	long
=	O
0	int
;	O
size_t	long
nread	long
;	O
mu_opool_t	*(struct)
acc	*(struct)
=	O
NULL	O
;	O
mu_stream_t	*(struct)
flt	*(struct)
;	O
const	O
char	O
*	O
argv	*(*(char))
[	O
]	O
=	O
{	O
"inline-comment"	*(char)
,	O
"#"	*(char)
,	O
"-i"	*(char)
,	O
"#"	*(char)
,	O
NULL	O
}	O
;	O
int	O
err	*(struct(*((*(void),*(struct`),*(char))->(void)),*(void),*((*(void))->(void))))
=	O
0	int
;	O
rc	int
=	O
mu_filter_create_args	(*(*(struct)),*(struct),*(char),int,*(*(char)),int,int)->(int)
(	O
&	O
flt	*(struct)
,	O
input	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
MU_ARRAY_SIZE	O
(	O
argv	*(*(char))
)	O
-	O
1	int
,	O
argv	*(*(char))
,	O
MU_FILTER_DECODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_locus_range_init	(*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
&	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
if	O
(	O
pt	*(struct(*(char),int,int))
)	O
{	O
mu_locus_point_copy	(*(struct(*(char),int,int)),*(struct(*(char),int,int)))->(int)
(	O
&	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
,	O
pt	*(struct(*(char),int,int))
)	O
;	O
mu_locus_point_copy	(*(struct(*(char),int,int)),*(struct(*(char),int,int)))->(int)
(	O
&	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
,	O
pt	*(struct(*(char),int,int))
)	O
;	O
}	O
while	O
(	O
(	O
rc	int
=	O
mu_stream_getline	(*(struct),*(*(char)),*(long),*(long))->(int)
(	O
flt	*(struct)
,	O
&	O
buffer	*(char)
,	O
&	O
bufsize	long
,	O
&	O
nread	long
)	O
)	O
==	O
0	int
)	O
{	O
mu_mailcap_entry_t	*(struct)
entry	*(*(struct))
;	O
int	O
cont	int
=	O
acc	*(struct)
&&	O
mu_opool_size	(*(struct))->(long)
(	O
acc	*(struct)
)	O
>	O
0	int
;	O
if	O
(	O
nread	long
>	O
0	int
)	O
{	O
buffer	*(char)
[	O
--	O
nread	long
]	O
=	O
0	int
;	O
if	O
(	O
buffer	*(char)
[	O
0	int
]	O
==	O
'#'	O
)	O
{	O
unsigned	O
long	O
n	long
;	O
char	O
*	O
p	*(char)
;	O
errno	O
=	O
0	int
;	O
n	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
buffer	*(char)
+	O
2	int
,	O
&	O
p	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
errno	O
==	O
0	int
&&	O
(	O
*	O
p	*(char)
==	O
0	int
||	O
mu_isspace	O
(	O
*	O
p	*(char)
)	O
)	O
)	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_line	int
=	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
.	O
mu_line	int
=	O
n	long
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
nread	long
&&	O
buffer	*(char)
[	O
nread	long
-	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
if	O
(	O
--	O
nread	long
>	O
0	int
)	O
{	O
if	O
(	O
!	O
acc	*(struct)
)	O
{	O
rc	int
=	O
mu_opool_create	(*(*(struct)),int)->(int)
(	O
&	O
acc	*(struct)
,	O
MU_OPOOL_DEFAULT	int
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
}	O
rc	int
=	O
mu_opool_append	(*(struct),*(void),long)->(int)
(	O
acc	*(struct)
,	O
buffer	*(char)
,	O
nread	long
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
}	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
.	O
mu_line	int
++	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
cont	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
rc	int
=	O
mu_opool_append	(*(struct),*(void),long)->(int)
(	O
acc	*(struct)
,	O
buffer	*(char)
,	O
nread	long
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
rc	int
=	O
mu_opool_append_char	(*(struct),char)->(int)
(	O
acc	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
p	*(char)
=	O
mu_opool_finish	(*(struct),*(long))->(*(void))
(	O
acc	*(struct)
,	O
NULL	O
)	O
;	O
rc	int
=	O
create_entry	(*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*`,int,int),struct(*`,int,int)))),*(char),*(*(struct(*(char),*(char),*(struct`),*(struct`)))))->(int)
(	O
mailcap	*(struct)
,	O
p	*(char)
,	O
&	O
entry	*(*(struct))
)	O
;	O
mu_opool_clear	(*(struct))->(void)
(	O
acc	*(struct)
)	O
;	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_line	int
=	O
++	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
.	O
mu_line	int
;	O
}	O
else	O
if	O
(	O
nread	long
==	O
0	int
)	O
{	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_line	int
=	O
++	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
.	O
mu_line	int
;	O
continue	O
;	O
}	O
else	O
{	O
rc	int
=	O
create_entry	(*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*`,int,int),struct(*`,int,int)))),*(char),*(*(struct(*(char),*(char),*(struct`),*(struct`)))))->(int)
(	O
mailcap	*(struct)
,	O
buffer	*(char)
,	O
&	O
entry	*(*(struct))
)	O
;	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_line	int
=	O
++	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
.	O
mu_line	int
;	O
}	O
}	O
else	O
if	O
(	O
cont	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
rc	int
=	O
mu_opool_append_char	(*(struct),char)->(int)
(	O
acc	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
p	*(char)
=	O
mu_opool_finish	(*(struct),*(long))->(*(void))
(	O
acc	*(struct)
,	O
NULL	O
)	O
;	O
rc	int
=	O
create_entry	(*(struct(int,*(struct),struct(*((*`,*`)->(int)),*(void),*((*`)->(void))),struct(*((*`,*`,*`)->(void)),*(void),*((*`)->(void))),struct(struct(*`,int,int),struct(*`,int,int)))),*(char),*(*(struct(*(char),*(char),*(struct`),*(struct`)))))->(int)
(	O
mailcap	*(struct)
,	O
p	*(char)
,	O
&	O
entry	*(*(struct))
)	O
;	O
mu_opool_clear	(*(struct))->(void)
(	O
acc	*(struct)
)	O
;	O
}	O
else	O
break	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
mailcap	*(struct)
->	O
selector	*((*(struct),*(void))->(int))
.	O
selector	*((*(struct),*(void))->(int))
&&	O
mailcap	*(struct)
->	O
selector	*((*(struct),*(void))->(int))
.	O
selector	*((*(struct),*(void))->(int))
(	O
entry	*(*(struct))
,	O
mailcap	*(struct)
->	O
selector	*((*(struct),*(void))->(int))
.	O
data	*(void)
)	O
!=	O
0	int
)	O
{	O
mu_mailcap_entry_destroy	(*(*(struct)))->(void)
(	O
&	O
entry	*(*(struct))
)	O
;	O
}	O
else	O
{	O
mu_list_append	(*(struct),*(void))->(int)
(	O
mailcap	*(struct)
->	O
elist	*(struct)
,	O
entry	*(*(struct))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
rc	int
==	O
MU_ERR_PARSE	O
)	O
err	*(struct(*((*(void),*(struct`),*(char))->(void)),*(void),*((*(void))->(void))))
=	O
1	int
;	O
else	O
break	O
;	O
}	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
flt	*(struct)
)	O
;	O
mu_locus_range_deinit	(*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
&	O
mailcap	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
mu_opool_destroy	(*(*(struct)))->(void)
(	O
&	O
acc	*(struct)
)	O
;	O
if	O
(	O
rc	int
&&	O
err	*(struct(*((*(void),*(struct`),*(char))->(void)),*(void),*((*(void))->(void))))
)	O
rc	int
=	O
MU_ERR_PARSE	O
;	O
return	O
rc	int
;	O
}	O
