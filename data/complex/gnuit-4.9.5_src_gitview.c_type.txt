char	O
built_in	array(array(char))
[	O
BUILTIN_OPERATIONS	int
]	O
[	O
MAX_BUILTIN_NAME	int
]	O
=	O
{	O
"previous-line"	*(char)
,	O
"next-line"	*(char)
,	O
"scroll-down"	*(char)
,	O
"scroll-up"	*(char)
,	O
"beginning-of-file"	*(char)
,	O
"end-of-file"	*(char)
,	O
"refresh"	*(char)
,	O
"exit"	*(char)
,	O
"hard-refresh"	*(char)
,	O
"backspace"	*(char)
,	O
"action"	*(char)
,	O
}	O
;	O
static	O
char	O
*	O
ViewerFields	array(*(char))
[	O
VIEWER_FIELDS	int
]	O
=	O
{	O
"TitleForeground"	*(char)
,	O
"TitleBackground"	*(char)
,	O
"TitleBrightness"	*(char)
,	O
"HeaderForeground"	*(char)
,	O
"HeaderBackground"	*(char)
,	O
"HeaderBrightness"	*(char)
,	O
"ScreenForeground"	*(char)
,	O
"ScreenBackground"	*(char)
,	O
"ScreenBrightness"	*(char)
,	O
"StatusForeground"	*(char)
,	O
"StatusBackground"	*(char)
,	O
"StatusBrightness"	*(char)
}	O
;	O
static	O
int	O
ViewerColors	array(int)
[	O
VIEWER_FIELDS	int
]	O
=	O
{	O
CYAN	int
,	O
BLUE	int
,	O
ON	int
,	O
CYAN	int
,	O
RED	int
,	O
ON	int
,	O
BLACK	int
,	O
CYAN	int
,	O
OFF	int
,	O
CYAN	int
,	O
BLUE	int
,	O
ON	int
}	O
;	O
extern	O
int	O
LinuxConsole	int
;	O
int	O
AnsiColors	int
=	O
ON	int
;	O
char	O
*	O
g_home	*(char)
;	O
char	O
*	O
g_program	*(char)
;	O
char	O
*	O
program_name	*(char)
;	O
char	O
*	O
screen	*(char)
;	O
char	O
*	O
filename	*(char)
;	O
int	O
count	int
;	O
off64_t	long
g_size	long
;	O
char	O
g_offset	array(char)
[	O
16	int
]	O
;	O
char	O
*	O
header_text	*(char)
;	O
int	O
UseLastScreenChar	int
;	O
char	O
*	O
global_buf	*(char)
;	O
char	O
color_section	array(char)
[	O
]	O
=	O
"[GITVIEW-Color]"	*(char)
;	O
char	O
monochrome_section	array(char)
[	O
]	O
=	O
"[GITVIEW-Monochrome]"	*(char)
;	O
int	O
fd	int
,	O
regular_file	int
;	O
long	O
long	O
g_current_line	long long
,	O
g_lines	long long
;	O
window_t	struct(int,int,int,int,int,int)
*	O
title_window	*(struct(int,int,int,int,int,int))
,	O
*	O
header_window	*(struct(int,int,int,int,int,int))
,	O
*	O
file_window	*(struct(int,int,int,int,int,int))
,	O
*	O
status_window	*(struct(int,int,int,int,int,int))
;	O
static	O
char	O
*	O
title_text	*(char)
;	O
static	O
char	O
*	O
g_help	*(char)
;	O
static	O
char	O
info_txt	array(char)
[	O
]	O
=	O
"   Offset     00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F       Ascii       "	*(char)
;	O
static	O
char	O
line_txt	array(char)
[	O
]	O
=	O
"-------------------------------------------------------------------------------- "	*(char)
;	O
static	O
char	O
seek_txt	array(char)
[	O
]	O
=	O
" Seek at: "	*(char)
;	O
off64_t	long
file_length	()->(long)
(	O
)	O
{	O
off64_t	long
current	long
,	O
length	long
;	O
if	O
(	O
!	O
regular_file	int
)	O
return	O
0x7FFFFFFF	int
;	O
current	long
=	O
lseek64	(int,long,int)->(long)
(	O
fd	int
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
length	long
=	O
lseek64	(int,long,int)->(long)
(	O
fd	int
,	O
0	int
,	O
SEEK_END	int
)	O
;	O
lseek64	(int,long,int)->(long)
(	O
fd	int
,	O
current	long
,	O
SEEK_SET	int
)	O
;	O
return	O
length	long
;	O
}	O
void	O
cursor_update	()->(void)
(	O
)	O
{	O
if	O
(	O
tty_lines	int
>=	O
9	int
)	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
SEEK_LINE	O
,	O
strlen	(*(char))->(long)
(	O
seek_txt	array(char)
)	O
+	O
count	int
)	O
;	O
else	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
tty_lines	int
-	O
1	int
,	O
tty_columns	int
-	O
1	int
)	O
;	O
}	O
void	O
set_title	()->(void)
(	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
global_buf	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
global_buf	*(char)
,	O
title_text	*(char)
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
title_text	*(char)
)	O
)	O
)	O
;	O
tty_colors	(int,int,int)->(void)
(	O
TitleBrightness	O
,	O
TitleForeground	O
,	O
TitleBackground	O
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
title_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
title_window	*(struct(int,int,int,int,int,int))
,	O
global_buf	*(char)
,	O
tty_columns	int
)	O
;	O
}	O
void	O
set_header	()->(void)
(	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
global_buf	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
global_buf	*(char)
,	O
header_text	*(char)
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
header_text	*(char)
)	O
)	O
)	O
;	O
tty_colors	(int,int,int)->(void)
(	O
HeaderBrightness	O
,	O
HeaderForeground	O
,	O
HeaderBackground	O
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
header_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
header_window	*(struct(int,int,int,int,int,int))
,	O
global_buf	*(char)
,	O
tty_columns	int
)	O
;	O
}	O
void	O
set_status	()->(void)
(	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
global_buf	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
global_buf	*(char)
,	O
g_help	*(char)
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
g_help	*(char)
)	O
)	O
)	O
;	O
tty_colors	(int,int,int)->(void)
(	O
StatusBrightness	O
,	O
StatusForeground	O
,	O
StatusBackground	O
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
global_buf	*(char)
,	O
tty_columns	int
)	O
;	O
}	O
void	O
report_undefined_key	()->(void)
(	O
)	O
{	O
char	O
*	O
prev	*(char)
=	O
tty_get_previous_key_seq	()->(*(char))
(	O
)	O
;	O
size_t	long
length	long
=	O
strlen	(*(char))->(long)
(	O
prev	*(char)
)	O
;	O
if	O
(	O
length	long
&&	O
(	O
prev	*(char)
[	O
length	long
-	O
1	int
]	O
!=	O
key_INTERRUPT	O
)	O
)	O
{	O
char	O
*	O
str	*(char)
=	O
(	O
char	O
*	O
)	O
tty_key_machine2human	(*(char))->(*(char))
(	O
tty_get_previous_key_seq	()->(*(char))
(	O
)	O
)	O
;	O
char	O
*	O
buf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
128	int
+	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%s: not defined."	*(char)
,	O
str	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
global_buf	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
global_buf	*(char)
,	O
buf	*(char)
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
)	O
)	O
;	O
xfree	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
tty_colors	(int,int,int)->(void)
(	O
ON	int
,	O
WHITE	int
,	O
RED	int
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
global_buf	*(char)
,	O
tty_columns	int
)	O
;	O
tty_beep	()->(void)
(	O
)	O
;	O
tty_update	()->(void)
(	O
)	O
;	O
sleep	(int)->(int)
(	O
1	int
)	O
;	O
}	O
else	O
tty_beep	()->(void)
(	O
)	O
;	O
set_status	()->(void)
(	O
)	O
;	O
cursor_update	()->(void)
(	O
)	O
;	O
tty_update	()->(void)
(	O
)	O
;	O
}	O
char	O
char_to_print	(int,int,int)->(char)
(	O
c	char
,	O
index	(*(char),int)->(*(char))
,	O
total	int
)	O
char	O
c	char
;	O
int	O
index	(*(char),int)->(*(char))
;	O
int	O
total	int
;	O
{	O
if	O
(	O
index	(*(char),int)->(*(char))
<	O
total	int
)	O
return	O
isprint	(int)->(int)
(	O
(	O
int	O
)	O
c	char
)	O
?	O
c	char
:	O
'.'	O
;	O
return	O
' '	O
;	O
}	O
void	O
update_line	(long long)->(void)
(	O
line	long long
)	O
long	O
long	O
line	long long
;	O
{	O
ssize_t	long
r	long
;	O
unsigned	O
char	O
buf	*(char)
[	O
16	int
]	O
;	O
char	O
*	O
line_string	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
max	O
(	O
tty_columns	int
,	O
80	int
+	O
1	int
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
line_string	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
buf	*(char)
,	O
'\0'	O
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
lseek64	(int,long,int)->(long)
(	O
fd	int
,	O
(	O
off64_t	long
)	O
line	long long
*	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
(	O
r	long
=	O
read	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
)	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
line_string	*(char)
,	O
"%011X0  %02X %02X %02X %02X %02X %02X %02X %02X  %02X %02X %02X %02X %02X %02X %02X %02X  %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c "	*(char)
,	O
(	O
unsigned	O
int	O
)	O
(	O
line	long long
&	O
0xFFFFFFFF	int
)	O
,	O
buf	*(char)
[	O
0	int
]	O
,	O
buf	*(char)
[	O
1	int
]	O
,	O
buf	*(char)
[	O
2	int
]	O
,	O
buf	*(char)
[	O
3	int
]	O
,	O
buf	*(char)
[	O
4	int
]	O
,	O
buf	*(char)
[	O
5	int
]	O
,	O
buf	*(char)
[	O
6	int
]	O
,	O
buf	*(char)
[	O
7	int
]	O
,	O
buf	*(char)
[	O
8	int
]	O
,	O
buf	*(char)
[	O
9	int
]	O
,	O
buf	*(char)
[	O
10	int
]	O
,	O
buf	*(char)
[	O
11	int
]	O
,	O
buf	*(char)
[	O
12	int
]	O
,	O
buf	*(char)
[	O
13	int
]	O
,	O
buf	*(char)
[	O
14	int
]	O
,	O
buf	*(char)
[	O
15	int
]	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
0	int
]	O
,	O
0	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
1	int
]	O
,	O
1	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
2	int
]	O
,	O
2	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
3	int
]	O
,	O
3	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
4	int
]	O
,	O
4	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
5	int
]	O
,	O
5	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
6	int
]	O
,	O
6	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
7	int
]	O
,	O
7	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
8	int
]	O
,	O
8	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
9	int
]	O
,	O
9	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
10	int
]	O
,	O
10	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
11	int
]	O
,	O
11	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
12	int
]	O
,	O
12	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
13	int
]	O
,	O
13	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
14	int
]	O
,	O
14	int
,	O
r	long
)	O
,	O
char_to_print	(int,int,int)->(char)
(	O
buf	*(char)
[	O
15	int
]	O
,	O
15	int
,	O
r	long
)	O
)	O
;	O
}	O
else	O
{	O
r	long
=	O
0	int
;	O
*	O
line_string	*(char)
=	O
'\0'	O
;	O
}	O
if	O
(	O
r	long
<	O
8	int
)	O
memset	(*(void),int,long)->(*(void))
(	O
line_string	*(char)
+	O
12	int
+	O
r	long
*	O
3	int
,	O
' '	O
,	O
(	O
16	int
-	O
r	long
)	O
*	O
3	int
+	O
1	int
)	O
;	O
else	O
if	O
(	O
r	long
>=	O
8	int
&&	O
r	long
<	O
16	int
)	O
memset	(*(void),int,long)->(*(void))
(	O
line_string	*(char)
+	O
12	int
+	O
r	long
*	O
3	int
+	O
1	int
,	O
' '	O
,	O
(	O
16	int
-	O
r	long
)	O
*	O
3	int
)	O
;	O
line_string	*(char)
[	O
strlen	(*(char))->(long)
(	O
line_string	*(char)
)	O
]	O
=	O
' '	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
line_string	*(char)
,	O
tty_columns	int
)	O
;	O
xfree	(*(void))->(void)
(	O
line_string	*(char)
)	O
;	O
}	O
void	O
update_all	()->(void)
(	O
)	O
{	O
long	O
long	O
i	long long
;	O
tty_colors	(int,int,int)->(void)
(	O
ScreenBrightness	O
,	O
ScreenForeground	O
,	O
ScreenBackground	O
)	O
;	O
for	O
(	O
i	long long
=	O
g_current_line	long long
;	O
i	long long
<	O
g_current_line	long long
+	O
VIEW_LINES	O
;	O
i	long long
++	O
)	O
{	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
3	int
+	O
i	long long
-	O
g_current_line	long long
,	O
0	int
)	O
;	O
update_line	(long long)->(void)
(	O
i	long long
)	O
;	O
}	O
}	O
void	O
clean_up	()->(void)
(	O
)	O
{	O
tty_end	(*(char))->(void)
(	O
NULL	O
)	O
;	O
}	O
void	O
fatal	(*(char))->(void)
(	O
postmsg	*(char)
)	O
char	O
*	O
postmsg	*(char)
;	O
{	O
clean_up	()->(void)
(	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: fatal error: %s.\n"	*(char)
,	O
g_program	*(char)
,	O
postmsg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
int	O
read_keys	(int)->(int)
(	O
keys	int
)	O
int	O
keys	int
;	O
{	O
char	O
*	O
contents	*(char)
;	O
char	O
key_seq	*(char)
[	O
80	int
]	O
;	O
int	O
i	long long
,	O
j	int
,	O
need_conversion	int
;	O
for	O
(	O
i	long long
=	O
keys	int
;	O
i	long long
<	O
MAX_KEYS	int
;	O
i	long long
++	O
)	O
{	O
configuration_getvarinfo	(*(char),*(*(char)),int,int)->(void)
(	O
key_seq	*(char)
,	O
&	O
contents	*(char)
,	O
1	int
,	O
NO_SEEK	int
)	O
;	O
if	O
(	O
*	O
key_seq	*(char)
==	O
0	int
)	O
break	O
;	O
if	O
(	O
*	O
key_seq	*(char)
!=	O
'^'	O
)	O
{	O
char	O
*	O
key_seq_ptr	*(char)
=	O
tty_get_symbol_key_seq	(*(char))->(*(char))
(	O
key_seq	*(char)
)	O
;	O
if	O
(	O
key_seq_ptr	*(char)
)	O
{	O
if	O
(	O
*	O
key_seq_ptr	*(char)
==	O
'\0'	O
)	O
continue	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
key_seq	*(char)
,	O
key_seq_ptr	*(char)
)	O
;	O
need_conversion	int
=	O
0	int
;	O
}	O
else	O
{	O
need_conversion	int
=	O
1	int
;	O
}	O
}	O
else	O
need_conversion	int
=	O
1	int
;	O
if	O
(	O
contents	*(char)
==	O
NULL	O
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
BUILTIN_OPERATIONS	int
;	O
j	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
contents	*(char)
,	O
built_in	array(array(char))
[	O
j	int
]	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
j	int
<	O
BUILTIN_OPERATIONS	int
)	O
{	O
if	O
(	O
!	O
need_conversion	int
||	O
tty_key_human2machine	(*(char))->(*(char))
(	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	*(char)
)	O
)	O
tty_key_list_insert	(*(char),*(void))->(void)
(	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	*(char)
,	O
built_in	array(array(char))
[	O
-	O
j	int
-	O
1	int
]	O
)	O
;	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: invalid built-in operation: %s.\n"	*(char)
,	O
g_program	*(char)
,	O
contents	*(char)
)	O
;	O
}	O
return	O
i	long long
;	O
}	O
void	O
resize	(int)->(void)
(	O
resize_required	int
)	O
int	O
resize_required	int
;	O
{	O
int	O
display_status	int
=	O
OFF	int
;	O
int	O
display_header	int
=	O
OFF	int
;	O
int	O
display_file	int
=	O
OFF	int
;	O
int	O
old_tty_lines	int
=	O
tty_lines	int
;	O
int	O
old_tty_columns	int
=	O
tty_columns	int
;	O
tty_resize	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
resize_required	int
)	O
if	O
(	O
tty_lines	int
==	O
old_tty_lines	int
&&	O
tty_columns	int
==	O
old_tty_columns	int
)	O
return	O
;	O
if	O
(	O
LinuxConsole	int
)	O
screen	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
screen	*(char)
,	O
4	int
+	O
tty_columns	int
*	O
tty_lines	int
*	O
2	int
)	O
;	O
global_buf	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
global_buf	*(char)
,	O
tty_columns	int
+	O
1	int
)	O
;	O
header_text	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
header_text	*(char)
,	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
+	O
10	int
)	O
;	O
window_resize	(*(struct(int,int,int,int,int,int)),int,int,int,int)->(void)
(	O
title_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
0	int
,	O
1	int
,	O
tty_columns	int
)	O
;	O
if	O
(	O
tty_lines	int
>=	O
2	int
)	O
display_status	int
=	O
ON	int
;	O
if	O
(	O
tty_lines	int
>=	O
3	int
)	O
display_header	int
=	O
ON	int
;	O
if	O
(	O
tty_lines	int
>=	O
4	int
)	O
display_file	int
=	O
ON	int
;	O
window_resize	(*(struct(int,int,int,int,int,int)),int,int,int,int)->(void)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
tty_lines	int
-	O
1	int
,	O
display_status	int
?	O
1	int
:	O
0	int
,	O
tty_columns	int
)	O
;	O
window_resize	(*(struct(int,int,int,int,int,int)),int,int,int,int)->(void)
(	O
header_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
1	int
,	O
display_header	int
?	O
1	int
:	O
0	int
,	O
tty_columns	int
)	O
;	O
window_resize	(*(struct(int,int,int,int,int,int)),int,int,int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
2	int
,	O
display_file	int
?	O
(	O
tty_lines	int
-	O
2	int
)	O
:	O
0	int
,	O
tty_columns	int
)	O
;	O
}	O
void	O
refresh	(int)->(void)
(	O
signum	int
)	O
int	O
signum	int
;	O
{	O
resize	(int)->(void)
(	O
0	int
)	O
;	O
if	O
(	O
signum	int
==	O
SIGCONT	int
)	O
{	O
tty_set_mode	(int)->(void)
(	O
TTY_NONCANONIC	int
)	O
;	O
tty_defaults	()->(void)
(	O
)	O
;	O
}	O
tty_colors	(int,int,int)->(void)
(	O
ScreenBrightness	O
,	O
ScreenForeground	O
,	O
ScreenBackground	O
)	O
;	O
tty_fill	()->(void)
(	O
)	O
;	O
g_size	long
=	O
file_length	()->(long)
(	O
)	O
;	O
g_lines	long long
=	O
g_size	long
/	O
16	int
+	O
(	O
g_size	long
%	O
16	int
?	O
1	int
:	O
0	int
)	O
;	O
if	O
(	O
tty_lines	int
>=	O
5	int
)	O
{	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
1	int
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
info_txt	array(char)
,	O
sizeof	O
(	O
info_txt	array(char)
)	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
tty_lines	int
>=	O
6	int
)	O
{	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
2	int
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
line_txt	array(char)
,	O
sizeof	O
(	O
line_txt	array(char)
)	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
tty_lines	int
>=	O
9	int
)	O
{	O
if	O
(	O
VIEW_LINES	O
==	O
0	int
)	O
g_current_line	long long
=	O
0	int
;	O
else	O
g_current_line	long long
=	O
min	O
(	O
g_current_line	long long
,	O
(	O
g_lines	long long
/	O
VIEW_LINES	O
)	O
*	O
VIEW_LINES	O
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
SEEK_LINE	O
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
seek_txt	array(char)
,	O
sizeof	O
(	O
seek_txt	array(char)
)	O
-	O
1	int
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
SEEK_LINE	O
,	O
sizeof	O
(	O
seek_txt	array(char)
)	O
-	O
1	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
g_offset	array(char)
,	O
count	int
)	O
;	O
}	O
else	O
g_current_line	long long
=	O
0	int
;	O
set_title	()->(void)
(	O
)	O
;	O
set_status	()->(void)
(	O
)	O
;	O
set_header	()->(void)
(	O
)	O
;	O
update_all	()->(void)
(	O
)	O
;	O
if	O
(	O
tty_lines	int
>=	O
9	int
)	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
SEEK_LINE	O
,	O
sizeof	O
(	O
seek_txt	array(char)
)	O
-	O
1	int
+	O
count	int
)	O
;	O
else	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
tty_lines	int
-	O
1	int
,	O
tty_columns	int
-	O
1	int
)	O
;	O
tty_update	()->(void)
(	O
)	O
;	O
if	O
(	O
signum	int
==	O
SIGCONT	int
)	O
tty_update_title	(*(char))->(void)
(	O
header_text	*(char)
)	O
;	O
}	O
void	O
hide	()->(void)
(	O
)	O
{	O
tty_set_mode	(int)->(void)
(	O
TTY_CANONIC	int
)	O
;	O
tty_defaults	()->(void)
(	O
)	O
;	O
tty_put_screen	(*(char))->(void)
(	O
screen	*(char)
)	O
;	O
}	O
void	O
clock_refresh	()->(void)
(	O
)	O
{	O
}	O
void	O
usage	()->(void)
(	O
)	O
{	O
printf	(*(char))->(int)
(	O
"usage: %s [-hvicbl] file\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" -h         print this help message\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" -v         print the version number\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" -c         use ANSI colors\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" -b         don't use ANSI colors\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" -l         don't use the last screen character\n"	*(char)
)	O
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
argc	int
,	O
argv	array(*(char))
)	O
int	O
argc	int
;	O
char	O
*	O
argv	array(*(char))
[	O
]	O
;	O
{	O
int	O
key	int
=	O
0	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
s	long
;	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
ks	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
;	O
int	O
keys	int
,	O
repeat_count	int
,	O
need_update	int
;	O
int	O
c	char
,	O
ansi_colors	int
=	O
-	O
1	int
,	O
use_last_screen_character	int
=	O
ON	int
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
signals_init	()->(void)
(	O
)	O
;	O
program_name	*(char)
=	O
g_program	*(char)
=	O
argv	array(*(char))
[	O
0	int
]	O
;	O
g_home	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
;	O
if	O
(	O
g_home	*(char)
==	O
NULL	O
)	O
g_home	*(char)
=	O
"."	*(char)
;	O
compute_directories	()->(void)
(	O
)	O
;	O
get_login_name	()->(void)
(	O
)	O
;	O
if	O
(	O
getenv	(*(char))->(*(char))
(	O
"COLORTERM"	*(char)
)	O
!=	O
NULL	O
)	O
ansi_colors	int
=	O
ON	int
;	O
while	O
(	O
(	O
c	char
=	O
getopt	(int,*(*(char)),*(char))->(int)
(	O
argc	int
,	O
argv	array(*(char))
,	O
"hvcblp"	*(char)
)	O
)	O
!=	O
-	O
1	int
)	O
switch	O
(	O
c	char
)	O
{	O
case	O
'h'	O
:	O
usage	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
case	O
'v'	O
:	O
printf	(*(char))->(int)
(	O
"%s %s\n"	*(char)
,	O
PRODUCT	*(char)
,	O
VERSION	*(char)
)	O
;	O
return	O
0	int
;	O
case	O
'c'	O
:	O
ansi_colors	int
=	O
ON	int
;	O
break	O
;	O
case	O
'b'	O
:	O
ansi_colors	int
=	O
OFF	int
;	O
break	O
;	O
case	O
'l'	O
:	O
use_last_screen_character	int
=	O
OFF	int
;	O
break	O
;	O
case	O
'?'	O
:	O
return	O
1	int
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: unknown error\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
optind	int
<	O
argc	int
)	O
filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
argv	array(*(char))
[	O
optind	int
++	O
]	O
)	O
;	O
else	O
{	O
usage	()->(void)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
optind	int
<	O
argc	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: warning: invalid extra options ignored\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
title_text	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
PRODUCT	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
VERSION	*(char)
)	O
+	O
64	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
title_text	*(char)
,	O
" %s %s - Hex/Ascii File Viewer"	*(char)
,	O
PRODUCT	*(char)
,	O
VERSION	*(char)
)	O
;	O
tty_init	(int)->(void)
(	O
TTY_RESTRICTED_INPUT	int
)	O
;	O
xstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
filename	*(char)
,	O
&	O
s	long
)	O
;	O
fd	int
=	O
open64	(*(char),int)->(int)
(	O
filename	*(char)
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: cannot open file %s.\n"	*(char)
,	O
g_program	*(char)
,	O
filename	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
regular_file	int
=	O
S_ISREG	O
(	O
s	long
.	O
st_mode	int
)	O
;	O
common_configuration_init	()->(void)
(	O
)	O
;	O
use_section	(*(char))->(void)
(	O
"[GITVIEW-Keys]"	*(char)
)	O
;	O
keys	int
=	O
read_keys	(int)->(int)
(	O
0	int
)	O
;	O
configuration_end	()->(void)
(	O
)	O
;	O
specific_configuration_init	()->(int)
(	O
)	O
;	O
use_section	(*(char))->(void)
(	O
"[Setup]"	*(char)
)	O
;	O
if	O
(	O
ansi_colors	int
==	O
-	O
1	int
)	O
AnsiColors	int
=	O
get_flag_var	(*(char),int)->(int)
(	O
"AnsiColors"	*(char)
,	O
OFF	int
)	O
;	O
else	O
AnsiColors	int
=	O
ansi_colors	int
;	O
if	O
(	O
use_last_screen_character	int
)	O
UseLastScreenChar	int
=	O
get_flag_var	(*(char),int)->(int)
(	O
"UseLastScreenChar"	*(char)
,	O
OFF	int
)	O
;	O
else	O
UseLastScreenChar	int
=	O
OFF	int
;	O
tty_set_last_char_flag	(int)->(void)
(	O
UseLastScreenChar	int
)	O
;	O
use_section	(*(char))->(void)
(	O
"[GITVIEW-Setup]"	*(char)
)	O
;	O
g_help	*(char)
=	O
get_string_var	(*(char),*(char))->(*(char))
(	O
"Help"	*(char)
,	O
""	*(char)
)	O
;	O
use_section	(*(char))->(void)
(	O
AnsiColors	int
?	O
color_section	array(char)
:	O
monochrome_section	array(char)
)	O
;	O
get_colorset_var	(*(int),array(*(char)),int)->(void)
(	O
ViewerColors	array(int)
,	O
ViewerFields	array(*(char))
,	O
VIEWER_FIELDS	int
)	O
;	O
use_section	(*(char))->(void)
(	O
"[GITVIEW-Keys]"	*(char)
)	O
;	O
keys	int
=	O
read_keys	(int)->(int)
(	O
keys	int
)	O
;	O
if	O
(	O
keys	int
==	O
MAX_KEYS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: too many key sequences; only %d are allowed.\n"	*(char)
,	O
g_program	*(char)
,	O
MAX_KEYS	int
)	O
;	O
configuration_end	()->(void)
(	O
)	O
;	O
tty_start_cursorapp	()->(void)
(	O
)	O
;	O
title_window	*(struct(int,int,int,int,int,int))
=	O
window_init	()->(*(struct(int,int,int,int,int,int)))
(	O
)	O
;	O
header_window	*(struct(int,int,int,int,int,int))
=	O
window_init	()->(*(struct(int,int,int,int,int,int)))
(	O
)	O
;	O
file_window	*(struct(int,int,int,int,int,int))
=	O
window_init	()->(*(struct(int,int,int,int,int,int)))
(	O
)	O
;	O
status_window	*(struct(int,int,int,int,int,int))
=	O
window_init	()->(*(struct(int,int,int,int,int,int)))
(	O
)	O
;	O
resize	(int)->(void)
(	O
0	int
)	O
;	O
tty_get_screen	(*(char))->(void)
(	O
screen	*(char)
)	O
;	O
tty_set_mode	(int)->(void)
(	O
TTY_NONCANONIC	int
)	O
;	O
tty_defaults	()->(void)
(	O
)	O
;	O
signal_handlers	(int)->(void)
(	O
ON	int
)	O
;	O
g_offset	array(char)
[	O
count	int
]	O
=	O
0	int
;	O
g_current_line	long long
=	O
0	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
header_text	*(char)
,	O
" File: %s"	*(char)
,	O
filename	*(char)
)	O
;	O
tty_update_title	(*(char))->(void)
(	O
header_text	*(char)
)	O
;	O
restart	O
:	O
refresh	(int)->(void)
(	O
0	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
(	O
ks	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
=	O
tty_get_key	(*(int))->(*(struct(*(char),*(struct(*`,*`,*`)),*(void))))
(	O
&	O
repeat_count	int
)	O
)	O
==	O
NULL	O
)	O
report_undefined_key	()->(void)
(	O
)	O
;	O
set_status	()->(void)
(	O
)	O
;	O
if	O
(	O
ks	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
->	O
aux_data	*(void)
==	O
NULL	O
)	O
key	int
=	O
ks	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
->	O
key_seq	*(char)
[	O
0	int
]	O
;	O
else	O
key	int
=	O
(	O
(	O
char	O
*	O
)	O
ks	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
->	O
aux_data	*(void)
-	O
(	O
char	O
*	O
)	O
built_in	array(array(char))
)	O
/	O
MAX_BUILTIN_NAME	int
;	O
g_size	long
=	O
file_length	()->(long)
(	O
)	O
;	O
g_lines	long long
=	O
g_size	long
/	O
16	int
+	O
(	O
g_size	long
%	O
16	int
?	O
1	int
:	O
0	int
)	O
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
BUILTIN_previous_line	O
:	O
need_update	int
=	O
0	int
;	O
while	O
(	O
repeat_count	int
--	O
)	O
{	O
if	O
(	O
g_current_line	long long
==	O
0	int
)	O
break	O
;	O
g_current_line	long long
--	O
,	O
need_update	int
=	O
1	int
;	O
}	O
if	O
(	O
need_update	int
)	O
update_all	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_next_line	O
:	O
need_update	int
=	O
0	int
;	O
while	O
(	O
repeat_count	int
--	O
)	O
{	O
if	O
(	O
g_current_line	long long
>=	O
g_lines	long long
-	O
VIEW_LINES	O
)	O
break	O
;	O
g_current_line	long long
++	O
,	O
need_update	int
=	O
1	int
;	O
}	O
if	O
(	O
need_update	int
)	O
update_all	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_backspace	O
:	O
if	O
(	O
count	int
)	O
{	O
count	int
--	O
;	O
if	O
(	O
tty_lines	int
>=	O
9	int
)	O
{	O
tty_colors	(int,int,int)->(void)
(	O
ScreenBrightness	O
,	O
ScreenForeground	O
,	O
ScreenBackground	O
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
SEEK_LINE	O
,	O
strlen	(*(char))->(long)
(	O
seek_txt	array(char)
)	O
+	O
count	int
)	O
;	O
window_putc	(*(struct(int,int,int,int,int,int)),int)->(int)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
' '	O
)	O
;	O
}	O
else	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
tty_lines	int
-	O
1	int
,	O
tty_columns	int
-	O
1	int
)	O
;	O
break	O
;	O
}	O
case	O
BUILTIN_scroll_down	O
:	O
if	O
(	O
g_current_line	long long
==	O
0	int
)	O
break	O
;	O
g_current_line	long long
=	O
max	O
(	O
0	int
,	O
g_current_line	long long
-	O
VIEW_LINES	O
)	O
;	O
update_all	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
' '	O
:	O
case	O
BUILTIN_scroll_up	O
:	O
if	O
(	O
g_current_line	long long
>=	O
g_lines	long long
-	O
VIEW_LINES	O
)	O
break	O
;	O
g_current_line	long long
=	O
min	O
(	O
g_lines	long long
-	O
1	int
,	O
g_current_line	long long
+	O
VIEW_LINES	O
)	O
;	O
update_all	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_beginning_of_file	O
:	O
if	O
(	O
g_current_line	long long
)	O
{	O
g_current_line	long long
=	O
0	int
;	O
update_all	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_end_of_file	O
:	O
if	O
(	O
regular_file	int
&&	O
g_current_line	long long
<	O
g_lines	long long
-	O
VIEW_LINES	O
)	O
{	O
g_current_line	long long
=	O
g_lines	long long
-	O
VIEW_LINES	O
;	O
update_all	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_hard_refresh	O
:	O
case	O
BUILTIN_refresh	O
:	O
goto	O
restart	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
if	O
(	O
count	int
<	O
8	int
)	O
{	O
if	O
(	O
tty_lines	int
>=	O
9	int
)	O
{	O
char	O
tmp	char
;	O
tty_colors	(int,int,int)->(void)
(	O
ScreenBrightness	O
,	O
ScreenForeground	O
,	O
ScreenBackground	O
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
SEEK_LINE	O
,	O
strlen	(*(char))->(long)
(	O
seek_txt	array(char)
)	O
+	O
count	int
)	O
;	O
tmp	char
=	O
(	O
char	O
)	O
key	int
;	O
window_putc	(*(struct(int,int,int,int,int,int)),int)->(int)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
tmp	char
)	O
;	O
g_offset	array(char)
[	O
count	int
++	O
]	O
=	O
tmp	char
;	O
}	O
}	O
else	O
tty_beep	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_action	O
:	O
if	O
(	O
count	int
==	O
0	int
)	O
tty_beep	()->(void)
(	O
)	O
;	O
else	O
{	O
if	O
(	O
tty_lines	int
>=	O
9	int
)	O
{	O
g_offset	array(char)
[	O
count	int
]	O
=	O
0	int
;	O
sscanf	(*(char),*(char))->(int)
(	O
g_offset	array(char)
,	O
"%x"	*(char)
,	O
&	O
count	int
)	O
;	O
tty_colors	(int,int,int)->(void)
(	O
ScreenBrightness	O
,	O
ScreenForeground	O
,	O
ScreenBackground	O
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
SEEK_LINE	O
,	O
strlen	(*(char))->(long)
(	O
seek_txt	array(char)
)	O
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
file_window	*(struct(int,int,int,int,int,int))
,	O
"        "	*(char)
,	O
8	int
)	O
;	O
if	O
(	O
count	int
<	O
0	int
)	O
count	int
=	O
0	int
;	O
if	O
(	O
count	int
>	O
g_size	long
)	O
count	int
=	O
g_size	long
;	O
g_current_line	long long
=	O
count	int
>>	O
4	int
;	O
update_all	()->(void)
(	O
)	O
;	O
count	int
=	O
0	int
;	O
}	O
}	O
break	O
;	O
case	O
'q'	O
:	O
case	O
BUILTIN_exit	O
:	O
goto	O
end	O
;	O
default	O
:	O
report_undefined_key	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
cursor_update	()->(void)
(	O
)	O
;	O
}	O
end	O
:	O
tty_set_mode	(int)->(void)
(	O
TTY_CANONIC	int
)	O
;	O
tty_end_cursorapp	()->(void)
(	O
)	O
;	O
tty_end	(*(char))->(void)
(	O
screen	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
