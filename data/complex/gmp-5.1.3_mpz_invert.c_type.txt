int	O
mpz_invert	O
(	O
mpz_ptr	*(struct(int,int,*(long)))
inverse	*(struct(int,int,*(long)))
,	O
mpz_srcptr	*(struct(int,int,*(long)))
x	*(struct(int,int,*(long)))
,	O
mpz_srcptr	*(struct(int,int,*(long)))
n	long
)	O
{	O
mpz_t	array(struct(int,int,*(long)))
gcd	array(struct(int,int,*(long)))
,	O
tmp	array(struct(int,int,*(long)))
;	O
mp_size_t	long
xsize	long
,	O
nsize	long
,	O
size	long
;	O
TMP_DECL	O
;	O
xsize	long
=	O
ABSIZ	O
(	O
x	*(struct(int,int,*(long)))
)	O
;	O
nsize	long
=	O
ABSIZ	O
(	O
n	long
)	O
;	O
if	O
(	O
xsize	long
==	O
0	int
||	O
(	O
nsize	long
==	O
1	int
&&	O
(	O
PTR	O
(	O
n	long
)	O
)	O
[	O
0	int
]	O
==	O
1	int
)	O
)	O
return	O
0	int
;	O
size	long
=	O
MAX	O
(	O
xsize	long
,	O
nsize	long
)	O
+	O
1	int
;	O
TMP_MARK	O
;	O
MPZ_TMP_INIT	O
(	O
gcd	array(struct(int,int,*(long)))
,	O
size	long
)	O
;	O
MPZ_TMP_INIT	O
(	O
tmp	array(struct(int,int,*(long)))
,	O
size	long
)	O
;	O
mpz_gcdext	O
(	O
gcd	array(struct(int,int,*(long)))
,	O
tmp	array(struct(int,int,*(long)))
,	O
(	O
mpz_ptr	*(struct(int,int,*(long)))
)	O
0	int
,	O
x	*(struct(int,int,*(long)))
,	O
n	long
)	O
;	O
if	O
(	O
!	O
MPZ_EQUAL_1_P	O
(	O
gcd	array(struct(int,int,*(long)))
)	O
)	O
{	O
TMP_FREE	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
SIZ	O
(	O
tmp	array(struct(int,int,*(long)))
)	O
<	O
0	int
)	O
{	O
if	O
(	O
SIZ	O
(	O
n	long
)	O
<	O
0	int
)	O
mpz_sub	O
(	O
inverse	*(struct(int,int,*(long)))
,	O
tmp	array(struct(int,int,*(long)))
,	O
n	long
)	O
;	O
else	O
mpz_add	O
(	O
inverse	*(struct(int,int,*(long)))
,	O
tmp	array(struct(int,int,*(long)))
,	O
n	long
)	O
;	O
}	O
else	O
mpz_set	O
(	O
inverse	*(struct(int,int,*(long)))
,	O
tmp	array(struct(int,int,*(long)))
)	O
;	O
TMP_FREE	O
;	O
return	O
1	int
;	O
}	O
