static	O
void	O
gcl_regerror	(*(char))->(void)
(	O
char	O
*	O
s	*(char)
)	O
{	O
FEerror	()->(int)
(	O
"Regexp Error: ~a"	*(char)
,	O
1	int
,	O
make_simple_string	()->(int)
(	O
s	*(char)
)	O
)	O
;	O
}	O
DEFVAR	()->(int)
(	O
"*MATCH-DATA*"	*(char)
,	O
sSAmatch_dataA	O
,	O
SI	O
,	O
sLnil	O
,	O
""	*(char)
)	O
;	O
DEFVAR	()->(int)
(	O
"*CASE-FOLD-SEARCH*"	*(char)
,	O
sSAcase_fold_searchA	O
,	O
SI	O
,	O
sLnil	O
,	O
"Non nil means that a string-match should ignore case"	*(char)
)	O
;	O
DEFUN_NEW	()->(int)
(	O
"MATCH-BEGINNING"	*(char)
,	O
object	O
,	O
fSmatch_beginning	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
i	int
)	O
,	O
"Returns the beginning of the I'th match from the previous STRING-MATCH, where the 0th is for the whole regexp and the subsequent ones match parenthetical expressions.  -1 is returned if there is no match, or if the *match-data* vector is not a fixnum array."	*(char)
)	O
{	O
object	O
v	O
=	O
sSAmatch_dataA	O
->	O
s	*(char)
.	O
s_dbind	O
;	O
if	O
(	O
type_of	()->(int)
(	O
v	O
)	O
==	O
t_vector	O
&&	O
(	O
v	O
->	O
v	O
.	O
v_elttype	O
==	O
aet_fix	O
)	O
)	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
sSAmatch_dataA	O
->	O
s	*(char)
.	O
s_dbind	O
->	O
fixa	O
.	O
fixa_self	O
[	O
i	int
]	O
)	O
)	O
;	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
-	O
1	int
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"MATCH-END"	*(char)
,	O
object	O
,	O
fSmatch_end	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
i	int
)	O
,	O
"Returns the end of the I'th match from the previous STRING-MATCH"	*(char)
)	O
{	O
object	O
v	O
=	O
sSAmatch_dataA	O
->	O
s	*(char)
.	O
s_dbind	O
;	O
if	O
(	O
type_of	()->(int)
(	O
v	O
)	O
==	O
t_vector	O
&&	O
(	O
v	O
->	O
v	O
.	O
v_elttype	O
==	O
aet_fix	O
)	O
)	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
sSAmatch_dataA	O
->	O
s	*(char)
.	O
s_dbind	O
->	O
fixa	O
.	O
fixa_self	O
[	O
i	int
+	O
NSUBEXP	O
]	O
)	O
)	O
;	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
-	O
1	int
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"COMPILE-REGEXP"	*(char)
,	O
object	O
,	O
fScompile_regexp	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
p	O
)	O
,	O
"Provide handle to export pre-compiled regexp's to string-match"	*(char)
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
object	O
res	O
;	O
if	O
(	O
type_of	()->(int)
(	O
p	O
)	O
!=	O
t_string	O
&&	O
type_of	()->(int)
(	O
p	O
)	O
!=	O
t_symbol	O
)	O
not_a_string_or_symbol	()->(int)
(	O
p	O
)	O
;	O
if	O
(	O
!	O
(	O
tmp	*(char)
=	O
alloca	(long)->(*(void))
(	O
p	O
->	O
st	O
.	O
st_fillp	O
+	O
1	int
)	O
)	O
)	O
FEerror	()->(int)
(	O
"out of C stack"	*(char)
,	O
0	int
)	O
;	O
memcpy	O
(	O
tmp	*(char)
,	O
p	O
->	O
st	O
.	O
st_self	O
,	O
p	O
->	O
st	O
.	O
st_fillp	O
)	O
;	O
tmp	*(char)
[	O
p	O
->	O
st	O
.	O
st_fillp	O
]	O
=	O
0	int
;	O
res	O
=	O
alloc_object	()->(int)
(	O
t_vector	O
)	O
;	O
res	O
->	O
v	O
.	O
v_displaced	O
=	O
Cnil	O
;	O
res	O
->	O
v	O
.	O
v_hasfillp	O
=	O
1	int
;	O
res	O
->	O
v	O
.	O
v_elttype	O
=	O
aet_uchar	O
;	O
res	O
->	O
v	O
.	O
v_adjustable	O
=	O
0	int
;	O
res	O
->	O
v	O
.	O
v_offset	O
=	O
0	int
;	O
if	O
(	O
!	O
(	O
res	O
->	O
v	O
.	O
v_self	O
=	O
(	O
void	O
*	O
)	O
regcomp	()->(int)
(	O
tmp	*(char)
,	O
&	O
res	O
->	O
v	O
.	O
v_dim	O
)	O
)	O
)	O
FEerror	()->(int)
(	O
"regcomp failure"	*(char)
,	O
0	int
)	O
;	O
res	O
->	O
v	O
.	O
v_fillp	O
=	O
res	O
->	O
v	O
.	O
v_dim	O
;	O
RETURN1	()->(int)
(	O
res	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"STRING-MATCH"	*(char)
,	O
object	O
,	O
fSstring_match	O
,	O
SI	O
,	O
2	int
,	O
4	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
pattern	O
,	O
object	O
string	O
,	O
...	O
)	O
,	O
"Match regexp PATTERN in STRING starting in string starting at START and ending at END.  Return -1 if match not found, otherwise return the start index  of the first matchs.  The variable *MATCH-DATA* will be set to a fixnum array of sufficient size to hold the matches, to be obtained with match-beginning and match-end. If it already contains such an array, then the contents of it will be over written.   "	*(char)
)	O
{	O
int	O
i	int
,	O
ans	int
,	O
nargs	int
=	O
VFUN_NARGS	O
,	O
len	int
,	O
start	int
,	O
end	int
;	O
static	O
char	O
buf	array(char)
[	O
400	int
]	O
,	O
case_fold	char
;	O
static	O
regexp	O
*	O
saved_compiled_regexp	*(int)
;	O
va_list	O
ap	O
;	O
object	O
v	O
=	O
sSAmatch_dataA	O
->	O
s	*(char)
.	O
s_dbind	O
;	O
char	O
*	O
*	O
pp	*(*(char))
,	O
*	O
str	*(char)
,	O
save_c	char
=	O
0	int
;	O
if	O
(	O
type_of	()->(int)
(	O
pattern	O
)	O
!=	O
t_string	O
&&	O
type_of	()->(int)
(	O
pattern	O
)	O
!=	O
t_symbol	O
&&	O
(	O
type_of	()->(int)
(	O
pattern	O
)	O
!=	O
t_vector	O
||	O
pattern	O
->	O
v	O
.	O
v_elttype	O
!=	O
aet_uchar	O
)	O
)	O
FEerror	()->(int)
(	O
"~S is not a regexp pattern"	*(char)
,	O
1	int
,	O
pattern	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
string	O
)	O
!=	O
t_string	O
&&	O
type_of	()->(int)
(	O
string	O
)	O
!=	O
t_symbol	O
)	O
not_a_string_or_symbol	()->(int)
(	O
string	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
v	O
)	O
!=	O
t_vector	O
||	O
v	O
->	O
v	O
.	O
v_elttype	O
!=	O
aet_fix	O
||	O
v	O
->	O
v	O
.	O
v_dim	O
<	O
NSUBEXP	O
*	O
2	int
)	O
v	O
=	O
sSAmatch_dataA	O
->	O
s	*(char)
.	O
s_dbind	O
=	O
fSmake_vector1_1	()->(int)
(	O
(	O
NSUBEXP	O
*	O
2	int
)	O
,	O
aet_fix	O
,	O
sLnil	O
)	O
;	O
start	int
=	O
0	int
;	O
end	int
=	O
string	O
->	O
st	O
.	O
st_fillp	O
;	O
if	O
(	O
nargs	int
>	O
2	int
)	O
{	O
va_start	O
(	O
ap	O
,	O
string	O
)	O
;	O
start	int
=	O
fixint	()->(int)
(	O
va_arg	()->(int)
(	O
ap	O
,	O
object	O
)	O
)	O
;	O
if	O
(	O
nargs	int
>	O
3	int
)	O
end	int
=	O
fixint	()->(int)
(	O
va_arg	()->(int)
(	O
ap	O
,	O
object	O
)	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
if	O
(	O
start	int
<	O
0	int
||	O
end	int
>	O
string	O
->	O
st	O
.	O
st_fillp	O
||	O
start	int
>	O
end	int
)	O
FEerror	()->(int)
(	O
"Bad start or end"	*(char)
,	O
0	int
)	O
;	O
len	int
=	O
pattern	O
->	O
ust	O
.	O
ust_fillp	O
;	O
if	O
(	O
len	int
==	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NSUBEXP	O
;	O
i	int
++	O
)	O
v	O
->	O
fixa	O
.	O
fixa_self	O
[	O
i	int
]	O
=	O
i	int
?	O
-	O
1	int
:	O
0	int
;	O
memcpy	O
(	O
v	O
->	O
fixa	O
.	O
fixa_self	O
+	O
NSUBEXP	O
,	O
v	O
->	O
fixa	O
.	O
fixa_self	O
,	O
NSUBEXP	O
*	O
sizeof	O
(	O
*	O
v	O
->	O
fixa	O
.	O
fixa_self	O
)	O
)	O
;	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
0	int
)	O
)	O
;	O
}	O
{	O
regexp	O
*	O
compiled_regexp	O
=	O
saved_compiled_regexp	*(int)
;	O
BEGIN_NO_INTERRUPT	O
;	O
case_fold_search	O
=	O
sSAcase_fold_searchA	O
->	O
s	*(char)
.	O
s_dbind	O
!=	O
sLnil	O
?	O
1	int
:	O
0	int
;	O
if	O
(	O
type_of	()->(int)
(	O
pattern	O
)	O
==	O
t_vector	O
)	O
compiled_regexp	O
=	O
(	O
void	O
*	O
)	O
pattern	O
->	O
ust	O
.	O
ust_self	O
;	O
else	O
if	O
(	O
case_fold	char
!=	O
case_fold_search	O
||	O
len	int
!=	O
strlen	O
(	O
buf	array(char)
)	O
||	O
memcmp	O
(	O
pattern	O
->	O
ust	O
.	O
ust_self	O
,	O
buf	array(char)
,	O
len	int
)	O
)	O
compiled_regexp	O
=	O
saved_compiled_regexp	*(int)
=	O
(	O
regexp	O
*	O
)	O
FFN	O
(	O
fScompile_regexp	O
)	O
(	O
pattern	O
)	O
->	O
v	O
.	O
v_self	O
;	O
str	*(char)
=	O
string	O
->	O
st	O
.	O
st_self	O
;	O
if	O
(	O
str	*(char)
+	O
end	int
==	O
(	O
void	O
*	O
)	O
core_end	O
||	O
str	*(char)
+	O
end	int
==	O
(	O
void	O
*	O
)	O
compiled_regexp	O
)	O
{	O
if	O
(	O
!	O
(	O
str	*(char)
=	O
alloca	(long)->(*(void))
(	O
string	O
->	O
st	O
.	O
st_fillp	O
+	O
1	int
)	O
)	O
)	O
FEerror	()->(int)
(	O
"Cannot allocate memory on C stack"	*(char)
,	O
0	int
)	O
;	O
memcpy	O
(	O
str	*(char)
,	O
string	O
->	O
st	O
.	O
st_self	O
,	O
string	O
->	O
st	O
.	O
st_fillp	O
)	O
;	O
}	O
else	O
save_c	char
=	O
str	*(char)
[	O
end	int
]	O
;	O
str	*(char)
[	O
end	int
]	O
=	O
0	int
;	O
ans	int
=	O
regexec	()->(int)
(	O
compiled_regexp	O
,	O
str	*(char)
+	O
start	int
,	O
str	*(char)
,	O
end	int
-	O
start	int
)	O
;	O
str	*(char)
[	O
end	int
]	O
=	O
save_c	char
;	O
if	O
(	O
!	O
ans	int
)	O
{	O
END_NO_INTERRUPT	O
;	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
-	O
1	int
)	O
)	O
;	O
}	O
pp	*(*(char))
=	O
compiled_regexp	O
->	O
startp	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NSUBEXP	O
;	O
i	int
++	O
,	O
pp	*(*(char))
++	O
)	O
v	O
->	O
fixa	O
.	O
fixa_self	O
[	O
i	int
]	O
=	O
*	O
pp	*(*(char))
?	O
*	O
pp	*(*(char))
-	O
str	*(char)
:	O
-	O
1	int
;	O
pp	*(*(char))
=	O
compiled_regexp	O
->	O
endp	O
;	O
for	O
(	O
;	O
i	int
<	O
2	int
*	O
NSUBEXP	O
;	O
i	int
++	O
,	O
pp	*(*(char))
++	O
)	O
v	O
->	O
fixa	O
.	O
fixa_self	O
[	O
i	int
]	O
=	O
*	O
pp	*(*(char))
?	O
*	O
pp	*(*(char))
-	O
str	*(char)
:	O
-	O
1	int
;	O
END_NO_INTERRUPT	O
;	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
v	O
->	O
fixa	O
.	O
fixa_self	O
[	O
0	int
]	O
)	O
)	O
;	O
}	O
}	O
