double	O
CurrentLinePatLen	double
;	O
signed	O
int	O
CurrentLinePattern	int
;	O
LINESTYLE	array(array(double))
lt	array(array(double))
;	O
LineAttr	struct(enum(int,int,int,int),enum(int,int,int,int,int,int),int)
CurrentLineAttr	struct(enum(int,int,int,int),enum(int,int,int,int,int,int),int)
;	O
LineEnds	enum(int,int,int,int)
CurrentLineEnd	enum(int,int,int,int)
;	O
void	O
set_line_style	(char)->(void)
(	O
SCHAR	char
index	char
,	O
...	O
)	O
{	O
SCHAR	char
count	char
;	O
double	O
factor	double
,	O
percentage	double
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
SCHAR	char
val	char
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
index	char
)	O
;	O
for	O
(	O
count	char
=	O
0	int
,	O
percentage	double
=	O
0	int
;	O
count	char
<	O
LT_ELEMENTS	int
;	O
count	char
++	O
)	O
{	O
val	char
=	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
int	O
)	O
;	O
if	O
(	O
val	char
<	O
0	int
)	O
{	O
break	O
;	O
}	O
else	O
{	O
lt	array(array(double))
[	O
index	char
-	O
LT_MIN	O
]	O
[	O
count	char
]	O
=	O
(	O
double	O
)	O
val	char
;	O
percentage	double
+=	O
val	char
;	O
}	O
}	O
lt	array(array(double))
[	O
index	char
-	O
LT_MIN	O
]	O
[	O
count	char
]	O
=	O
-	O
1	int
;	O
if	O
(	O
fabs	(double)->(double)
(	O
percentage	double
-	O
100.	int
)	O
>	O
0.5	int
)	O
{	O
factor	double
=	O
100.0	int
/	O
percentage	double
;	O
for	O
(	O
count	char
=	O
0	int
;	O
count	char
<	O
LT_ELEMENTS	int
;	O
count	char
++	O
)	O
{	O
if	O
(	O
lt	array(array(double))
[	O
index	char
-	O
LT_MIN	O
]	O
[	O
count	char
]	O
<	O
0	int
)	O
{	O
break	O
;	O
}	O
else	O
{	O
lt	array(array(double))
[	O
index	char
-	O
LT_MIN	O
]	O
[	O
count	char
]	O
*=	O
factor	double
;	O
}	O
}	O
}	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
set_line_style_by_UL	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
hd	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
SCHAR	char
index	char
,	O
pos_index	char
,	O
neg_index	char
,	O
count	char
,	O
i	char
;	O
double	O
factor	double
,	O
percentage	double
;	O
float	O
tmp	float
;	O
if	O
(	O
read_float	(*(float),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
&	O
tmp	float
,	O
hd	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
set_line_style_defaults	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
else	O
{	O
index	char
=	O
(	O
int	O
)	O
tmp	float
;	O
}	O
pos_index	char
=	O
index	char
-	O
LT_MIN	O
;	O
neg_index	char
=	O
(	O
index	char
*	O
-	O
1	int
)	O
-	O
LT_MIN	O
;	O
for	O
(	O
count	char
=	O
0	int
,	O
percentage	double
=	O
0	int
;	O
(	O
read_float	(*(float),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
&	O
tmp	float
,	O
hd	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
0	int
)	O
;	O
count	char
++	O
)	O
{	O
lt	array(array(double))
[	O
pos_index	char
]	O
[	O
count	char
]	O
=	O
(	O
double	O
)	O
tmp	float
;	O
percentage	double
+=	O
(	O
int	O
)	O
tmp	float
;	O
}	O
lt	array(array(double))
[	O
pos_index	char
]	O
[	O
count	char
]	O
=	O
-	O
1	int
;	O
if	O
(	O
fabs	(double)->(double)
(	O
percentage	double
-	O
100.	int
)	O
>	O
0.5	int
)	O
{	O
factor	double
=	O
100.0	int
/	O
percentage	double
;	O
for	O
(	O
count	char
=	O
0	int
;	O
count	char
<	O
LT_ELEMENTS	int
;	O
count	char
++	O
)	O
{	O
if	O
(	O
lt	array(array(double))
[	O
pos_index	char
]	O
[	O
count	char
]	O
<	O
0	int
)	O
{	O
break	O
;	O
}	O
else	O
{	O
lt	array(array(double))
[	O
pos_index	char
]	O
[	O
count	char
]	O
*=	O
factor	double
;	O
}	O
}	O
}	O
count	char
--	O
;	O
if	O
(	O
count	char
%	O
2	int
)	O
{	O
lt	array(array(double))
[	O
neg_index	char
]	O
[	O
0	int
]	O
=	O
lt	array(array(double))
[	O
pos_index	char
]	O
[	O
0	int
]	O
/	O
2	int
;	O
for	O
(	O
i	char
=	O
1	int
;	O
i	char
<=	O
count	char
;	O
i	char
++	O
)	O
lt	array(array(double))
[	O
neg_index	char
]	O
[	O
i	char
]	O
=	O
lt	array(array(double))
[	O
pos_index	char
]	O
[	O
i	char
]	O
;	O
lt	array(array(double))
[	O
neg_index	char
]	O
[	O
count	char
+	O
1	int
]	O
=	O
lt	array(array(double))
[	O
pos_index	char
]	O
[	O
0	int
]	O
/	O
2	int
;	O
lt	array(array(double))
[	O
neg_index	char
]	O
[	O
count	char
+	O
2	int
]	O
=	O
-	O
1	int
;	O
}	O
else	O
{	O
lt	array(array(double))
[	O
neg_index	char
]	O
[	O
0	int
]	O
=	O
(	O
lt	array(array(double))
[	O
pos_index	char
]	O
[	O
0	int
]	O
+	O
lt	array(array(double))
[	O
pos_index	char
]	O
[	O
count	char
]	O
)	O
/	O
2	int
;	O
for	O
(	O
i	char
=	O
1	int
;	O
i	char
<	O
count	char
;	O
i	char
++	O
)	O
lt	array(array(double))
[	O
neg_index	char
]	O
[	O
i	char
]	O
=	O
lt	array(array(double))
[	O
pos_index	char
]	O
[	O
i	char
]	O
;	O
lt	array(array(double))
[	O
neg_index	char
]	O
[	O
count	char
]	O
=	O
lt	array(array(double))
[	O
neg_index	char
]	O
[	O
0	int
]	O
;	O
lt	array(array(double))
[	O
neg_index	char
]	O
[	O
count	char
+	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
}	O
void	O
set_line_style_defaults	()->(void)
(	O
)	O
{	O
set_line_style	(char)->(void)
(	O
-	O
8	int
,	O
25	int
,	O
10	int
,	O
0	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
0	int
,	O
10	int
,	O
25	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
-	O
7	int
,	O
35	int
,	O
10	int
,	O
0	int
,	O
10	int
,	O
0	int
,	O
10	int
,	O
35	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
-	O
6	int
,	O
25	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
25	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
-	O
5	int
,	O
35	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
35	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
-	O
4	int
,	O
40	int
,	O
10	int
,	O
0	int
,	O
10	int
,	O
40	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
-	O
3	int
,	O
35	int
,	O
30	int
,	O
35	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
-	O
2	int
,	O
25	int
,	O
50	int
,	O
25	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
-	O
1	int
,	O
0	int
,	O
100	int
,	O
0	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
0	int
,	O
0	int
,	O
100	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
1	int
,	O
0	int
,	O
100	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
2	int
,	O
50	int
,	O
50	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
3	int
,	O
70	int
,	O
30	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
4	int
,	O
80	int
,	O
10	int
,	O
0	int
,	O
10	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
5	int
,	O
70	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
6	int
,	O
50	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
7	int
,	O
70	int
,	O
10	int
,	O
0	int
,	O
10	int
,	O
0	int
,	O
10	int
,	O
-	O
1	int
)	O
;	O
set_line_style	(char)->(void)
(	O
8	int
,	O
50	int
,	O
10	int
,	O
0	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
0	int
,	O
10	int
,	O
-	O
1	int
)	O
;	O
}	O
void	O
print_line_style	()->(void)
(	O
void	O
)	O
{	O
int	O
i	char
,	O
j	int
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
LT_PATTERNS	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
lt	array(array(double))
[	O
j	int
]	O
[	O
0	int
]	O
<	O
0	int
)	O
continue	O
;	O
else	O
printf	(*(char))->(int)
(	O
"LT %3d "	*(char)
,	O
LT_MIN	O
+	O
j	int
)	O
;	O
for	O
(	O
i	char
=	O
0	int
;	O
i	char
<=	O
LT_ELEMENTS	int
;	O
i	char
++	O
)	O
{	O
if	O
(	O
lt	array(array(double))
[	O
j	int
]	O
[	O
i	char
]	O
<	O
0	int
)	O
break	O
;	O
printf	(*(char))->(int)
(	O
"%3.00f "	*(char)
,	O
lt	array(array(double))
[	O
j	int
]	O
[	O
i	char
]	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
void	O
set_line_attr_defaults	()->(void)
(	O
void	O
)	O
{	O
PlotCmd_to_tmpfile	(enum(int,int,int,int,int,int,int,int,int))->(void)
(	O
DEF_LA	int
)	O
;	O
Line_Attr_to_tmpfile	(enum(int,int,int),int)->(void)
(	O
LineAttrEnd	int
,	O
LAE_butt	int
)	O
;	O
PlotCmd_to_tmpfile	(enum(int,int,int,int,int,int,int,int,int))->(void)
(	O
DEF_LA	int
)	O
;	O
Line_Attr_to_tmpfile	(enum(int,int,int),int)->(void)
(	O
LineAttrJoin	int
,	O
LAJ_plain_miter	int
)	O
;	O
PlotCmd_to_tmpfile	(enum(int,int,int,int,int,int,int,int,int))->(void)
(	O
DEF_LA	int
)	O
;	O
Line_Attr_to_tmpfile	(enum(int,int,int),int)->(void)
(	O
LineAttrLimit	int
,	O
5	int
)	O
;	O
}	O
void	O
set_line_attr	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
hd	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
float	O
ftmp1	float
;	O
float	O
ftmp2	float
;	O
int	O
itmp	int
;	O
if	O
(	O
read_float	(*(float),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
&	O
ftmp1	float
,	O
hd	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
set_line_attr_defaults	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
read_float	(*(float),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
&	O
ftmp2	float
,	O
hd	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
return	O
;	O
}	O
itmp	int
=	O
(	O
int	O
)	O
ftmp2	float
;	O
PlotCmd_to_tmpfile	(enum(int,int,int,int,int,int,int,int,int))->(void)
(	O
DEF_LA	int
)	O
;	O
switch	O
(	O
(	O
int	O
)	O
ftmp1	float
)	O
{	O
case	O
1	int
:	O
if	O
(	O
(	O
itmp	int
>=	O
LAE_butt	int
)	O
&&	O
(	O
itmp	int
<=	O
LAE_round	int
)	O
)	O
{	O
Line_Attr_to_tmpfile	(enum(int,int,int),int)->(void)
(	O
LineAttrEnd	int
,	O
itmp	int
)	O
;	O
}	O
else	O
{	O
Line_Attr_to_tmpfile	(enum(int,int,int),int)->(void)
(	O
LineAttrEnd	int
,	O
LAE_butt	int
)	O
;	O
}	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
(	O
itmp	int
>=	O
LAJ_plain_miter	int
)	O
&&	O
(	O
itmp	int
<=	O
LAJ_nojoin	int
)	O
)	O
{	O
Line_Attr_to_tmpfile	(enum(int,int,int),int)->(void)
(	O
LineAttrJoin	int
,	O
itmp	int
)	O
;	O
}	O
else	O
{	O
Line_Attr_to_tmpfile	(enum(int,int,int),int)->(void)
(	O
LineAttrJoin	int
,	O
LAJ_plain_miter	int
)	O
;	O
}	O
break	O
;	O
case	O
3	int
:	O
Line_Attr_to_tmpfile	(enum(int,int,int),int)->(void)
(	O
LineAttrLimit	int
,	O
itmp	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
read_float	(*(float),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
&	O
ftmp1	float
,	O
hd	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
return	O
;	O
}	O
}	O
return	O
;	O
}	O
void	O
Line_Attr_to_tmpfile	(enum(int,int,int),int)->(void)
(	O
LineAttrKind	enum(int,int,int)
kind	enum(int,int,int)
,	O
int	O
value	int
)	O
{	O
LineAttrKind	enum(int,int,int)
tk	enum(int,int,int)
=	O
kind	enum(int,int,int)
;	O
LineEnds	enum(int,int,int,int)
tv	enum(int,int,int,int)
=	O
value	int
;	O
if	O
(	O
record_off	short
)	O
return	O
;	O
if	O
(	O
kind	enum(int,int,int)
==	O
LineAttrEnd	int
)	O
CurrentLineEnd	enum(int,int,int,int)
=	O
value	int
;	O
if	O
(	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
tk	enum(int,int,int)
,	O
sizeof	O
(	O
tk	enum(int,int,int)
)	O
,	O
1	int
,	O
td	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
1	int
)	O
{	O
PError	(*(char))->(void)
(	O
"Line_Attr_to_tmpfile - kind"	*(char)
)	O
;	O
Eprintf	(*(char))->(void)
(	O
"Error @ Cmd %ld\n"	*(char)
,	O
vec_cntr_w	long
)	O
;	O
exit	(int)->(void)
(	O
ERROR	O
)	O
;	O
}	O
if	O
(	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
tv	enum(int,int,int,int)
,	O
sizeof	O
(	O
tv	enum(int,int,int,int)
)	O
,	O
1	int
,	O
td	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
1	int
)	O
{	O
PError	(*(char))->(void)
(	O
"Line_Attr_to_tmpfile - value"	*(char)
)	O
;	O
Eprintf	(*(char))->(void)
(	O
"Error @ Cmd %ld\n"	*(char)
,	O
vec_cntr_w	long
)	O
;	O
exit	(int)->(void)
(	O
ERROR	O
)	O
;	O
}	O
return	O
;	O
}	O
int	O
load_line_attr	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
FILE	struct
*	O
td	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
LineAttrKind	enum(int,int,int)
kind	enum(int,int,int)
;	O
int	O
value	int
;	O
static	O
int	O
FoundJoin	int
=	O
0	int
;	O
static	O
int	O
FoundLimit	int
=	O
0	int
;	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
(	O
void	O
*	O
)	O
&	O
kind	enum(int,int,int)
,	O
sizeof	O
(	O
kind	enum(int,int,int)
)	O
,	O
1	int
,	O
td	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
1	int
)	O
{	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
(	O
void	O
*	O
)	O
&	O
value	int
,	O
sizeof	O
(	O
value	int
)	O
,	O
1	int
,	O
td	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
1	int
)	O
{	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
switch	O
(	O
kind	enum(int,int,int)
)	O
{	O
case	O
LineAttrEnd	int
:	O
CurrentLineAttr	struct(enum(int,int,int,int),enum(int,int,int,int,int,int),int)
.	O
End	enum(int,int,int,int)
=	O
value	int
;	O
break	O
;	O
case	O
LineAttrJoin	int
:	O
if	O
(	O
!	O
FoundJoin	int
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\nLA - Joins not supported\n"	*(char)
)	O
;	O
FoundJoin	int
=	O
1	int
;	O
}	O
CurrentLineAttr	struct(enum(int,int,int,int),enum(int,int,int,int,int,int),int)
.	O
Join	enum(int,int,int,int,int,int)
=	O
value	int
;	O
case	O
LineAttrLimit	int
:	O
if	O
(	O
!	O
FoundLimit	int
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\nLA - Limit not supported\n"	*(char)
)	O
;	O
FoundLimit	int
=	O
1	int
;	O
}	O
CurrentLineAttr	struct(enum(int,int,int,int),enum(int,int,int,int,int,int),int)
.	O
Limit	int
=	O
value	int
;	O
break	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
