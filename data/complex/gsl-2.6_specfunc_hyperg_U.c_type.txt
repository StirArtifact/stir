static	O
int	O
hyperg_lnU_beq2a	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
lx	double
=	O
log	(double)->(double)
(	O
x	double
)	O
;	O
const	O
double	O
nu	double
=	O
a	double
-	O
0.5	int
;	O
const	O
double	O
lnpre	double
=	O
0.5	int
*	O
(	O
x	double
-	O
M_LNPI	int
)	O
-	O
nu	double
*	O
lx	double
;	O
gsl_sf_result	struct(double,double)
lnK	struct(double,double)
;	O
gsl_sf_bessel_lnKnu_e	(double,double,*(struct(double,double)))->(int)
(	O
nu	double
,	O
0.5	int
*	O
x	double
,	O
&	O
lnK	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
lnpre	double
+	O
lnK	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
0.5	int
*	O
x	double
)	O
+	O
0.5	int
*	O
M_LNPI	int
+	O
fabs	(double)->(double)
(	O
nu	double
*	O
lx	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
lnK	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
hyperg_U_CF1	(double,double,int,double,*(double),*(int))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
int	O
N	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result	*(struct(double,double))
,	O
int	O
*	O
count	*(int)
)	O
{	O
const	O
double	O
RECUR_BIG	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
const	O
int	O
maxiter	int
=	O
20000	int
;	O
int	O
n	int
=	O
1	int
;	O
double	O
Anm2	double
=	O
1.0	int
;	O
double	O
Bnm2	double
=	O
0.0	int
;	O
double	O
Anm1	double
=	O
0.0	int
;	O
double	O
Bnm1	double
=	O
1.0	int
;	O
double	O
a1	double
=	O
-	O
(	O
a	double
+	O
N	int
)	O
;	O
double	O
b1	double
=	O
(	O
b	double
-	O
2.0	int
*	O
a	double
-	O
x	double
-	O
2.0	int
*	O
(	O
N	int
+	O
1	int
)	O
)	O
;	O
double	O
An	double
=	O
b1	double
*	O
Anm1	double
+	O
a1	double
*	O
Anm2	double
;	O
double	O
Bn	double
=	O
b1	double
*	O
Bnm1	double
+	O
a1	double
*	O
Bnm2	double
;	O
double	O
an	double
,	O
bn	double
;	O
double	O
fn	double
=	O
An	double
/	O
Bn	double
;	O
while	O
(	O
n	int
<	O
maxiter	int
)	O
{	O
double	O
old_fn	double
;	O
double	O
del	double
;	O
n	int
++	O
;	O
Anm2	double
=	O
Anm1	double
;	O
Bnm2	double
=	O
Bnm1	double
;	O
Anm1	double
=	O
An	double
;	O
Bnm1	double
=	O
Bn	double
;	O
an	double
=	O
-	O
(	O
a	double
+	O
N	int
+	O
n	int
-	O
b	double
)	O
*	O
(	O
a	double
+	O
N	int
+	O
n	int
-	O
1.0	int
)	O
;	O
bn	double
=	O
(	O
b	double
-	O
2.0	int
*	O
a	double
-	O
x	double
-	O
2.0	int
*	O
(	O
N	int
+	O
n	int
)	O
)	O
;	O
An	double
=	O
bn	double
*	O
Anm1	double
+	O
an	double
*	O
Anm2	double
;	O
Bn	double
=	O
bn	double
*	O
Bnm1	double
+	O
an	double
*	O
Bnm2	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
An	double
)	O
>	O
RECUR_BIG	double
||	O
fabs	(double)->(double)
(	O
Bn	double
)	O
>	O
RECUR_BIG	double
)	O
{	O
An	double
/=	O
RECUR_BIG	double
;	O
Bn	double
/=	O
RECUR_BIG	double
;	O
Anm1	double
/=	O
RECUR_BIG	double
;	O
Bnm1	double
/=	O
RECUR_BIG	double
;	O
Anm2	double
/=	O
RECUR_BIG	double
;	O
Bnm2	double
/=	O
RECUR_BIG	double
;	O
}	O
old_fn	double
=	O
fn	double
;	O
fn	double
=	O
An	double
/	O
Bn	double
;	O
del	double
=	O
old_fn	double
/	O
fn	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
del	double
-	O
1.0	int
)	O
<	O
10.0	int
*	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
*	O
result	*(struct(double,double))
=	O
fn	double
;	O
*	O
count	*(int)
=	O
n	int
;	O
if	O
(	O
n	int
==	O
maxiter	int
)	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
d9chu	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
EPS	double
=	O
8.0	int
*	O
GSL_DBL_EPSILON	int
;	O
const	O
int	O
maxiter	int
=	O
500	int
;	O
double	O
aa	array(double)
[	O
4	int
]	O
,	O
bb	array(double)
[	O
4	int
]	O
;	O
int	O
i	int
;	O
double	O
bp	double
=	O
1.0	int
+	O
a	double
-	O
b	double
;	O
double	O
ab	double
=	O
a	double
*	O
bp	double
;	O
double	O
ct2	double
=	O
2.0	int
*	O
(	O
x	double
-	O
ab	double
)	O
;	O
double	O
sab	double
=	O
a	double
+	O
bp	double
;	O
double	O
ct3	double
=	O
sab	double
+	O
1.0	int
+	O
ab	double
;	O
double	O
anbn	double
=	O
ct3	double
+	O
sab	double
+	O
3.0	int
;	O
double	O
ct1	double
=	O
1.0	int
+	O
2.0	int
*	O
x	double
/	O
anbn	double
;	O
bb	array(double)
[	O
0	int
]	O
=	O
1.0	int
;	O
aa	array(double)
[	O
0	int
]	O
=	O
1.0	int
;	O
bb	array(double)
[	O
1	int
]	O
=	O
1.0	int
+	O
2.0	int
*	O
x	double
/	O
ct3	double
;	O
aa	array(double)
[	O
1	int
]	O
=	O
1.0	int
+	O
ct2	double
/	O
ct3	double
;	O
bb	array(double)
[	O
2	int
]	O
=	O
1.0	int
+	O
6.0	int
*	O
ct1	double
*	O
x	double
/	O
ct3	double
;	O
aa	array(double)
[	O
2	int
]	O
=	O
1.0	int
+	O
6.0	int
*	O
ab	double
/	O
anbn	double
+	O
3.0	int
*	O
ct1	double
*	O
ct2	double
/	O
ct3	double
;	O
for	O
(	O
i	int
=	O
4	int
;	O
i	int
<	O
maxiter	int
;	O
i	int
++	O
)	O
{	O
int	O
j	int
;	O
double	O
c2	double
;	O
double	O
d1z	double
;	O
double	O
g1	double
,	O
g2	double
,	O
g3	double
;	O
double	O
x2i1	double
=	O
2	int
*	O
i	int
-	O
3	int
;	O
ct1	double
=	O
x2i1	double
/	O
(	O
x2i1	double
-	O
2.0	int
)	O
;	O
anbn	double
+=	O
x2i1	double
+	O
sab	double
;	O
ct2	double
=	O
(	O
x2i1	double
-	O
1.0	int
)	O
/	O
anbn	double
;	O
c2	double
=	O
x2i1	double
*	O
ct2	double
-	O
1.0	int
;	O
d1z	double
=	O
2.0	int
*	O
x2i1	double
*	O
x	double
/	O
anbn	double
;	O
ct3	double
=	O
sab	double
*	O
ct2	double
;	O
g1	double
=	O
d1z	double
+	O
ct1	double
*	O
(	O
c2	double
+	O
ct3	double
)	O
;	O
g2	double
=	O
d1z	double
-	O
c2	double
;	O
g3	double
=	O
ct1	double
*	O
(	O
1.0	int
-	O
ct3	double
-	O
2.0	int
*	O
ct2	double
)	O
;	O
bb	array(double)
[	O
3	int
]	O
=	O
g1	double
*	O
bb	array(double)
[	O
2	int
]	O
+	O
g2	double
*	O
bb	array(double)
[	O
1	int
]	O
+	O
g3	double
*	O
bb	array(double)
[	O
0	int
]	O
;	O
aa	array(double)
[	O
3	int
]	O
=	O
g1	double
*	O
aa	array(double)
[	O
2	int
]	O
+	O
g2	double
*	O
aa	array(double)
[	O
1	int
]	O
+	O
g3	double
*	O
aa	array(double)
[	O
0	int
]	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
aa	array(double)
[	O
3	int
]	O
*	O
bb	array(double)
[	O
0	int
]	O
-	O
aa	array(double)
[	O
0	int
]	O
*	O
bb	array(double)
[	O
3	int
]	O
)	O
<	O
EPS	double
*	O
fabs	(double)->(double)
(	O
bb	array(double)
[	O
3	int
]	O
*	O
bb	array(double)
[	O
0	int
]	O
)	O
)	O
break	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
3	int
;	O
j	int
++	O
)	O
{	O
aa	array(double)
[	O
j	int
]	O
=	O
aa	array(double)
[	O
j	int
+	O
1	int
]	O
;	O
bb	array(double)
[	O
j	int
]	O
=	O
bb	array(double)
[	O
j	int
+	O
1	int
]	O
;	O
}	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
aa	array(double)
[	O
3	int
]	O
/	O
bb	array(double)
[	O
3	int
]	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
8.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
if	O
(	O
i	int
==	O
maxiter	int
)	O
{	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
}	O
else	O
{	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
hyperg_zaU_asymp	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
ap	double
=	O
a	double
;	O
const	O
double	O
bp	double
=	O
1.0	int
+	O
a	double
-	O
b	double
;	O
const	O
double	O
rintap	double
=	O
floor	(double)->(double)
(	O
ap	double
+	O
0.5	int
)	O
;	O
const	O
double	O
rintbp	double
=	O
floor	(double)->(double)
(	O
bp	double
+	O
0.5	int
)	O
;	O
const	O
int	O
ap_neg_int	int
=	O
(	O
ap	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
ap	double
-	O
rintap	double
)	O
<	O
INT_THRESHOLD	O
)	O
;	O
const	O
int	O
bp_neg_int	int
=	O
(	O
bp	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
bp	double
-	O
rintbp	double
)	O
<	O
INT_THRESHOLD	O
)	O
;	O
if	O
(	O
ap_neg_int	int
||	O
bp_neg_int	int
)	O
{	O
double	O
mxi	double
=	O
-	O
1.0	int
/	O
x	double
;	O
double	O
nmax	int
=	O
-	O
(	O
int	O
)	O
(	O
GSL_MIN	O
(	O
ap	double
,	O
bp	double
)	O
-	O
0.1	int
)	O
;	O
double	O
tn	double
=	O
1.0	int
;	O
double	O
sum	double
=	O
1.0	int
;	O
double	O
n	int
=	O
1.0	int
;	O
double	O
sum_err	double
=	O
0.0	int
;	O
while	O
(	O
n	int
<=	O
nmax	int
)	O
{	O
double	O
apn	double
=	O
(	O
ap	double
+	O
n	int
-	O
1.0	int
)	O
;	O
double	O
bpn	double
=	O
(	O
bp	double
+	O
n	int
-	O
1.0	int
)	O
;	O
tn	double
*=	O
(	O
(	O
apn	double
/	O
n	int
)	O
*	O
mxi	double
)	O
*	O
bpn	double
;	O
sum	double
+=	O
tn	double
;	O
sum_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
tn	double
)	O
;	O
n	int
+=	O
1.0	int
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
sum	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
sum_err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
nmax	int
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
sum	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
return	O
d9chu	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
static	O
int	O
hyperg_U_finite_sum	(int,double,double,double,double,*(struct(double,double)))->(int)
(	O
int	O
N	int
,	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
x	double
,	O
double	O
xeps	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
int	O
i	int
;	O
double	O
sum_val	double
;	O
double	O
sum_err	double
;	O
if	O
(	O
N	int
<=	O
0	int
)	O
{	O
double	O
t_val	double
=	O
1.0	int
;	O
double	O
t_err	double
=	O
0.0	int
;	O
gsl_sf_result	struct(double,double)
poch	struct(double,double)
;	O
int	O
stat_poch	int
;	O
sum_val	double
=	O
1.0	int
;	O
sum_err	double
=	O
0.0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
-	O
N	int
;	O
i	int
++	O
)	O
{	O
const	O
double	O
xi1	double
=	O
i	int
-	O
1	int
;	O
const	O
double	O
mult	double
=	O
(	O
a	double
+	O
xi1	double
)	O
*	O
x	double
/	O
(	O
(	O
b	double
+	O
xi1	double
)	O
*	O
(	O
xi1	double
+	O
1.0	int
)	O
)	O
;	O
t_val	double
*=	O
mult	double
;	O
t_err	double
+=	O
fabs	(double)->(double)
(	O
mult	double
)	O
*	O
t_err	double
+	O
fabs	(double)->(double)
(	O
t_val	double
)	O
*	O
8.0	int
*	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
sum_val	double
+=	O
t_val	double
;	O
sum_err	double
+=	O
t_err	double
;	O
}	O
stat_poch	int
=	O
gsl_sf_poch_e	(double,double,*(struct(double,double)))->(int)
(	O
1.0	int
+	O
a	double
-	O
b	double
,	O
-	O
a	double
,	O
&	O
poch	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sum_val	double
*	O
poch	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
sum_val	double
)	O
*	O
poch	struct(double,double)
.	O
err	double
+	O
sum_err	double
*	O
fabs	(double)->(double)
(	O
poch	struct(double,double)
.	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
fabs	(double)->(double)
(	O
poch	struct(double,double)
.	O
val	double
)	O
*	O
(	O
fabs	(double)->(double)
(	O
N	int
)	O
+	O
2.0	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
sum_val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
2.0	int
;	O
return	O
stat_poch	int
;	O
}	O
else	O
{	O
const	O
int	O
M	int
=	O
N	int
-	O
2	int
;	O
if	O
(	O
M	int
<	O
0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
gbm1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
gamr	struct(double,double)
;	O
int	O
stat_gbm1	int
;	O
int	O
stat_gamr	int
;	O
double	O
t_val	double
=	O
1.0	int
;	O
double	O
t_err	double
=	O
0.0	int
;	O
sum_val	double
=	O
1.0	int
;	O
sum_err	double
=	O
0.0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
M	int
;	O
i	int
++	O
)	O
{	O
const	O
double	O
mult	double
=	O
(	O
a	double
-	O
b	double
+	O
i	int
)	O
*	O
x	double
/	O
(	O
(	O
1.0	int
-	O
b	double
+	O
i	int
)	O
*	O
i	int
)	O
;	O
t_val	double
*=	O
mult	double
;	O
t_err	double
+=	O
t_err	double
*	O
fabs	(double)->(double)
(	O
mult	double
)	O
+	O
fabs	(double)->(double)
(	O
t_val	double
)	O
*	O
8.0	int
*	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
sum_val	double
+=	O
t_val	double
;	O
sum_err	double
+=	O
t_err	double
;	O
}	O
stat_gbm1	int
=	O
gsl_sf_gamma_e	(double,*(struct(double,double)))->(int)
(	O
b	double
-	O
1.0	int
,	O
&	O
gbm1	struct(double,double)
)	O
;	O
stat_gamr	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
a	double
,	O
&	O
gamr	struct(double,double)
)	O
;	O
if	O
(	O
stat_gbm1	int
==	O
GSL_SUCCESS	int
)	O
{	O
gsl_sf_result	struct(double,double)
powx1N	struct(double,double)
;	O
int	O
stat_p	int
=	O
gsl_sf_pow_int_e	(double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
1	int
-	O
N	int
,	O
&	O
powx1N	struct(double,double)
)	O
;	O
double	O
pe_val	double
=	O
powx1N	struct(double,double)
.	O
val	double
*	O
xeps	double
;	O
double	O
pe_err	double
=	O
powx1N	struct(double,double)
.	O
err	double
*	O
fabs	(double)->(double)
(	O
xeps	double
)	O
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
pe_val	double
)	O
;	O
double	O
coeff_val	double
=	O
gbm1	struct(double,double)
.	O
val	double
*	O
gamr	struct(double,double)
.	O
val	double
*	O
pe_val	double
;	O
double	O
coeff_err	double
=	O
gbm1	struct(double,double)
.	O
err	double
*	O
fabs	(double)->(double)
(	O
gamr	struct(double,double)
.	O
val	double
*	O
pe_val	double
)	O
+	O
gamr	struct(double,double)
.	O
err	double
*	O
fabs	(double)->(double)
(	O
gbm1	struct(double,double)
.	O
val	double
*	O
pe_val	double
)	O
+	O
fabs	(double)->(double)
(	O
gbm1	struct(double,double)
.	O
val	double
*	O
gamr	struct(double,double)
.	O
val	double
)	O
*	O
pe_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
coeff_val	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sum_val	double
*	O
coeff_val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
sum_val	double
)	O
*	O
coeff_err	double
+	O
sum_err	double
*	O
fabs	(double)->(double)
(	O
coeff_val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
M	int
+	O
2.0	int
)	O
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
2.0	int
;	O
return	O
stat_p	int
;	O
}	O
else	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
stat_gbm1	int
;	O
}	O
}	O
}	O
}	O
static	O
int	O
hyperg_U_infinite_sum_stable	(int,double,double,double,double,double,double,struct(double,double),*(struct(double,double)))->(int)
(	O
int	O
N	int
,	O
double	O
a	double
,	O
double	O
bint	double
,	O
double	O
b	double
,	O
double	O
beps	double
,	O
double	O
x	double
,	O
double	O
xeps	double
,	O
gsl_sf_result	struct(double,double)
sum	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
EPS	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
int	O
istrt	int
=	O
(	O
N	int
<	O
1	int
?	O
1	int
-	O
N	int
:	O
0	int
)	O
;	O
double	O
xi	double
=	O
istrt	int
;	O
gsl_sf_result	struct(double,double)
gamr	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
powx	struct(double,double)
;	O
int	O
stat_gamr	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
1.0	int
+	O
a	double
-	O
b	double
,	O
&	O
gamr	struct(double,double)
)	O
;	O
int	O
stat_powx	int
=	O
gsl_sf_pow_int_e	(double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
istrt	int
,	O
&	O
powx	struct(double,double)
)	O
;	O
double	O
sarg	double
=	O
beps	double
*	O
M_PI	int
;	O
double	O
sfact	double
=	O
(	O
sarg	double
!=	O
0.0	int
?	O
sarg	double
/	O
sin	(double)->(double)
(	O
sarg	double
)	O
:	O
1.0	int
)	O
;	O
double	O
factor_val	double
=	O
sfact	double
*	O
(	O
GSL_IS_ODD	O
(	O
N	int
)	O
?	O
-	O
1.0	int
:	O
1.0	int
)	O
*	O
gamr	struct(double,double)
.	O
val	double
*	O
powx	struct(double,double)
.	O
val	double
;	O
double	O
factor_err	double
=	O
fabs	(double)->(double)
(	O
gamr	struct(double,double)
.	O
val	double
)	O
*	O
powx	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
powx	struct(double,double)
.	O
val	double
)	O
*	O
gamr	struct(double,double)
.	O
err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
factor_val	double
)	O
;	O
gsl_sf_result	struct(double,double)
pochai	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
gamri1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
gamrni	struct(double,double)
;	O
int	O
stat_pochai	int
=	O
gsl_sf_poch_e	(double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
xi	double
,	O
&	O
pochai	struct(double,double)
)	O
;	O
int	O
stat_gamri1	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
xi	double
+	O
1.0	int
,	O
&	O
gamri1	struct(double,double)
)	O
;	O
int	O
stat_gamrni	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
bint	double
+	O
xi	double
,	O
&	O
gamrni	struct(double,double)
)	O
;	O
int	O
stat_gam123	int
=	O
GSL_ERROR_SELECT_3	O
(	O
stat_gamr	int
,	O
stat_gamri1	int
,	O
stat_gamrni	int
)	O
;	O
int	O
stat_gamall	int
=	O
GSL_ERROR_SELECT_3	O
(	O
stat_gam123	int
,	O
stat_pochai	int
,	O
stat_powx	int
)	O
;	O
gsl_sf_result	struct(double,double)
pochaxibeps	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
gamrxi1beps	struct(double,double)
;	O
int	O
stat_pochaxibeps	int
=	O
gsl_sf_poch_e	(double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
xi	double
-	O
beps	double
,	O
&	O
pochaxibeps	struct(double,double)
)	O
;	O
int	O
stat_gamrxi1beps	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
xi	double
+	O
1.0	int
-	O
beps	double
,	O
&	O
gamrxi1beps	struct(double,double)
)	O
;	O
int	O
stat_all	int
=	O
GSL_ERROR_SELECT_3	O
(	O
stat_gamall	int
,	O
stat_pochaxibeps	int
,	O
stat_gamrxi1beps	int
)	O
;	O
double	O
b0_val	double
=	O
factor_val	double
*	O
pochaxibeps	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
;	O
double	O
b0_err	double
=	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochaxibeps	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
)	O
*	O
gamrxi1beps	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochaxibeps	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
)	O
*	O
gamrni	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
)	O
*	O
pochaxibeps	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
pochaxibeps	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
)	O
*	O
factor_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
b0_val	double
)	O
;	O
int	O
i	int
;	O
double	O
dchu_val	double
;	O
double	O
dchu_err	double
;	O
double	O
t_val	double
;	O
double	O
t_err	double
;	O
gsl_sf_result	struct(double,double)
dgamrbxi	struct(double,double)
;	O
int	O
stat_dgamrbxi	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
b	double
+	O
xi	double
,	O
&	O
dgamrbxi	struct(double,double)
)	O
;	O
double	O
a0_val	double
=	O
factor_val	double
*	O
pochai	struct(double,double)
.	O
val	double
*	O
dgamrbxi	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
/	O
beps	double
;	O
double	O
a0_err	double
=	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochai	struct(double,double)
.	O
val	double
*	O
dgamrbxi	struct(double,double)
.	O
val	double
/	O
beps	double
)	O
*	O
gamri1	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochai	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
/	O
beps	double
)	O
*	O
dgamrbxi	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
dgamrbxi	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
/	O
beps	double
)	O
*	O
pochai	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
pochai	struct(double,double)
.	O
val	double
*	O
dgamrbxi	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
/	O
beps	double
)	O
*	O
factor_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
a0_val	double
)	O
;	O
stat_all	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_all	int
,	O
stat_dgamrbxi	int
)	O
;	O
b0_val	double
=	O
xeps	double
*	O
b0_val	double
/	O
beps	double
;	O
b0_err	double
=	O
fabs	(double)->(double)
(	O
xeps	double
/	O
beps	double
)	O
*	O
b0_err	double
+	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
b0_val	double
)	O
;	O
dchu_val	double
=	O
sum	double
.	O
val	double
+	O
a0_val	double
-	O
b0_val	double
;	O
dchu_err	double
=	O
sum	double
.	O
err	double
+	O
a0_err	double
+	O
b0_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
sum	double
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
a0_val	double
)	O
+	O
fabs	(double)->(double)
(	O
b0_val	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
2000	int
;	O
i	int
++	O
)	O
{	O
double	O
xi	double
=	O
istrt	int
+	O
i	int
;	O
double	O
xi1	double
=	O
istrt	int
+	O
i	int
-	O
1	int
;	O
double	O
a0_multiplier	double
=	O
(	O
a	double
+	O
xi1	double
)	O
*	O
x	double
/	O
(	O
(	O
b	double
+	O
xi1	double
)	O
*	O
xi	double
)	O
;	O
double	O
b0_multiplier	double
=	O
(	O
a	double
+	O
xi1	double
-	O
beps	double
)	O
*	O
x	double
/	O
(	O
(	O
bint	double
+	O
xi1	double
)	O
*	O
(	O
xi	double
-	O
beps	double
)	O
)	O
;	O
a0_val	double
*=	O
a0_multiplier	double
;	O
a0_err	double
+=	O
fabs	(double)->(double)
(	O
a0_multiplier	double
)	O
*	O
a0_err	double
;	O
b0_val	double
*=	O
b0_multiplier	double
;	O
b0_err	double
+=	O
fabs	(double)->(double)
(	O
b0_multiplier	double
)	O
*	O
b0_err	double
;	O
t_val	double
=	O
a0_val	double
-	O
b0_val	double
;	O
t_err	double
=	O
a0_err	double
+	O
b0_err	double
;	O
dchu_val	double
+=	O
t_val	double
;	O
dchu_err	double
+=	O
t_err	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
t_val	double
)	O
<	O
EPS	double
*	O
fabs	(double)->(double)
(	O
dchu_val	double
)	O
)	O
break	O
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
dchu_val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
dchu_err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
fabs	(double)->(double)
(	O
t_val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
i	int
+	O
2.0	int
)	O
*	O
fabs	(double)->(double)
(	O
dchu_val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
2.0	int
;	O
if	O
(	O
i	int
>=	O
2000	int
)	O
{	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
}	O
else	O
{	O
return	O
stat_all	int
;	O
}	O
}	O
static	O
int	O
hyperg_U_infinite_sum_simple	(int,double,double,double,double,double,double,struct(double,double),*(struct(double,double)))->(int)
(	O
int	O
N	int
,	O
double	O
a	double
,	O
double	O
bint	double
,	O
double	O
b	double
,	O
double	O
beps	double
,	O
double	O
x	double
,	O
double	O
xeps	double
,	O
gsl_sf_result	struct(double,double)
sum	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
EPS	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
int	O
istrt	int
=	O
(	O
N	int
<	O
1	int
?	O
1	int
-	O
N	int
:	O
0	int
)	O
;	O
double	O
xi	double
=	O
istrt	int
;	O
gsl_sf_result	struct(double,double)
powx	struct(double,double)
;	O
int	O
stat_powx	int
=	O
gsl_sf_pow_int_e	(double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
istrt	int
,	O
&	O
powx	struct(double,double)
)	O
;	O
double	O
sarg	double
=	O
beps	double
*	O
M_PI	int
;	O
double	O
sfact	double
=	O
(	O
sarg	double
!=	O
0.0	int
?	O
sarg	double
/	O
sin	(double)->(double)
(	O
sarg	double
)	O
:	O
1.0	int
)	O
;	O
double	O
factor_val	double
=	O
sfact	double
*	O
(	O
GSL_IS_ODD	O
(	O
N	int
)	O
?	O
-	O
1.0	int
:	O
1.0	int
)	O
*	O
powx	struct(double,double)
.	O
val	double
;	O
double	O
factor_err	double
=	O
fabs	(double)->(double)
(	O
powx	struct(double,double)
.	O
err	double
)	O
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
factor_val	double
)	O
;	O
gsl_sf_result	struct(double,double)
pochai	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
gamri1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
gamrni	struct(double,double)
;	O
int	O
stat_pochai	int
=	O
gsl_sf_poch_e	(double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
xi	double
,	O
&	O
pochai	struct(double,double)
)	O
;	O
int	O
stat_gamri1	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
xi	double
+	O
1.0	int
,	O
&	O
gamri1	struct(double,double)
)	O
;	O
int	O
stat_gamrni	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
bint	double
+	O
xi	double
,	O
&	O
gamrni	struct(double,double)
)	O
;	O
int	O
stat_gam123	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_gamri1	int
,	O
stat_gamrni	int
)	O
;	O
int	O
stat_gamall	int
=	O
GSL_ERROR_SELECT_3	O
(	O
stat_gam123	int
,	O
stat_pochai	int
,	O
stat_powx	int
)	O
;	O
gsl_sf_result	struct(double,double)
pochaxibeps	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
gamrxi1beps	struct(double,double)
;	O
int	O
stat_pochaxibeps	int
=	O
gsl_sf_poch_e	(double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
xi	double
-	O
beps	double
,	O
&	O
pochaxibeps	struct(double,double)
)	O
;	O
int	O
stat_gamrxi1beps	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
xi	double
+	O
1.0	int
-	O
beps	double
,	O
&	O
gamrxi1beps	struct(double,double)
)	O
;	O
int	O
stat_all	int
=	O
GSL_ERROR_SELECT_3	O
(	O
stat_gamall	int
,	O
stat_pochaxibeps	int
,	O
stat_gamrxi1beps	int
)	O
;	O
double	O
X	double
=	O
sfact	double
*	O
(	O
GSL_IS_ODD	O
(	O
N	int
)	O
?	O
-	O
1.0	int
:	O
1.0	int
)	O
*	O
powx	struct(double,double)
.	O
val	double
*	O
gsl_sf_poch	(double,double)->(double)
(	O
1	int
+	O
a	double
-	O
b	double
,	O
xi	double
-	O
1	int
+	O
b	double
-	O
beps	double
)	O
*	O
gsl_sf_gammainv	(double)->(double)
(	O
a	double
)	O
;	O
double	O
b0_val	double
=	O
X	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
;	O
double	O
b0_err	double
=	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochaxibeps	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
)	O
*	O
gamrxi1beps	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochaxibeps	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
)	O
*	O
gamrni	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
)	O
*	O
pochaxibeps	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
pochaxibeps	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
)	O
*	O
factor_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
b0_val	double
)	O
;	O
int	O
i	int
;	O
double	O
dchu_val	double
;	O
double	O
dchu_err	double
;	O
double	O
t_val	double
;	O
double	O
t_err	double
;	O
gsl_sf_result	struct(double,double)
gamr	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
dgamrbxi	struct(double,double)
;	O
int	O
stat_gamr	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
1.0	int
+	O
a	double
-	O
b	double
,	O
&	O
gamr	struct(double,double)
)	O
;	O
int	O
stat_dgamrbxi	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
b	double
+	O
xi	double
,	O
&	O
dgamrbxi	struct(double,double)
)	O
;	O
double	O
a0_val	double
=	O
factor_val	double
*	O
gamr	struct(double,double)
.	O
val	double
*	O
pochai	struct(double,double)
.	O
val	double
*	O
dgamrbxi	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
/	O
beps	double
;	O
double	O
a0_err	double
=	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochai	struct(double,double)
.	O
val	double
*	O
dgamrbxi	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
/	O
beps	double
)	O
*	O
gamr	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
gamr	struct(double,double)
.	O
val	double
*	O
dgamrbxi	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
/	O
beps	double
)	O
*	O
pochai	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
gamr	struct(double,double)
.	O
val	double
*	O
pochai	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
/	O
beps	double
)	O
*	O
dgamrbxi	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
gamr	struct(double,double)
.	O
val	double
*	O
pochai	struct(double,double)
.	O
val	double
*	O
dgamrbxi	struct(double,double)
.	O
val	double
/	O
beps	double
)	O
*	O
gamri1	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
pochai	struct(double,double)
.	O
val	double
*	O
gamr	struct(double,double)
.	O
val	double
*	O
dgamrbxi	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
/	O
beps	double
)	O
*	O
factor_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
a0_val	double
)	O
;	O
stat_all	int
=	O
GSL_ERROR_SELECT_3	O
(	O
stat_all	int
,	O
stat_gamr	int
,	O
stat_dgamrbxi	int
)	O
;	O
b0_val	double
=	O
xeps	double
*	O
b0_val	double
/	O
beps	double
;	O
b0_err	double
=	O
fabs	(double)->(double)
(	O
xeps	double
/	O
beps	double
)	O
*	O
b0_err	double
+	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
b0_val	double
)	O
;	O
dchu_val	double
=	O
sum	double
.	O
val	double
+	O
a0_val	double
-	O
b0_val	double
;	O
dchu_err	double
=	O
sum	double
.	O
err	double
+	O
a0_err	double
+	O
b0_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
sum	double
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
a0_val	double
)	O
+	O
fabs	(double)->(double)
(	O
b0_val	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
2000	int
;	O
i	int
++	O
)	O
{	O
double	O
xi	double
=	O
istrt	int
+	O
i	int
;	O
double	O
xi1	double
=	O
istrt	int
+	O
i	int
-	O
1	int
;	O
double	O
a0_multiplier	double
=	O
(	O
a	double
+	O
xi1	double
)	O
*	O
x	double
/	O
(	O
(	O
b	double
+	O
xi1	double
)	O
*	O
xi	double
)	O
;	O
double	O
b0_multiplier	double
=	O
(	O
a	double
+	O
xi1	double
-	O
beps	double
)	O
*	O
x	double
/	O
(	O
(	O
bint	double
+	O
xi1	double
)	O
*	O
(	O
xi	double
-	O
beps	double
)	O
)	O
;	O
a0_val	double
*=	O
a0_multiplier	double
;	O
a0_err	double
+=	O
fabs	(double)->(double)
(	O
a0_multiplier	double
)	O
*	O
a0_err	double
;	O
b0_val	double
*=	O
b0_multiplier	double
;	O
b0_err	double
+=	O
fabs	(double)->(double)
(	O
b0_multiplier	double
)	O
*	O
b0_err	double
;	O
t_val	double
=	O
a0_val	double
-	O
b0_val	double
;	O
t_err	double
=	O
a0_err	double
+	O
b0_err	double
;	O
dchu_val	double
+=	O
t_val	double
;	O
dchu_err	double
+=	O
t_err	double
;	O
if	O
(	O
!	O
gsl_finite	(double)->(int)
(	O
t_val	double
)	O
||	O
fabs	(double)->(double)
(	O
t_val	double
)	O
<	O
EPS	double
*	O
fabs	(double)->(double)
(	O
dchu_val	double
)	O
)	O
break	O
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
dchu_val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
dchu_err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
fabs	(double)->(double)
(	O
t_val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
i	int
+	O
2.0	int
)	O
*	O
fabs	(double)->(double)
(	O
dchu_val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
2.0	int
;	O
if	O
(	O
i	int
>=	O
2000	int
)	O
{	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
}	O
else	O
{	O
return	O
stat_all	int
;	O
}	O
}	O
static	O
int	O
hyperg_U_infinite_sum_improved	(int,double,double,double,double,double,double,struct(double,double),*(struct(double,double)))->(int)
(	O
int	O
N	int
,	O
double	O
a	double
,	O
double	O
bint	double
,	O
double	O
b	double
,	O
double	O
beps	double
,	O
double	O
x	double
,	O
double	O
xeps	double
,	O
gsl_sf_result	struct(double,double)
sum	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
EPS	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
const	O
double	O
lnx	double
=	O
log	(double)->(double)
(	O
x	double
)	O
;	O
int	O
istrt	int
=	O
(	O
N	int
<	O
1	int
?	O
1	int
-	O
N	int
:	O
0	int
)	O
;	O
double	O
xi	double
=	O
istrt	int
;	O
gsl_sf_result	struct(double,double)
gamr	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
powx	struct(double,double)
;	O
int	O
stat_gamr	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
1.0	int
+	O
a	double
-	O
b	double
,	O
&	O
gamr	struct(double,double)
)	O
;	O
int	O
stat_powx	int
=	O
gsl_sf_pow_int_e	(double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
istrt	int
,	O
&	O
powx	struct(double,double)
)	O
;	O
double	O
sarg	double
=	O
beps	double
*	O
M_PI	int
;	O
double	O
sfact	double
=	O
(	O
sarg	double
!=	O
0.0	int
?	O
sarg	double
/	O
sin	(double)->(double)
(	O
sarg	double
)	O
:	O
1.0	int
)	O
;	O
double	O
factor_val	double
=	O
sfact	double
*	O
(	O
GSL_IS_ODD	O
(	O
N	int
)	O
?	O
-	O
1.0	int
:	O
1.0	int
)	O
*	O
gamr	struct(double,double)
.	O
val	double
*	O
powx	struct(double,double)
.	O
val	double
;	O
double	O
factor_err	double
=	O
fabs	(double)->(double)
(	O
gamr	struct(double,double)
.	O
val	double
)	O
*	O
powx	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
powx	struct(double,double)
.	O
val	double
)	O
*	O
gamr	struct(double,double)
.	O
err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
factor_val	double
)	O
;	O
gsl_sf_result	struct(double,double)
pochai	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
gamri1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
gamrni	struct(double,double)
;	O
int	O
stat_pochai	int
=	O
gsl_sf_poch_e	(double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
xi	double
,	O
&	O
pochai	struct(double,double)
)	O
;	O
int	O
stat_gamri1	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
xi	double
+	O
1.0	int
,	O
&	O
gamri1	struct(double,double)
)	O
;	O
int	O
stat_gamrni	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
bint	double
+	O
xi	double
,	O
&	O
gamrni	struct(double,double)
)	O
;	O
int	O
stat_gam123	int
=	O
GSL_ERROR_SELECT_3	O
(	O
stat_gamr	int
,	O
stat_gamri1	int
,	O
stat_gamrni	int
)	O
;	O
int	O
stat_gamall	int
=	O
GSL_ERROR_SELECT_3	O
(	O
stat_gam123	int
,	O
stat_pochai	int
,	O
stat_powx	int
)	O
;	O
gsl_sf_result	struct(double,double)
pochaxibeps	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
gamrxi1beps	struct(double,double)
;	O
int	O
stat_pochaxibeps	int
=	O
gsl_sf_poch_e	(double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
xi	double
-	O
beps	double
,	O
&	O
pochaxibeps	struct(double,double)
)	O
;	O
int	O
stat_gamrxi1beps	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
xi	double
+	O
1.0	int
-	O
beps	double
,	O
&	O
gamrxi1beps	struct(double,double)
)	O
;	O
int	O
stat_all	int
=	O
GSL_ERROR_SELECT_3	O
(	O
stat_gamall	int
,	O
stat_pochaxibeps	int
,	O
stat_gamrxi1beps	int
)	O
;	O
double	O
b0_val	double
=	O
factor_val	double
*	O
pochaxibeps	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
;	O
double	O
b0_err	double
=	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochaxibeps	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
)	O
*	O
gamrxi1beps	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochaxibeps	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
)	O
*	O
gamrni	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
)	O
*	O
pochaxibeps	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
pochaxibeps	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamrxi1beps	struct(double,double)
.	O
val	double
)	O
*	O
factor_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
b0_val	double
)	O
;	O
int	O
i	int
;	O
gsl_sf_result	struct(double,double)
pch1ai	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
pch1i	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
poch1bxibeps	struct(double,double)
;	O
int	O
stat_pch1ai	int
=	O
gsl_sf_pochrel_e	(double,double,*(struct(double,double)))->(int)
(	O
a	double
+	O
xi	double
,	O
-	O
beps	double
,	O
&	O
pch1ai	struct(double,double)
)	O
;	O
int	O
stat_pch1i	int
=	O
gsl_sf_pochrel_e	(double,double,*(struct(double,double)))->(int)
(	O
xi	double
+	O
1.0	int
-	O
beps	double
,	O
beps	double
,	O
&	O
pch1i	struct(double,double)
)	O
;	O
int	O
stat_poch1bxibeps	int
=	O
gsl_sf_pochrel_e	(double,double,*(struct(double,double)))->(int)
(	O
b	double
+	O
xi	double
,	O
-	O
beps	double
,	O
&	O
poch1bxibeps	struct(double,double)
)	O
;	O
double	O
c0_t1_val	double
=	O
beps	double
*	O
pch1ai	struct(double,double)
.	O
val	double
*	O
pch1i	struct(double,double)
.	O
val	double
;	O
double	O
c0_t1_err	double
=	O
fabs	(double)->(double)
(	O
beps	double
)	O
*	O
fabs	(double)->(double)
(	O
pch1ai	struct(double,double)
.	O
val	double
)	O
*	O
pch1i	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
beps	double
)	O
*	O
fabs	(double)->(double)
(	O
pch1i	struct(double,double)
.	O
val	double
)	O
*	O
pch1ai	struct(double,double)
.	O
err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
c0_t1_val	double
)	O
;	O
double	O
c0_t2_val	double
=	O
-	O
poch1bxibeps	struct(double,double)
.	O
val	double
+	O
pch1ai	struct(double,double)
.	O
val	double
-	O
pch1i	struct(double,double)
.	O
val	double
+	O
c0_t1_val	double
;	O
double	O
c0_t2_err	double
=	O
poch1bxibeps	struct(double,double)
.	O
err	double
+	O
pch1ai	struct(double,double)
.	O
err	double
+	O
pch1i	struct(double,double)
.	O
err	double
+	O
c0_t1_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
c0_t2_val	double
)	O
;	O
double	O
c0_val	double
=	O
factor_val	double
*	O
pochai	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
*	O
c0_t2_val	double
;	O
double	O
c0_err	double
=	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochai	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
)	O
*	O
c0_t2_err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochai	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
c0_t2_val	double
)	O
*	O
gamri1	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
pochai	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
*	O
c0_t2_val	double
)	O
*	O
gamrni	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
factor_val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
*	O
c0_t2_val	double
)	O
*	O
pochai	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
pochai	struct(double,double)
.	O
val	double
*	O
gamrni	struct(double,double)
.	O
val	double
*	O
gamri1	struct(double,double)
.	O
val	double
*	O
c0_t2_val	double
)	O
*	O
factor_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
c0_val	double
)	O
;	O
gsl_sf_result	struct(double,double)
dexprl	struct(double,double)
;	O
int	O
stat_dexprl	int
=	O
gsl_sf_exprel_e	(double,*(struct(double,double)))->(int)
(	O
-	O
beps	double
*	O
lnx	double
,	O
&	O
dexprl	struct(double,double)
)	O
;	O
double	O
xeps1_val	double
=	O
lnx	double
*	O
dexprl	struct(double,double)
.	O
val	double
;	O
double	O
xeps1_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
1.0	int
+	O
fabs	(double)->(double)
(	O
beps	double
*	O
lnx	double
)	O
)	O
*	O
fabs	(double)->(double)
(	O
dexprl	struct(double,double)
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
lnx	double
)	O
*	O
dexprl	struct(double,double)
.	O
err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
xeps1_val	double
)	O
;	O
double	O
dchu_val	double
=	O
sum	double
.	O
val	double
+	O
c0_val	double
+	O
xeps1_val	double
*	O
b0_val	double
;	O
double	O
dchu_err	double
=	O
sum	double
.	O
err	double
+	O
c0_err	double
+	O
fabs	(double)->(double)
(	O
xeps1_val	double
)	O
*	O
b0_err	double
+	O
xeps1_err	double
*	O
fabs	(double)->(double)
(	O
b0_val	double
)	O
+	O
fabs	(double)->(double)
(	O
b0_val	double
*	O
lnx	double
)	O
*	O
dexprl	struct(double,double)
.	O
err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
sum	double
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
c0_val	double
)	O
+	O
fabs	(double)->(double)
(	O
xeps1_val	double
*	O
b0_val	double
)	O
)	O
;	O
double	O
xn	double
=	O
N	int
;	O
double	O
t_val	double
;	O
double	O
t_err	double
;	O
stat_all	int
=	O
GSL_ERROR_SELECT_5	O
(	O
stat_all	int
,	O
stat_dexprl	int
,	O
stat_poch1bxibeps	int
,	O
stat_pch1i	int
,	O
stat_pch1ai	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
2000	int
;	O
i	int
++	O
)	O
{	O
const	O
double	O
xi	double
=	O
istrt	int
+	O
i	int
;	O
const	O
double	O
xi1	double
=	O
istrt	int
+	O
i	int
-	O
1	int
;	O
const	O
double	O
tmp	double
=	O
(	O
a	double
-	O
1.0	int
)	O
*	O
(	O
xn	double
+	O
2.0	int
*	O
xi	double
-	O
1.0	int
)	O
+	O
xi	double
*	O
(	O
xi	double
-	O
beps	double
)	O
;	O
const	O
double	O
b0_multiplier	double
=	O
(	O
a	double
+	O
xi1	double
-	O
beps	double
)	O
*	O
x	double
/	O
(	O
(	O
xn	double
+	O
xi1	double
)	O
*	O
(	O
xi	double
-	O
beps	double
)	O
)	O
;	O
const	O
double	O
c0_multiplier_1	double
=	O
(	O
a	double
+	O
xi1	double
)	O
*	O
x	double
/	O
(	O
(	O
b	double
+	O
xi1	double
)	O
*	O
xi	double
)	O
;	O
const	O
double	O
c0_multiplier_2	double
=	O
tmp	double
/	O
(	O
xi	double
*	O
(	O
b	double
+	O
xi1	double
)	O
*	O
(	O
a	double
+	O
xi1	double
-	O
beps	double
)	O
)	O
;	O
b0_val	double
*=	O
b0_multiplier	double
;	O
b0_err	double
+=	O
fabs	(double)->(double)
(	O
b0_multiplier	double
)	O
*	O
b0_err	double
+	O
fabs	(double)->(double)
(	O
b0_val	double
)	O
*	O
8.0	int
*	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
c0_val	double
=	O
c0_multiplier_1	double
*	O
c0_val	double
-	O
c0_multiplier_2	double
*	O
b0_val	double
;	O
c0_err	double
=	O
fabs	(double)->(double)
(	O
c0_multiplier_1	double
)	O
*	O
c0_err	double
+	O
fabs	(double)->(double)
(	O
c0_multiplier_2	double
)	O
*	O
b0_err	double
+	O
fabs	(double)->(double)
(	O
c0_val	double
)	O
*	O
8.0	int
*	O
2.0	int
*	O
GSL_DBL_EPSILON	int
+	O
fabs	(double)->(double)
(	O
b0_val	double
*	O
c0_multiplier_2	double
)	O
*	O
16.0	int
*	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
t_val	double
=	O
c0_val	double
+	O
xeps1_val	double
*	O
b0_val	double
;	O
t_err	double
=	O
c0_err	double
+	O
fabs	(double)->(double)
(	O
xeps1_val	double
)	O
*	O
b0_err	double
;	O
t_err	double
+=	O
fabs	(double)->(double)
(	O
b0_val	double
*	O
lnx	double
)	O
*	O
dexprl	struct(double,double)
.	O
err	double
;	O
t_err	double
+=	O
fabs	(double)->(double)
(	O
b0_val	double
)	O
*	O
xeps1_err	double
;	O
dchu_val	double
+=	O
t_val	double
;	O
dchu_err	double
+=	O
t_err	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
t_val	double
)	O
<	O
EPS	double
*	O
fabs	(double)->(double)
(	O
dchu_val	double
)	O
)	O
break	O
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
dchu_val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
dchu_err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
fabs	(double)->(double)
(	O
t_val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
i	int
+	O
2.0	int
)	O
*	O
fabs	(double)->(double)
(	O
dchu_val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
2.0	int
;	O
if	O
(	O
i	int
>=	O
2000	int
)	O
{	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
}	O
else	O
{	O
return	O
stat_all	int
;	O
}	O
}	O
static	O
int	O
hyperg_U_series	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
SQRT_EPS	double
=	O
M_SQRT2	int
*	O
GSL_SQRT_DBL_EPSILON	int
;	O
double	O
bint	double
=	O
(	O
b	double
<	O
0.0	int
?	O
ceil	(double)->(double)
(	O
b	double
-	O
0.5	int
)	O
:	O
floor	(double)->(double)
(	O
b	double
+	O
0.5	int
)	O
)	O
;	O
double	O
beps	double
=	O
b	double
-	O
bint	double
;	O
double	O
a_beps	double
=	O
a	double
-	O
beps	double
;	O
double	O
r_a_beps	double
=	O
floor	(double)->(double)
(	O
a_beps	double
+	O
0.5	int
)	O
;	O
double	O
a_beps_int	double
=	O
(	O
fabs	(double)->(double)
(	O
a_beps	double
-	O
r_a_beps	double
)	O
<	O
INT_THRESHOLD	O
)	O
;	O
if	O
(	O
a_beps_int	double
&&	O
a_beps	double
<=	O
0	int
)	O
{	O
beps	double
=	O
beps	double
-	O
1	int
+	O
floor	(double)->(double)
(	O
a_beps	double
)	O
;	O
bint	double
=	O
bint	double
+	O
1	int
-	O
floor	(double)->(double)
(	O
a_beps	double
)	O
;	O
}	O
if	O
(	O
fabs	(double)->(double)
(	O
1.0	int
+	O
a	double
-	O
b	double
)	O
<	O
SQRT_EPS	double
)	O
{	O
double	O
lnr	*(struct(double,double))
=	O
-	O
a	double
*	O
log	(double)->(double)
(	O
x	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
lnr	*(struct(double,double))
,	O
result	*(struct(double,double))
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
SQRT_EPS	double
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
stat_e	int
;	O
}	O
else	O
{	O
int	O
N	int
=	O
(	O
int	O
)	O
bint	double
;	O
double	O
lnx	double
=	O
log	(double)->(double)
(	O
x	double
)	O
;	O
double	O
xeps	double
=	O
exp	(double)->(double)
(	O
-	O
beps	double
*	O
lnx	double
)	O
;	O
gsl_sf_result	struct(double,double)
sum	double
;	O
int	O
stat_sum	int
=	O
hyperg_U_finite_sum	(int,double,double,double,double,*(struct(double,double)))->(int)
(	O
N	int
,	O
a	double
,	O
b	double
,	O
x	double
,	O
xeps	double
,	O
&	O
sum	double
)	O
;	O
int	O
stat_inf	int
;	O
if	O
(	O
fabs	(double)->(double)
(	O
xeps	double
-	O
1.0	int
)	O
>	O
0.5	int
)	O
{	O
stat_inf	int
=	O
hyperg_U_infinite_sum_stable	(int,double,double,double,double,double,double,struct(double,double),*(struct(double,double)))->(int)
(	O
N	int
,	O
a	double
,	O
bint	double
,	O
b	double
,	O
beps	double
,	O
x	double
,	O
xeps	double
,	O
sum	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
1	int
+	O
a	double
-	O
b	double
<	O
0	int
&&	O
1	int
+	O
a	double
-	O
b	double
==	O
floor	(double)->(double)
(	O
1	int
+	O
a	double
-	O
b	double
)	O
&&	O
beps	double
!=	O
0	int
)	O
{	O
stat_inf	int
=	O
hyperg_U_infinite_sum_simple	(int,double,double,double,double,double,double,struct(double,double),*(struct(double,double)))->(int)
(	O
N	int
,	O
a	double
,	O
bint	double
,	O
b	double
,	O
beps	double
,	O
x	double
,	O
xeps	double
,	O
sum	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
stat_inf	int
=	O
hyperg_U_infinite_sum_improved	(int,double,double,double,double,double,double,struct(double,double),*(struct(double,double)))->(int)
(	O
N	int
,	O
a	double
,	O
bint	double
,	O
b	double
,	O
beps	double
,	O
x	double
,	O
xeps	double
,	O
sum	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_sum	int
,	O
stat_inf	int
)	O
;	O
}	O
}	O
static	O
int	O
hyperg_U_small_ab	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
a	double
==	O
-	O
1.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
b	double
+	O
x	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
b	double
)	O
+	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
a	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
ASYMP_EVAL_OK	O
(	O
a	double
,	O
b	double
,	O
x	double
)	O
)	O
{	O
double	O
p	double
=	O
pow	(double,double)->(double)
(	O
x	double
,	O
-	O
a	double
)	O
;	O
gsl_sf_result	struct(double,double)
asymp	struct(double,double)
;	O
int	O
stat_asymp	int
=	O
hyperg_zaU_asymp	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
asymp	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
asymp	struct(double,double)
.	O
val	double
*	O
p	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
asymp	struct(double,double)
.	O
err	double
*	O
p	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
fabs	(double)->(double)
(	O
asymp	struct(double,double)
.	O
val	double
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
a	double
)	O
*	O
p	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
stat_asymp	int
;	O
}	O
else	O
{	O
return	O
hyperg_U_series	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
static	O
int	O
hyperg_U_small_a_bgt0	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
,	O
double	O
*	O
ln_multiplier	*(double)
)	O
{	O
if	O
(	O
a	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
*	O
ln_multiplier	*(double)
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
(	O
b	double
>	O
5000.0	int
&&	O
x	double
<	O
0.90	int
*	O
fabs	(double)->(double)
(	O
b	double
)	O
)	O
||	O
(	O
b	double
>	O
500.0	int
&&	O
x	double
<	O
0.50	int
*	O
fabs	(double)->(double)
(	O
b	double
)	O
)	O
)	O
{	O
int	O
stat	int
=	O
gsl_sf_hyperg_U_large_b_e	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
,	O
ln_multiplier	*(double)
)	O
;	O
if	O
(	O
stat	int
==	O
GSL_EOVRFLW	int
)	O
return	O
GSL_SUCCESS	int
;	O
else	O
return	O
stat	int
;	O
}	O
else	O
if	O
(	O
b	double
>	O
15.0	int
)	O
{	O
double	O
eps	double
=	O
b	double
-	O
floor	(double)->(double)
(	O
b	double
)	O
;	O
double	O
b0	double
=	O
1.0	int
+	O
eps	double
;	O
gsl_sf_result	struct(double,double)
r_Ubm1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
r_Ub	struct(double,double)
;	O
int	O
stat_0	int
=	O
hyperg_U_small_ab	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b0	double
,	O
x	double
,	O
&	O
r_Ubm1	struct(double,double)
)	O
;	O
int	O
stat_1	int
=	O
hyperg_U_small_ab	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b0	double
+	O
1.0	int
,	O
x	double
,	O
&	O
r_Ub	struct(double,double)
)	O
;	O
double	O
Ubm1	double
=	O
r_Ubm1	struct(double,double)
.	O
val	double
;	O
double	O
Ub	double
=	O
r_Ub	struct(double,double)
.	O
val	double
;	O
double	O
Ubp1	double
;	O
double	O
bp	double
;	O
for	O
(	O
bp	double
=	O
b0	double
+	O
1.0	int
;	O
bp	double
<	O
b	double
-	O
0.1	int
;	O
bp	double
+=	O
1.0	int
)	O
{	O
Ubp1	double
=	O
(	O
(	O
1.0	int
+	O
a	double
-	O
bp	double
)	O
*	O
Ubm1	double
+	O
(	O
bp	double
+	O
x	double
-	O
1.0	int
)	O
*	O
Ub	double
)	O
/	O
x	double
;	O
Ubm1	double
=	O
Ub	double
;	O
Ub	double
=	O
Ubp1	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
Ub	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
(	O
fabs	(double)->(double)
(	O
r_Ubm1	struct(double,double)
.	O
err	double
/	O
r_Ubm1	struct(double,double)
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
r_Ub	struct(double,double)
.	O
err	double
/	O
r_Ub	struct(double,double)
.	O
val	double
)	O
)	O
*	O
fabs	(double)->(double)
(	O
Ub	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
b	double
-	O
b0	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Ub	double
)	O
;	O
*	O
ln_multiplier	*(double)
=	O
0.0	int
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_0	int
,	O
stat_1	int
)	O
;	O
}	O
else	O
{	O
*	O
ln_multiplier	*(double)
=	O
0.0	int
;	O
return	O
hyperg_U_small_ab	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
static	O
int	O
hyperg_U_int_bge1	(int,int,double,*(struct(double,double,int)))->(int)
(	O
const	O
int	O
a	double
,	O
const	O
int	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
a	double
==	O
0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
a	double
==	O
-	O
1	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
b	double
+	O
x	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
b	double
)	O
+	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
b	double
==	O
a	double
+	O
1	int
)	O
{	O
return	O
gsl_sf_exp_e10_e	(double,*(struct(double,double,int)))->(int)
(	O
-	O
a	double
*	O
log	(double)->(double)
(	O
x	double
)	O
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
ASYMP_EVAL_OK	O
(	O
a	double
,	O
b	double
,	O
x	double
)	O
)	O
{	O
const	O
double	O
ln_pre_val	double
=	O
-	O
a	double
*	O
log	(double)->(double)
(	O
x	double
)	O
;	O
const	O
double	O
ln_pre_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
ln_pre_val	double
)	O
;	O
gsl_sf_result	struct(double,double)
asymp	struct(double,double)
;	O
int	O
stat_asymp	int
=	O
hyperg_zaU_asymp	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
asymp	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
ln_pre_val	double
,	O
ln_pre_err	double
,	O
asymp	struct(double,double)
.	O
val	double
,	O
asymp	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_asymp	int
)	O
;	O
}	O
else	O
if	O
(	O
SERIES_EVAL_OK	O
(	O
a	double
,	O
b	double
,	O
x	double
)	O
&&	O
1	int
+	O
a	double
-	O
b	double
>	O
0	int
)	O
{	O
gsl_sf_result	struct(double,double)
ser	struct(double,double)
;	O
const	O
int	O
stat_ser	int
=	O
hyperg_U_series	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
ser	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
ser	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
ser	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
stat_ser	int
;	O
}	O
else	O
if	O
(	O
a	double
<	O
0	int
)	O
{	O
int	O
scale_count	int
=	O
0	int
;	O
const	O
double	O
scale_factor	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
gsl_sf_result	struct(double,double)
lnm	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
y	double
;	O
double	O
lnscale	double
;	O
double	O
Uap1	double
=	O
1.0	int
;	O
double	O
Ua	double
=	O
-	O
b	double
+	O
x	double
;	O
double	O
Uam1	double
;	O
int	O
ap	double
;	O
for	O
(	O
ap	double
=	O
-	O
1	int
;	O
ap	double
>	O
a	double
;	O
ap	double
--	O
)	O
{	O
Uam1	double
=	O
ap	double
*	O
(	O
b	double
-	O
ap	double
-	O
1.0	int
)	O
*	O
Uap1	double
+	O
(	O
x	double
+	O
2.0	int
*	O
ap	double
-	O
b	double
)	O
*	O
Ua	double
;	O
Uap1	double
=	O
Ua	double
;	O
Ua	double
=	O
Uam1	double
;	O
RESCALE_2	O
(	O
Ua	double
,	O
Uap1	double
,	O
scale_factor	double
,	O
scale_count	int
)	O
;	O
}	O
lnscale	double
=	O
log	(double)->(double)
(	O
scale_factor	double
)	O
;	O
lnm	struct(double,double)
.	O
val	double
=	O
scale_count	int
*	O
lnscale	double
;	O
lnm	struct(double,double)
.	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
lnm	struct(double,double)
.	O
val	double
)	O
;	O
y	double
.	O
val	double
=	O
Ua	double
;	O
y	double
.	O
err	double
=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Ua	double
)	O
;	O
return	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
lnm	struct(double,double)
.	O
val	double
,	O
lnm	struct(double,double)
.	O
err	double
,	O
y	double
.	O
val	double
,	O
y	double
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
>=	O
2.0	int
*	O
a	double
+	O
x	double
)	O
{	O
int	O
scale_count	int
=	O
0	int
;	O
const	O
double	O
scale_factor	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
gsl_sf_result	struct(double,double)
r_Ua	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
lnm	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
y	double
;	O
double	O
lnscale	double
;	O
double	O
lm	double
;	O
int	O
stat_1	int
=	O
hyperg_U_small_a_bgt0	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
1.0	int
,	O
b	double
,	O
x	double
,	O
&	O
r_Ua	struct(double,double)
,	O
&	O
lm	double
)	O
;	O
int	O
stat_e	int
;	O
double	O
Uam1	double
=	O
1.0	int
;	O
double	O
Ua	double
=	O
r_Ua	struct(double,double)
.	O
val	double
;	O
double	O
Uap1	double
;	O
int	O
ap	double
;	O
Uam1	double
*=	O
exp	(double)->(double)
(	O
-	O
lm	double
)	O
;	O
for	O
(	O
ap	double
=	O
1	int
;	O
ap	double
<	O
a	double
;	O
ap	double
++	O
)	O
{	O
Uap1	double
=	O
-	O
(	O
Uam1	double
+	O
(	O
b	double
-	O
2.0	int
*	O
ap	double
-	O
x	double
)	O
*	O
Ua	double
)	O
/	O
(	O
ap	double
*	O
(	O
1.0	int
+	O
ap	double
-	O
b	double
)	O
)	O
;	O
Uam1	double
=	O
Ua	double
;	O
Ua	double
=	O
Uap1	double
;	O
RESCALE_2	O
(	O
Ua	double
,	O
Uam1	double
,	O
scale_factor	double
,	O
scale_count	int
)	O
;	O
}	O
lnscale	double
=	O
log	(double)->(double)
(	O
scale_factor	double
)	O
;	O
lnm	struct(double,double)
.	O
val	double
=	O
lm	double
+	O
scale_count	int
*	O
lnscale	double
;	O
lnm	struct(double,double)
.	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
lm	double
)	O
+	O
fabs	(double)->(double)
(	O
scale_count	int
*	O
lnscale	double
)	O
)	O
;	O
y	double
.	O
val	double
=	O
Ua	double
;	O
y	double
.	O
err	double
=	O
fabs	(double)->(double)
(	O
r_Ua	struct(double,double)
.	O
err	double
/	O
r_Ua	struct(double,double)
.	O
val	double
)	O
*	O
fabs	(double)->(double)
(	O
Ua	double
)	O
;	O
y	double
.	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Ua	double
)	O
;	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
lnm	struct(double,double)
.	O
val	double
,	O
lnm	struct(double,double)
.	O
err	double
,	O
y	double
.	O
val	double
,	O
y	double
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
b	double
<=	O
x	double
)	O
{	O
const	O
double	O
scale_factor	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
int	O
scale_count	int
=	O
0	int
;	O
int	O
stat_CF1	int
;	O
double	O
ru	double
;	O
int	O
CF1_count	int
;	O
int	O
a_target	int
;	O
double	O
lnU_target	double
;	O
double	O
Ua	double
;	O
double	O
Uap1	double
;	O
double	O
Uam1	double
;	O
int	O
ap	double
;	O
if	O
(	O
b	double
<	O
a	double
+	O
1	int
)	O
{	O
a_target	int
=	O
b	double
-	O
1	int
;	O
lnU_target	double
=	O
-	O
a_target	int
*	O
log	(double)->(double)
(	O
x	double
)	O
;	O
}	O
else	O
{	O
a_target	int
=	O
0	int
;	O
lnU_target	double
=	O
0.0	int
;	O
}	O
stat_CF1	int
=	O
hyperg_U_CF1	(double,double,int,double,*(double),*(int))->(int)
(	O
a	double
,	O
b	double
,	O
0	int
,	O
x	double
,	O
&	O
ru	double
,	O
&	O
CF1_count	int
)	O
;	O
Ua	double
=	O
1.0	int
;	O
Uap1	double
=	O
ru	double
/	O
a	double
*	O
Ua	double
;	O
for	O
(	O
ap	double
=	O
a	double
;	O
ap	double
>	O
a_target	int
;	O
ap	double
--	O
)	O
{	O
Uam1	double
=	O
-	O
(	O
(	O
b	double
-	O
2.0	int
*	O
ap	double
-	O
x	double
)	O
*	O
Ua	double
+	O
ap	double
*	O
(	O
1.0	int
+	O
ap	double
-	O
b	double
)	O
*	O
Uap1	double
)	O
;	O
Uap1	double
=	O
Ua	double
;	O
Ua	double
=	O
Uam1	double
;	O
RESCALE_2	O
(	O
Ua	double
,	O
Uap1	double
,	O
scale_factor	double
,	O
scale_count	int
)	O
;	O
}	O
if	O
(	O
Ua	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EZERODIV	int
)	O
;	O
}	O
else	O
{	O
double	O
lnscl	double
=	O
-	O
scale_count	int
*	O
log	(double)->(double)
(	O
scale_factor	double
)	O
;	O
double	O
lnpre_val	double
=	O
lnU_target	double
+	O
lnscl	double
;	O
double	O
lnpre_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
lnU_target	double
)	O
+	O
fabs	(double)->(double)
(	O
lnscl	double
)	O
)	O
;	O
double	O
oUa_err	double
=	O
2.0	int
*	O
(	O
fabs	(double)->(double)
(	O
a_target	int
-	O
a	double
)	O
+	O
CF1_count	int
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
1.0	int
/	O
Ua	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
lnpre_val	double
,	O
lnpre_err	double
,	O
1.0	int
/	O
Ua	double
,	O
oUa_err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_CF1	int
)	O
;	O
}	O
}	O
else	O
{	O
const	O
double	O
scale_factor	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
int	O
scale_count_for	int
=	O
0	int
;	O
int	O
scale_count_bck	int
=	O
0	int
;	O
int	O
a0	int
=	O
1	int
;	O
int	O
a1	double
=	O
a0	int
+	O
ceil	(double)->(double)
(	O
0.5	int
*	O
(	O
b	double
-	O
x	double
)	O
-	O
a0	int
)	O
;	O
double	O
Ua1_bck_val	double
;	O
double	O
Ua1_bck_err	double
;	O
double	O
Ua1_for_val	double
;	O
double	O
Ua1_for_err	double
;	O
int	O
stat_for	int
;	O
int	O
stat_bck	int
;	O
gsl_sf_result	struct(double,double)
lm_for	struct(double,double)
;	O
{	O
double	O
ru	double
;	O
int	O
CF1_count	int
;	O
int	O
stat_CF1	int
=	O
hyperg_U_CF1	(double,double,int,double,*(double),*(int))->(int)
(	O
a	double
,	O
b	double
,	O
0	int
,	O
x	double
,	O
&	O
ru	double
,	O
&	O
CF1_count	int
)	O
;	O
double	O
Ua	double
=	O
1.0	int
;	O
double	O
Uap1	double
=	O
ru	double
/	O
a	double
*	O
Ua	double
;	O
double	O
Uam1	double
;	O
int	O
ap	double
;	O
for	O
(	O
ap	double
=	O
a	double
;	O
ap	double
>	O
a1	double
;	O
ap	double
--	O
)	O
{	O
Uam1	double
=	O
-	O
(	O
(	O
b	double
-	O
2.0	int
*	O
ap	double
-	O
x	double
)	O
*	O
Ua	double
+	O
ap	double
*	O
(	O
1.0	int
+	O
ap	double
-	O
b	double
)	O
*	O
Uap1	double
)	O
;	O
Uap1	double
=	O
Ua	double
;	O
Ua	double
=	O
Uam1	double
;	O
RESCALE_2	O
(	O
Ua	double
,	O
Uap1	double
,	O
scale_factor	double
,	O
scale_count_bck	int
)	O
;	O
}	O
Ua1_bck_val	double
=	O
Ua	double
;	O
Ua1_bck_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a1	double
-	O
a	double
)	O
+	O
CF1_count	int
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Ua	double
)	O
;	O
stat_bck	int
=	O
stat_CF1	int
;	O
}	O
if	O
(	O
b	double
==	O
2	int
*	O
a1	double
&&	O
a1	double
>	O
1	int
)	O
{	O
hyperg_lnU_beq2a	(double,double,*(struct(double,double)))->(int)
(	O
(	O
double	O
)	O
a1	double
,	O
x	double
,	O
&	O
lm_for	struct(double,double)
)	O
;	O
Ua1_for_val	double
=	O
1.0	int
;	O
Ua1_for_err	double
=	O
0.0	int
;	O
stat_for	int
=	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
b	double
==	O
2	int
*	O
a1	double
-	O
1	int
&&	O
a1	double
>	O
1	int
)	O
{	O
gsl_sf_result	struct(double,double)
lnU00	struct(double,double)
,	O
lnU12	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
U00	struct(double,double)
,	O
U12	struct(double,double)
;	O
hyperg_lnU_beq2a	(double,double,*(struct(double,double)))->(int)
(	O
a1	double
-	O
1.0	int
,	O
x	double
,	O
&	O
lnU00	struct(double,double)
)	O
;	O
hyperg_lnU_beq2a	(double,double,*(struct(double,double)))->(int)
(	O
a1	double
,	O
x	double
,	O
&	O
lnU12	struct(double,double)
)	O
;	O
if	O
(	O
lnU00	struct(double,double)
.	O
val	double
>	O
lnU12	struct(double,double)
.	O
val	double
)	O
{	O
lm_for	struct(double,double)
.	O
val	double
=	O
lnU00	struct(double,double)
.	O
val	double
;	O
lm_for	struct(double,double)
.	O
err	double
=	O
lnU00	struct(double,double)
.	O
err	double
;	O
U00	struct(double,double)
.	O
val	double
=	O
1.0	int
;	O
U00	struct(double,double)
.	O
err	double
=	O
0.0	int
;	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
lnU12	struct(double,double)
.	O
val	double
-	O
lm_for	struct(double,double)
.	O
val	double
,	O
lnU12	struct(double,double)
.	O
err	double
+	O
lm_for	struct(double,double)
.	O
err	double
,	O
&	O
U12	struct(double,double)
)	O
;	O
}	O
else	O
{	O
lm_for	struct(double,double)
.	O
val	double
=	O
lnU12	struct(double,double)
.	O
val	double
;	O
lm_for	struct(double,double)
.	O
err	double
=	O
lnU12	struct(double,double)
.	O
err	double
;	O
U12	struct(double,double)
.	O
val	double
=	O
1.0	int
;	O
U12	struct(double,double)
.	O
err	double
=	O
0.0	int
;	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
lnU00	struct(double,double)
.	O
val	double
-	O
lm_for	struct(double,double)
.	O
val	double
,	O
lnU00	struct(double,double)
.	O
err	double
+	O
lm_for	struct(double,double)
.	O
err	double
,	O
&	O
U00	struct(double,double)
)	O
;	O
}	O
Ua1_for_val	double
=	O
(	O
x	double
*	O
U12	struct(double,double)
.	O
val	double
-	O
U00	struct(double,double)
.	O
val	double
)	O
/	O
(	O
2.0	int
*	O
a1	double
-	O
2.0	int
)	O
;	O
Ua1_for_err	double
=	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
*	O
U12	struct(double,double)
.	O
err	double
+	O
U00	struct(double,double)
.	O
err	double
)	O
/	O
fabs	(double)->(double)
(	O
2.0	int
*	O
a1	double
-	O
2.0	int
)	O
;	O
Ua1_for_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Ua1_for_val	double
)	O
;	O
stat_for	int
=	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
r_Ua	struct(double,double)
;	O
double	O
Uam1	double
=	O
1.0	int
;	O
double	O
Ua	double
;	O
double	O
Uap1	double
;	O
int	O
ap	double
;	O
double	O
lm_for_local	double
;	O
stat_for	int
=	O
hyperg_U_small_a_bgt0	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
a0	int
,	O
b	double
,	O
x	double
,	O
&	O
r_Ua	struct(double,double)
,	O
&	O
lm_for_local	double
)	O
;	O
Ua	double
=	O
r_Ua	struct(double,double)
.	O
val	double
;	O
Uam1	double
*=	O
exp	(double)->(double)
(	O
-	O
lm_for_local	double
)	O
;	O
lm_for	struct(double,double)
.	O
val	double
=	O
lm_for_local	double
;	O
lm_for	struct(double,double)
.	O
err	double
=	O
0.0	int
;	O
for	O
(	O
ap	double
=	O
a0	int
;	O
ap	double
<	O
a1	double
;	O
ap	double
++	O
)	O
{	O
Uap1	double
=	O
-	O
(	O
Uam1	double
+	O
(	O
b	double
-	O
2.0	int
*	O
ap	double
-	O
x	double
)	O
*	O
Ua	double
)	O
/	O
(	O
ap	double
*	O
(	O
1.0	int
+	O
ap	double
-	O
b	double
)	O
)	O
;	O
Uam1	double
=	O
Ua	double
;	O
Ua	double
=	O
Uap1	double
;	O
RESCALE_2	O
(	O
Ua	double
,	O
Uam1	double
,	O
scale_factor	double
,	O
scale_count_for	int
)	O
;	O
}	O
Ua1_for_val	double
=	O
Ua	double
;	O
Ua1_for_err	double
=	O
fabs	(double)->(double)
(	O
Ua	double
)	O
*	O
fabs	(double)->(double)
(	O
r_Ua	struct(double,double)
.	O
err	double
/	O
r_Ua	struct(double,double)
.	O
val	double
)	O
;	O
Ua1_for_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a1	double
-	O
a0	int
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Ua1_for_val	double
)	O
;	O
}	O
if	O
(	O
Ua1_bck_val	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EZERODIV	int
)	O
;	O
}	O
else	O
if	O
(	O
Ua1_for_val	double
==	O
0.0	int
)	O
{	O
UNDERFLOW_ERROR_E10	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
double	O
lns	double
=	O
(	O
scale_count_for	int
-	O
scale_count_bck	int
)	O
*	O
log	(double)->(double)
(	O
scale_factor	double
)	O
;	O
double	O
ln_for_val	double
=	O
log	(double)->(double)
(	O
fabs	(double)->(double)
(	O
Ua1_for_val	double
)	O
)	O
;	O
double	O
ln_for_err	double
=	O
GSL_DBL_EPSILON	int
+	O
fabs	(double)->(double)
(	O
Ua1_for_err	double
/	O
Ua1_for_val	double
)	O
;	O
double	O
ln_bck_val	double
=	O
log	(double)->(double)
(	O
fabs	(double)->(double)
(	O
Ua1_bck_val	double
)	O
)	O
;	O
double	O
ln_bck_err	double
=	O
GSL_DBL_EPSILON	int
+	O
fabs	(double)->(double)
(	O
Ua1_bck_err	double
/	O
Ua1_bck_val	double
)	O
;	O
double	O
lnr_val	double
=	O
lm_for	struct(double,double)
.	O
val	double
+	O
ln_for_val	double
-	O
ln_bck_val	double
+	O
lns	double
;	O
double	O
lnr_err	double
=	O
lm_for	struct(double,double)
.	O
err	double
+	O
ln_for_err	double
+	O
ln_bck_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
lm_for	struct(double,double)
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
ln_for_val	double
)	O
+	O
fabs	(double)->(double)
(	O
ln_bck_val	double
)	O
+	O
fabs	(double)->(double)
(	O
lns	double
)	O
)	O
;	O
double	O
sgn	*(double)
=	O
GSL_SIGN	O
(	O
Ua1_for_val	double
)	O
*	O
GSL_SIGN	O
(	O
Ua1_bck_val	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_err_e10_e	(double,double,*(struct(double,double,int)))->(int)
(	O
lnr_val	double
,	O
lnr_err	double
,	O
result	*(struct(double,double))
)	O
;	O
result	*(struct(double,double))
->	O
val	double
*=	O
sgn	*(double)
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_bck	int
,	O
stat_for	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
hyperg_U_bge1	(double,double,double,*(struct(double,double,int)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
rinta	double
=	O
floor	(double)->(double)
(	O
a	double
+	O
0.5	int
)	O
;	O
const	O
int	O
a_neg_integer	int
=	O
(	O
a	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
a	double
-	O
rinta	double
)	O
<	O
INT_THRESHOLD	O
)	O
;	O
if	O
(	O
a	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
a_neg_integer	int
&&	O
fabs	(double)->(double)
(	O
rinta	double
)	O
<	O
INT_MAX	O
)	O
{	O
const	O
int	O
n	int
=	O
-	O
(	O
int	O
)	O
rinta	double
;	O
const	O
double	O
sgn	*(double)
=	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
?	O
-	O
1.0	int
:	O
1.0	int
)	O
;	O
gsl_sf_result	struct(double,double)
lnfact	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
L	struct(double,double)
;	O
const	O
int	O
stat_L	int
=	O
gsl_sf_laguerre_n_e	(int,double,double,*(struct(double,double)))->(int)
(	O
n	int
,	O
b	double
-	O
1.0	int
,	O
x	double
,	O
&	O
L	struct(double,double)
)	O
;	O
gsl_sf_lnfact_e	(int,*(struct(double,double)))->(int)
(	O
n	int
,	O
&	O
lnfact	struct(double,double)
)	O
;	O
{	O
const	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
lnfact	struct(double,double)
.	O
val	double
,	O
lnfact	struct(double,double)
.	O
err	double
,	O
sgn	*(double)
*	O
L	struct(double,double)
.	O
val	double
,	O
L	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_L	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
ASYMP_EVAL_OK	O
(	O
a	double
,	O
b	double
,	O
x	double
)	O
)	O
{	O
const	O
double	O
ln_pre_val	double
=	O
-	O
a	double
*	O
log	(double)->(double)
(	O
x	double
)	O
;	O
const	O
double	O
ln_pre_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
ln_pre_val	double
)	O
;	O
gsl_sf_result	struct(double,double)
asymp	struct(double,double)
;	O
int	O
stat_asymp	int
=	O
hyperg_zaU_asymp	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
asymp	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
ln_pre_val	double
,	O
ln_pre_err	double
,	O
asymp	struct(double,double)
.	O
val	double
,	O
asymp	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_asymp	int
)	O
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
<=	O
1.0	int
)	O
{	O
gsl_sf_result	struct(double,double)
rU	struct(double,double)
;	O
double	O
ln_multiplier	*(double)
;	O
int	O
stat_U	int
=	O
hyperg_U_small_a_bgt0	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
rU	struct(double,double)
,	O
&	O
ln_multiplier	*(double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
ln_multiplier	*(double)
,	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
ln_multiplier	*(double)
)	O
,	O
rU	struct(double,double)
.	O
val	double
,	O
rU	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_U	int
,	O
stat_e	int
)	O
;	O
}	O
else	O
if	O
(	O
SERIES_EVAL_OK	O
(	O
a	double
,	O
b	double
,	O
x	double
)	O
)	O
{	O
gsl_sf_result	struct(double,double)
ser	struct(double,double)
;	O
const	O
int	O
stat_ser	int
=	O
hyperg_U_series	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
ser	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
ser	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
ser	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
stat_ser	int
;	O
}	O
else	O
if	O
(	O
a	double
<	O
0.0	int
)	O
{	O
const	O
double	O
scale_factor	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
const	O
double	O
a0	int
=	O
a	double
-	O
floor	(double)->(double)
(	O
a	double
)	O
-	O
1.0	int
;	O
const	O
double	O
b0	double
=	O
b	double
-	O
floor	(double)->(double)
(	O
b	double
)	O
+	O
1.0	int
;	O
int	O
scale_count	int
=	O
0	int
;	O
double	O
lm_0	double
,	O
lm_1	double
;	O
double	O
lm_max	double
;	O
gsl_sf_result	struct(double,double)
r_Uap1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
r_Ua	struct(double,double)
;	O
int	O
stat_0	int
=	O
hyperg_U_small_a_bgt0	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
a0	int
+	O
1.0	int
,	O
b0	double
,	O
x	double
,	O
&	O
r_Uap1	struct(double,double)
,	O
&	O
lm_0	double
)	O
;	O
int	O
stat_1	int
=	O
hyperg_U_small_a_bgt0	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
a0	int
,	O
b0	double
,	O
x	double
,	O
&	O
r_Ua	struct(double,double)
,	O
&	O
lm_1	double
)	O
;	O
int	O
stat_e	int
;	O
double	O
Uap1	double
=	O
r_Uap1	struct(double,double)
.	O
val	double
;	O
double	O
Ua	double
=	O
r_Ua	struct(double,double)
.	O
val	double
;	O
double	O
Uam1	double
;	O
double	O
ap	double
;	O
lm_max	double
=	O
GSL_MAX	O
(	O
lm_0	double
,	O
lm_1	double
)	O
;	O
Uap1	double
*=	O
exp	(double)->(double)
(	O
lm_0	double
-	O
lm_max	double
)	O
;	O
Ua	double
*=	O
exp	(double)->(double)
(	O
lm_1	double
-	O
lm_max	double
)	O
;	O
for	O
(	O
ap	double
=	O
a0	int
;	O
ap	double
>	O
a	double
+	O
0.1	int
;	O
ap	double
-=	O
1.0	int
)	O
{	O
Uam1	double
=	O
ap	double
*	O
(	O
b0	double
-	O
ap	double
-	O
1.0	int
)	O
*	O
Uap1	double
+	O
(	O
x	double
+	O
2.0	int
*	O
ap	double
-	O
b0	double
)	O
*	O
Ua	double
;	O
Uap1	double
=	O
Ua	double
;	O
Ua	double
=	O
Uam1	double
;	O
RESCALE_2	O
(	O
Ua	double
,	O
Uap1	double
,	O
scale_factor	double
,	O
scale_count	int
)	O
;	O
}	O
if	O
(	O
b	double
<	O
2.0	int
)	O
{	O
const	O
double	O
lnscale	double
=	O
log	(double)->(double)
(	O
scale_factor	double
)	O
;	O
gsl_sf_result	struct(double,double)
lnm	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
y	double
;	O
lnm	struct(double,double)
.	O
val	double
=	O
lm_max	double
+	O
scale_count	int
*	O
lnscale	double
;	O
lnm	struct(double,double)
.	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
lm_max	double
)	O
+	O
scale_count	int
*	O
fabs	(double)->(double)
(	O
lnscale	double
)	O
)	O
;	O
y	double
.	O
val	double
=	O
Ua	double
;	O
y	double
.	O
err	double
=	O
fabs	(double)->(double)
(	O
r_Uap1	struct(double,double)
.	O
err	double
/	O
r_Uap1	struct(double,double)
.	O
val	double
)	O
*	O
fabs	(double)->(double)
(	O
Ua	double
)	O
;	O
y	double
.	O
err	double
+=	O
fabs	(double)->(double)
(	O
r_Ua	struct(double,double)
.	O
err	double
/	O
r_Ua	struct(double,double)
.	O
val	double
)	O
*	O
fabs	(double)->(double)
(	O
Ua	double
)	O
;	O
y	double
.	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a	double
-	O
a0	int
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Ua	double
)	O
;	O
y	double
.	O
err	double
*=	O
fabs	(double)->(double)
(	O
lm_0	double
-	O
lm_max	double
)	O
+	O
1.0	int
;	O
y	double
.	O
err	double
*=	O
fabs	(double)->(double)
(	O
lm_1	double
-	O
lm_max	double
)	O
+	O
1.0	int
;	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
lnm	struct(double,double)
.	O
val	double
,	O
lnm	struct(double,double)
.	O
err	double
,	O
y	double
.	O
val	double
,	O
y	double
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
const	O
double	O
err_mult	double
=	O
fabs	(double)->(double)
(	O
b	double
-	O
b0	double
)	O
+	O
fabs	(double)->(double)
(	O
a	double
-	O
a0	int
)	O
+	O
1.0	int
;	O
const	O
double	O
lnscale	double
=	O
log	(double)->(double)
(	O
scale_factor	double
)	O
;	O
gsl_sf_result	struct(double,double)
lnm	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
y	double
;	O
double	O
Ubm1	double
=	O
Ua	double
;	O
double	O
Ub	double
=	O
(	O
a	double
*	O
(	O
b0	double
-	O
a	double
-	O
1.0	int
)	O
*	O
Uap1	double
+	O
(	O
a	double
+	O
x	double
)	O
*	O
Ua	double
)	O
/	O
x	double
;	O
double	O
Ubp1	double
;	O
double	O
bp	double
;	O
for	O
(	O
bp	double
=	O
b0	double
+	O
1.0	int
;	O
bp	double
<	O
b	double
-	O
0.1	int
;	O
bp	double
+=	O
1.0	int
)	O
{	O
Ubp1	double
=	O
(	O
(	O
1.0	int
+	O
a	double
-	O
bp	double
)	O
*	O
Ubm1	double
+	O
(	O
bp	double
+	O
x	double
-	O
1.0	int
)	O
*	O
Ub	double
)	O
/	O
x	double
;	O
Ubm1	double
=	O
Ub	double
;	O
Ub	double
=	O
Ubp1	double
;	O
RESCALE_2	O
(	O
Ub	double
,	O
Ubm1	double
,	O
scale_factor	double
,	O
scale_count	int
)	O
;	O
}	O
lnm	struct(double,double)
.	O
val	double
=	O
lm_max	double
+	O
scale_count	int
*	O
lnscale	double
;	O
lnm	struct(double,double)
.	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
lm_max	double
)	O
+	O
fabs	(double)->(double)
(	O
scale_count	int
*	O
lnscale	double
)	O
)	O
;	O
y	double
.	O
val	double
=	O
Ub	double
;	O
y	double
.	O
err	double
=	O
2.0	int
*	O
err_mult	double
*	O
fabs	(double)->(double)
(	O
r_Uap1	struct(double,double)
.	O
err	double
/	O
r_Uap1	struct(double,double)
.	O
val	double
)	O
*	O
fabs	(double)->(double)
(	O
Ub	double
)	O
;	O
y	double
.	O
err	double
+=	O
2.0	int
*	O
err_mult	double
*	O
fabs	(double)->(double)
(	O
r_Ua	struct(double,double)
.	O
err	double
/	O
r_Ua	struct(double,double)
.	O
val	double
)	O
*	O
fabs	(double)->(double)
(	O
Ub	double
)	O
;	O
y	double
.	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
err_mult	double
*	O
fabs	(double)->(double)
(	O
Ub	double
)	O
;	O
y	double
.	O
err	double
*=	O
fabs	(double)->(double)
(	O
lm_0	double
-	O
lm_max	double
)	O
+	O
1.0	int
;	O
y	double
.	O
err	double
*=	O
fabs	(double)->(double)
(	O
lm_1	double
-	O
lm_max	double
)	O
+	O
1.0	int
;	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
lnm	struct(double,double)
.	O
val	double
,	O
lnm	struct(double,double)
.	O
err	double
,	O
y	double
.	O
val	double
,	O
y	double
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_0	int
,	O
stat_1	int
)	O
;	O
}	O
else	O
if	O
(	O
b	double
>=	O
2	int
*	O
a	double
+	O
x	double
)	O
{	O
int	O
scale_count	int
=	O
0	int
;	O
const	O
double	O
a0	int
=	O
a	double
-	O
floor	(double)->(double)
(	O
a	double
)	O
;	O
const	O
double	O
scale_factor	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
double	O
lnscale	double
;	O
double	O
lm_0	double
,	O
lm_1	double
,	O
lm_max	double
;	O
gsl_sf_result	struct(double,double)
r_Uam1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
r_Ua	struct(double,double)
;	O
int	O
stat_0	int
=	O
hyperg_U_small_a_bgt0	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
a0	int
-	O
1.0	int
,	O
b	double
,	O
x	double
,	O
&	O
r_Uam1	struct(double,double)
,	O
&	O
lm_0	double
)	O
;	O
int	O
stat_1	int
=	O
hyperg_U_small_a_bgt0	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
a0	int
,	O
b	double
,	O
x	double
,	O
&	O
r_Ua	struct(double,double)
,	O
&	O
lm_1	double
)	O
;	O
int	O
stat_e	int
;	O
gsl_sf_result	struct(double,double)
lnm	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
y	double
;	O
double	O
Uam1	double
=	O
r_Uam1	struct(double,double)
.	O
val	double
;	O
double	O
Ua	double
=	O
r_Ua	struct(double,double)
.	O
val	double
;	O
double	O
Uap1	double
;	O
double	O
ap	double
;	O
lm_max	double
=	O
GSL_MAX	O
(	O
lm_0	double
,	O
lm_1	double
)	O
;	O
Uam1	double
*=	O
exp	(double)->(double)
(	O
lm_0	double
-	O
lm_max	double
)	O
;	O
Ua	double
*=	O
exp	(double)->(double)
(	O
lm_1	double
-	O
lm_max	double
)	O
;	O
for	O
(	O
ap	double
=	O
a0	int
;	O
ap	double
<	O
a	double
-	O
0.1	int
;	O
ap	double
+=	O
1.0	int
)	O
{	O
Uap1	double
=	O
-	O
(	O
Uam1	double
+	O
(	O
b	double
-	O
2.0	int
*	O
ap	double
-	O
x	double
)	O
*	O
Ua	double
)	O
/	O
(	O
ap	double
*	O
(	O
1.0	int
+	O
ap	double
-	O
b	double
)	O
)	O
;	O
Uam1	double
=	O
Ua	double
;	O
Ua	double
=	O
Uap1	double
;	O
RESCALE_2	O
(	O
Ua	double
,	O
Uam1	double
,	O
scale_factor	double
,	O
scale_count	int
)	O
;	O
}	O
lnscale	double
=	O
log	(double)->(double)
(	O
scale_factor	double
)	O
;	O
lnm	struct(double,double)
.	O
val	double
=	O
lm_max	double
+	O
scale_count	int
*	O
lnscale	double
;	O
lnm	struct(double,double)
.	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
lm_max	double
)	O
+	O
fabs	(double)->(double)
(	O
scale_count	int
*	O
lnscale	double
)	O
)	O
;	O
y	double
.	O
val	double
=	O
Ua	double
;	O
y	double
.	O
err	double
=	O
fabs	(double)->(double)
(	O
r_Uam1	struct(double,double)
.	O
err	double
/	O
r_Uam1	struct(double,double)
.	O
val	double
)	O
*	O
fabs	(double)->(double)
(	O
Ua	double
)	O
;	O
y	double
.	O
err	double
+=	O
fabs	(double)->(double)
(	O
r_Ua	struct(double,double)
.	O
err	double
/	O
r_Ua	struct(double,double)
.	O
val	double
)	O
*	O
fabs	(double)->(double)
(	O
Ua	double
)	O
;	O
y	double
.	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a	double
-	O
a0	int
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Ua	double
)	O
;	O
y	double
.	O
err	double
*=	O
fabs	(double)->(double)
(	O
lm_0	double
-	O
lm_max	double
)	O
+	O
1.0	int
;	O
y	double
.	O
err	double
*=	O
fabs	(double)->(double)
(	O
lm_1	double
-	O
lm_max	double
)	O
+	O
1.0	int
;	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
lnm	struct(double,double)
.	O
val	double
,	O
lnm	struct(double,double)
.	O
err	double
,	O
y	double
.	O
val	double
,	O
y	double
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_0	int
,	O
stat_1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
b	double
<=	O
x	double
)	O
{	O
const	O
double	O
a0	int
=	O
a	double
-	O
floor	(double)->(double)
(	O
a	double
)	O
;	O
const	O
double	O
scale_factor	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
int	O
scale_count	int
=	O
0	int
;	O
gsl_sf_result	struct(double,double)
lnm	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
y	double
;	O
double	O
lnscale	double
;	O
double	O
lm_0	double
;	O
double	O
Uap1	double
;	O
double	O
Ua	double
;	O
double	O
Uam1	double
;	O
gsl_sf_result	struct(double,double)
U0	struct(double,double)
;	O
double	O
ap	double
;	O
double	O
ru	double
;	O
double	O
r	*(struct(double,double))
;	O
int	O
CF1_count	int
;	O
int	O
stat_CF1	int
=	O
hyperg_U_CF1	(double,double,int,double,*(double),*(int))->(int)
(	O
a	double
,	O
b	double
,	O
0	int
,	O
x	double
,	O
&	O
ru	double
,	O
&	O
CF1_count	int
)	O
;	O
int	O
stat_U0	int
;	O
int	O
stat_e	int
;	O
r	*(struct(double,double))
=	O
ru	double
/	O
a	double
;	O
Ua	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
Uap1	double
=	O
r	*(struct(double,double))
*	O
Ua	double
;	O
for	O
(	O
ap	double
=	O
a	double
;	O
ap	double
>	O
a0	int
+	O
0.1	int
;	O
ap	double
-=	O
1.0	int
)	O
{	O
Uam1	double
=	O
-	O
(	O
(	O
b	double
-	O
2.0	int
*	O
ap	double
-	O
x	double
)	O
*	O
Ua	double
+	O
ap	double
*	O
(	O
1.0	int
+	O
ap	double
-	O
b	double
)	O
*	O
Uap1	double
)	O
;	O
Uap1	double
=	O
Ua	double
;	O
Ua	double
=	O
Uam1	double
;	O
RESCALE_2	O
(	O
Ua	double
,	O
Uap1	double
,	O
scale_factor	double
,	O
scale_count	int
)	O
;	O
}	O
stat_U0	int
=	O
hyperg_U_small_a_bgt0	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
a0	int
,	O
b	double
,	O
x	double
,	O
&	O
U0	struct(double,double)
,	O
&	O
lm_0	double
)	O
;	O
lnscale	double
=	O
log	(double)->(double)
(	O
scale_factor	double
)	O
;	O
lnm	struct(double,double)
.	O
val	double
=	O
lm_0	double
-	O
scale_count	int
*	O
lnscale	double
;	O
lnm	struct(double,double)
.	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
lm_0	double
)	O
+	O
fabs	(double)->(double)
(	O
scale_count	int
*	O
lnscale	double
)	O
)	O
;	O
y	double
.	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
(	O
U0	struct(double,double)
.	O
val	double
/	O
Ua	double
)	O
;	O
y	double
.	O
err	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
(	O
U0	struct(double,double)
.	O
err	double
/	O
fabs	(double)->(double)
(	O
Ua	double
)	O
)	O
;	O
y	double
.	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a0	int
-	O
a	double
)	O
+	O
CF1_count	int
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
y	double
.	O
val	double
)	O
;	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
lnm	struct(double,double)
.	O
val	double
,	O
lnm	struct(double,double)
.	O
err	double
,	O
y	double
.	O
val	double
,	O
y	double
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_U0	int
,	O
stat_CF1	int
)	O
;	O
}	O
else	O
{	O
int	O
scale_count_for	int
=	O
0	int
;	O
int	O
scale_count_bck	int
=	O
0	int
;	O
const	O
double	O
scale_factor	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
const	O
double	O
eps	double
=	O
a	double
-	O
floor	(double)->(double)
(	O
a	double
)	O
;	O
const	O
double	O
a0	int
=	O
(	O
eps	double
==	O
0.0	int
?	O
1.0	int
:	O
eps	double
)	O
;	O
const	O
double	O
a1	double
=	O
a0	int
+	O
ceil	(double)->(double)
(	O
0.5	int
*	O
(	O
b	double
-	O
x	double
)	O
-	O
a0	int
)	O
;	O
gsl_sf_result	struct(double,double)
lnm	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
y	double
;	O
double	O
lm_for	struct(double,double)
;	O
double	O
lnscale	double
;	O
double	O
Ua1_bck	double
;	O
double	O
Ua1_for	double
;	O
int	O
stat_for	int
;	O
int	O
stat_bck	int
;	O
int	O
stat_e	int
;	O
int	O
CF1_count	int
;	O
{	O
double	O
Uap1	double
;	O
double	O
Ua	double
;	O
double	O
Uam1	double
;	O
double	O
ap	double
;	O
double	O
ru	double
;	O
double	O
r	*(struct(double,double))
;	O
int	O
stat_CF1	int
=	O
hyperg_U_CF1	(double,double,int,double,*(double),*(int))->(int)
(	O
a	double
,	O
b	double
,	O
0	int
,	O
x	double
,	O
&	O
ru	double
,	O
&	O
CF1_count	int
)	O
;	O
r	*(struct(double,double))
=	O
ru	double
/	O
a	double
;	O
Ua	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
Uap1	double
=	O
r	*(struct(double,double))
*	O
Ua	double
;	O
for	O
(	O
ap	double
=	O
a	double
;	O
ap	double
>	O
a1	double
+	O
0.1	int
;	O
ap	double
-=	O
1.0	int
)	O
{	O
Uam1	double
=	O
-	O
(	O
(	O
b	double
-	O
2.0	int
*	O
ap	double
-	O
x	double
)	O
*	O
Ua	double
+	O
ap	double
*	O
(	O
1.0	int
+	O
ap	double
-	O
b	double
)	O
*	O
Uap1	double
)	O
;	O
Uap1	double
=	O
Ua	double
;	O
Ua	double
=	O
Uam1	double
;	O
RESCALE_2	O
(	O
Ua	double
,	O
Uap1	double
,	O
scale_factor	double
,	O
scale_count_bck	int
)	O
;	O
}	O
Ua1_bck	double
=	O
Ua	double
;	O
stat_bck	int
=	O
stat_CF1	int
;	O
}	O
{	O
gsl_sf_result	struct(double,double)
r_Uam1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
r_Ua	struct(double,double)
;	O
double	O
lm_0	double
,	O
lm_1	double
;	O
int	O
stat_0	int
=	O
hyperg_U_small_a_bgt0	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
a0	int
-	O
1.0	int
,	O
b	double
,	O
x	double
,	O
&	O
r_Uam1	struct(double,double)
,	O
&	O
lm_0	double
)	O
;	O
int	O
stat_1	int
=	O
hyperg_U_small_a_bgt0	(double,double,double,*(struct(double,double)),*(double))->(int)
(	O
a0	int
,	O
b	double
,	O
x	double
,	O
&	O
r_Ua	struct(double,double)
,	O
&	O
lm_1	double
)	O
;	O
double	O
Uam1	double
=	O
r_Uam1	struct(double,double)
.	O
val	double
;	O
double	O
Ua	double
=	O
r_Ua	struct(double,double)
.	O
val	double
;	O
double	O
Uap1	double
;	O
double	O
ap	double
;	O
lm_for	struct(double,double)
=	O
GSL_MAX	O
(	O
lm_0	double
,	O
lm_1	double
)	O
;	O
Uam1	double
*=	O
exp	(double)->(double)
(	O
lm_0	double
-	O
lm_for	struct(double,double)
)	O
;	O
Ua	double
*=	O
exp	(double)->(double)
(	O
lm_1	double
-	O
lm_for	struct(double,double)
)	O
;	O
for	O
(	O
ap	double
=	O
a0	int
;	O
ap	double
<	O
a1	double
-	O
0.1	int
;	O
ap	double
+=	O
1.0	int
)	O
{	O
Uap1	double
=	O
-	O
(	O
Uam1	double
+	O
(	O
b	double
-	O
2.0	int
*	O
ap	double
-	O
x	double
)	O
*	O
Ua	double
)	O
/	O
(	O
ap	double
*	O
(	O
1.0	int
+	O
ap	double
-	O
b	double
)	O
)	O
;	O
Uam1	double
=	O
Ua	double
;	O
Ua	double
=	O
Uap1	double
;	O
RESCALE_2	O
(	O
Ua	double
,	O
Uam1	double
,	O
scale_factor	double
,	O
scale_count_for	int
)	O
;	O
}	O
Ua1_for	double
=	O
Ua	double
;	O
stat_for	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_0	int
,	O
stat_1	int
)	O
;	O
}	O
lnscale	double
=	O
log	(double)->(double)
(	O
scale_factor	double
)	O
;	O
lnm	struct(double,double)
.	O
val	double
=	O
lm_for	struct(double,double)
+	O
(	O
scale_count_for	int
-	O
scale_count_bck	int
)	O
*	O
lnscale	double
;	O
lnm	struct(double,double)
.	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
lm_for	struct(double,double)
)	O
+	O
fabs	(double)->(double)
(	O
scale_count_for	int
-	O
scale_count_bck	int
)	O
*	O
fabs	(double)->(double)
(	O
lnscale	double
)	O
)	O
;	O
y	double
.	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
Ua1_for	double
/	O
Ua1_bck	double
;	O
y	double
.	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a	double
-	O
a0	int
)	O
+	O
CF1_count	int
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
y	double
.	O
val	double
)	O
;	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
lnm	struct(double,double)
.	O
val	double
,	O
lnm	struct(double,double)
.	O
err	double
,	O
y	double
.	O
val	double
,	O
y	double
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_bck	int
,	O
stat_for	int
)	O
;	O
}	O
}	O
}	O
static	O
int	O
hyperg_U_origin	(double,double,*(struct(double,double,int)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
gsl_sf_result	struct(double,double)
r1	struct(double,double)
,	O
r2	struct(double,double)
;	O
int	O
stat_1	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
1	int
+	O
a	double
-	O
b	double
,	O
&	O
r1	struct(double,double)
)	O
;	O
int	O
stat_2	int
=	O
gsl_sf_gammainv_e	(double,*(struct(double,double)))->(int)
(	O
b	double
,	O
&	O
r2	struct(double,double)
)	O
;	O
double	O
factor	double
=	O
M_PI	int
/	O
sin	(double)->(double)
(	O
M_PI	int
*	O
b	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
factor	double
*	O
r1	struct(double,double)
.	O
val	double
*	O
r2	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
factor	double
)	O
*	O
(	O
r1	struct(double,double)
.	O
err	double
+	O
r2	struct(double,double)
.	O
err	double
)	O
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_1	int
,	O
stat_2	int
)	O
;	O
}	O
static	O
int	O
hyperg_U_int_origin	(int,int,*(struct(double,double,int)))->(int)
(	O
const	O
int	O
a	double
,	O
const	O
int	O
b	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
return	O
hyperg_U_origin	(double,double,*(struct(double,double,int)))->(int)
(	O
a	double
,	O
b	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
static	O
int	O
hyperg_U_negx	(double,double,double,*(struct(double,double,int)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
gsl_sf_result	struct(double,double)
r1	struct(double,double)
,	O
r2	struct(double,double)
;	O
int	O
stat_1	int
,	O
stat_2	int
,	O
status	int
;	O
int	O
a_int	int
=	O
(	O
a	double
==	O
floor	(double)->(double)
(	O
a	double
)	O
)	O
;	O
int	O
b_int	int
=	O
(	O
b	double
==	O
floor	(double)->(double)
(	O
b	double
)	O
)	O
;	O
double	O
T1	double
=	O
0	int
,	O
T1_err	double
=	O
0	int
,	O
T2	double
=	O
0	int
,	O
T2_err	double
=	O
0	int
;	O
if	O
(	O
b_int	int
&&	O
b	double
<=	O
0	int
&&	O
!	O
(	O
a_int	int
&&	O
a	double
<=	O
0	int
&&	O
a	double
>=	O
b	double
)	O
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
GSL_NAN	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_NAN	O
;	O
GSL_ERROR	O
(	O
"limit case integer b <= 0 unimplemented"	*(char)
,	O
GSL_EUNIMPL	int
)	O
;	O
}	O
else	O
{	O
stat_1	int
=	O
gsl_sf_poch_e	(double,double,*(struct(double,double)))->(int)
(	O
1	int
+	O
a	double
-	O
b	double
,	O
-	O
a	double
,	O
&	O
r1	struct(double,double)
)	O
;	O
status	int
=	O
stat_1	int
;	O
if	O
(	O
r1	struct(double,double)
.	O
val	double
!=	O
0.0	int
)	O
{	O
gsl_sf_result	struct(double,double)
Mr1	struct(double,double)
;	O
int	O
stat_Mr1	int
=	O
gsl_sf_hyperg_1F1_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
Mr1	struct(double,double)
)	O
;	O
status	int
=	O
GSL_ERROR_SELECT_2	O
(	O
status	int
,	O
stat_Mr1	int
)	O
;	O
T1	double
=	O
Mr1	struct(double,double)
.	O
val	double
*	O
r1	struct(double,double)
.	O
val	double
;	O
T1_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
T1	double
)	O
+	O
fabs	(double)->(double)
(	O
Mr1	struct(double,double)
.	O
err	double
*	O
r1	struct(double,double)
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
Mr1	struct(double,double)
.	O
val	double
*	O
r1	struct(double,double)
.	O
err	double
)	O
;	O
}	O
}	O
if	O
(	O
b_int	int
&&	O
b	double
>=	O
2	int
&&	O
!	O
(	O
a_int	int
&&	O
a	double
<=	O
(	O
b	double
-	O
2	int
)	O
)	O
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
GSL_NAN	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_NAN	O
;	O
GSL_ERROR	O
(	O
"limit case integer b >= 2 unimplemented"	*(char)
,	O
GSL_EUNIMPL	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a_int	int
&&	O
a	double
<=	O
0	int
&&	O
(	O
b	double
>=	O
1	int
)	O
)	O
{	O
r2	struct(double,double)
.	O
val	double
=	O
0	int
;	O
r2	struct(double,double)
.	O
err	double
=	O
0	int
;	O
}	O
else	O
{	O
stat_2	int
=	O
gsl_sf_poch_e	(double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
-	O
(	O
1	int
+	O
a	double
-	O
b	double
)	O
,	O
&	O
r2	struct(double,double)
)	O
;	O
status	int
=	O
GSL_ERROR_SELECT_2	O
(	O
status	int
,	O
stat_2	int
)	O
;	O
}	O
if	O
(	O
r2	struct(double,double)
.	O
val	double
!=	O
0.0	int
)	O
{	O
gsl_sf_result	struct(double,double)
Mr2	struct(double,double)
;	O
int	O
stat_Mr2	int
=	O
gsl_sf_hyperg_1F1_e	(double,double,double,*(struct(double,double)))->(int)
(	O
1	int
+	O
a	double
-	O
b	double
,	O
2	int
-	O
b	double
,	O
x	double
,	O
&	O
Mr2	struct(double,double)
)	O
;	O
T2	double
=	O
Mr2	struct(double,double)
.	O
val	double
*	O
r2	struct(double,double)
.	O
val	double
;	O
T2_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
T2	double
)	O
+	O
fabs	(double)->(double)
(	O
Mr2	struct(double,double)
.	O
err	double
*	O
r2	struct(double,double)
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
Mr2	struct(double,double)
.	O
val	double
*	O
r2	struct(double,double)
.	O
err	double
)	O
;	O
status	int
=	O
GSL_ERROR_SELECT_2	O
(	O
status	int
,	O
stat_Mr2	int
)	O
;	O
if	O
(	O
T2	double
!=	O
0.0	int
)	O
{	O
double	O
x1mb	double
=	O
pow	(double,double)->(double)
(	O
x	double
,	O
1	int
-	O
b	double
)	O
;	O
T2	double
=	O
x1mb	double
*	O
T2	double
;	O
T2_err	double
=	O
fabs	(double)->(double)
(	O
x1mb	double
)	O
*	O
T2_err	double
;	O
}	O
}	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
T1	double
+	O
T2	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
+	O
(	O
T1_err	double
+	O
T2_err	double
)	O
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
status	int
;	O
}	O
static	O
int	O
hyperg_U_int_negx	(int,int,double,*(struct(double,double,int)))->(int)
(	O
const	O
int	O
a	double
,	O
const	O
int	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
a	double
<	O
b	double
&&	O
b	double
<=	O
0	int
)	O
{	O
gsl_sf_result_e10	struct(double,double,int)
r1	struct(double,double)
;	O
double	O
z21_z	double
=	O
pow	(double,double)->(double)
(	O
x	double
,	O
1	int
-	O
b	double
)	O
;	O
int	O
status	int
=	O
hyperg_U_negx	(double,double,double,*(struct(double,double,int)))->(int)
(	O
1	int
+	O
a	double
-	O
b	double
,	O
2	int
-	O
b	double
,	O
x	double
,	O
&	O
r1	struct(double,double)
)	O
;	O
double	O
res_tem	double
=	O
z21_z	double
*	O
r1	struct(double,double)
.	O
val	double
;	O
double	O
res_tem_err	double
=	O
fabs	(double)->(double)
(	O
z21_z	double
)	O
*	O
r1	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
val	double
=	O
res_tem	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
res_tem_err	double
;	O
return	O
status	int
;	O
}	O
else	O
{	O
return	O
hyperg_U_negx	(double,double,double,*(struct(double,double,int)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_hyperg_U_int_e10_e	(int,int,double,*(struct(double,double,int)))->(int)
(	O
const	O
int	O
a	double
,	O
const	O
int	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
==	O
0.0	int
&&	O
b	double
>=	O
1	int
)	O
{	O
DOMAIN_ERROR_E10	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
return	O
hyperg_U_int_origin	(int,int,*(struct(double,double,int)))->(int)
(	O
a	double
,	O
b	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
return	O
hyperg_U_int_negx	(int,int,double,*(struct(double,double,int)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
b	double
>=	O
1	int
)	O
{	O
return	O
hyperg_U_int_bge1	(int,int,double,*(struct(double,double,int)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
gsl_sf_result_e10	struct(double,double,int)
U	struct(double,double,int)
;	O
double	O
ln_x	double
=	O
log	(double)->(double)
(	O
x	double
)	O
;	O
int	O
ap	double
=	O
1	int
+	O
a	double
-	O
b	double
;	O
int	O
bp	double
=	O
2	int
-	O
b	double
;	O
int	O
stat_e	int
;	O
int	O
stat_U	int
=	O
hyperg_U_int_bge1	(int,int,double,*(struct(double,double,int)))->(int)
(	O
ap	double
,	O
bp	double
,	O
x	double
,	O
&	O
U	struct(double,double,int)
)	O
;	O
double	O
ln_pre_val	double
=	O
(	O
1.0	int
-	O
b	double
)	O
*	O
ln_x	double
;	O
double	O
ln_pre_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
b	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
ln_x	double
)	O
;	O
ln_pre_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
1.0	int
-	O
b	double
)	O
;	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
ln_pre_val	double
+	O
U	struct(double,double,int)
.	O
e10	int
*	O
M_LN10	int
,	O
ln_pre_err	double
,	O
U	struct(double,double,int)
.	O
val	double
,	O
U	struct(double,double,int)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_U	int
)	O
;	O
}	O
}	O
}	O
int	O
gsl_sf_hyperg_U_e10_e	(double,double,double,*(struct(double,double,int)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
rinta	double
=	O
floor	(double)->(double)
(	O
a	double
+	O
0.5	int
)	O
;	O
const	O
double	O
rintb	double
=	O
floor	(double)->(double)
(	O
b	double
+	O
0.5	int
)	O
;	O
const	O
int	O
a_integer	int
=	O
(	O
fabs	(double)->(double)
(	O
a	double
-	O
rinta	double
)	O
<	O
INT_THRESHOLD	O
)	O
;	O
const	O
int	O
b_integer	int
=	O
(	O
fabs	(double)->(double)
(	O
b	double
-	O
rintb	double
)	O
<	O
INT_THRESHOLD	O
)	O
;	O
if	O
(	O
x	double
==	O
0.0	int
&&	O
b	double
>=	O
1	int
)	O
{	O
DOMAIN_ERROR_E10	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
a	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
return	O
hyperg_U_origin	(double,double,*(struct(double,double,int)))->(int)
(	O
a	double
,	O
b	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
a_integer	int
&&	O
b	double
==	O
a	double
+	O
1	int
)	O
{	O
gsl_sf_result	struct(double,double)
powx1N_1	struct(double,double)
;	O
gsl_sf_pow_int_e	(double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
-	O
a	double
,	O
&	O
powx1N_1	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
powx1N_1	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
powx1N_1	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
a_integer	int
&&	O
b_integer	int
)	O
{	O
return	O
gsl_sf_hyperg_U_int_e10_e	(int,int,double,*(struct(double,double,int)))->(int)
(	O
rinta	double
,	O
rintb	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
return	O
hyperg_U_negx	(double,double,double,*(struct(double,double,int)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
b	double
>=	O
1.0	int
)	O
{	O
return	O
hyperg_U_bge1	(double,double,double,*(struct(double,double,int)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
const	O
double	O
lnx	double
=	O
log	(double)->(double)
(	O
x	double
)	O
;	O
const	O
double	O
ln_pre_val	double
=	O
(	O
1.0	int
-	O
b	double
)	O
*	O
lnx	double
;	O
const	O
double	O
ln_pre_err	double
=	O
fabs	(double)->(double)
(	O
lnx	double
)	O
*	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
1.0	int
+	O
fabs	(double)->(double)
(	O
b	double
)	O
)	O
;	O
const	O
double	O
ap	double
=	O
1.0	int
+	O
a	double
-	O
b	double
;	O
const	O
double	O
bp	double
=	O
2.0	int
-	O
b	double
;	O
gsl_sf_result_e10	struct(double,double,int)
U	struct(double,double,int)
;	O
int	O
stat_U	int
=	O
hyperg_U_bge1	(double,double,double,*(struct(double,double,int)))->(int)
(	O
ap	double
,	O
bp	double
,	O
x	double
,	O
&	O
U	struct(double,double,int)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
ln_pre_val	double
+	O
U	struct(double,double,int)
.	O
e10	int
*	O
M_LN10	int
,	O
ln_pre_err	double
,	O
U	struct(double,double,int)
.	O
val	double
,	O
U	struct(double,double,int)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_U	int
)	O
;	O
}	O
}	O
}	O
int	O
gsl_sf_hyperg_U_int_e	(int,int,double,*(struct(double,double)))->(int)
(	O
const	O
int	O
a	double
,	O
const	O
int	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
gsl_sf_result_e10	struct(double,double,int)
re	*(struct(double,double,int))
=	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
int	O
stat_U	int
=	O
gsl_sf_hyperg_U_int_e10_e	(int,int,double,*(struct(double,double,int)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
re	*(struct(double,double,int))
)	O
;	O
int	O
stat_c	int
=	O
gsl_sf_result_smash_e	(*(struct(double,double,int)),*(struct(double,double)))->(int)
(	O
&	O
re	*(struct(double,double,int))
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_c	int
,	O
stat_U	int
)	O
;	O
}	O
int	O
gsl_sf_hyperg_U_e	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
gsl_sf_result_e10	struct(double,double,int)
re	*(struct(double,double,int))
=	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
int	O
stat_U	int
=	O
gsl_sf_hyperg_U_e10_e	(double,double,double,*(struct(double,double,int)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
re	*(struct(double,double,int))
)	O
;	O
int	O
stat_c	int
=	O
gsl_sf_result_smash_e	(*(struct(double,double,int)),*(struct(double,double)))->(int)
(	O
&	O
re	*(struct(double,double,int))
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_c	int
,	O
stat_U	int
)	O
;	O
}	O
double	O
gsl_sf_hyperg_U_int	(int,int,double)->(double)
(	O
const	O
int	O
a	double
,	O
const	O
int	O
b	double
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hyperg_U_int_e	(int,int,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_hyperg_U	(double,double,double)->(double)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hyperg_U_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
