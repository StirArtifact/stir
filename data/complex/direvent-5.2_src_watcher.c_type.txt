void	O
watchpoint_ref	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
{	O
++	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
refcnt	long
;	O
}	O
void	O
watchpoint_unref	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
{	O
if	O
(	O
--	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
refcnt	long
)	O
return	O
;	O
free	(*(void))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
)	O
;	O
handler_list_unref	(*(struct))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
handler_list	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
}	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
{	O
int	O
used	int
;	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
}	O
;	O
static	O
unsigned	O
wpref_hash	(*(void),long)->(int)
(	O
void	O
*	O
data	*(void)
,	O
unsigned	O
long	O
hashsize	long
)	O
{	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
sym	*(void)
=	O
data	*(void)
;	O
return	O
grecs_hash_string	(*(char),long)->(int)
(	O
sym	*(void)
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
hashsize	long
)	O
;	O
}	O
static	O
int	O
wpref_cmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(void)
,	O
const	O
void	O
*	O
b	*(void)
)	O
{	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
const	O
*	O
syma	*(struct(int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char)))))
=	O
a	*(void)
;	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
const	O
*	O
symb	*(struct(int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char)))))
=	O
b	*(void)
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
syma	*(struct(int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char)))))
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
symb	*(struct(int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char)))))
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
)	O
;	O
}	O
static	O
int	O
wpref_copy	(*(void),*(void))->(int)
(	O
void	O
*	O
a	*(void)
,	O
void	O
*	O
b	*(void)
)	O
{	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
syma	*(struct(int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char)))))
=	O
a	*(void)
;	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
symb	*(struct(int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char)))))
=	O
b	*(void)
;	O
syma	*(struct(int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char)))))
->	O
used	int
=	O
1	int
;	O
syma	*(struct(int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char)))))
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
symb	*(struct(int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char)))))
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
return	O
0	int
;	O
}	O
static	O
void	O
wpref_free	(*(void))->(void)
(	O
void	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
{	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
watchpoint_unref	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
free	(*(void))->(void)
(	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
)	O
;	O
}	O
struct	O
grecs_symtab	O
*	O
nametab	*(struct)
;	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
watchpoint_install	(*(char),*(int))->(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))
(	O
const	O
char	O
*	O
path	array(char)
,	O
int	O
*	O
pnew	*(int)
)	O
{	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
wpkey	struct(long,int,*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
;	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
key	*(void)
;	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
ent	*(void)
;	O
int	O
install	*(int)
=	O
1	int
;	O
if	O
(	O
!	O
nametab	*(struct)
)	O
{	O
nametab	*(struct)
=	O
grecs_symtab_create	(long,*((*(void),long)->(int)),*((*(void),*(void))->(int)),*((*(void),*(void))->(int)),*((long)->(*(void))),*((*(void))->(void)))->(*(struct))
(	O
sizeof	O
(	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
)	O
,	O
wpref_hash	(*(void),long)->(int)
,	O
wpref_cmp	(*(void),*(void))->(int)
,	O
wpref_copy	(*(void),*(void))->(int)
,	O
NULL	O
,	O
wpref_free	(*(void))->(void)
)	O
;	O
if	O
(	O
!	O
nametab	*(struct)
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
_	O
(	O
"not enough memory"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
wpkey	struct(long,int,*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
.	O
dirname	*(char)
=	O
(	O
char	O
*	O
)	O
path	array(char)
;	O
key	*(void)
.	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
&	O
wpkey	struct(long,int,*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
;	O
ent	*(void)
=	O
grecs_symtab_lookup_or_install	(*(struct),*(void),*(int))->(*(void))
(	O
nametab	*(struct)
,	O
&	O
key	*(void)
,	O
&	O
install	*(int)
)	O
;	O
if	O
(	O
install	*(int)
)	O
{	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
ecalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
)	O
;	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
=	O
estrdup	(*(char))->(*(char))
(	O
path	array(char)
)	O
;	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
wd	int
=	O
-	O
1	int
;	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
handler_list	*(struct)
=	O
handler_list_create	()->(*(struct))
(	O
)	O
;	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
refcnt	long
=	O
0	int
;	O
ent	*(void)
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
}	O
if	O
(	O
!	O
ent	*(void)
)	O
abort	()->(void)
(	O
)	O
;	O
watchpoint_ref	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
ent	*(void)
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
if	O
(	O
pnew	*(int)
)	O
*	O
pnew	*(int)
=	O
install	*(int)
;	O
return	O
ent	*(void)
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
}	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
watchpoint_install_ptr	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
{	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
key	*(void)
;	O
int	O
install	*(int)
=	O
1	int
;	O
key	*(void)
.	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
if	O
(	O
!	O
grecs_symtab_lookup_or_install	(*(struct),*(void),*(int))->(*(void))
(	O
nametab	*(struct)
,	O
&	O
key	*(void)
,	O
&	O
install	*(int)
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
_	O
(	O
"not enough memory"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
watchpoint_ref	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
return	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
}	O
static	O
void	O
wpref_destroy	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
data	*(void)
;	O
watchpoint_destroy	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
}	O
static	O
grecs_list_ptr_t	*(struct)
watchpoint_gc_list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
;	O
void	O
watchpoint_gc	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
watchpoint_gc_list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
{	O
grecs_list_free	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
watchpoint_gc_list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
;	O
watchpoint_gc_list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
=	O
NULL	O
;	O
}	O
}	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
watchpoint_lookup	(*(char))->(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))
(	O
const	O
char	O
*	O
dirname	*(char)
)	O
{	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
wpkey	struct(long,int,*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
;	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
key	*(void)
;	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
ent	*(void)
;	O
if	O
(	O
!	O
nametab	*(struct)
)	O
return	O
NULL	O
;	O
wpkey	struct(long,int,*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
.	O
dirname	*(char)
=	O
(	O
char	O
*	O
)	O
dirname	*(char)
;	O
key	*(void)
.	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
&	O
wpkey	struct(long,int,*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
;	O
ent	*(void)
=	O
grecs_symtab_lookup_or_install	(*(struct),*(void),*(int))->(*(void))
(	O
nametab	*(struct)
,	O
&	O
key	*(void)
,	O
NULL	O
)	O
;	O
return	O
ent	*(void)
?	O
ent	*(void)
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
:	O
NULL	O
;	O
}	O
static	O
void	O
watchpoint_remove	(*(char))->(void)
(	O
const	O
char	O
*	O
dirname	*(char)
)	O
{	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
wpkey	struct(long,int,*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
;	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
key	*(void)
;	O
if	O
(	O
!	O
nametab	*(struct)
)	O
return	O
;	O
wpkey	struct(long,int,*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
.	O
dirname	*(char)
=	O
(	O
char	O
*	O
)	O
dirname	*(char)
;	O
key	*(void)
.	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
&	O
wpkey	struct(long,int,*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
;	O
grecs_symtab_remove	(*(struct),*(void))->(int)
(	O
nametab	*(struct)
,	O
&	O
key	*(void)
)	O
;	O
}	O
void	O
watchpoint_destroy	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
{	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"removing watcher %s"	*(char)
)	O
,	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
)	O
)	O
;	O
sysev_rm_watch	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
watchpoint_remove	(*(char))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
)	O
;	O
}	O
void	O
watchpoint_suspend	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
{	O
if	O
(	O
!	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
watchpoint_install_sentinel	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(int)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
watchpoint_destroy	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
if	O
(	O
grecs_symtab_count	(*(struct))->(long)
(	O
nametab	*(struct)
)	O
==	O
0	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
_	O
(	O
"no watchers left; exiting now"	*(char)
)	O
)	O
;	O
stop	int
=	O
1	int
;	O
}	O
}	O
struct	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
{	O
struct	O
handler	struct(long,struct(int,int),*(struct),*((*(struct),*(struct(int,int)),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))
*	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
;	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
;	O
}	O
;	O
static	O
int	O
sentinel_handler_run	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(struct(int,int)),*(char),*(char),*(void))->(int)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wp	*(struct)
,	O
event_mask	struct(int,int)
*	O
event	*(struct(int,int))
,	O
const	O
char	O
*	O
dirname	*(char)
,	O
const	O
char	O
*	O
file	*(char)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
=	O
data	*(void)
;	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
->	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
;	O
watchpoint_init	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(int)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
watchpoint_install_ptr	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
deliver_ev_create	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),*(char))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
dirname	*(char)
,	O
file	*(char)
)	O
;	O
if	O
(	O
handler_list_remove	(*(struct),*(struct(long,struct(int,int),*(struct),*((*`,*`,*`,*`,*`)->(int)),*((*`)->(void)),*(void))))->(long)
(	O
wp	*(struct)
->	O
handler_list	*(struct)
,	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
->	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
watchpoint_gc_list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
{	O
watchpoint_gc_list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
=	O
grecs_list_create	()->(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))
(	O
)	O
;	O
watchpoint_gc_list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
free_entry	*((*(void))->(void))
=	O
wpref_destroy	(*(void))->(void)
;	O
}	O
grecs_list_append	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),*(void))->(void)
(	O
watchpoint_gc_list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
wp	*(struct)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
sentinel_handler_free	(*(void))->(void)
(	O
void	O
*	O
ptr	*(void)
)	O
{	O
struct	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
=	O
ptr	*(void)
;	O
watchpoint_unref	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
->	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
)	O
;	O
free	(*(void))->(void)
(	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
)	O
;	O
}	O
int	O
watchpoint_install_sentinel	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(int)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
{	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
sent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
char	O
*	O
dirname	*(char)
;	O
char	O
*	O
filename	*(char)
;	O
struct	O
handler	struct(long,struct(int,int),*(struct),*((*(struct),*(struct(int,int)),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))
*	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
;	O
event_mask	struct(int,int)
ev_mask	struct(int,int)
;	O
struct	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
;	O
filename	*(char)
=	O
split_pathname	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(*(char)))->(*(char))
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
&	O
dirname	*(char)
)	O
;	O
sent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
watchpoint_install	(*(char),*(int))->(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))
(	O
dirname	*(char)
,	O
NULL	O
)	O
;	O
getevt	(*(char),*(struct(int,int)))->(int)
(	O
"create"	*(char)
,	O
&	O
ev_mask	struct(int,int)
)	O
;	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
=	O
handler_alloc	(struct(int,int))->(*(struct(long,struct(int,int),*(struct),*((*`,*`,*`,*`,*`)->(int)),*((*`)->(void)),*(void))))
(	O
ev_mask	struct(int,int)
)	O
;	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
run	*((*(struct),*(struct(int,int)),*(char),*(char),*(void))->(int))
=	O
sentinel_handler_run	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(struct(int,int)),*(char),*(char),*(void))->(int)
;	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
free	(*(void))->(void)
=	O
sentinel_handler_free	(*(void))->(void)
;	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
=	O
emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
)	O
)	O
;	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
->	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
=	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
->	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
=	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
;	O
watchpoint_ref	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
data	*(void)
=	O
sentinel	struct(*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))),*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
;	O
filpatlist_add_exact	(*(*(struct)),*(char))->(void)
(	O
&	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
fnames	*(struct)
,	O
filename	*(char)
)	O
;	O
handler_list_append	(*(struct),*(struct(long,struct(int,int),*(struct),*((*`,*`,*`,*`,*`)->(int)),*((*`)->(void)),*(void))))->(void)
(	O
sent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
handler_list	*(struct)
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
)	O
;	O
unsplit_pathname	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
diag	(int,*(char))->(void)
(	O
LOG_NOTICE	int
,	O
_	O
(	O
"installing CREATE sentinel for %s"	*(char)
)	O
,	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
)	O
;	O
return	O
watchpoint_init	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(int)
(	O
sent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
}	O
int	O
watchpoint_init	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(int)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct)
;	O
event_mask	struct(int,int)
mask	struct(int,int)
=	O
{	O
0	int
,	O
0	int
}	O
;	O
struct	O
handler	struct(long,struct(int,int),*(struct),*((*(struct),*(struct(int,int)),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))
*	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
;	O
handler_iterator_t	*(struct)
itr	*(*(struct))
;	O
int	O
wd	int
;	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"creating watcher %s"	*(char)
)	O
,	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
)	O
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
&	O
st	*(struct)
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
return	O
watchpoint_install_sentinel	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(int)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
}	O
else	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
_	O
(	O
"cannot set watcher on %s: %s"	*(char)
)	O
,	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
isdir	int
=	O
S_ISDIR	O
(	O
st	*(struct)
.	O
st_mode	int
)	O
;	O
for_each_handler	O
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
itr	*(*(struct))
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
)	O
{	O
mask	struct(int,int)
.	O
sys_mask	int
|=	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
ev_mask	struct(int,int)
.	O
sys_mask	int
;	O
mask	struct(int,int)
.	O
gen_mask	int
|=	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
ev_mask	struct(int,int)
.	O
gen_mask	int
;	O
}	O
wd	int
=	O
sysev_add_watch	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),struct(int,int))->(int)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
mask	struct(int,int)
)	O
;	O
if	O
(	O
wd	int
==	O
-	O
1	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
_	O
(	O
"cannot set watcher on %s: %s"	*(char)
)	O
,	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
wd	int
=	O
wd	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
watch_subdirs	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),int)->(int)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
int	O
notify	int
)	O
;	O
int	O
subwatcher_create	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int)->(int)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
const	O
char	O
*	O
dirname	*(char)
,	O
int	O
notify	int
)	O
{	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
int	O
inst	int
;	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
watchpoint_install	(*(char),*(int))->(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))
(	O
dirname	*(char)
,	O
&	O
inst	int
)	O
;	O
if	O
(	O
!	O
inst	int
)	O
return	O
-	O
1	int
;	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
handler_list	*(struct)
=	O
handler_list_copy	(*(struct))->(*(struct))
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
handler_list	*(struct)
)	O
;	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
if	O
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
depth	int
==	O
-	O
1	int
)	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
depth	int
=	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
depth	int
;	O
else	O
if	O
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
depth	int
)	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
depth	int
=	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
depth	int
-	O
1	int
;	O
else	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
depth	int
=	O
0	int
;	O
if	O
(	O
watchpoint_init	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(int)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
return	O
1	int
+	O
watch_subdirs	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),int)->(int)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
notify	int
)	O
;	O
}	O
void	O
deliver_ev_create	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),*(char))->(void)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wp	*(struct)
,	O
const	O
char	O
*	O
dirname	*(char)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
event_mask	struct(int,int)
m	*(struct(int,int))
=	O
{	O
GENEV_CREATE	int
,	O
0	int
}	O
;	O
struct	O
handler	struct(long,struct(int,int),*(struct),*((*(struct),*(struct(int,int)),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))
*	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
;	O
handler_iterator_t	*(struct)
itr	*(*(struct))
;	O
for_each_handler	O
(	O
wp	*(struct)
,	O
itr	*(*(struct))
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
)	O
{	O
if	O
(	O
handler_matches_event	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
,	O
gen	O
,	O
GENEV_CREATE	int
,	O
name	*(char)
)	O
)	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
run	*((*(struct),*(struct(int,int)),*(char),*(char),*(void))->(int))
(	O
wp	*(struct)
,	O
&	O
m	*(struct(int,int))
,	O
dirname	*(char)
,	O
name	*(char)
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
data	*(void)
)	O
;	O
}	O
}	O
int	O
check_new_watcher	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
dir	*(char)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
fname	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct)
;	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
watchpoint_lookup	(*(char))->(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))
(	O
dir	*(char)
)	O
;	O
if	O
(	O
!	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
||	O
!	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
depth	int
)	O
return	O
0	int
;	O
fname	*(char)
=	O
mkfilename	(*(char),*(char))->(*(char))
(	O
dir	*(char)
,	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
fname	*(char)
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
_	O
(	O
"cannot create watcher %s/%s: not enough memory"	*(char)
)	O
,	O
dir	*(char)
,	O
name	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
fname	*(char)
,	O
&	O
st	*(struct)
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
_	O
(	O
"cannot create watcher %s/%s, stat failed: %s"	*(char)
)	O
,	O
dir	*(char)
,	O
name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
rc	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
S_ISDIR	O
(	O
st	*(struct)
.	O
st_mode	int
)	O
)	O
{	O
deliver_ev_create	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),*(char))->(void)
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
name	*(char)
)	O
;	O
rc	int
=	O
subwatcher_create	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int)->(int)
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
fname	*(char)
,	O
1	int
)	O
;	O
}	O
else	O
rc	int
=	O
0	int
;	O
free	(*(void))->(void)
(	O
fname	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
watchpoint_pattern_match	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char))->(int)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
const	O
char	O
*	O
file_name	*(char)
)	O
{	O
struct	O
handler	struct(long,struct(int,int),*(struct),*((*(struct),*(struct(int,int)),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))
*	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
;	O
handler_iterator_t	*(struct)
itr	*(*(struct))
;	O
for_each_handler	O
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
itr	*(*(struct))
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
)	O
{	O
if	O
(	O
filpatlist_match	(*(struct),*(char))->(int)
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
fnames	*(struct)
,	O
file_name	*(char)
)	O
==	O
0	int
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
watch_subdirs	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),int)->(int)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
int	O
notify	int
)	O
{	O
DIR	struct
*	O
dir	*(char)
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
ent	*(void)
;	O
int	O
filemask	int
;	O
int	O
total	int
=	O
0	int
;	O
if	O
(	O
!	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
isdir	int
)	O
return	O
0	int
;	O
filemask	int
=	O
sysev_filemask	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(int)
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
if	O
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
depth	int
)	O
filemask	int
|=	O
S_IFDIR	O
;	O
if	O
(	O
!	O
filemask	int
)	O
return	O
0	int
;	O
dir	*(char)
=	O
opendir	(*(char))->(*(struct))
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
)	O
;	O
if	O
(	O
!	O
dir	*(char)
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
_	O
(	O
"cannot open directory %s: %s"	*(char)
)	O
,	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
ent	*(void)
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dir	*(char)
)	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct)
;	O
char	O
*	O
dirname	*(char)
;	O
if	O
(	O
ent	*(void)
->	O
d_name	array(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
(	O
ent	*(void)
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
0	int
||	O
(	O
ent	*(void)
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
ent	*(void)
->	O
d_name	array(char)
[	O
2	int
]	O
==	O
0	int
)	O
)	O
)	O
continue	O
;	O
dirname	*(char)
=	O
mkfilename	(*(char),*(char))->(*(char))
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
ent	*(void)
->	O
d_name	array(char)
)	O
;	O
if	O
(	O
!	O
dirname	*(char)
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
_	O
(	O
"cannot stat %s/%s: not enough memory"	*(char)
)	O
,	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
ent	*(void)
->	O
d_name	array(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
dirname	*(char)
,	O
&	O
st	*(struct)
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
_	O
(	O
"cannot stat %s: %s"	*(char)
)	O
,	O
dirname	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
watchpoint_pattern_match	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char))->(int)
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
ent	*(void)
->	O
d_name	array(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
notify	int
)	O
deliver_ev_create	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),*(char))->(void)
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
ent	*(void)
->	O
d_name	array(char)
)	O
;	O
if	O
(	O
st	*(struct)
.	O
st_mode	int
&	O
filemask	int
)	O
{	O
int	O
rc	int
=	O
subwatcher_create	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(char),int)->(int)
(	O
parent	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
dirname	*(char)
,	O
notify	int
)	O
;	O
if	O
(	O
rc	int
>	O
0	int
)	O
total	int
+=	O
rc	int
;	O
}	O
}	O
free	(*(void))->(void)
(	O
dirname	*(char)
)	O
;	O
}	O
closedir	(*(struct))->(int)
(	O
dir	*(char)
)	O
;	O
return	O
total	int
;	O
}	O
static	O
int	O
setwatcher	(*(void),*(void))->(int)
(	O
void	O
*	O
ent	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
=	O
(	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
)	O
ent	*(void)
;	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
if	O
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
wd	int
==	O
-	O
1	int
&&	O
watchpoint_init	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(int)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
==	O
0	int
)	O
watch_subdirs	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),int)->(int)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
checkwatcher	(*(void),*(void))->(int)
(	O
void	O
*	O
ent	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
=	O
(	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
)	O
ent	*(void)
;	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
return	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
wd	int
>=	O
0	int
;	O
}	O
void	O
setup_watchers	()->(void)
(	O
void	O
)	O
{	O
sysev_init	()->(void)
(	O
)	O
;	O
if	O
(	O
grecs_symtab_count	(*(struct))->(long)
(	O
nametab	*(struct)
)	O
==	O
0	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
_	O
(	O
"no event handlers configured"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
grecs_symtab_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
nametab	*(struct)
,	O
setwatcher	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
grecs_symtab_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
nametab	*(struct)
,	O
checkwatcher	(*(void),*(void))->(int)
,	O
NULL	O
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
_	O
(	O
"no event handlers installed"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
}	O
static	O
int	O
stopwatcher	(*(void),*(void))->(int)
(	O
void	O
*	O
ent	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
=	O
(	O
struct	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
*	O
)	O
ent	*(void)
;	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
wpref	struct(int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))))
->	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
if	O
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
wd	int
!=	O
-	O
1	int
)	O
{	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"removing watcher %s"	*(char)
)	O
,	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
)	O
)	O
;	O
sysev_rm_watch	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
shutdown_watchers	()->(void)
(	O
void	O
)	O
{	O
grecs_symtab_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
nametab	*(struct)
,	O
stopwatcher	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
grecs_symtab_clear	(*(struct))->(void)
(	O
nametab	*(struct)
)	O
;	O
}	O
char	O
*	O
split_pathname	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))),*(*(char)))->(*(char))
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
dp	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
,	O
char	O
*	O
*	O
dirname	*(char)
)	O
{	O
char	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
strrchr	(*(char),int)->(*(char))
(	O
dp	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
{	O
dp	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
split_p	*(char)
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
++	O
=	O
0	int
;	O
*	O
dirname	*(char)
=	O
dp	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
;	O
}	O
else	O
{	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
dp	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
dirname	*(char)
;	O
*	O
dirname	*(char)
=	O
"."	*(char)
;	O
}	O
return	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
}	O
void	O
unsplit_pathname	(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))->(void)
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
dp	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
{	O
if	O
(	O
dp	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
split_p	*(char)
)	O
{	O
*	O
dp	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
split_p	*(char)
=	O
'/'	O
;	O
dp	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
split_p	*(char)
=	O
NULL	O
;	O
}	O
}	O
