DEFUNO_NEW	()->(int)
(	O
"SPECIALP"	*(char)
,	O
object	O
,	O
fSspecialp	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
siLspecialp	O
,	O
(	O
object	O
sym	O
)	O
,	O
""	*(char)
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
sym	O
)	O
==	O
t_symbol	O
&&	O
(	O
enum	O
stype	O
)	O
sym	O
->	O
s	*(char)
.	O
s_stype	O
==	O
stp_special	O
)	O
sym	O
=	O
Ct	O
;	O
else	O
sym	O
=	O
Cnil	O
;	O
RETURN1	()->(int)
(	O
sym	O
)	O
;	O
}	O
DEF_ORDINARY	()->(int)
(	O
"DEBUG"	*(char)
,	O
sSdebug	O
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEFUN_NEW	()->(int)
(	O
"DEFVAR1"	*(char)
,	O
object	O
,	O
fSdefvar1	O
,	O
SI	O
,	O
2	int
,	O
3	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
sym	O
,	O
object	O
val	O
,	O
...	O
)	O
,	O
""	*(char)
)	O
{	O
int	O
n	int
=	O
VFUN_NARGS	O
;	O
object	O
doc	O
;	O
va_list	O
ap	O
;	O
{	O
va_start	O
(	O
ap	O
,	O
val	O
)	O
;	O
if	O
(	O
n	int
>=	O
3	int
)	O
doc	O
=	O
va_arg	()->(int)
(	O
ap	O
,	O
object	O
)	O
;	O
else	O
goto	O
LDEFAULT3	O
;	O
goto	O
LEND_VARARG	O
;	O
LDEFAULT3	O
:	O
doc	O
=	O
Cnil	O
;	O
LEND_VARARG	O
:	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
CHECK_ARG_RANGE	()->(int)
(	O
2	int
,	O
3	int
)	O
;	O
if	O
(	O
sym	O
->	O
s	*(char)
.	O
s_dbind	O
==	O
0	int
&&	O
n	int
>	O
1	int
)	O
sym	O
->	O
s	*(char)
.	O
s_dbind	O
=	O
val	O
;	O
sym	O
->	O
s	*(char)
.	O
s_stype	O
=	O
(	O
short	O
)	O
stp_special	O
;	O
if	O
(	O
n	int
>	O
2	int
)	O
putprop	()->(int)
(	O
sym	O
,	O
doc	O
,	O
sSvariable_documentation	O
)	O
;	O
RETURN1	()->(int)
(	O
sym	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"DEBUG"	*(char)
,	O
object	O
,	O
fSdebug	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
sym	O
,	O
object	O
val	O
)	O
,	O
""	*(char)
)	O
{	O
putprop	()->(int)
(	O
sym	O
,	O
val	O
,	O
sSdebug	O
)	O
;	O
RETURN1	()->(int)
(	O
sym	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"SETVV"	*(char)
,	O
object	O
,	O
fSsetvv	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
index	(*(char),int)->(*(char))
,	O
object	O
val	O
)	O
,	O
""	*(char)
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
)	O
==	O
t_cfdata	O
)	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
->	O
cfd	O
.	O
cfd_self	O
[	O
fix	()->(int)
(	O
index	(*(char),int)->(*(char))
)	O
]	O
=	O
val	O
;	O
else	O
FEerror	()->(int)
(	O
"setvv called outside %init"	*(char)
,	O
0	int
)	O
;	O
RETURN1	()->(int)
(	O
index	(*(char),int)->(*(char))
)	O
;	O
}	O
DEF_ORDINARY	()->(int)
(	O
"%MEMORY"	*(char)
,	O
sSPmemory	O
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"%INIT"	*(char)
,	O
sSPinit	O
,	O
SI	O
,	O
""	*(char)
)	O
;	O
void	O
gcl_init_cmpaux	()->(void)
(	O
void	O
)	O
{	O
}	O
char	O
object_to_char	(int)->(char)
(	O
object	O
x	int
)	O
{	O
int	O
c	int
=	O
0	int
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
c	int
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
{	O
object	O
*	O
to	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
small_fixnum	()->(int)
(	O
0xff	int
)	O
)	O
;	O
Llogand	()->(int)
(	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_top	O
=	O
to	O
;	O
c	int
=	O
(	O
char	O
)	O
fix	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
}	O
case	O
t_character	O
:	O
c	int
=	O
char_code	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	()->(int)
(	O
"~S cannot be coerce to a C char."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
}	O
return	O
(	O
c	int
)	O
;	O
}	O
int	O
object_to_int	(int)->(int)
(	O
object	O
x	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_character	O
:	O
i	int
=	O
char_code	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_fixnum	O
:	O
i	int
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
i	int
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_ratio	O
:	O
i	int
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
i	int
=	O
sf	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
i	int
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	()->(int)
(	O
"~S cannot be coerce to a C int."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
}	O
return	O
(	O
i	int
)	O
;	O
}	O
fixnum	O
object_to_fixnum	(int)->(int)
(	O
object	O
x	int
)	O
{	O
fixnum	O
i	int
=	O
0	int
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_character	O
:	O
i	int
=	O
char_code	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_fixnum	O
:	O
i	int
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
i	int
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_ratio	O
:	O
i	int
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
i	int
=	O
sf	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
i	int
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	()->(int)
(	O
"~S cannot be coerce to a C int."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
}	O
return	O
(	O
i	int
)	O
;	O
}	O
float	O
object_to_float	(int)->(float)
(	O
object	O
x	int
)	O
{	O
float	O
f	float
=	O
0.0	int
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_character	O
:	O
f	float
=	O
char_code	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_fixnum	O
:	O
f	float
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
f	float
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
f	float
=	O
sf	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
f	float
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	()->(int)
(	O
"~S cannot be coerce to a C float."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
}	O
return	O
(	O
f	float
)	O
;	O
}	O
double	O
object_to_double	(int)->(double)
(	O
object	O
x	int
)	O
{	O
double	O
d	double
=	O
0.0	int
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_character	O
:	O
d	double
=	O
char_code	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_fixnum	O
:	O
d	double
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
d	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
d	double
=	O
sf	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
d	double
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	()->(int)
(	O
"~S cannot be coerce to a C double."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
}	O
return	O
(	O
d	double
)	O
;	O
}	O
char	O
*	O
object_to_string	(int)->(*(char))
(	O
object	O
x	int
)	O
{	O
unsigned	O
int	O
leng	int
;	O
char	O
*	O
res	*(char)
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_string	O
)	O
FEwrong_type_argument	()->(int)
(	O
sLstring	O
,	O
x	int
)	O
;	O
leng	int
=	O
x	int
->	O
st	O
.	O
st_fillp	O
;	O
if	O
(	O
leng	int
>	O
0	int
&&	O
leng	int
<	O
x	int
->	O
st	O
.	O
st_dim	O
&&	O
x	int
->	O
st	O
.	O
st_self	O
[	O
leng	int
]	O
==	O
0	int
)	O
return	O
x	int
->	O
st	O
.	O
st_self	O
;	O
if	O
(	O
x	int
->	O
st	O
.	O
st_dim	O
==	O
leng	int
&&	O
leng	int
%	O
sizeof	O
(	O
object	O
)	O
&&	O
MAYBE_DATA_P	()->(int)
(	O
x	int
->	O
st	O
.	O
st_self	O
)	O
)	O
{	O
x	int
->	O
st	O
.	O
st_self	O
[	O
leng	int
]	O
=	O
0	int
;	O
return	O
x	int
->	O
st	O
.	O
st_self	O
;	O
}	O
res	*(char)
=	O
malloc	(long)->(*(void))
(	O
leng	int
+	O
1	int
)	O
;	O
bcopy	(*(void),*(void),long)->(void)
(	O
x	int
->	O
st	O
.	O
st_self	O
,	O
res	*(char)
,	O
leng	int
)	O
;	O
res	*(char)
[	O
leng	int
]	O
=	O
0	int
;	O
return	O
res	*(char)
;	O
}	O
void	O
call_init	(int,int,int,int)->(void)
(	O
int	O
init_address	int
,	O
object	O
memory	int
,	O
object	O
fasl_vec	int
,	O
FUNC	O
fptr	*(int)
)	O
{	O
object	O
form	O
;	O
FUNC	O
at	O
;	O
check_type	()->(int)
(	O
fasl_vec	int
,	O
t_vector	O
)	O
;	O
form	O
=	O
(	O
fasl_vec	int
->	O
v	O
.	O
v_self	O
[	O
fasl_vec	int
->	O
v	O
.	O
v_fillp	O
-	O
1	int
]	O
)	O
;	O
if	O
(	O
fptr	*(int)
)	O
at	O
=	O
fptr	*(int)
;	O
else	O
at	O
=	O
(	O
FUNC	O
)	O
(	O
memory	int
->	O
cfd	O
.	O
cfd_start	O
+	O
init_address	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
form	O
)	O
==	O
t_cons	O
&&	O
form	O
->	O
c	int
.	O
c_car	O
==	O
sSPinit	O
)	O
{	O
bds_bind	()->(int)
(	O
sSPinit	O
,	O
fasl_vec	int
)	O
;	O
bds_bind	()->(int)
(	O
sSPmemory	O
,	O
memory	int
)	O
;	O
(	O
*	O
at	O
)	O
(	O
)	O
;	O
bds_unwind1	O
;	O
bds_unwind1	O
;	O
}	O
else	O
{	O
memory	int
->	O
cfd	O
.	O
cfd_self	O
=	O
fasl_vec	int
->	O
v	O
.	O
v_self	O
;	O
memory	int
->	O
cfd	O
.	O
cfd_fillp	O
=	O
fasl_vec	int
->	O
v	O
.	O
v_fillp	O
;	O
(	O
*	O
at	O
)	O
(	O
memory	int
->	O
cfd	O
.	O
cfd_start	O
,	O
memory	int
->	O
cfd	O
.	O
cfd_size	O
,	O
memory	int
)	O
;	O
}	O
}	O
void	O
do_init	(*(int))->(void)
(	O
object	O
*	O
statVV	*(int)
)	O
{	O
object	O
fasl_vec	int
=	O
sSPinit	O
->	O
s	*(char)
.	O
s_dbind	O
;	O
object	O
data	O
=	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
;	O
{	O
object	O
*	O
p	O
,	O
*	O
q	*(char)
,	O
y	O
;	O
int	O
n	int
=	O
fasl_vec	int
->	O
v	O
.	O
v_fillp	O
-	O
1	int
;	O
int	O
i	int
;	O
object	O
form	O
;	O
check_type	()->(int)
(	O
fasl_vec	int
,	O
t_vector	O
)	O
;	O
form	O
=	O
fasl_vec	int
->	O
v	O
.	O
v_self	O
[	O
n	int
]	O
;	O
dcheck_type	O
(	O
form	O
,	O
t_cons	O
)	O
;	O
fasl_vec	int
->	O
v	O
.	O
v_elttype	O
=	O
aet_fix	O
;	O
fasl_vec	int
->	O
v	O
.	O
v_dim	O
*=	O
(	O
sizeof	O
(	O
object	O
)	O
/	O
sizeof	O
(	O
fixnum	O
)	O
)	O
;	O
fasl_vec	int
->	O
v	O
.	O
v_fillp	O
*=	O
(	O
sizeof	O
(	O
object	O
)	O
/	O
sizeof	O
(	O
fixnum	O
)	O
)	O
;	O
p	O
=	O
fasl_vec	int
->	O
v	O
.	O
v_self	O
;	O
q	*(char)
=	O
statVV	*(int)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
n	int
;	O
i	int
++	O
)	O
{	O
y	O
=	O
*	O
p	O
;	O
*	O
p	O
++	O
=	O
*	O
q	*(char)
;	O
*	O
q	*(char)
++	O
=	O
y	O
;	O
}	O
data	O
->	O
cfd	O
.	O
cfd_self	O
=	O
statVV	*(int)
;	O
data	O
->	O
cfd	O
.	O
cfd_fillp	O
=	O
n	int
+	O
1	int
;	O
statVV	*(int)
[	O
n	int
]	O
=	O
data	O
;	O
form	O
=	O
form	O
->	O
c	int
.	O
c_cdr	O
;	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
form	O
->	O
v	O
.	O
v_fillp	O
;	O
i	int
++	O
)	O
{	O
eval	()->(int)
(	O
form	O
->	O
v	O
.	O
v_self	O
[	O
i	int
]	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
}	O
}	O
}	O
}	O
void	O
gcl_init_or_load1	(*(()->(void)),*(char))->(void)
(	O
void	O
(	O
*	O
fn	*(()->(void))
)	O
(	O
void	O
)	O
,	O
const	O
char	O
*	O
file	*(char)
)	O
{	O
if	O
(	O
file	*(char)
[	O
strlen	(*(char))->(long)
(	O
file	*(char)
)	O
-	O
1	int
]	O
==	O
'o'	O
)	O
{	O
object	O
memory	int
;	O
object	O
fasl_data	O
;	O
file	*(char)
=	O
FIX_PATH_STRING	()->(int)
(	O
file	*(char)
)	O
;	O
memory	int
=	O
alloc_object	()->(int)
(	O
t_cfdata	O
)	O
;	O
memory	int
->	O
cfd	O
.	O
cfd_self	O
=	O
0	int
;	O
memory	int
->	O
cfd	O
.	O
cfd_fillp	O
=	O
0	int
;	O
memory	int
->	O
cfd	O
.	O
cfd_size	O
=	O
0	int
;	O
memory	int
->	O
cfd	O
.	O
cfd_start	O
=	O
(	O
char	O
*	O
)	O
fn	*(()->(void))
;	O
printf	O
(	O
"Initializing %s\n"	*(char)
,	O
file	*(char)
)	O
;	O
fflush	()->(int)
(	O
stdout	O
)	O
;	O
fasl_data	O
=	O
read_fasl_data	()->(int)
(	O
file	*(char)
)	O
;	O
call_init	(int,int,int,int)->(void)
(	O
0	int
,	O
memory	int
,	O
fasl_data	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
printf	O
(	O
"loading %s\n"	*(char)
,	O
file	*(char)
)	O
;	O
fflush	()->(int)
(	O
stdout	O
)	O
;	O
load	()->(int)
(	O
file	*(char)
)	O
;	O
}	O
}	O
DEFUN_NEW	()->(int)
(	O
"INIT-CMP-ANON"	*(char)
,	O
object	O
,	O
fSinit_cmp_anon	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
"Initialize previously compiled and linked anonymous function from the .text section of the running executable.  This function is inherently dangerous, and is meant as a work-around to facilitate the production of an ansi GCL image on systems which must currently link using dlopen.  On such systems, it is imposible to compile and load anonymous functions as part of the initialization sequence of the lisp image, as is done in pcl, and preserve that function across a save-system call.  The approach here is to provide a flag to GCL's compile function which will direct the algorithm to forgo recompilation and loading in favor of initialization via this function."	*(char)
)	O
{	O
int	O
i	int
;	O
i	int
=	O
gcl_init_cmp_anon	()->(int)
(	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
FEerror	()->(int)
(	O
"No such anonymous function"	*(char)
,	O
0	int
)	O
;	O
return	O
i	int
?	O
Cnil	O
:	O
Ct	O
;	O
}	O
object	O
find_init_name1	(*(char),int)->(int)
(	O
char	O
*	O
s	*(char)
,	O
unsigned	O
len	int
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
ss	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
char	O
*	O
tmp	*(char)
,	O
*	O
q	*(char)
;	O
FILE	O
*	O
f	float
;	O
if	O
(	O
len	int
)	O
{	O
tmp	*(char)
=	O
alloca	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tmp	*(char)
,	O
s	*(char)
,	O
len	int
)	O
;	O
tmp	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
tmp	*(char)
=	O
s	*(char)
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
tmp	*(char)
,	O
&	O
ss	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
FEerror	()->(int)
(	O
"File ~a does not exist"	*(char)
,	O
1	int
,	O
make_simple_string	()->(int)
(	O
tmp	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
(	O
f	float
=	O
fopen	()->(int)
(	O
tmp	*(char)
,	O
"rb"	*(char)
)	O
)	O
)	O
FEerror	()->(int)
(	O
"Cannot open ~a for binary reading"	*(char)
,	O
1	int
,	O
make_simple_string	()->(int)
(	O
tmp	*(char)
)	O
)	O
;	O
tmp	*(char)
=	O
alloca	(long)->(*(void))
(	O
ss	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
+	O
1	int
)	O
;	O
if	O
(	O
fread	()->(int)
(	O
tmp	*(char)
,	O
1	int
,	O
ss	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
,	O
f	float
)	O
!=	O
ss	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
FEerror	()->(int)
(	O
"Error reading binary file"	*(char)
,	O
0	int
)	O
;	O
fclose	()->(int)
(	O
f	float
)	O
;	O
for	O
(	O
s	*(char)
=	O
tmp	*(char)
+	O
1	int
;	O
s	*(char)
<	O
tmp	*(char)
+	O
ss	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
&&	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
"init_"	*(char)
,	O
5	int
)	O
||	O
(	O
s	*(char)
>	O
tmp	*(char)
&&	O
(	O
s	*(char)
[	O
-	O
1	int
]	O
==	O
'_'	O
?	O
(	O
s	*(char)
>	O
tmp	*(char)
+	O
1	int
&&	O
s	*(char)
[	O
-	O
2	int
]	O
)	O
:	O
s	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
)	O
;	O
q	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
s	*(char)
+	O
1	int
,	O
"init_"	*(char)
)	O
,	O
s	*(char)
=	O
q	*(char)
?	O
q	*(char)
:	O
s	*(char)
+	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
"init_"	*(char)
,	O
5	int
)	O
)	O
FEerror	()->(int)
(	O
"Init name not found"	*(char)
,	O
0	int
)	O
;	O
return	O
make_simple_string	()->(int)
(	O
s	*(char)
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"FIND-INIT-NAME"	*(char)
,	O
object	O
,	O
fSfind_init_name	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
namestring	O
)	O
,	O
""	*(char)
)	O
{	O
check_type_string	()->(int)
(	O
&	O
namestring	O
)	O
;	O
return	O
find_init_name1	(*(char),int)->(int)
(	O
namestring	O
->	O
st	O
.	O
st_self	O
,	O
namestring	O
->	O
st	O
.	O
st_dim	O
)	O
;	O
}	O
