struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
{	O
char	O
*	O
name	*(char)
;	O
grad_uint32_t	int
nas_ip	int
;	O
int	O
port	array(int)
;	O
char	O
*	O
sid	*(char)
;	O
grad_uint32_t	int
framed_ip	int
;	O
int	O
method	int
;	O
char	O
*	O
func	*(char)
;	O
grad_envar_t	struct
*	O
args	*(struct)
;	O
char	O
*	O
nasname	*(char)
;	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
int	O
timeout	int
;	O
int	O
result	*(struct(*(char),*(*(char)),int,int,*(*(char))))
;	O
}	O
;	O
char	O
*	O
slookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),*(char))->(*(char))
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
defval	*(char)
)	O
{	O
return	O
grad_envar_lookup_str	(*(struct),*(char),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
args	*(struct)
,	O
name	*(char)
,	O
defval	*(char)
)	O
;	O
}	O
int	O
ilookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),int)->(int)
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
char	O
*	O
name	*(char)
,	O
int	O
defval	*(char)
)	O
{	O
return	O
grad_envar_lookup_int	(*(struct),*(char),int)->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
args	*(struct)
,	O
name	*(char)
,	O
defval	*(char)
)	O
;	O
}	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
create_instance	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)))
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
grad_nas_t	struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))
*	O
nas	int
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
RADCK_TYPE	struct
*	O
radck_type	struct(*(char),int,*(struct))
;	O
if	O
(	O
(	O
radck_type	struct(*(char),int,*(struct))
=	O
find_radck_type	(*(char))->(*(struct(*(char),int,*(struct))))
(	O
nas	int
->	O
nastype	array(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"unknown NAS type: %s (nas %s)"	*(char)
)	O
,	O
nas	int
->	O
nastype	array(char)
,	O
nas	int
->	O
shortname	array(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
name	*(char)
=	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
orig_login	array(char)
[	O
0	int
]	O
?	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
orig_login	array(char)
:	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
login	array(char)
;	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
port	array(int)
=	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
nas_port	int
;	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
sid	*(char)
=	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
session_id	array(char)
;	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
framed_ip	int
=	O
ntohl	(int)->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
framed_address	int
)	O
;	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
nas_ip	int
=	O
ntohl	(int)->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
nas_address	int
)	O
;	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
result	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
-	O
1	int
;	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
timeout	int
=	O
0	int
;	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
nasname	*(char)
=	O
nas	int
->	O
shortname	array(char)
?	O
nas	int
->	O
shortname	array(char)
:	O
nas	int
->	O
longname	array(char)
;	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
method	int
=	O
radck_type	struct(*(char),int,*(struct))
->	O
method	int
;	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
args	*(struct)
=	O
grad_envar_merge_lists	(*(struct),*(struct))->(*(struct))
(	O
(	O
grad_envar_t	struct
*	O
)	O
nas	int
->	O
args	*(struct)
,	O
radck_type	struct(*(char),int,*(struct))
->	O
args	*(struct)
)	O
;	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
func	*(char)
=	O
slookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),*(char))->(*(char))
(	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"function"	*(char)
,	O
NULL	O
)	O
;	O
obstack_init	O
(	O
&	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
return	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
;	O
}	O
void	O
free_instance	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)))->(void)
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
)	O
{	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
NULL	O
)	O
;	O
grad_envar_free_list	(*(*(struct)))->(void)
(	O
&	O
cptr	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
args	*(struct)
)	O
;	O
}	O
int	O
compare	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(int)
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
char	O
*	O
str	*(char)
)	O
{	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
val	array(int)
;	O
if	O
(	O
rewrite_invoke	(enum(int,int,int),*(struct(enum(int,int,int),union(int,struct(long,*`)))),*(char),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(char))->(int)
(	O
Integer	int
,	O
&	O
val	array(int)
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
func	*(char)
,	O
NULL	O
,	O
"ssis"	*(char)
,	O
str	*(char)
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
name	*(char)
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
port	array(int)
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
sid	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
return	O
val	array(int)
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
}	O
char	O
*	O
checkrad_xlat_new	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(*(char))
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
char	O
*	O
template	*(char)
)	O
{	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
;	O
char	O
*	O
str	*(char)
;	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
=	O
grad_request_alloc	()->(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
(	O
)	O
;	O
grad_avl_add_pair	(*(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
&	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
grad_avp_create_string	(int,*(char))->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
DA_USER_NAME	int
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
name	*(char)
)	O
)	O
;	O
grad_avl_add_pair	(*(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
&	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
grad_avp_create_integer	(int,int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
DA_NAS_PORT_ID	int
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
port	array(int)
)	O
)	O
;	O
grad_avl_add_pair	(*(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
&	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
grad_avp_create_string	(int,*(char))->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
DA_ACCT_SESSION_ID	int
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
sid	*(char)
)	O
)	O
;	O
grad_avl_add_pair	(*(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
&	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
grad_avp_create_integer	(int,int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
DA_FRAMED_IP_ADDRESS	int
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
framed_ip	int
)	O
)	O
;	O
grad_avl_add_pair	(*(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
&	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
grad_avp_create_integer	(int,int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
DA_NAS_IP_ADDRESS	int
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
nas_ip	int
)	O
)	O
;	O
str	*(char)
=	O
util_xlate	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(char),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))->(*(char))
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
template	*(char)
,	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
;	O
grad_request_free	(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))->(void)
(	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
;	O
return	O
str	*(char)
;	O
}	O
char	O
*	O
checkrad_xlat_old	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(*(char))
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
ptr	*(*(void))
;	O
int	O
len	int
;	O
char	O
buf	*(char)
[	O
24	int
]	O
;	O
while	O
(	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
*	O
str	*(char)
==	O
'%'	O
)	O
{	O
switch	O
(	O
str	*(char)
[	O
1	int
]	O
)	O
{	O
case	O
'u'	O
:	O
ptr	*(*(void))
=	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
name	*(char)
;	O
break	O
;	O
case	O
's'	O
:	O
ptr	*(*(void))
=	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
sid	*(char)
;	O
break	O
;	O
case	O
'd'	O
:	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"%lu"	*(char)
,	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
sid	*(char)
,	O
NULL	O
,	O
16	int
)	O
)	O
;	O
ptr	*(*(void))
=	O
buf	*(char)
;	O
break	O
;	O
case	O
'p'	O
:	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"%d"	*(char)
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
port	array(int)
)	O
;	O
ptr	*(*(void))
=	O
buf	*(char)
;	O
break	O
;	O
case	O
'P'	O
:	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"%d"	*(char)
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
port	array(int)
+	O
1	int
)	O
;	O
ptr	*(*(void))
=	O
buf	*(char)
;	O
break	O
;	O
case	O
'i'	O
:	O
grad_ip_iptostr	(int,*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
framed_ip	int
,	O
buf	*(char)
)	O
;	O
ptr	*(*(void))
=	O
buf	*(char)
;	O
break	O
;	O
default	O
:	O
ptr	*(*(void))
=	O
NULL	O
;	O
obstack_grow	O
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
str	*(char)
,	O
2	int
)	O
;	O
}	O
if	O
(	O
ptr	*(*(void))
)	O
{	O
len	int
=	O
strlen	(*(char))->(long)
(	O
ptr	*(*(void))
)	O
;	O
obstack_grow	O
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
ptr	*(*(void))
,	O
len	int
)	O
;	O
}	O
str	*(char)
+=	O
2	int
;	O
}	O
else	O
{	O
obstack_1grow	O
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
*	O
str	*(char)
)	O
;	O
str	*(char)
++	O
;	O
}	O
}	O
obstack_1grow	O
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
0	int
)	O
;	O
return	O
obstack_finish	O
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
char	O
*	O
checkrad_xlat	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(*(char))
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
str	*(char)
[	O
0	int
]	O
==	O
'='	O
)	O
return	O
checkrad_xlat_new	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
str	*(char)
+	O
1	int
)	O
;	O
return	O
checkrad_xlat_old	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
str	*(char)
)	O
;	O
}	O
static	O
int	O
converse	*((int,*(struct(*(struct`),int,struct(*`,int),int,int,*(char),short,short,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*(struct`))),*(struct(char,struct(short,short,struct`,array(char)),int,int,int,*(struct`))),*(void))->(int))
(	O
int	O
type	int
,	O
struct	O
snmp_session	struct(*(struct(*(struct(*(struct`),int,struct(*`,int),int,int,*(char),short,short,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*(struct`))),int,struct(*(char),int),int,int,*(char),short,short,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*((int,*(struct`),*(struct`),*(void))->(int)),*(void),*(struct(char,struct(short,short,struct`,array(char)),int,int,int,*(struct`))),*(struct(*(struct`),int,int,struct(long,long),*(struct`))))),int,struct(*(char),int),int,int,*(char),short,short,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*((int,*(struct(*(struct`),int,struct(*`,int),int,int,*(char),short,short,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*(struct`))),*(struct(char,struct(short,short,struct`,array(char)),int,int,int,*(struct`))),*(void))->(int)),*(void),*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*(struct`),*(int),int,char,union(int,*`,*`))))),*(struct(*(struct(*(struct`),int,int,struct(long,long),*(struct`))),int,int,struct(long,long),*(struct(char,struct(short,short,struct`,array(char)),int,int,int,*(struct`))))))
*	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
struct	O
snmp_pdu	struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int)))))
*	O
pdu	*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*(struct`),*(int),int,char,union(int,*`,*`)))))
,	O
void	O
*	O
closure	*(void)
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
struct	O
snmp_var	struct(*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int)))),*(int),int,char,union(int,*(char),*(int)))
*	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
;	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
=	O
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
)	O
closure	*(void)
;	O
char	O
buf	*(char)
[	O
64	int
]	O
;	O
if	O
(	O
type	int
==	O
SNMP_CONV_TIMEOUT	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"timed out in waiting SNMP response from NAS %s"	*(char)
)	O
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
nasname	*(char)
)	O
;	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
timeout	int
++	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
type	int
!=	O
SNMP_CONV_RECV_MSG	int
)	O
return	O
1	int
;	O
for	O
(	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
=	O
pdu	*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*(struct`),*(int),int,char,union(int,*`,*`)))))
->	O
var	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
;	O
rc	int
==	O
0	int
&&	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
;	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
=	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
switch	O
(	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
->	O
type	int
)	O
{	O
case	O
SMI_STRING	O
:	O
rc	int
=	O
compare	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
->	O
var_str	O
)	O
;	O
GRAD_DEBUG2	O
(	O
2	int
,	O
"(STRING) %s: %d"	*(char)
,	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
->	O
var_str	O
,	O
rc	int
)	O
;	O
break	O
;	O
case	O
SMI_INTEGER	O
:	O
case	O
SMI_COUNTER32	O
:	O
case	O
SMI_COUNTER64	O
:	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"%d"	*(char)
,	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
->	O
var_int	O
)	O
;	O
rc	int
=	O
compare	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
buf	*(char)
)	O
;	O
GRAD_DEBUG2	O
(	O
2	int
,	O
"(INT) %d: %d"	*(char)
,	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
->	O
var_int	O
,	O
rc	int
)	O
;	O
break	O
;	O
case	O
SMI_IPADDRESS	O
:	O
grad_ip_iptostr	(int,*(char))->(*(char))
(	O
*	O
(	O
grad_uint32_t	int
*	O
)	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
->	O
var_int	O
,	O
buf	*(char)
)	O
;	O
rc	int
=	O
compare	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
buf	*(char)
)	O
;	O
GRAD_DEBUG2	O
(	O
2	int
,	O
"(IPADDR) %#x: %d"	*(char)
,	O
*	O
(	O
grad_uint32_t	int
*	O
)	O
vlist	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
->	O
var_str	O
,	O
rc	int
)	O
;	O
break	O
;	O
}	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
result	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
rc	int
;	O
return	O
1	int
;	O
}	O
int	O
snmp_check	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))->(int)
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
grad_nas_t	struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))
*	O
nas	int
)	O
{	O
int	O
rc	int
=	O
-	O
1	int
;	O
struct	O
snmp_pdu	struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int)))))
*	O
pdu	*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*(struct`),*(int),int,char,union(int,*`,*`)))))
;	O
struct	O
snmp_session	struct(*(struct(*(struct(*(struct`),int,struct(*`,int),int,int,*(char),short,short,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*(struct`))),int,struct(*(char),int),int,int,*(char),short,short,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*((int,*(struct`),*(struct`),*(void))->(int)),*(void),*(struct(char,struct(short,short,struct`,array(char)),int,int,int,*(struct`))),*(struct(*(struct`),int,int,struct(long,long),*(struct`))))),int,struct(*(char),int),int,int,*(char),short,short,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*((int,*(struct(*(struct`),int,struct(*`,int),int,int,*(char),short,short,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*(struct`))),*(struct(char,struct(short,short,struct`,array(char)),int,int,int,*(struct`))),*(void))->(int)),*(void),*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*(struct`),*(int),int,char,union(int,*`,*`))))),*(struct(*(struct(*(struct`),int,int,struct(long,long),*(struct`))),int,int,struct(long,long),*(struct(char,struct(short,short,struct`,array(char)),int,int,int,*(struct`))))))
*	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
struct	O
snmp_var	struct(*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int)))),*(int),int,char,union(int,*(char),*(int)))
*	O
var	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
;	O
char	O
*	O
community	struct(*(char),int)
;	O
int	O
retries	int
;	O
int	O
timeout	int
;	O
char	O
*	O
peername	*(char)
;	O
int	O
remote_port	short
;	O
oid_t	*(int)
oid	*(int)
;	O
char	O
*	O
snmp_oid	*(char)
;	O
if	O
(	O
(	O
snmp_oid	*(char)
=	O
slookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"oid"	*(char)
,	O
NULL	O
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"no snmp_oid"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
snmp_oid	*(char)
=	O
checkrad_xlat	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
snmp_oid	*(char)
)	O
;	O
if	O
(	O
!	O
snmp_oid	*(char)
)	O
return	O
-	O
1	int
;	O
oid	*(int)
=	O
oid_create_from_string	(*(char))->(*(int))
(	O
snmp_oid	*(char)
)	O
;	O
if	O
(	O
!	O
oid	*(int)
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"invalid OID: %s"	*(char)
)	O
,	O
snmp_oid	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
community	struct(*(char),int)
=	O
slookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"password"	*(char)
,	O
NULL	O
)	O
)	O
==	O
NULL	O
&&	O
(	O
community	struct(*(char),int)
=	O
slookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"community"	*(char)
,	O
NULL	O
)	O
)	O
==	O
NULL	O
)	O
community	struct(*(char),int)
=	O
"public"	*(char)
;	O
retries	int
=	O
ilookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),int)->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"retries"	*(char)
,	O
3	int
)	O
;	O
timeout	int
=	O
ilookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),int)->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"timeout"	*(char)
,	O
2	int
)	O
;	O
peername	*(char)
=	O
slookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"host"	*(char)
,	O
nas	int
->	O
longname	array(char)
)	O
;	O
remote_port	short
=	O
ilookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),int)->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"port"	*(char)
,	O
161	int
)	O
;	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
snmp_session_create	(*(char),*(char),int,*((int,*(struct(*`,int,struct`,int,int,*`,short,short,int,struct`,struct`,*`,*`,*`,*`)),*(struct(char,struct`,int,int,int,*`)),*(void))->(int)),*(void))->(*(struct(*(struct(*`,int,struct`,int,int,*`,short,short,int,struct`,struct`,*`,*`,*`,*`)),int,struct(*(char),int),int,int,*(char),short,short,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct(char,struct`,int,int,int,*`)),*(struct(*`,int,int,struct`,*`)))))
(	O
community	struct(*(char),int)
,	O
peername	*(char)
,	O
remote_port	short
,	O
converse	*((int,*(struct(*(struct`),int,struct(*`,int),int,int,*(char),short,short,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*(struct`))),*(struct(char,struct(short,short,struct`,array(char)),int,int,int,*(struct`))),*(void))->(int))
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
)	O
;	O
if	O
(	O
!	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't create snmp session: %s"	*(char)
)	O
,	O
snmp_strerror	(int)->(*(char))
(	O
snmp_errno	O
)	O
)	O
;	O
snmp_free	(*(void))->(void)
(	O
oid	*(int)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
snmp_session_open	(*(struct(*(struct(*`,int,struct`,int,int,*`,short,short,int,struct`,struct`,*`,*`,*`,*`)),int,struct(*(char),int),int,int,*(char),short,short,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct(char,struct`,int,int,int,*`)),*(struct(*`,int,int,struct`,*`)))),int,int,int,int)->(int)
(	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
myip	int
,	O
0	int
,	O
timeout	int
,	O
retries	int
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't open snmp session: %s"	*(char)
)	O
,	O
snmp_strerror	(int)->(*(char))
(	O
snmp_errno	O
)	O
)	O
;	O
snmp_free	(*(void))->(void)
(	O
oid	*(int)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
pdu	*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*(struct`),*(int),int,char,union(int,*`,*`)))))
=	O
snmp_pdu_create	(int)->(*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*`,*`,int,char,union`)))))
(	O
SNMP_PDU_GET	O
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't create SNMP PDU: %s"	*(char)
)	O
,	O
snmp_strerror	(int)->(*(char))
(	O
snmp_errno	O
)	O
)	O
;	O
snmp_free	(*(void))->(void)
(	O
oid	*(int)
)	O
;	O
snmp_session_close	(*(struct(*(struct(*`,int,struct`,int,int,*`,short,short,int,struct`,struct`,*`,*`,*`,*`)),int,struct(*(char),int),int,int,*(char),short,short,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct(char,struct`,int,int,int,*`)),*(struct(*`,int,int,struct`,*`)))))->(void)
(	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
var	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
=	O
snmp_var_create	(*(int))->(*(struct(*(struct(*`,*`,int,char,union`)),*(int),int,char,union(int,*(char),*(int)))))
(	O
oid	*(int)
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't create SNMP PDU: %s"	*(char)
)	O
,	O
snmp_strerror	(int)->(*(char))
(	O
snmp_errno	O
)	O
)	O
;	O
snmp_free	(*(void))->(void)
(	O
oid	*(int)
)	O
;	O
snmp_session_close	(*(struct(*(struct(*`,int,struct`,int,int,*`,short,short,int,struct`,struct`,*`,*`,*`,*`)),int,struct(*(char),int),int,int,*(char),short,short,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct(char,struct`,int,int,int,*`)),*(struct(*`,int,int,struct`,*`)))))->(void)
(	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
snmp_pdu_free	(*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*`,*`,int,char,union`)))))->(void)
(	O
pdu	*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*(struct`),*(int),int,char,union(int,*`,*`)))))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
snmp_pdu_add_var	(*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*`,*`,int,char,union`)))),*(struct(*(struct(*`,*`,int,char,union`)),*(int),int,char,union(int,*(char),*(int)))))->(void)
(	O
pdu	*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*(struct`),*(int),int,char,union(int,*`,*`)))))
,	O
var	*(struct(*(struct(*(struct`),*(int),int,char,union(int,*`,*`))),*(int),int,char,union(int,*(char),*(int))))
)	O
;	O
snmp_free	(*(void))->(void)
(	O
oid	*(int)
)	O
;	O
GRAD_DEBUG4	O
(	O
1	int
,	O
"snmpget: %s:%d %s %s"	*(char)
,	O
peername	*(char)
,	O
remote_port	short
,	O
community	struct(*(char),int)
,	O
snmp_oid	*(char)
)	O
;	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
result	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
rc	int
;	O
snmp_query	(*(struct(*(struct(*`,int,struct`,int,int,*`,short,short,int,struct`,struct`,*`,*`,*`,*`)),int,struct(*(char),int),int,int,*(char),short,short,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct(char,struct`,int,int,int,*`)),*(struct(*`,int,int,struct`,*`)))),*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*`,*`,int,char,union`)))))->(int)
(	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
pdu	*(struct(char,struct(short,short,struct(int),array(char)),int,int,int,*(struct(*(struct`),*(int),int,char,union(int,*`,*`)))))
)	O
;	O
rc	int
=	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
result	*(struct(*(char),*(*(char)),int,int,*(*(char))))
;	O
snmp_session_close	(*(struct(*(struct(*`,int,struct`,int,int,*`,short,short,int,struct`,struct`,*`,*`,*`,*`)),int,struct(*(char),int),int,int,*(char),short,short,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*((int,*`,*`,*`)->(int)),*(void),*(struct(char,struct`,int,int,int,*`)),*(struct(*`,int,int,struct`,*`)))))->(void)
(	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"result: %d"	*(char)
,	O
rc	int
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
to_env	array(struct(array(long),int,struct(array(long))))
;	O
static	O
RETSIGTYPE	void
alrm_handler	()->(void)
(	O
)	O
{	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
to_env	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
int	O
finger_check	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))->(int)
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
grad_nas_t	struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))
*	O
nas	int
)	O
{	O
char	O
*	O
arg	*(char)
;	O
char	O
namebuf	array(char)
[	O
RUT_NAMESIZE	int
+	O
1	int
]	O
;	O
int	O
namelen	int
;	O
register	O
FILE	struct
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
register	O
int	O
c	*(void)
,	O
lastc	int
;	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
sin	struct(short,short,struct(int),array(char))
;	O
int	O
i	int
,	O
port	array(int)
;	O
int	O
s	*(*(char))
;	O
struct	O
iovec	struct(*(void),long)
iov	array(struct(*(void),long))
[	O
3	int
]	O
;	O
struct	O
msghdr	struct(*(void),int,*(struct(*(void),long)),long,*(void),long,int)
msg	*(char)
;	O
int	O
found	int
=	O
0	int
;	O
char	O
*	O
peername	*(char)
;	O
char	O
*	O
ptr	*(*(void))
;	O
RETSIGTYPE	void
(	O
*	O
handler	*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int))
)	O
(	O
)	O
=	O
SIG_IGN	O
;	O
unsigned	O
int	O
to	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
;	O
arg	*(char)
=	O
checkrad_xlat	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
slookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"arg"	*(char)
,	O
"%u"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
arg	*(char)
)	O
return	O
-	O
1	int
;	O
ptr	*(*(void))
=	O
arg	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
RUT_NAMESIZE	int
&&	O
*	O
ptr	*(*(void))
;	O
++	O
ptr	*(*(void))
,	O
++	O
i	int
)	O
namebuf	array(char)
[	O
i	int
]	O
=	O
*	O
ptr	*(*(void))
;	O
namebuf	array(char)
[	O
i	int
]	O
=	O
0	int
;	O
namelen	int
=	O
i	int
;	O
peername	*(char)
=	O
slookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"host"	*(char)
,	O
nas	int
->	O
longname	array(char)
)	O
;	O
if	O
(	O
!	O
(	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
peername	*(char)
)	O
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"unknown host: %s"	*(char)
)	O
,	O
peername	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
port	array(int)
=	O
ilookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),int)->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"port"	*(char)
,	O
0	int
)	O
)	O
==	O
0	int
)	O
{	O
struct	O
servent	struct(*(char),*(*(char)),int,*(char))
*	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
if	O
(	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
getservbyname	(*(char),*(char))->(*(struct(*(char),*(*(char)),int,*(char))))
(	O
"finger"	*(char)
,	O
"tcp"	*(char)
)	O
)	O
port	array(int)
=	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
->	O
s_port	int
;	O
else	O
port	array(int)
=	O
htons	(short)->(short)
(	O
79	int
)	O
;	O
}	O
else	O
port	array(int)
=	O
htons	(short)->(short)
(	O
port	array(int)
)	O
;	O
sin	struct(short,short,struct(int),array(char))
.	O
sin_family	short
=	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addrtype	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
sin	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
,	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addr	O
,	O
MIN	O
(	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_length	int
,	O
sizeof	O
(	O
sin	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
)	O
)	O
;	O
sin	struct(short,short,struct(int),array(char))
.	O
sin_port	short
=	O
port	array(int)
;	O
if	O
(	O
(	O
s	*(*(char))
=	O
socket	(int,int,int)->(int)
(	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addrtype	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"socket"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
GRAD_DEBUG3	O
(	O
1	int
,	O
"finger %s@%s:%d"	*(char)
,	O
namebuf	array(char)
,	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_name	*(char)
,	O
ntohs	(short)->(short)
(	O
port	array(int)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
msg	*(char)
,	O
0	int
,	O
sizeof	O
(	O
msg	*(char)
)	O
)	O
;	O
msg	*(char)
.	O
msg_name	*(void)
=	O
(	O
void	O
*	O
)	O
&	O
sin	struct(short,short,struct(int),array(char))
;	O
msg	*(char)
.	O
msg_namelen	int
=	O
sizeof	O
sin	struct(short,short,struct(int),array(char))
;	O
msg	*(char)
.	O
msg_iov	*(struct(*(void),long))
=	O
iov	array(struct(*(void),long))
;	O
msg	*(char)
.	O
msg_iovlen	long
=	O
0	int
;	O
iov	array(struct(*(void),long))
[	O
msg	*(char)
.	O
msg_iovlen	long
]	O
.	O
iov_base	*(void)
=	O
namebuf	array(char)
;	O
iov	array(struct(*(void),long))
[	O
msg	*(char)
.	O
msg_iovlen	long
++	O
]	O
.	O
iov_len	long
=	O
namelen	int
;	O
iov	array(struct(*(void),long))
[	O
msg	*(char)
.	O
msg_iovlen	long
]	O
.	O
iov_base	*(void)
=	O
"\r\n"	*(char)
;	O
iov	array(struct(*(void),long))
[	O
msg	*(char)
.	O
msg_iovlen	long
++	O
]	O
.	O
iov_len	long
=	O
2	int
;	O
if	O
(	O
ilookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),int)->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"tcp"	*(char)
,	O
1	int
)	O
&&	O
connect	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
s	*(*(char))
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
sin	struct(short,short,struct(int),array(char))
,	O
sizeof	O
(	O
sin	struct(short,short,struct(int),array(char))
)	O
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"connect"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
sendmsg	(int,*(struct(*(void),int,*(struct(*`,long)),long,*(void),long,int)),int)->(long)
(	O
s	*(*(char))
,	O
&	O
msg	*(char)
,	O
0	int
)	O
<	O
0	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"sendmsg"	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
s	*(*(char))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
lastc	int
=	O
0	int
;	O
if	O
(	O
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
s	*(*(char))
,	O
"r"	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
to_env	array(struct(array(long),int,struct(array(long))))
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"timed out in waiting for finger response from NAS %s"	*(char)
)	O
,	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
nasname	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
;	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
grad_set_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
handler	*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int))
)	O
;	O
return	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
result	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
-	O
1	int
;	O
}	O
to	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
=	O
ilookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),int)->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"timeout"	*(char)
,	O
10	int
)	O
;	O
handler	*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int))
=	O
grad_set_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
alrm_handler	()->(void)
)	O
;	O
alarm	(int)->(int)
(	O
to	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
)	O
;	O
while	O
(	O
(	O
c	*(void)
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	*(void)
==	O
0x0d	int
)	O
{	O
if	O
(	O
lastc	int
==	O
'\r'	O
)	O
continue	O
;	O
c	*(void)
=	O
'\n'	O
;	O
lastc	int
=	O
'\r'	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
isprint	(int)->(int)
(	O
c	*(void)
)	O
&&	O
!	O
isspace	(int)->(int)
(	O
c	*(void)
)	O
)	O
{	O
c	*(void)
&=	O
0x7f	int
;	O
c	*(void)
|=	O
0x40	int
;	O
}	O
if	O
(	O
lastc	int
!=	O
'\r'	O
||	O
c	*(void)
!=	O
'\n'	O
)	O
lastc	int
=	O
c	*(void)
;	O
else	O
{	O
lastc	int
=	O
'\n'	O
;	O
continue	O
;	O
}	O
}	O
obstack_1grow	O
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
c	*(void)
)	O
;	O
if	O
(	O
c	*(void)
==	O
'\n'	O
)	O
{	O
to	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
=	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
grad_set_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
handler	*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int))
)	O
;	O
obstack_1grow	O
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
0	int
)	O
;	O
ptr	*(*(void))
=	O
obstack_finish	O
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
GRAD_DEBUG1	O
(	O
2	int
,	O
"got : %s"	*(char)
,	O
ptr	*(*(void))
)	O
;	O
found	int
=	O
compare	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
ptr	*(*(void))
)	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
ptr	*(*(void))
)	O
;	O
if	O
(	O
found	int
)	O
break	O
;	O
grad_set_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
alrm_handler	()->(void)
)	O
;	O
alarm	(int)->(int)
(	O
to	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
)	O
;	O
}	O
}	O
if	O
(	O
!	O
found	int
&&	O
lastc	int
!=	O
'\n'	O
)	O
{	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
grad_set_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
handler	*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int))
)	O
;	O
obstack_1grow	O
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
'\n'	O
)	O
;	O
obstack_1grow	O
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
0	int
)	O
;	O
GRAD_DEBUG1	O
(	O
2	int
,	O
"got : %s"	*(char)
,	O
ptr	*(*(void))
)	O
;	O
ptr	*(*(void))
=	O
obstack_finish	O
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
found	int
=	O
compare	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(int)
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
ptr	*(*(void))
)	O
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"finger"	*(char)
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
;	O
}	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"result: %d"	*(char)
,	O
found	int
)	O
;	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
->	O
result	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
found	int
;	O
return	O
found	int
;	O
}	O
int	O
ext_check	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))->(int)
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
grad_nas_t	struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))
*	O
nas	int
)	O
{	O
char	O
*	O
s	*(*(char))
,	O
*	O
path	*(char)
;	O
int	O
rc	int
;	O
s	*(*(char))
=	O
slookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"path"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
s	*(*(char))
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"path variable not set"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
path	*(char)
=	O
checkrad_xlat_new	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
s	*(*(char))
)	O
;	O
if	O
(	O
!	O
path	*(char)
)	O
return	O
-	O
1	int
;	O
rc	int
=	O
radius_exec_command	(*(char))->(int)
(	O
path	*(char)
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
case	O
1	int
:	O
return	O
rc	int
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
guile_check	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))->(int)
(	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
*	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
grad_nas_t	struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))
*	O
nas	int
)	O
{	O
char	O
*	O
s	*(*(char))
,	O
*	O
expr	*(char)
;	O
int	O
rc	int
;	O
s	*(*(char))
=	O
slookup	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
"expr"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
s	*(*(char))
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"expr variable not set"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
expr	*(char)
=	O
checkrad_xlat_new	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(char))->(*(char))
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
s	*(*(char))
)	O
;	O
if	O
(	O
!	O
expr	*(char)
)	O
return	O
-	O
1	int
;	O
rc	int
=	O
scheme_eval_boolean_expr	(*(char))->(int)
(	O
expr	*(char)
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
case	O
1	int
:	O
return	O
rc	int
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
checkrad	(*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
grad_nas_t	struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))
*	O
nas	int
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
struct	O
check_instance	struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),int,int)
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
;	O
int	O
rc	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
create_instance	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)))
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
nas	int
,	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
)	O
return	O
-	O
1	int
;	O
switch	O
(	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
.	O
method	int
)	O
{	O
case	O
METHOD_FINGER	int
:	O
rc	int
=	O
finger_check	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))->(int)
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
nas	int
)	O
;	O
break	O
;	O
case	O
METHOD_SNMP	int
:	O
rc	int
=	O
snmp_check	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))->(int)
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
nas	int
)	O
;	O
break	O
;	O
case	O
METHOD_EXT	int
:	O
rc	int
=	O
ext_check	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))->(int)
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
nas	int
)	O
;	O
break	O
;	O
case	O
METHOD_GUILE	int
:	O
rc	int
=	O
guile_check	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)),*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))->(int)
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
,	O
nas	int
)	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"bad method"	*(char)
)	O
;	O
}	O
free_instance	(*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int)))->(void)
(	O
&	O
checkp	*(struct(*(char),int,int,*(char),int,int,*(char),*(struct),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),int,int))
)	O
;	O
return	O
rc	int
;	O
}	O
