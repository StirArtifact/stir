static	O
double	O
frequency	double
=	O
0.0	int
;	O
static	O
void	O
NORETURN	O
PRINTF_STYLE	O
(	O
1	int
,	O
2	int
)	O
die	(*(char))->(void)
(	O
const	O
char	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
double	O
overhead	double
=	O
0.0	int
;	O
static	O
double	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
void	O
(	O
*	O
f	*((*(void),long,*(char),*(char))->(void))
)	O
(	O
void	O
*	O
arg	*(void)
)	O
,	O
void	O
*	O
arg	*(void)
)	O
{	O
unsigned	O
ncalls	int
;	O
double	O
elapsed	double
;	O
for	O
(	O
ncalls	int
=	O
10	int
;	O
;	O
)	O
{	O
unsigned	O
i	char
;	O
time_start	*(()->(void))
(	O
)	O
;	O
for	O
(	O
i	char
=	O
0	int
;	O
i	char
<	O
ncalls	int
;	O
i	char
++	O
)	O
f	*((*(void),long,*(char),*(char))->(void))
(	O
arg	*(void)
)	O
;	O
elapsed	double
=	O
time_end	*(()->(double))
(	O
)	O
;	O
if	O
(	O
elapsed	double
>	O
BENCH_INTERVAL	int
)	O
break	O
;	O
else	O
if	O
(	O
elapsed	double
<	O
BENCH_INTERVAL	int
/	O
10	int
)	O
ncalls	int
*=	O
10	int
;	O
else	O
ncalls	int
*=	O
2	int
;	O
}	O
return	O
elapsed	double
/	O
ncalls	int
-	O
overhead	double
;	O
}	O
static	O
void	O
bench_nothing	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
UNUSED	O
)	O
{	O
return	O
;	O
}	O
struct	O
bench_memxor_info	struct(*(void),*(void),*(void))
{	O
void	O
*	O
dst	*(char)
;	O
const	O
void	O
*	O
src	*(char)
;	O
const	O
void	O
*	O
other	*(void)
;	O
}	O
;	O
static	O
void	O
bench_memxor	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
struct	O
bench_memxor_info	struct(*(void),*(void),*(void))
*	O
info	*(struct(*(void),*(void),*(void)))
=	O
arg	*(void)
;	O
memxor	O
(	O
info	*(struct(*(void),*(void),*(void)))
->	O
dst	*(char)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
src	*(char)
,	O
BENCH_BLOCK	int
)	O
;	O
}	O
static	O
void	O
bench_memxor3	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
struct	O
bench_memxor_info	struct(*(void),*(void),*(void))
*	O
info	*(struct(*(void),*(void),*(void)))
=	O
arg	*(void)
;	O
memxor3	O
(	O
info	*(struct(*(void),*(void),*(void)))
->	O
dst	*(char)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
src	*(char)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
other	*(void)
,	O
BENCH_BLOCK	int
)	O
;	O
}	O
struct	O
bench_hash_info	struct(*(void),*((*(void),long,*(char))->(void)),*(char))
{	O
void	O
*	O
ctx	*(void)
;	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
update	*((*(void),long,*(char))->(void))
;	O
const	O
uint8_t	char
*	O
data	*(char)
;	O
}	O
;	O
static	O
void	O
bench_hash	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
struct	O
bench_hash_info	struct(*(void),*((*(void),long,*(char))->(void)),*(char))
*	O
info	*(struct(*(void),*(void),*(void)))
=	O
arg	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
->	O
update	*((*(void),long,*(char))->(void))
(	O
info	*(struct(*(void),*(void),*(void)))
->	O
ctx	*(void)
,	O
BENCH_BLOCK	int
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
data	*(char)
)	O
;	O
}	O
struct	O
bench_cipher_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*(char))
{	O
void	O
*	O
ctx	*(void)
;	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
crypt	*((*(void),long,*(char),*(char))->(void))
;	O
uint8_t	char
*	O
data	*(char)
;	O
}	O
;	O
static	O
void	O
bench_cipher	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
struct	O
bench_cipher_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*(char))
*	O
info	*(struct(*(void),*(void),*(void)))
=	O
arg	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
->	O
crypt	*((*(void),long,*(char),*(char))->(void))
(	O
info	*(struct(*(void),*(void),*(void)))
->	O
ctx	*(void)
,	O
BENCH_BLOCK	int
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
data	*(char)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
data	*(char)
)	O
;	O
}	O
struct	O
bench_cbc_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*(char),*(char),int,*(char))
{	O
void	O
*	O
ctx	*(void)
;	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
crypt	*((*(void),long,*(char),*(char))->(void))
;	O
const	O
uint8_t	char
*	O
src	*(char)
;	O
uint8_t	char
*	O
dst	*(char)
;	O
unsigned	O
block_size	long
;	O
uint8_t	char
*	O
iv	*(char)
;	O
}	O
;	O
static	O
void	O
bench_cbc_encrypt	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
struct	O
bench_cbc_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*(char),*(char),int,*(char))
*	O
info	*(struct(*(void),*(void),*(void)))
=	O
arg	*(void)
;	O
cbc_encrypt	O
(	O
info	*(struct(*(void),*(void),*(void)))
->	O
ctx	*(void)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
crypt	*((*(void),long,*(char),*(char))->(void))
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
block_size	long
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
iv	*(char)
,	O
BENCH_BLOCK	int
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
dst	*(char)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
src	*(char)
)	O
;	O
}	O
static	O
void	O
bench_cbc_decrypt	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
struct	O
bench_cbc_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*(char),*(char),int,*(char))
*	O
info	*(struct(*(void),*(void),*(void)))
=	O
arg	*(void)
;	O
cbc_decrypt	O
(	O
info	*(struct(*(void),*(void),*(void)))
->	O
ctx	*(void)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
crypt	*((*(void),long,*(char),*(char))->(void))
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
block_size	long
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
iv	*(char)
,	O
BENCH_BLOCK	int
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
dst	*(char)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
src	*(char)
)	O
;	O
}	O
static	O
void	O
bench_ctr	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
struct	O
bench_cbc_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*(char),*(char),int,*(char))
*	O
info	*(struct(*(void),*(void),*(void)))
=	O
arg	*(void)
;	O
ctr_crypt	O
(	O
info	*(struct(*(void),*(void),*(void)))
->	O
ctx	*(void)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
crypt	*((*(void),long,*(char),*(char))->(void))
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
block_size	long
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
iv	*(char)
,	O
BENCH_BLOCK	int
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
dst	*(char)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
src	*(char)
)	O
;	O
}	O
struct	O
bench_aead_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)),*(char))
{	O
void	O
*	O
ctx	*(void)
;	O
nettle_crypt_func	(*(void),long,*(char),*(char))->(void)
*	O
crypt	*((*(void),long,*(char),*(char))->(void))
;	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
update	*((*(void),long,*(char))->(void))
;	O
uint8_t	char
*	O
data	*(char)
;	O
}	O
;	O
static	O
void	O
bench_aead_crypt	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
const	O
struct	O
bench_aead_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)),*(char))
*	O
info	*(struct(*(void),*(void),*(void)))
=	O
arg	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
->	O
crypt	*((*(void),long,*(char),*(char))->(void))
(	O
info	*(struct(*(void),*(void),*(void)))
->	O
ctx	*(void)
,	O
BENCH_BLOCK	int
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
data	*(char)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
data	*(char)
)	O
;	O
}	O
static	O
void	O
bench_aead_update	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
const	O
struct	O
bench_aead_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)),*(char))
*	O
info	*(struct(*(void),*(void),*(void)))
=	O
arg	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
->	O
update	*((*(void),long,*(char))->(void))
(	O
info	*(struct(*(void),*(void),*(void)))
->	O
ctx	*(void)
,	O
BENCH_BLOCK	int
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
data	*(char)
)	O
;	O
}	O
static	O
void	O
init_data	(*(char))->(void)
(	O
uint8_t	char
*	O
data	*(char)
)	O
{	O
unsigned	O
i	char
,	O
j	char
;	O
for	O
(	O
i	char
=	O
j	char
=	O
0	int
;	O
i	char
<	O
BENCH_BLOCK	int
;	O
i	char
++	O
)	O
{	O
if	O
(	O
j	char
*	O
j	char
<	O
i	char
)	O
j	char
++	O
;	O
data	*(char)
[	O
i	char
]	O
=	O
j	char
;	O
}	O
}	O
static	O
void	O
init_key	(int,*(char))->(void)
(	O
unsigned	O
length	long
,	O
uint8_t	char
*	O
key	*(char)
)	O
{	O
unsigned	O
i	char
;	O
for	O
(	O
i	char
=	O
0	int
;	O
i	char
<	O
length	long
;	O
i	char
++	O
)	O
key	*(char)
[	O
i	char
]	O
=	O
i	char
;	O
}	O
static	O
void	O
init_nonce	(int,*(char))->(void)
(	O
unsigned	O
length	long
,	O
uint8_t	char
*	O
nonce	*(char)
)	O
{	O
unsigned	O
i	char
;	O
for	O
(	O
i	char
=	O
0	int
;	O
i	char
<	O
length	long
;	O
i	char
++	O
)	O
nonce	*(char)
[	O
i	char
]	O
=	O
3	int
*	O
i	char
;	O
}	O
static	O
void	O
header	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%18s %12s Mbyte/s%s\n"	*(char)
,	O
"Algorithm"	*(char)
,	O
"mode"	*(char)
,	O
frequency	double
>	O
0.0	int
?	O
" cycles/byte cycles/block"	*(char)
:	O
""	*(char)
)	O
;	O
}	O
static	O
void	O
display	(*(char),*(char),int,double)->(void)
(	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
mode	*(char)
,	O
unsigned	O
block_size	long
,	O
double	O
time	(*(long))->(long)
)	O
{	O
printf	(*(char))->(int)
(	O
"%18s %12s %7.2f"	*(char)
,	O
name	*(char)
,	O
mode	*(char)
,	O
BENCH_BLOCK	int
/	O
(	O
time	(*(long))->(long)
*	O
1048576.0	int
)	O
)	O
;	O
if	O
(	O
frequency	double
>	O
0.0	int
)	O
{	O
printf	(*(char))->(int)
(	O
" %11.2f"	*(char)
,	O
time	(*(long))->(long)
*	O
frequency	double
/	O
BENCH_BLOCK	int
)	O
;	O
if	O
(	O
block_size	long
>	O
0	int
)	O
printf	(*(char))->(int)
(	O
" %12.2f"	*(char)
,	O
time	(*(long))->(long)
*	O
frequency	double
*	O
block_size	long
/	O
BENCH_BLOCK	int
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
*	O
xalloc	(long)->(*(void))
(	O
size_t	long
size	long
)	O
{	O
void	O
*	O
p	*(void)
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
die	(*(char))->(void)
(	O
"Virtual memory exhausted.\n"	*(char)
)	O
;	O
return	O
p	*(void)
;	O
}	O
static	O
void	O
time_overhead	()->(void)
(	O
void	O
)	O
{	O
overhead	double
=	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_nothing	(*(void))->(void)
,	O
NULL	O
)	O
;	O
printf	(*(char))->(int)
(	O
"benchmark call overhead: %7f us"	*(char)
,	O
overhead	double
*	O
1e6	int
)	O
;	O
if	O
(	O
frequency	double
>	O
0.0	int
)	O
printf	(*(char))->(int)
(	O
"%7.2f cycles\n"	*(char)
,	O
overhead	double
*	O
frequency	double
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
time_memxor	()->(void)
(	O
void	O
)	O
{	O
struct	O
bench_memxor_info	struct(*(void),*(void),*(void))
info	*(struct(*(void),*(void),*(void)))
;	O
unsigned	O
long	O
src	*(char)
[	O
BENCH_BLOCK	int
/	O
sizeof	O
(	O
long	O
)	O
+	O
2	int
]	O
;	O
unsigned	O
long	O
other	*(void)
[	O
BENCH_BLOCK	int
/	O
sizeof	O
(	O
long	O
)	O
+	O
2	int
]	O
;	O
unsigned	O
long	O
dst	*(char)
[	O
BENCH_BLOCK	int
/	O
sizeof	O
(	O
long	O
)	O
+	O
1	int
]	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
src	*(char)
=	O
src	*(char)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
dst	*(char)
=	O
dst	*(char)
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"memxor"	*(char)
,	O
"aligned"	*(char)
,	O
sizeof	O
(	O
unsigned	O
long	O
)	O
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_memxor	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
src	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
src	*(char)
+	O
1	int
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"memxor"	*(char)
,	O
"unaligned"	*(char)
,	O
sizeof	O
(	O
unsigned	O
long	O
)	O
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_memxor	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
src	*(char)
=	O
src	*(char)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
other	*(void)
=	O
other	*(void)
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"memxor3"	*(char)
,	O
"aligned"	*(char)
,	O
sizeof	O
(	O
unsigned	O
long	O
)	O
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_memxor3	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
other	*(void)
=	O
(	O
const	O
char	O
*	O
)	O
other	*(void)
+	O
1	int
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"memxor3"	*(char)
,	O
"unaligned01"	*(char)
,	O
sizeof	O
(	O
unsigned	O
long	O
)	O
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_memxor3	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
src	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
src	*(char)
+	O
1	int
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"memxor3"	*(char)
,	O
"unaligned11"	*(char)
,	O
sizeof	O
(	O
unsigned	O
long	O
)	O
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_memxor3	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
other	*(void)
=	O
(	O
const	O
char	O
*	O
)	O
other	*(void)
+	O
2	int
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"memxor3"	*(char)
,	O
"unaligned12"	*(char)
,	O
sizeof	O
(	O
unsigned	O
long	O
)	O
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_memxor3	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
static	O
void	O
time_hash	(*(struct(*(char),int,int,int,*((*`)->(void)),*((*`,long,*`)->(void)),*((*`,long,*`)->(void)))))->(void)
(	O
const	O
struct	O
nettle_hash	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
*	O
hash	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
)	O
{	O
static	O
uint8_t	char
data	*(char)
[	O
BENCH_BLOCK	int
]	O
;	O
struct	O
bench_hash_info	struct(*(void),*((*(void),long,*(char))->(void)),*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
xalloc	(long)->(*(void))
(	O
hash	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
context_size	int
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
hash	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
update	*((*(void),long,*(char))->(void))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
init_data	(*(char))->(void)
(	O
data	*(char)
)	O
;	O
hash	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
init	*((*(void))->(void))
(	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
)	O
;	O
display	(*(char),*(char),int,double)->(void)
(	O
hash	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
name	*(char)
,	O
"update"	*(char)
,	O
hash	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
block_size	long
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_hash	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
free	(*(void))->(void)
(	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
)	O
;	O
}	O
static	O
void	O
time_umac	()->(void)
(	O
void	O
)	O
{	O
static	O
uint8_t	char
data	*(char)
[	O
BENCH_BLOCK	int
]	O
;	O
struct	O
bench_hash_info	struct(*(void),*((*(void),long,*(char))->(void)),*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
struct	O
umac32_ctx	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,short,array(int),int,long,array(char))
ctx32	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,short,array(int),int,long,array(char))
;	O
struct	O
umac64_ctx	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,short,array(int),int,long,array(char))
ctx64	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,short,array(int),int,long,array(char))
;	O
struct	O
umac96_ctx	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,int,long,array(char))
ctx96	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,int,long,array(char))
;	O
struct	O
umac128_ctx	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,int,long,array(char))
ctx128	struct(array(int))
;	O
uint8_t	char
key	*(char)
[	O
16	int
]	O
;	O
umac32_set_key	O
(	O
&	O
ctx32	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,short,array(int),int,long,array(char))
,	O
key	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
&	O
ctx32	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,short,array(int),int,long,array(char))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
(	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
)	O
umac32_update	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"umac32"	*(char)
,	O
"update"	*(char)
,	O
UMAC_BLOCK_SIZE	int
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_hash	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
umac64_set_key	O
(	O
&	O
ctx64	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,short,array(int),int,long,array(char))
,	O
key	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
&	O
ctx64	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,short,array(int),int,long,array(char))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
(	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
)	O
umac64_update	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"umac64"	*(char)
,	O
"update"	*(char)
,	O
UMAC_BLOCK_SIZE	int
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_hash	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
umac96_set_key	O
(	O
&	O
ctx96	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,int,long,array(char))
,	O
key	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
&	O
ctx96	struct(array(int),array(int),array(long),array(int),struct(array(int)),array(long),array(char),short,int,long,array(char))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
(	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
)	O
umac96_update	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"umac96"	*(char)
,	O
"update"	*(char)
,	O
UMAC_BLOCK_SIZE	int
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_hash	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
umac128_set_key	O
(	O
&	O
ctx128	struct(array(int))
,	O
key	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
&	O
ctx128	struct(array(int))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
(	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
)	O
umac128_update	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"umac128"	*(char)
,	O
"update"	*(char)
,	O
UMAC_BLOCK_SIZE	int
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_hash	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
static	O
void	O
time_cmac	()->(void)
(	O
void	O
)	O
{	O
static	O
uint8_t	char
data	*(char)
[	O
BENCH_BLOCK	int
]	O
;	O
struct	O
bench_hash_info	struct(*(void),*((*(void),long,*(char))->(void)),*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
struct	O
cmac_aes128_ctx	struct(struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long))),struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),long),struct(array(int)))
ctx	*(void)
;	O
uint8_t	char
key	*(char)
[	O
16	int
]	O
;	O
cmac_aes128_set_key	O
(	O
&	O
ctx	*(void)
,	O
key	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
&	O
ctx	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
(	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
)	O
cmac_aes128_update	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"cmac-aes128"	*(char)
,	O
"update"	*(char)
,	O
AES_BLOCK_SIZE	int
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_hash	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
static	O
void	O
time_poly1305_aes	()->(void)
(	O
void	O
)	O
{	O
static	O
uint8_t	char
data	*(char)
[	O
BENCH_BLOCK	int
]	O
;	O
struct	O
bench_hash_info	struct(*(void),*((*(void),long,*(char))->(void)),*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
struct	O
poly1305_aes_ctx	struct(struct(union(array(int),array(long)),array(int),int,union(array(int),array(long))),array(char),int,array(char),struct(array(int)))
ctx	*(void)
;	O
uint8_t	char
key	*(char)
[	O
32	int
]	O
;	O
poly1305_aes_set_key	O
(	O
&	O
ctx	*(void)
,	O
key	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
&	O
ctx	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
(	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
)	O
poly1305_aes_update	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"poly1305-aes"	*(char)
,	O
"update"	*(char)
,	O
1024	int
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_hash	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
struct	O
bench_hmac_info	struct(*(void),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)),long,long,*(char))
{	O
void	O
*	O
ctx	*(void)
;	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
update	*((*(void),long,*(char))->(void))
;	O
nettle_hash_digest_func	(*(void),long,*(char))->(void)
*	O
digest	*(char)
;	O
size_t	long
length	long
;	O
size_t	long
digest_length	long
;	O
const	O
uint8_t	char
*	O
data	*(char)
;	O
}	O
;	O
static	O
void	O
bench_hmac	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
struct	O
bench_hmac_info	struct(*(void),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)),long,long,*(char))
*	O
info	*(struct(*(void),*(void),*(void)))
=	O
arg	*(void)
;	O
uint8_t	char
digest	*(char)
[	O
NETTLE_MAX_HASH_DIGEST_SIZE	int
]	O
;	O
size_t	long
pos	long
,	O
length	long
;	O
length	long
=	O
info	*(struct(*(void),*(void),*(void)))
->	O
length	long
;	O
for	O
(	O
pos	long
=	O
0	int
;	O
pos	long
<	O
BENCH_BLOCK	int
;	O
pos	long
+=	O
length	long
)	O
{	O
size_t	long
single	long
=	O
pos	long
+	O
length	long
<	O
BENCH_BLOCK	int
?	O
length	long
:	O
BENCH_BLOCK	int
-	O
pos	long
;	O
info	*(struct(*(void),*(void),*(void)))
->	O
update	*((*(void),long,*(char))->(void))
(	O
info	*(struct(*(void),*(void),*(void)))
->	O
ctx	*(void)
,	O
single	long
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
data	*(char)
+	O
pos	long
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
->	O
digest	*(char)
(	O
info	*(struct(*(void),*(void),*(void)))
->	O
ctx	*(void)
,	O
info	*(struct(*(void),*(void),*(void)))
->	O
digest_length	long
,	O
digest	*(char)
)	O
;	O
}	O
}	O
static	O
const	O
struct	O
{	O
size_t	long
length	long
;	O
const	O
char	O
*	O
msg	*(char)
;	O
}	O
hmac_tests	array(struct(long,*(char)))
[	O
]	O
=	O
{	O
{	O
64	int
,	O
"64 bytes"	*(char)
}	O
,	O
{	O
256	int
,	O
"256 bytes"	*(char)
}	O
,	O
{	O
1024	int
,	O
"1024 bytes"	*(char)
}	O
,	O
{	O
4096	int
,	O
"4096 bytes"	*(char)
}	O
,	O
{	O
BENCH_BLOCK	int
,	O
"single msg"	*(char)
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
,	O
}	O
;	O
static	O
void	O
time_hmac_md5	()->(void)
(	O
void	O
)	O
{	O
static	O
uint8_t	char
data	*(char)
[	O
BENCH_BLOCK	int
]	O
;	O
struct	O
bench_hmac_info	struct(*(void),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)),long,long,*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
struct	O
hmac_md5_ctx	struct(struct(array(int),long,int,array(char)),struct(array(int),long,int,array(char)),struct(array(int),long,int,array(char)))
md5_ctx	struct(array(int),long,int,array(char))
;	O
unsigned	O
int	O
pos	long
;	O
init_data	(*(char))->(void)
(	O
data	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
hmac_md5_set_key	O
(	O
&	O
md5_ctx	struct(array(int),long,int,array(char))
,	O
MD5_BLOCK_SIZE	int
,	O
data	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
&	O
md5_ctx	struct(array(int),long,int,array(char))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
(	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
)	O
hmac_md5_update	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
digest	*(char)
=	O
(	O
nettle_hash_digest_func	(*(void),long,*(char))->(void)
*	O
)	O
hmac_md5_digest	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
digest_length	long
=	O
MD5_DIGEST_SIZE	int
;	O
for	O
(	O
pos	long
=	O
0	int
;	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
length	long
!=	O
0	int
;	O
pos	long
++	O
)	O
{	O
info	*(struct(*(void),*(void),*(void)))
.	O
length	long
=	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
length	long
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"hmac-md5"	*(char)
,	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
msg	*(char)
,	O
MD5_BLOCK_SIZE	int
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_hmac	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
}	O
static	O
void	O
time_hmac_sha1	()->(void)
(	O
void	O
)	O
{	O
static	O
uint8_t	char
data	*(char)
[	O
BENCH_BLOCK	int
]	O
;	O
struct	O
bench_hmac_info	struct(*(void),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)),long,long,*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
struct	O
hmac_sha1_ctx	struct(struct(array(int),long,int,array(char)),struct(array(int),long,int,array(char)),struct(array(int),long,int,array(char)))
sha1_ctx	struct(array(int),long,int,array(char))
;	O
unsigned	O
int	O
pos	long
;	O
init_data	(*(char))->(void)
(	O
data	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
hmac_sha1_set_key	O
(	O
&	O
sha1_ctx	struct(array(int),long,int,array(char))
,	O
SHA1_BLOCK_SIZE	int
,	O
data	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
&	O
sha1_ctx	struct(array(int),long,int,array(char))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
(	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
)	O
hmac_sha1_update	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
digest	*(char)
=	O
(	O
nettle_hash_digest_func	(*(void),long,*(char))->(void)
*	O
)	O
hmac_sha1_digest	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
digest_length	long
=	O
SHA1_DIGEST_SIZE	int
;	O
for	O
(	O
pos	long
=	O
0	int
;	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
length	long
!=	O
0	int
;	O
pos	long
++	O
)	O
{	O
info	*(struct(*(void),*(void),*(void)))
.	O
length	long
=	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
length	long
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"hmac-sha1"	*(char)
,	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
msg	*(char)
,	O
SHA1_BLOCK_SIZE	int
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_hmac	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
}	O
static	O
void	O
time_hmac_sha256	()->(void)
(	O
void	O
)	O
{	O
static	O
uint8_t	char
data	*(char)
[	O
BENCH_BLOCK	int
]	O
;	O
struct	O
bench_hmac_info	struct(*(void),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)),long,long,*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
struct	O
hmac_sha256_ctx	struct(struct(array(int),long,int,array(char)),struct(array(int),long,int,array(char)),struct(array(int),long,int,array(char)))
sha256_ctx	struct(array(int),long,int,array(char))
;	O
unsigned	O
int	O
pos	long
;	O
init_data	(*(char))->(void)
(	O
data	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
hmac_sha256_set_key	O
(	O
&	O
sha256_ctx	struct(array(int),long,int,array(char))
,	O
SHA256_BLOCK_SIZE	int
,	O
data	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
&	O
sha256_ctx	struct(array(int),long,int,array(char))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
(	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
)	O
hmac_sha256_update	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
digest	*(char)
=	O
(	O
nettle_hash_digest_func	(*(void),long,*(char))->(void)
*	O
)	O
hmac_sha256_digest	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
digest_length	long
=	O
SHA256_DIGEST_SIZE	int
;	O
for	O
(	O
pos	long
=	O
0	int
;	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
length	long
!=	O
0	int
;	O
pos	long
++	O
)	O
{	O
info	*(struct(*(void),*(void),*(void)))
.	O
length	long
=	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
length	long
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"hmac-sha256"	*(char)
,	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
msg	*(char)
,	O
SHA256_BLOCK_SIZE	int
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_hmac	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
}	O
static	O
void	O
time_hmac_sha512	()->(void)
(	O
void	O
)	O
{	O
static	O
uint8_t	char
data	*(char)
[	O
BENCH_BLOCK	int
]	O
;	O
struct	O
bench_hmac_info	struct(*(void),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)),long,long,*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
struct	O
hmac_sha512_ctx	struct(struct(array(long),long,long,int,array(char)),struct(array(long),long,long,int,array(char)),struct(array(long),long,long,int,array(char)))
sha512_ctx	struct(array(long),long,long,int,array(char))
;	O
unsigned	O
int	O
pos	long
;	O
init_data	(*(char))->(void)
(	O
data	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
hmac_sha512_set_key	O
(	O
&	O
sha512_ctx	struct(array(long),long,long,int,array(char))
,	O
SHA512_BLOCK_SIZE	int
,	O
data	*(char)
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
&	O
sha512_ctx	struct(array(long),long,long,int,array(char))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
(	O
nettle_hash_update_func	(*(void),long,*(char))->(void)
*	O
)	O
hmac_sha512_update	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
digest	*(char)
=	O
(	O
nettle_hash_digest_func	(*(void),long,*(char))->(void)
*	O
)	O
hmac_sha512_digest	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
digest_length	long
=	O
SHA512_DIGEST_SIZE	int
;	O
for	O
(	O
pos	long
=	O
0	int
;	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
length	long
!=	O
0	int
;	O
pos	long
++	O
)	O
{	O
info	*(struct(*(void),*(void),*(void)))
.	O
length	long
=	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
length	long
;	O
display	(*(char),*(char),int,double)->(void)
(	O
"hmac-sha512"	*(char)
,	O
hmac_tests	array(struct(long,*(char)))
[	O
pos	long
]	O
.	O
msg	*(char)
,	O
SHA512_BLOCK_SIZE	int
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_hmac	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
}	O
static	O
int	O
prefix_p	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
prefix	*(char)
,	O
const	O
char	O
*	O
s	array(array(int))
)	O
{	O
size_t	long
i	char
;	O
for	O
(	O
i	char
=	O
0	int
;	O
prefix	*(char)
[	O
i	char
]	O
;	O
i	char
++	O
)	O
if	O
(	O
prefix	*(char)
[	O
i	char
]	O
!=	O
s	array(array(int))
[	O
i	char
]	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
block_cipher_p	(*(struct(*(char),int,int,int,*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,long,*`,*`)->(void)),*((*`,long,*`,*`)->(void)))))->(int)
(	O
const	O
struct	O
nettle_cipher	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
*	O
cipher	*(void)
)	O
{	O
return	O
cipher	*(void)
->	O
block_size	long
>	O
0	int
&&	O
!	O
prefix_p	(*(char),*(char))->(int)
(	O
"openssl"	*(char)
,	O
cipher	*(void)
->	O
name	*(char)
)	O
;	O
}	O
static	O
void	O
time_cipher	(*(struct(*(char),int,int,int,*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,long,*`,*`)->(void)),*((*`,long,*`,*`)->(void)))))->(void)
(	O
const	O
struct	O
nettle_cipher	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
*	O
cipher	*(void)
)	O
{	O
void	O
*	O
ctx	*(void)
=	O
xalloc	(long)->(*(void))
(	O
cipher	*(void)
->	O
context_size	int
)	O
;	O
uint8_t	char
*	O
key	*(char)
=	O
xalloc	(long)->(*(void))
(	O
cipher	*(void)
->	O
key_size	int
)	O
;	O
static	O
uint8_t	char
src_data	array(char)
[	O
BENCH_BLOCK	int
]	O
;	O
static	O
uint8_t	char
data	*(char)
[	O
BENCH_BLOCK	int
]	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
init_data	(*(char))->(void)
(	O
data	*(char)
)	O
;	O
init_data	(*(char))->(void)
(	O
src_data	array(char)
)	O
;	O
{	O
struct	O
bench_cipher_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
ctx	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
crypt	*((*(void),long,*(char),*(char))->(void))
=	O
cipher	*(void)
->	O
encrypt	*((*(void),long,*(char),*(char))->(void))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
init_key	(int,*(char))->(void)
(	O
cipher	*(void)
->	O
key_size	int
,	O
key	*(char)
)	O
;	O
cipher	*(void)
->	O
set_encrypt_key	*((*(void),*(char))->(void))
(	O
ctx	*(void)
,	O
key	*(char)
)	O
;	O
display	(*(char),*(char),int,double)->(void)
(	O
cipher	*(void)
->	O
name	*(char)
,	O
"ECB encrypt"	*(char)
,	O
cipher	*(void)
->	O
block_size	long
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_cipher	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
{	O
struct	O
bench_cipher_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
ctx	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
crypt	*((*(void),long,*(char),*(char))->(void))
=	O
cipher	*(void)
->	O
decrypt	*((*(void),long,*(char),*(char))->(void))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
init_key	(int,*(char))->(void)
(	O
cipher	*(void)
->	O
key_size	int
,	O
key	*(char)
)	O
;	O
cipher	*(void)
->	O
set_decrypt_key	*((*(void),*(char))->(void))
(	O
ctx	*(void)
,	O
key	*(char)
)	O
;	O
display	(*(char),*(char),int,double)->(void)
(	O
cipher	*(void)
->	O
name	*(char)
,	O
"ECB decrypt"	*(char)
,	O
cipher	*(void)
->	O
block_size	long
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_cipher	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
if	O
(	O
block_cipher_p	(*(struct(*(char),int,int,int,*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,long,*`,*`)->(void)),*((*`,long,*`,*`)->(void)))))->(int)
(	O
cipher	*(void)
)	O
)	O
{	O
uint8_t	char
*	O
iv	*(char)
=	O
xalloc	(long)->(*(void))
(	O
cipher	*(void)
->	O
block_size	long
)	O
;	O
{	O
struct	O
bench_cbc_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*(char),*(char),int,*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
ctx	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
crypt	*((*(void),long,*(char),*(char))->(void))
=	O
cipher	*(void)
->	O
encrypt	*((*(void),long,*(char),*(char))->(void))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
src	*(char)
=	O
src_data	array(char)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
dst	*(char)
=	O
data	*(char)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
block_size	long
=	O
cipher	*(void)
->	O
block_size	long
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
iv	*(char)
=	O
iv	*(char)
;	O
memset	(*(void),int,long)->(*(void))
(	O
iv	*(char)
,	O
0	int
,	O
cipher	*(void)
->	O
block_size	long
)	O
;	O
cipher	*(void)
->	O
set_encrypt_key	*((*(void),*(char))->(void))
(	O
ctx	*(void)
,	O
key	*(char)
)	O
;	O
display	(*(char),*(char),int,double)->(void)
(	O
cipher	*(void)
->	O
name	*(char)
,	O
"CBC encrypt"	*(char)
,	O
cipher	*(void)
->	O
block_size	long
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_cbc_encrypt	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
{	O
struct	O
bench_cbc_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*(char),*(char),int,*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
ctx	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
crypt	*((*(void),long,*(char),*(char))->(void))
=	O
cipher	*(void)
->	O
decrypt	*((*(void),long,*(char),*(char))->(void))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
src	*(char)
=	O
src_data	array(char)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
dst	*(char)
=	O
data	*(char)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
block_size	long
=	O
cipher	*(void)
->	O
block_size	long
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
iv	*(char)
=	O
iv	*(char)
;	O
memset	(*(void),int,long)->(*(void))
(	O
iv	*(char)
,	O
0	int
,	O
cipher	*(void)
->	O
block_size	long
)	O
;	O
cipher	*(void)
->	O
set_decrypt_key	*((*(void),*(char))->(void))
(	O
ctx	*(void)
,	O
key	*(char)
)	O
;	O
display	(*(char),*(char),int,double)->(void)
(	O
cipher	*(void)
->	O
name	*(char)
,	O
"CBC decrypt"	*(char)
,	O
cipher	*(void)
->	O
block_size	long
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_cbc_decrypt	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
iv	*(char)
,	O
0	int
,	O
cipher	*(void)
->	O
block_size	long
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
src	*(char)
=	O
data	*(char)
;	O
display	(*(char),*(char),int,double)->(void)
(	O
cipher	*(void)
->	O
name	*(char)
,	O
"  (in-place)"	*(char)
,	O
cipher	*(void)
->	O
block_size	long
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_cbc_decrypt	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
{	O
struct	O
bench_cbc_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*(char),*(char),int,*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
ctx	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
crypt	*((*(void),long,*(char),*(char))->(void))
=	O
cipher	*(void)
->	O
encrypt	*((*(void),long,*(char),*(char))->(void))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
src	*(char)
=	O
src_data	array(char)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
dst	*(char)
=	O
data	*(char)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
block_size	long
=	O
cipher	*(void)
->	O
block_size	long
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
iv	*(char)
=	O
iv	*(char)
;	O
memset	(*(void),int,long)->(*(void))
(	O
iv	*(char)
,	O
0	int
,	O
cipher	*(void)
->	O
block_size	long
)	O
;	O
cipher	*(void)
->	O
set_encrypt_key	*((*(void),*(char))->(void))
(	O
ctx	*(void)
,	O
key	*(char)
)	O
;	O
display	(*(char),*(char),int,double)->(void)
(	O
cipher	*(void)
->	O
name	*(char)
,	O
"CTR"	*(char)
,	O
cipher	*(void)
->	O
block_size	long
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_ctr	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
iv	*(char)
,	O
0	int
,	O
cipher	*(void)
->	O
block_size	long
)	O
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
src	*(char)
=	O
data	*(char)
;	O
display	(*(char),*(char),int,double)->(void)
(	O
cipher	*(void)
->	O
name	*(char)
,	O
"  (in-place)"	*(char)
,	O
cipher	*(void)
->	O
block_size	long
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_ctr	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
iv	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
ctx	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
key	*(char)
)	O
;	O
}	O
static	O
void	O
time_aead	(*(struct(*(char),int,int,int,int,int,*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,long,*`)->(void)),*((*`,long,*`,*`)->(void)),*((*`,long,*`,*`)->(void)),*((*`,long,*`)->(void)))))->(void)
(	O
const	O
struct	O
nettle_aead	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
*	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
)	O
{	O
void	O
*	O
ctx	*(void)
=	O
xalloc	(long)->(*(void))
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
context_size	int
)	O
;	O
uint8_t	char
*	O
key	*(char)
=	O
xalloc	(long)->(*(void))
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
key_size	int
)	O
;	O
uint8_t	char
*	O
nonce	*(char)
=	O
xalloc	(long)->(*(void))
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
nonce_size	int
)	O
;	O
static	O
uint8_t	char
data	*(char)
[	O
BENCH_BLOCK	int
]	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
init_data	(*(char))->(void)
(	O
data	*(char)
)	O
;	O
if	O
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
set_nonce	*((*(void),*(char))->(void))
)	O
init_nonce	(int,*(char))->(void)
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
nonce_size	int
,	O
nonce	*(char)
)	O
;	O
{	O
struct	O
bench_aead_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)),*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
ctx	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
crypt	*((*(void),long,*(char),*(char))->(void))
=	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
encrypt	*((*(void),long,*(char),*(char))->(void))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
init_key	(int,*(char))->(void)
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
key_size	int
,	O
key	*(char)
)	O
;	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
set_encrypt_key	*((*(void),*(char))->(void))
(	O
ctx	*(void)
,	O
key	*(char)
)	O
;	O
if	O
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
set_nonce	*((*(void),*(char))->(void))
)	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
set_nonce	*((*(void),*(char))->(void))
(	O
ctx	*(void)
,	O
nonce	*(char)
)	O
;	O
display	(*(char),*(char),int,double)->(void)
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
name	*(char)
,	O
"encrypt"	*(char)
,	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
block_size	long
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_aead_crypt	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
{	O
struct	O
bench_aead_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)),*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
ctx	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
crypt	*((*(void),long,*(char),*(char))->(void))
=	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
decrypt	*((*(void),long,*(char),*(char))->(void))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
init_key	(int,*(char))->(void)
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
key_size	int
,	O
key	*(char)
)	O
;	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
set_decrypt_key	*((*(void),*(char))->(void))
(	O
ctx	*(void)
,	O
key	*(char)
)	O
;	O
if	O
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
set_nonce	*((*(void),*(char))->(void))
)	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
set_nonce	*((*(void),*(char))->(void))
(	O
ctx	*(void)
,	O
nonce	*(char)
)	O
;	O
display	(*(char),*(char),int,double)->(void)
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
name	*(char)
,	O
"decrypt"	*(char)
,	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
block_size	long
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_aead_crypt	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
if	O
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
update	*((*(void),long,*(char))->(void))
)	O
{	O
struct	O
bench_aead_info	struct(*(void),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)),*(char))
info	*(struct(*(void),*(void),*(void)))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
ctx	*(void)
=	O
ctx	*(void)
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
update	*((*(void),long,*(char))->(void))
=	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
update	*((*(void),long,*(char))->(void))
;	O
info	*(struct(*(void),*(void),*(void)))
.	O
data	*(char)
=	O
data	*(char)
;	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
set_encrypt_key	*((*(void),*(char))->(void))
(	O
ctx	*(void)
,	O
key	*(char)
)	O
;	O
if	O
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
set_nonce	*((*(void),*(char))->(void))
)	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
set_nonce	*((*(void),*(char))->(void))
(	O
ctx	*(void)
,	O
nonce	*(char)
)	O
;	O
display	(*(char),*(char),int,double)->(void)
(	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
name	*(char)
,	O
"update"	*(char)
,	O
aead	*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
block_size	long
,	O
time_function	(*((*(void))->(void)),*(void))->(double)
(	O
bench_aead_update	(*(void))->(void)
,	O
&	O
info	*(struct(*(void),*(void),*(void)))
)	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
ctx	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
key	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
nonce	*(char)
)	O
;	O
}	O
static	O
int	O
compare_double	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
ap	*(void)
,	O
const	O
void	O
*	O
bp	*(void)
)	O
{	O
double	O
a	*(void)
=	O
*	O
(	O
const	O
double	O
*	O
)	O
ap	*(void)
;	O
double	O
b	array(char)
=	O
*	O
(	O
const	O
double	O
*	O
)	O
bp	*(void)
;	O
if	O
(	O
a	*(void)
<	O
b	array(char)
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
a	*(void)
>	O
b	array(char)
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
static	O
void	O
bench_sha1_compress	()->(void)
(	O
void	O
)	O
{	O
uint32_t	int
state	*(int)
[	O
_SHA1_DIGEST_LENGTH	int
]	O
;	O
uint8_t	char
data	*(char)
[	O
SHA1_BLOCK_SIZE	int
]	O
;	O
double	O
t	double
;	O
TIME_CYCLES	O
(	O
t	double
,	O
nettle_sha1_compress	(*(int),*(char))->(void)
(	O
state	*(int)
,	O
data	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"sha1_compress: %.2f cycles\n"	*(char)
,	O
t	double
)	O
;	O
}	O
static	O
void	O
bench_salsa20_core	()->(void)
(	O
void	O
)	O
{	O
uint32_t	int
state	*(int)
[	O
_SALSA20_INPUT_LENGTH	int
]	O
;	O
double	O
t	double
;	O
TIME_CYCLES	O
(	O
t	double
,	O
_nettle_salsa20_core	(*(int),*(int),int)->(void)
(	O
state	*(int)
,	O
state	*(int)
,	O
20	int
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"salsa20_core: %.2f cycles\n"	*(char)
,	O
t	double
)	O
;	O
}	O
static	O
void	O
bench_sha3_permute	()->(void)
(	O
void	O
)	O
{	O
struct	O
sha3_state	struct(array(long))
state	*(int)
;	O
double	O
t	double
;	O
TIME_CYCLES	O
(	O
t	double
,	O
sha3_permute	O
(	O
&	O
state	*(int)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"sha3_permute: %.2f cycles (%.2f / round)\n"	*(char)
,	O
t	double
,	O
t	double
/	O
24.0	int
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
unsigned	O
i	char
;	O
int	O
c	int
;	O
const	O
char	O
*	O
alg	*(char)
;	O
const	O
struct	O
nettle_hash	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
*	O
hashes	array(*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))))
[	O
]	O
=	O
{	O
&	O
nettle_md2	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_md4	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_md5	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
OPENSSL	O
(	O
&	O
nettle_openssl_md5	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
)	O
&	O
nettle_sha1	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
OPENSSL	O
(	O
&	O
nettle_openssl_sha1	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
)	O
&	O
nettle_sha224	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_sha256	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_sha384	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_sha512	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_sha512_224	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_sha512_256	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_sha3_224	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_sha3_256	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_sha3_384	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_sha3_512	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_ripemd160	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_gosthash94	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
NULL	O
}	O
;	O
const	O
struct	O
nettle_cipher	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
*	O
ciphers	array(*(struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))))
[	O
]	O
=	O
{	O
&	O
nettle_aes128	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
&	O
nettle_aes192	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
&	O
nettle_aes256	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
OPENSSL	O
(	O
&	O
nettle_openssl_aes128	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
)	O
OPENSSL	O
(	O
&	O
nettle_openssl_aes192	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
)	O
OPENSSL	O
(	O
&	O
nettle_openssl_aes256	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
)	O
&	O
nettle_blowfish128	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
OPENSSL	O
(	O
&	O
nettle_openssl_blowfish128	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
)	O
&	O
nettle_camellia128	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
&	O
nettle_camellia192	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
&	O
nettle_camellia256	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
&	O
nettle_cast128	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
OPENSSL	O
(	O
&	O
nettle_openssl_cast128	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
)	O
&	O
nettle_des	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
OPENSSL	O
(	O
&	O
nettle_openssl_des	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
)	O
&	O
nettle_des3	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
&	O
nettle_serpent256	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
&	O
nettle_twofish128	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
&	O
nettle_twofish192	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
&	O
nettle_twofish256	struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))
,	O
NULL	O
}	O
;	O
const	O
struct	O
nettle_aead	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
*	O
aeads	array(*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))))
[	O
]	O
=	O
{	O
&	O
nettle_arcfour128	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
OPENSSL	O
(	O
&	O
nettle_openssl_arcfour128	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
)	O
&	O
nettle_salsa20	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_salsa20r12	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_chacha	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_gcm_aes128	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_gcm_aes192	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_gcm_aes256	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
OPENSSL	O
(	O
&	O
nettle_openssl_gcm_aes128	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
)	O
OPENSSL	O
(	O
&	O
nettle_openssl_gcm_aes192	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
)	O
OPENSSL	O
(	O
&	O
nettle_openssl_gcm_aes256	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
)	O
&	O
nettle_gcm_camellia128	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_gcm_camellia256	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_eax_aes128	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
&	O
nettle_chacha_poly1305	struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))
,	O
NULL	O
}	O
;	O
enum	O
{	O
OPT_HELP	int
=	O
300	int
}	O
;	O
static	O
const	O
struct	O
option	struct(*(char),int,*(int),int)
options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
OPT_HELP	int
}	O
,	O
{	O
"clock-frequency"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'f'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"f:"	*(char)
,	O
options	array(struct(*(char),int,*(int),int))
,	O
NULL	O
)	O
)	O
!=	O
-	O
1	int
)	O
switch	O
(	O
c	int
)	O
{	O
case	O
'f'	O
:	O
frequency	double
=	O
atof	(*(char))->(double)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
frequency	double
>	O
0.0	int
)	O
break	O
;	O
case	O
OPT_HELP	int
:	O
printf	(*(char))->(int)
(	O
"Usage: nettle-benchmark [-f clock frequency] [alg...]\n"	*(char)
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
case	O
'?'	O
:	O
return	O
EXIT_FAILURE	int
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
time_init	()->(void)
(	O
)	O
;	O
bench_sha1_compress	()->(void)
(	O
)	O
;	O
bench_salsa20_core	()->(void)
(	O
)	O
;	O
bench_sha3_permute	()->(void)
(	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
time_overhead	()->(void)
(	O
)	O
;	O
header	()->(void)
(	O
)	O
;	O
do	O
{	O
alg	*(char)
=	O
argv	*(*(char))
[	O
optind	int
]	O
;	O
if	O
(	O
!	O
alg	*(char)
||	O
strstr	(*(char),*(char))->(*(char))
(	O
"memxor"	*(char)
,	O
alg	*(char)
)	O
)	O
{	O
time_memxor	()->(void)
(	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
for	O
(	O
i	char
=	O
0	int
;	O
hashes	array(*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))))
[	O
i	char
]	O
;	O
i	char
++	O
)	O
if	O
(	O
!	O
alg	*(char)
||	O
strstr	(*(char),*(char))->(*(char))
(	O
hashes	array(*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))))
[	O
i	char
]	O
->	O
name	*(char)
,	O
alg	*(char)
)	O
)	O
time_hash	(*(struct(*(char),int,int,int,*((*`)->(void)),*((*`,long,*`)->(void)),*((*`,long,*`)->(void)))))->(void)
(	O
hashes	array(*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))))
[	O
i	char
]	O
)	O
;	O
if	O
(	O
!	O
alg	*(char)
||	O
strstr	(*(char),*(char))->(*(char))
(	O
"umac"	*(char)
,	O
alg	*(char)
)	O
)	O
time_umac	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
alg	*(char)
||	O
strstr	(*(char),*(char))->(*(char))
(	O
"cmac"	*(char)
,	O
alg	*(char)
)	O
)	O
time_cmac	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
alg	*(char)
||	O
strstr	(*(char),*(char))->(*(char))
(	O
"poly1305-aes"	*(char)
,	O
alg	*(char)
)	O
)	O
time_poly1305_aes	()->(void)
(	O
)	O
;	O
for	O
(	O
i	char
=	O
0	int
;	O
ciphers	array(*(struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))))
[	O
i	char
]	O
;	O
i	char
++	O
)	O
if	O
(	O
!	O
alg	*(char)
||	O
strstr	(*(char),*(char))->(*(char))
(	O
ciphers	array(*(struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))))
[	O
i	char
]	O
->	O
name	*(char)
,	O
alg	*(char)
)	O
)	O
time_cipher	(*(struct(*(char),int,int,int,*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,long,*`,*`)->(void)),*((*`,long,*`,*`)->(void)))))->(void)
(	O
ciphers	array(*(struct(*(char),int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)))))
[	O
i	char
]	O
)	O
;	O
for	O
(	O
i	char
=	O
0	int
;	O
aeads	array(*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))))
[	O
i	char
]	O
;	O
i	char
++	O
)	O
if	O
(	O
!	O
alg	*(char)
||	O
strstr	(*(char),*(char))->(*(char))
(	O
aeads	array(*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))))
[	O
i	char
]	O
->	O
name	*(char)
,	O
alg	*(char)
)	O
)	O
time_aead	(*(struct(*(char),int,int,int,int,int,*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,long,*`)->(void)),*((*`,long,*`,*`)->(void)),*((*`,long,*`,*`)->(void)),*((*`,long,*`)->(void)))))->(void)
(	O
aeads	array(*(struct(*(char),int,int,int,int,int,*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),*(char))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char),*(char))->(void)),*((*(void),long,*(char))->(void)))))
[	O
i	char
]	O
)	O
;	O
if	O
(	O
!	O
alg	*(char)
||	O
strstr	(*(char),*(char))->(*(char))
(	O
"hmac-md5"	*(char)
,	O
alg	*(char)
)	O
)	O
time_hmac_md5	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
alg	*(char)
||	O
strstr	(*(char),*(char))->(*(char))
(	O
"hmac-sha1"	*(char)
,	O
alg	*(char)
)	O
)	O
time_hmac_sha1	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
alg	*(char)
||	O
strstr	(*(char),*(char))->(*(char))
(	O
"hmac-sha256"	*(char)
,	O
alg	*(char)
)	O
)	O
time_hmac_sha256	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
alg	*(char)
||	O
strstr	(*(char),*(char))->(*(char))
(	O
"hmac-sha512"	*(char)
,	O
alg	*(char)
)	O
)	O
time_hmac_sha512	()->(void)
(	O
)	O
;	O
optind	int
++	O
;	O
}	O
while	O
(	O
alg	*(char)
&&	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
