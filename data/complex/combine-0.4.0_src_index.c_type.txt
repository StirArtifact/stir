int	O
initialize_index	(long long,long long,long long,*(char),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
filename	*(char)
,	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
INDEXNUM	O
entries	long long
;	O
INDEXNUM	O
number_size	long long
;	O
INDEXNUM	O
hash_method	long
;	O
char	O
*	O
filename	*(char)
;	O
FILE	struct
*	O
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
{	O
comb_index_hdr	struct(long,long,long,long)
index_hdr	struct(long,long,long,long)
;	O
comb_index_hdr_ll	struct(long long,array(long long))
index_hdr_more	struct(long long,array(long long))
;	O
comb_hash_entry_ll	struct(long long,long long,long long,long long,long long,long long)
index_entry	struct(long long,long long,long long,long long,long long,long long)
;	O
long	O
long	O
int	O
i	long long
;	O
int	O
return_val	int
;	O
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
==	O
NULL	O
)	O
FATAL_PERROR	O
(	O
filename	*(char)
)	O
;	O
index_hdr	struct(long,long,long,long)
.	O
magic_number	long
=	O
'DpV!'	O
;	O
index_hdr	struct(long,long,long,long)
.	O
version	long
=	O
1	int
;	O
index_hdr	struct(long,long,long,long)
.	O
hash_method	long
=	O
hash_method	long
;	O
index_hdr	struct(long,long,long,long)
.	O
hash_number_size	long
=	O
number_size	long long
;	O
return_val	int
=	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
index_hdr	struct(long,long,long,long)
,	O
sizeof	O
(	O
index_hdr	struct(long,long,long,long)
)	O
,	O
1	int
,	O
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error writing to index file"	*(char)
)	O
)	O
;	O
index_hdr_more	struct(long long,array(long long))
.	O
hash_size	long long
=	O
entries	long long
;	O
return_val	int
=	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
index_hdr_more	struct(long long,array(long long))
,	O
sizeof	O
(	O
index_hdr_more	struct(long long,array(long long))
)	O
,	O
1	int
,	O
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error writing to index file"	*(char)
)	O
)	O
;	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
file_position	long long
=	O
0	int
;	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
record_length	long long
=	O
0	int
;	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
key_position	long long
=	O
0	int
;	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
key_length	long long
=	O
0	int
;	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
next_same_key	long long
=	O
0	int
;	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
prev_same_key	long long
=	O
0	int
;	O
for	O
(	O
i	long long
=	O
0	int
;	O
i	long long
<	O
entries	long long
;	O
i	long long
++	O
)	O
{	O
return_val	int
=	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
,	O
sizeof	O
(	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
)	O
,	O
1	int
,	O
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error writing to index file"	*(char)
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
open_index	(*(long long),*(long long),*(long long),*(char),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
filename	*(char)
,	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
INDEXNUM	O
*	O
entries	long long
;	O
INDEXNUM	O
*	O
number_size	long long
;	O
INDEXNUM	O
*	O
hash_method	long
;	O
char	O
*	O
filename	*(char)
;	O
FILE	struct
*	O
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
{	O
int	O
return_val	int
;	O
comb_index_hdr	struct(long,long,long,long)
index_hdr	struct(long,long,long,long)
;	O
comb_index_hdr_ll	struct(long long,array(long long))
index_hdr_more	struct(long long,array(long long))
;	O
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
==	O
NULL	O
)	O
FATAL_PERROR	O
(	O
filename	*(char)
)	O
;	O
return_val	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
index_hdr	struct(long,long,long,long)
,	O
sizeof	O
(	O
index_hdr	struct(long,long,long,long)
)	O
,	O
1	int
,	O
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error reading index file"	*(char)
)	O
)	O
;	O
if	O
(	O
index_hdr	struct(long,long,long,long)
.	O
magic_number	long
!=	O
'DpV!'	O
||	O
index_hdr	struct(long,long,long,long)
.	O
version	long
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"invalid index file or unsupported version"	*(char)
)	O
)	O
;	O
*	O
hash_method	long
=	O
index_hdr	struct(long,long,long,long)
.	O
hash_method	long
;	O
*	O
number_size	long long
=	O
index_hdr	struct(long,long,long,long)
.	O
hash_number_size	long
;	O
if	O
(	O
*	O
number_size	long long
!=	O
8	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"only long long numbers are supported now"	*(char)
)	O
)	O
;	O
return_val	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
index_hdr_more	struct(long long,array(long long))
,	O
sizeof	O
(	O
index_hdr_more	struct(long long,array(long long))
)	O
,	O
1	int
,	O
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error reading index file"	*(char)
)	O
)	O
;	O
*	O
entries	long long
=	O
index_hdr_more	struct(long long,array(long long))
.	O
hash_size	long long
;	O
return	O
0	int
;	O
}	O
INDEXNUM	O
find_index_key	(long long,long long,long long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(long,enum(int,int,int),*(char))),*(long long),*(long long),*(long long))->(long long)
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
key	*(struct(long,enum(int,int,int),*(char)))
,	O
next	*(long long)
,	O
position	*(long long)
,	O
length	long
)	O
INDEXNUM	O
entries	long long
;	O
INDEXNUM	O
number_size	long long
;	O
INDEXNUM	O
hash_method	long
;	O
FILE	struct
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
STRINGTYPE	O
*	O
key	*(struct(long,enum(int,int,int),*(char)))
;	O
INDEXNUM	O
*	O
next	*(long long)
;	O
INDEXNUM	O
*	O
position	*(long long)
;	O
INDEXNUM	O
*	O
length	long
;	O
{	O
HASHTYPE	O
hash_key	long
;	O
INDEXNUM	O
start_pos	long long
;	O
INDEXNUM	O
curr_pos	long long
;	O
comb_hash_entry_ll	struct(long long,long long,long long,long long,long long,long long)
index_entry	struct(long long,long long,long long,long long,long long,long long)
;	O
int	O
return_val	int
;	O
if	O
(	O
*	O
next	*(long long)
==	O
-	O
1	int
)	O
{	O
INDEXNUM	O
orig_pos	long long
;	O
start_pos	long long
=	O
-	O
1	int
;	O
hash_key	long
=	O
calc_hash_key	()->(int)
(	O
key	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
curr_pos	long long
=	O
hash_key	long
%	O
entries	long long
;	O
orig_pos	long long
=	O
curr_pos	long long
;	O
do	O
{	O
char	O
*	O
test_key	*(char)
;	O
return_val	int
=	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
sizeof	O
(	O
comb_index_hdr	struct(long,long,long,long)
)	O
+	O
sizeof	O
(	O
comb_index_hdr_ll	struct(long long,array(long long))
)	O
+	O
curr_pos	long long
*	O
sizeof	O
(	O
comb_hash_entry_ll	struct(long long,long long,long long,long long,long long,long long)
)	O
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
return_val	int
!=	O
0	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to reposition within index"	*(char)
)	O
)	O
;	O
return_val	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
,	O
sizeof	O
(	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
)	O
,	O
1	int
,	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error reading index file"	*(char)
)	O
)	O
;	O
test_key	*(char)
=	O
malloc	(long)->(*(void))
(	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
key_length	long long
)	O
;	O
if	O
(	O
test_key	*(char)
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
return_val	int
=	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
sizeof	O
(	O
comb_index_hdr	struct(long,long,long,long)
)	O
+	O
sizeof	O
(	O
comb_index_hdr_ll	struct(long long,array(long long))
)	O
+	O
entries	long long
*	O
sizeof	O
(	O
comb_hash_entry_ll	struct(long long,long long,long long,long long,long long,long long)
)	O
+	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
key_position	long long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
return_val	int
!=	O
0	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to reposition within index"	*(char)
)	O
)	O
;	O
return_val	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
test_key	*(char)
,	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
key_length	long long
,	O
1	int
,	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error reading index file"	*(char)
)	O
)	O
;	O
if	O
(	O
key	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
==	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
key_length	long long
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
key	*(struct(long,enum(int,int,int),*(char)))
->	O
string	*(char)
,	O
test_key	*(char)
,	O
key	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
)	O
==	O
0	int
)	O
{	O
start_pos	long long
=	O
curr_pos	long long
;	O
orig_pos	long long
=	O
curr_pos	long long
;	O
}	O
else	O
curr_pos	long long
=	O
(	O
curr_pos	long long
+	O
1	int
)	O
%	O
entries	long long
;	O
free	(*(void))->(void)
(	O
test_key	*(char)
)	O
;	O
}	O
while	O
(	O
curr_pos	long long
!=	O
orig_pos	long long
)	O
;	O
}	O
else	O
{	O
start_pos	long long
=	O
*	O
next	*(long long)
;	O
return_val	int
=	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
sizeof	O
(	O
comb_index_hdr	struct(long,long,long,long)
)	O
+	O
sizeof	O
(	O
comb_index_hdr_ll	struct(long long,array(long long))
)	O
+	O
start_pos	long long
*	O
sizeof	O
(	O
comb_hash_entry_ll	struct(long long,long long,long long,long long,long long,long long)
)	O
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
return_val	int
!=	O
0	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to reposition within index"	*(char)
)	O
)	O
;	O
return_val	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
,	O
sizeof	O
(	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
)	O
,	O
1	int
,	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error reading index file"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
start_pos	long long
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
next	*(long long)
!=	O
NULL	O
)	O
*	O
next	*(long long)
=	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
next_same_key	long long
;	O
if	O
(	O
position	*(long long)
!=	O
NULL	O
)	O
*	O
position	*(long long)
=	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
file_position	long long
;	O
if	O
(	O
length	long
!=	O
NULL	O
)	O
*	O
length	long
=	O
index_entry	struct(long long,long long,long long,long long,long long,long long)
.	O
record_length	long long
;	O
return	O
0	int
;	O
}	O
INDEXNUM	O
insert_index_where_open	(long long,long long,long long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(long,enum(int,int,int),*(char))),long long,long long,long long)->(long long)
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
key	*(struct(long,enum(int,int,int),*(char)))
,	O
position	*(long long)
,	O
length	long
,	O
hash_key	long
)	O
INDEXNUM	O
entries	long long
;	O
INDEXNUM	O
number_size	long long
;	O
INDEXNUM	O
hash_method	long
;	O
FILE	struct
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
STRINGTYPE	O
*	O
key	*(struct(long,enum(int,int,int),*(char)))
;	O
INDEXNUM	O
position	*(long long)
;	O
INDEXNUM	O
length	long
;	O
INDEXNUM	O
hash_key	long
;	O
{	O
INDEXNUM	O
start_pos	long long
;	O
INDEXNUM	O
curr_pos	long long
;	O
start_pos	long long
=	O
position	*(long long)
;	O
curr_pos	long long
=	O
start_pos	long long
+	O
1	int
;	O
while	O
(	O
curr_pos	long long
!=	O
start_pos	long long
)	O
{	O
if	O
(	O
1	int
)	O
{	O
return	O
0	int
;	O
}	O
curr_pos	long long
++	O
;	O
curr_pos	long long
%=	O
entries	long long
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
insert_index_key	(long long,long long,long long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(long,enum(int,int,int),*(char))),*(long long),*(long long),*(long long))->(int)
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
key	*(struct(long,enum(int,int,int),*(char)))
,	O
position	*(long long)
,	O
length	long
,	O
hash_key	long
)	O
INDEXNUM	O
entries	long long
;	O
INDEXNUM	O
number_size	long long
;	O
INDEXNUM	O
hash_method	long
;	O
FILE	struct
*	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
STRINGTYPE	O
*	O
key	*(struct(long,enum(int,int,int),*(char)))
;	O
INDEXNUM	O
*	O
position	*(long long)
;	O
INDEXNUM	O
*	O
length	long
;	O
INDEXNUM	O
*	O
hash_key	long
;	O
{	O
INDEXNUM	O
return_val	int
;	O
INDEXNUM	O
next	*(long long)
;	O
return_val	int
=	O
find_index_key	(long long,long long,long long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(long,enum(int,int,int),*(char))),*(long long),*(long long),*(long long))->(long long)
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
key	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
next	*(long long)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
while	O
(	O
return_val	int
!=	O
-	O
1	int
&&	O
next	*(long long)
!=	O
-	O
1	int
)	O
return_val	int
=	O
find_index_key	(long long,long long,long long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(long,enum(int,int,int),*(char))),*(long long),*(long long),*(long long))->(long long)
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
index_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
key	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
next	*(long long)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
return_val	int
==	O
-	O
1	int
)	O
{	O
}	O
else	O
{	O
}	O
}	O
int	O
find_or_create_index_chunk	(*(*(struct(long long,long long,long long,char))),*(long long),*(*(struct(long long,long long,long long,char))),*(long long),int,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
df_index_base	struct(long long,long long,long long,char)
*	O
*	O
,	O
INDEXNUM	O
*	O
,	O
df_index_base	struct(long long,long long,long long,char)
*	O
*	O
,	O
INDEXNUM	O
*	O
,	O
int	O
,	O
FILE	struct
*	O
*	O
)	O
;	O
int	O
create_index_record_entry	(*(struct(long long,long long,long long,char)),long long,int,long long,long long,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
df_index_base	struct(long long,long long,long long,char)
*	O
,	O
INDEXNUM	O
,	O
int	O
,	O
INDEXNUM	O
,	O
INDEXNUM	O
,	O
FILE	struct
*	O
*	O
)	O
;	O
df_index_base	struct(long long,long long,long long,char)
*	O
create_index_chunk	()->(*(struct(long long,long long,long long,char)))
(	O
)	O
;	O
df_index_record	struct(long long,long long,long long,long long)
*	O
create_index_record	()->(*(struct(long long,long long,long long,long long)))
(	O
)	O
;	O
df_index_base	struct(long long,long long,long long,char)
*	O
read_index_chunk	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long)->(*(struct(long long,long long,long long,char)))
(	O
FILE	struct
*	O
*	O
,	O
INDEXNUM	O
)	O
;	O
df_index_record	struct(long long,long long,long long,long long)
*	O
read_index_record	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long)->(*(struct(long long,long long,long long,long long)))
(	O
FILE	struct
*	O
*	O
,	O
INDEXNUM	O
)	O
;	O
int	O
write_index_chunk	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long,*(struct(long long,long long,long long,char)))->(int)
(	O
FILE	struct
*	O
*	O
,	O
INDEXNUM	O
,	O
df_index_base	struct(long long,long long,long long,char)
*	O
)	O
;	O
int	O
write_index_record	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long,*(struct(long long,long long,long long,long long)))->(int)
(	O
FILE	struct
*	O
*	O
,	O
INDEXNUM	O
,	O
df_index_record	struct(long long,long long,long long,long long)
*	O
)	O
;	O
int	O
add_index_record_entry	(*(*(struct(long,enum(int,int,int),*(char)))),int,long long,long long,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
field_count	int
,	O
data_file_position	long long
,	O
data_record_length	long long
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
DStr_string_descriptor	struct(long,enum(int,int,int),*(char))
*	O
*	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
;	O
int	O
field_count	int
;	O
INDEXNUM	O
data_file_position	long long
;	O
INDEXNUM	O
data_record_length	long long
;	O
FILE	struct
*	O
*	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
{	O
int	O
i	long long
;	O
int	O
j	int
;	O
int	O
return_code	int
;	O
int	O
string_loop_limit	int
;	O
df_index_base	struct(long long,long long,long long,char)
*	O
prev_index_node	*(struct(long long,long long,long long,char))
;	O
df_index_base	struct(long long,long long,long long,char)
*	O
curr_index_node	*(struct(long long,long long,long long,char))
;	O
INDEXNUM	O
prev_position	long long
;	O
INDEXNUM	O
curr_position	long long
;	O
curr_index_node	*(struct(long long,long long,long long,char))
=	O
read_index_chunk	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long)->(*(struct(long long,long long,long long,char)))
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
0	int
)	O
;	O
if	O
(	O
curr_index_node	*(struct(long long,long long,long long,char))
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
prev_index_node	*(struct(long long,long long,long long,char))
=	O
NULL	O
;	O
prev_position	long long
=	O
0	int
;	O
curr_position	long long
=	O
0	int
;	O
for	O
(	O
i	long long
=	O
0	int
;	O
i	long long
<	O
field_count	int
;	O
i	long long
++	O
)	O
{	O
if	O
(	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	long long
]	O
->	O
length	long
==	O
0	int
&&	O
i	long long
<	O
field_count	int
-	O
1	int
)	O
{	O
return_code	int
=	O
find_or_create_index_chunk	(*(*(struct(long long,long long,long long,char))),*(long long),*(*(struct(long long,long long,long long,char))),*(long long),int,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
&	O
prev_index_node	*(struct(long long,long long,long long,char))
,	O
&	O
prev_position	long long
,	O
&	O
curr_index_node	*(struct(long long,long long,long long,char))
,	O
&	O
curr_position	long long
,	O
INDEX_ATOM	int
-	O
2	int
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_code	int
==	O
EXIT_FAILURE	int
)	O
{	O
if	O
(	O
prev_index_node	*(struct(long long,long long,long long,char))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
prev_index_node	*(struct(long long,long long,long long,char))
)	O
;	O
if	O
(	O
curr_index_node	*(struct(long long,long long,long long,char))
!=	O
NULL	O
&&	O
curr_index_node	*(struct(long long,long long,long long,char))
!=	O
prev_index_node	*(struct(long long,long long,long long,char))
)	O
free	(*(void))->(void)
(	O
curr_index_node	*(struct(long long,long long,long long,char))
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
string_loop_limit	int
=	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	long long
]	O
->	O
length	long
;	O
if	O
(	O
i	long long
==	O
field_count	int
-	O
1	int
)	O
string_loop_limit	int
--	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
string_loop_limit	int
;	O
j	int
++	O
)	O
{	O
return_code	int
=	O
find_or_create_index_chunk	(*(*(struct(long long,long long,long long,char))),*(long long),*(*(struct(long long,long long,long long,char))),*(long long),int,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
&	O
prev_index_node	*(struct(long long,long long,long long,char))
,	O
&	O
prev_position	long long
,	O
&	O
curr_index_node	*(struct(long long,long long,long long,char))
,	O
&	O
curr_position	long long
,	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	long long
]	O
->	O
string	*(char)
[	O
j	int
]	O
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_code	int
==	O
EXIT_FAILURE	int
)	O
{	O
if	O
(	O
prev_index_node	*(struct(long long,long long,long long,char))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
prev_index_node	*(struct(long long,long long,long long,char))
)	O
;	O
if	O
(	O
curr_index_node	*(struct(long long,long long,long long,char))
!=	O
NULL	O
&&	O
curr_index_node	*(struct(long long,long long,long long,char))
!=	O
prev_index_node	*(struct(long long,long long,long long,char))
)	O
free	(*(void))->(void)
(	O
curr_index_node	*(struct(long long,long long,long long,char))
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
if	O
(	O
i	long long
<	O
field_count	int
-	O
1	int
)	O
{	O
return_code	int
=	O
find_or_create_index_chunk	(*(*(struct(long long,long long,long long,char))),*(long long),*(*(struct(long long,long long,long long,char))),*(long long),int,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
&	O
prev_index_node	*(struct(long long,long long,long long,char))
,	O
&	O
prev_position	long long
,	O
&	O
curr_index_node	*(struct(long long,long long,long long,char))
,	O
&	O
curr_position	long long
,	O
INDEX_ATOM	int
-	O
1	int
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_code	int
==	O
EXIT_FAILURE	int
)	O
{	O
if	O
(	O
prev_index_node	*(struct(long long,long long,long long,char))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
prev_index_node	*(struct(long long,long long,long long,char))
)	O
;	O
if	O
(	O
curr_index_node	*(struct(long long,long long,long long,char))
!=	O
NULL	O
&&	O
curr_index_node	*(struct(long long,long long,long long,char))
!=	O
prev_index_node	*(struct(long long,long long,long long,char))
)	O
free	(*(void))->(void)
(	O
curr_index_node	*(struct(long long,long long,long long,char))
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
}	O
if	O
(	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
field_count	int
-	O
1	int
]	O
->	O
length	long
==	O
0	int
)	O
return_code	int
=	O
create_index_record_entry	(*(struct(long long,long long,long long,char)),long long,int,long long,long long,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
curr_index_node	*(struct(long long,long long,long long,char))
,	O
curr_position	long long
,	O
INDEX_ATOM	int
-	O
2	int
,	O
data_file_position	long long
,	O
data_record_length	long long
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
else	O
return_code	int
=	O
create_index_record_entry	(*(struct(long long,long long,long long,char)),long long,int,long long,long long,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
curr_index_node	*(struct(long long,long long,long long,char))
,	O
curr_position	long long
,	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
field_count	int
-	O
1	int
]	O
->	O
string	*(char)
[	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
field_count	int
-	O
1	int
]	O
->	O
length	long
-	O
1	int
]	O
,	O
data_file_position	long long
,	O
data_record_length	long long
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
if	O
(	O
return_code	int
==	O
EXIT_FAILURE	int
)	O
return	O
EXIT_FAILURE	int
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
find_or_create_index_chunk	(*(*(struct(long long,long long,long long,char))),*(long long),*(*(struct(long long,long long,long long,char))),*(long long),int,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
prev_index_node	*(struct(long long,long long,long long,char))
,	O
prev_position	long long
,	O
curr_index_node	*(struct(long long,long long,long long,char))
,	O
curr_position	long long
,	O
index_value	int
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
df_index_base	struct(long long,long long,long long,char)
*	O
*	O
prev_index_node	*(struct(long long,long long,long long,char))
;	O
INDEXNUM	O
*	O
prev_position	long long
;	O
df_index_base	struct(long long,long long,long long,char)
*	O
*	O
curr_index_node	*(struct(long long,long long,long long,char))
;	O
INDEXNUM	O
*	O
curr_position	long long
;	O
int	O
index_value	int
;	O
FILE	struct
*	O
*	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
{	O
INDEXNUM	O
next_position	long long
;	O
if	O
(	O
*	O
prev_index_node	*(struct(long long,long long,long long,char))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
*	O
prev_index_node	*(struct(long long,long long,long long,char))
)	O
;	O
*	O
prev_index_node	*(struct(long long,long long,long long,char))
=	O
*	O
curr_index_node	*(struct(long long,long long,long long,char))
;	O
*	O
prev_position	long long
=	O
*	O
curr_position	long long
;	O
*	O
curr_position	long long
=	O
(	O
*	O
curr_index_node	*(struct(long long,long long,long long,char))
)	O
[	O
index_value	int
]	O
.	O
key_continuation	long long
;	O
if	O
(	O
*	O
curr_position	long long
==	O
0	int
)	O
{	O
*	O
curr_index_node	*(struct(long long,long long,long long,char))
=	O
create_index_chunk	()->(*(struct(long long,long long,long long,char)))
(	O
)	O
;	O
if	O
(	O
*	O
curr_index_node	*(struct(long long,long long,long long,char))
==	O
NULL	O
)	O
{	O
return	O
EXIT_FAILURE	int
;	O
}	O
(	O
*	O
curr_index_node	*(struct(long long,long long,long long,char))
)	O
->	O
key_previous	long long
=	O
*	O
prev_position	long long
;	O
*	O
curr_position	long long
=	O
write_index_chunk	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long,*(struct(long long,long long,long long,char)))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
-	O
1	int
,	O
*	O
curr_index_node	*(struct(long long,long long,long long,char))
)	O
;	O
if	O
(	O
*	O
curr_position	long long
==	O
-	O
1	int
)	O
return	O
EXIT_FAILURE	int
;	O
(	O
*	O
prev_index_node	*(struct(long long,long long,long long,char))
)	O
[	O
index_value	int
]	O
.	O
key_continuation	long long
=	O
*	O
curr_position	long long
;	O
next_position	long long
=	O
write_index_chunk	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long,*(struct(long long,long long,long long,char)))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
*	O
prev_position	long long
,	O
*	O
prev_index_node	*(struct(long long,long long,long long,char))
)	O
;	O
if	O
(	O
next_position	long long
==	O
-	O
1	int
)	O
return	O
EXIT_FAILURE	int
;	O
}	O
else	O
{	O
*	O
curr_index_node	*(struct(long long,long long,long long,char))
=	O
read_index_chunk	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long)->(*(struct(long long,long long,long long,char)))
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
*	O
curr_position	long long
)	O
;	O
if	O
(	O
*	O
curr_index_node	*(struct(long long,long long,long long,char))
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
create_index_record_entry	(*(struct(long long,long long,long long,char)),long long,int,long long,long long,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
chunk	*(struct(long long,long long,long long,char))
,	O
chunk_position	long long
,	O
key_position	long long
,	O
data_file_position	long long
,	O
data_record_length	long long
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
df_index_base	struct(long long,long long,long long,char)
*	O
chunk	*(struct(long long,long long,long long,char))
;	O
INDEXNUM	O
chunk_position	long long
;	O
int	O
key_position	long long
;	O
INDEXNUM	O
data_file_position	long long
;	O
INDEXNUM	O
data_record_length	long long
;	O
FILE	struct
*	O
*	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
{	O
long	O
prev_record_position	long
;	O
long	O
curr_record_position	long
;	O
long	O
new_record_position	long
;	O
long	O
result_position	long
;	O
df_index_record	struct(long long,long long,long long,long long)
*	O
curr_record_entry	*(struct(long long,long long,long long,long long))
;	O
df_index_record	struct(long long,long long,long long,long long)
*	O
new_record_entry	*(struct(long long,long long,long long,long long))
;	O
new_record_entry	*(struct(long long,long long,long long,long long))
=	O
create_index_record	()->(*(struct(long long,long long,long long,long long)))
(	O
)	O
;	O
if	O
(	O
new_record_entry	*(struct(long long,long long,long long,long long))
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
new_record_entry	*(struct(long long,long long,long long,long long))
->	O
file_position	long long
=	O
data_file_position	long long
;	O
new_record_entry	*(struct(long long,long long,long long,long long))
->	O
record_length	long long
=	O
data_record_length	long long
;	O
new_record_position	long
=	O
write_index_record	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long,*(struct(long long,long long,long long,long long)))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
-	O
1	int
,	O
new_record_entry	*(struct(long long,long long,long long,long long))
)	O
;	O
if	O
(	O
new_record_position	long
==	O
-	O
1	int
)	O
{	O
free	(*(void))->(void)
(	O
new_record_entry	*(struct(long long,long long,long long,long long))
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
chunk	*(struct(long long,long long,long long,char))
[	O
key_position	long long
]	O
.	O
first_record	long long
==	O
0	int
)	O
{	O
chunk	*(struct(long long,long long,long long,char))
[	O
key_position	long long
]	O
.	O
first_record	long long
=	O
new_record_position	long
;	O
write_index_chunk	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long,*(struct(long long,long long,long long,char)))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
chunk_position	long long
,	O
chunk	*(struct(long long,long long,long long,char))
)	O
;	O
}	O
else	O
{	O
prev_record_position	long
=	O
0	int
;	O
curr_record_position	long
=	O
chunk	*(struct(long long,long long,long long,char))
[	O
key_position	long long
]	O
.	O
first_record	long long
;	O
curr_record_entry	*(struct(long long,long long,long long,long long))
=	O
NULL	O
;	O
while	O
(	O
curr_record_position	long
!=	O
0	int
)	O
{	O
prev_record_position	long
=	O
curr_record_position	long
;	O
if	O
(	O
curr_record_entry	*(struct(long long,long long,long long,long long))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
curr_record_entry	*(struct(long long,long long,long long,long long))
)	O
;	O
curr_record_entry	*(struct(long long,long long,long long,long long))
=	O
read_index_record	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long)->(*(struct(long long,long long,long long,long long)))
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
curr_record_position	long
)	O
;	O
if	O
(	O
curr_record_entry	*(struct(long long,long long,long long,long long))
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
curr_record_position	long
=	O
curr_record_entry	*(struct(long long,long long,long long,long long))
->	O
next_same_key	long long
;	O
}	O
new_record_entry	*(struct(long long,long long,long long,long long))
->	O
prev_same_key	long long
=	O
prev_record_position	long
;	O
curr_record_entry	*(struct(long long,long long,long long,long long))
->	O
next_same_key	long long
=	O
new_record_position	long
;	O
result_position	long
=	O
write_index_record	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long,*(struct(long long,long long,long long,long long)))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
new_record_position	long
,	O
new_record_entry	*(struct(long long,long long,long long,long long))
)	O
;	O
if	O
(	O
result_position	long
!=	O
new_record_position	long
)	O
return	O
EXIT_FAILURE	int
;	O
result_position	long
=	O
write_index_record	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long,*(struct(long long,long long,long long,long long)))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
prev_record_position	long
,	O
curr_record_entry	*(struct(long long,long long,long long,long long))
)	O
;	O
if	O
(	O
result_position	long
!=	O
prev_record_position	long
)	O
return	O
EXIT_FAILURE	int
;	O
free	(*(void))->(void)
(	O
curr_record_entry	*(struct(long long,long long,long long,long long))
)	O
;	O
free	(*(void))->(void)
(	O
new_record_entry	*(struct(long long,long long,long long,long long))
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
df_index_base	struct(long long,long long,long long,char)
*	O
create_index_chunk	()->(*(struct(long long,long long,long long,char)))
(	O
)	O
{	O
df_index_base	struct(long long,long long,long long,char)
*	O
return_array	*(struct(long long,long long,long long,char))
;	O
int	O
i	long long
;	O
return_array	*(struct(long long,long long,long long,char))
=	O
malloc	(long)->(*(void))
(	O
INDEX_ATOM	int
*	O
sizeof	O
(	O
df_index_base	struct(long long,long long,long long,char)
)	O
)	O
;	O
if	O
(	O
return_array	*(struct(long long,long long,long long,char))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
bzero	(*(void),long)->(void)
(	O
return_array	*(struct(long long,long long,long long,char))
,	O
INDEX_ATOM	int
*	O
sizeof	O
(	O
df_index_base	struct(long long,long long,long long,char)
)	O
)	O
;	O
for	O
(	O
i	long long
=	O
0	int
;	O
i	long long
<	O
256	int
;	O
i	long long
++	O
)	O
return_array	*(struct(long long,long long,long long,char))
[	O
i	long long
]	O
.	O
byte_value	char
=	O
i	long long
;	O
return	O
return_array	*(struct(long long,long long,long long,char))
;	O
}	O
df_index_record	struct(long long,long long,long long,long long)
*	O
create_index_record	()->(*(struct(long long,long long,long long,long long)))
(	O
)	O
{	O
df_index_record	struct(long long,long long,long long,long long)
*	O
return_record	*(struct(long long,long long,long long,long long))
;	O
return_record	*(struct(long long,long long,long long,long long))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
df_index_record	struct(long long,long long,long long,long long)
)	O
)	O
;	O
if	O
(	O
return_record	*(struct(long long,long long,long long,long long))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
bzero	(*(void),long)->(void)
(	O
return_record	*(struct(long long,long long,long long,long long))
,	O
sizeof	O
(	O
df_index_record	struct(long long,long long,long long,long long)
)	O
)	O
;	O
return	O
return_record	*(struct(long long,long long,long long,long long))
;	O
}	O
int	O
open_index_file	(*(char),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),int)->(int)
(	O
filename	*(char)
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
new	int
)	O
char	O
*	O
filename	*(char)
;	O
FILE	struct
*	O
*	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
int	O
new	int
;	O
{	O
char	O
*	O
index_base_file_name	*(char)
;	O
char	O
*	O
index_record_file_name	*(char)
;	O
int	O
return_code	int
;	O
index_base_file_name	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
+	O
4	int
)	O
;	O
if	O
(	O
index_base_file_name	*(char)
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
index_base_file_name	*(char)
,	O
"%s.ib"	*(char)
,	O
filename	*(char)
)	O
;	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
0	int
]	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
index_base_file_name	*(char)
,	O
"a+"	*(char)
)	O
;	O
if	O
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
perror	(*(char))->(void)
(	O
index_base_file_name	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
new	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
truncate	(*(char),long)->(int)
(	O
index_base_file_name	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
index_base_file_name	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
free	(*(void))->(void)
(	O
index_base_file_name	*(char)
)	O
;	O
index_record_file_name	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
+	O
4	int
)	O
;	O
if	O
(	O
index_record_file_name	*(char)
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
index_record_file_name	*(char)
,	O
"%s.ir"	*(char)
,	O
filename	*(char)
)	O
;	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
1	int
]	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
index_record_file_name	*(char)
,	O
"a+"	*(char)
)	O
;	O
if	O
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
1	int
]	O
==	O
NULL	O
)	O
{	O
perror	(*(char))->(void)
(	O
index_record_file_name	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
new	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
truncate	(*(char),long)->(int)
(	O
index_record_file_name	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
index_record_file_name	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
free	(*(void))->(void)
(	O
index_record_file_name	*(char)
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
initialize_index_file	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
FILE	struct
*	O
*	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
{	O
df_index_base	struct(long long,long long,long long,char)
*	O
initial_chunk	*(struct(long long,long long,long long,char))
;	O
int	O
return_code	int
;	O
initial_chunk	*(struct(long long,long long,long long,char))
=	O
create_index_chunk	()->(*(struct(long long,long long,long long,char)))
(	O
)	O
;	O
if	O
(	O
initial_chunk	*(struct(long long,long long,long long,char))
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
return_code	int
=	O
write_index_chunk	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long,*(struct(long long,long long,long long,char)))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
0	int
,	O
initial_chunk	*(struct(long long,long long,long long,char))
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
return	O
EXIT_FAILURE	int
;	O
free	(*(void))->(void)
(	O
initial_chunk	*(struct(long long,long long,long long,char))
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
close_index_file	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
FILE	struct
*	O
*	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
{	O
int	O
return_code	int
;	O
return_code	int
=	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
NULL	O
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
return_code	int
=	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
NULL	O
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
df_index_base	struct(long long,long long,long long,char)
*	O
read_index_chunk	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long)->(*(struct(long long,long long,long long,char)))
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
position	*(long long)
)	O
FILE	struct
*	O
*	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
INDEXNUM	O
position	*(long long)
;	O
{	O
int	O
return_code	int
;	O
long	O
long_position	long
;	O
df_index_base	struct(long long,long long,long long,char)
*	O
return_array	*(struct(long long,long long,long long,char))
;	O
long_position	long
=	O
position	*(long long)
;	O
return_code	int
=	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
0	int
]	O
,	O
long_position	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
_	O
(	O
"index base file"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return_array	*(struct(long long,long long,long long,char))
=	O
malloc	(long)->(*(void))
(	O
INDEX_ATOM	int
*	O
sizeof	O
(	O
df_index_base	struct(long long,long long,long long,char)
)	O
)	O
;	O
if	O
(	O
return_array	*(struct(long long,long long,long long,char))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return_code	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
return_array	*(struct(long long,long long,long long,char))
,	O
sizeof	O
(	O
df_index_base	struct(long long,long long,long long,char)
)	O
,	O
INDEX_ATOM	int
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
INDEX_ATOM	int
)	O
{	O
perror	(*(char))->(void)
(	O
_	O
(	O
"index base file"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
return_array	*(struct(long long,long long,long long,char))
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
return_array	*(struct(long long,long long,long long,char))
;	O
}	O
df_index_record	struct(long long,long long,long long,long long)
*	O
read_index_record	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long)->(*(struct(long long,long long,long long,long long)))
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
position	*(long long)
)	O
FILE	struct
*	O
*	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
INDEXNUM	O
position	*(long long)
;	O
{	O
int	O
return_code	int
;	O
long	O
long_position	long
;	O
df_index_record	struct(long long,long long,long long,long long)
*	O
return_record	*(struct(long long,long long,long long,long long))
;	O
long_position	long
=	O
position	*(long long)
;	O
return_code	int
=	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
1	int
]	O
,	O
long_position	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
_	O
(	O
"index record file"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return_record	*(struct(long long,long long,long long,long long))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
df_index_record	struct(long long,long long,long long,long long)
)	O
)	O
;	O
if	O
(	O
return_record	*(struct(long long,long long,long long,long long))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return_code	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
return_record	*(struct(long long,long long,long long,long long))
,	O
sizeof	O
(	O
df_index_record	struct(long long,long long,long long,long long)
)	O
,	O
1	int
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
1	int
)	O
{	O
perror	(*(char))->(void)
(	O
_	O
(	O
"index record file"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
return_record	*(struct(long long,long long,long long,long long))
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
return_record	*(struct(long long,long long,long long,long long))
;	O
}	O
int	O
write_index_chunk	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long,*(struct(long long,long long,long long,char)))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
position	*(long long)
,	O
chunk	*(struct(long long,long long,long long,char))
)	O
FILE	struct
*	O
*	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
INDEXNUM	O
position	*(long long)
;	O
df_index_base	struct(long long,long long,long long,char)
*	O
chunk	*(struct(long long,long long,long long,char))
;	O
{	O
int	O
return_code	int
;	O
long	O
long_position	long
;	O
long	O
new_position	long
;	O
long_position	long
=	O
position	*(long long)
;	O
if	O
(	O
long_position	long
>=	O
0	int
)	O
return_code	int
=	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
0	int
]	O
,	O
long_position	long
,	O
SEEK_SET	int
)	O
;	O
else	O
return_code	int
=	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
0	int
]	O
,	O
0L	int
,	O
SEEK_END	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
_	O
(	O
"index base file"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
new_position	long
=	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
0	int
]	O
)	O
;	O
return_code	int
=	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
chunk	*(struct(long long,long long,long long,char))
,	O
sizeof	O
(	O
df_index_base	struct(long long,long long,long long,char)
)	O
,	O
INDEX_ATOM	int
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
INDEX_ATOM	int
)	O
{	O
perror	(*(char))->(void)
(	O
_	O
(	O
"index base file"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
new_position	long
;	O
}	O
int	O
write_index_record	(*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),long long,*(struct(long long,long long,long long,long long)))->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
position	*(long long)
,	O
record	*(struct(long long,long long,long long,long long))
)	O
FILE	struct
*	O
*	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
INDEXNUM	O
position	*(long long)
;	O
df_index_record	struct(long long,long long,long long,long long)
*	O
record	*(struct(long long,long long,long long,long long))
;	O
{	O
int	O
return_code	int
;	O
long	O
long_position	long
;	O
long	O
new_position	long
;	O
long_position	long
=	O
position	*(long long)
;	O
if	O
(	O
long_position	long
>	O
0	int
)	O
return_code	int
=	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
1	int
]	O
,	O
long_position	long
,	O
SEEK_SET	int
)	O
;	O
else	O
return_code	int
=	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
1	int
]	O
,	O
0L	int
,	O
SEEK_END	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
_	O
(	O
"index record file"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
new_position	long
=	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
1	int
]	O
)	O
;	O
return_code	int
=	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
record	*(struct(long long,long long,long long,long long))
,	O
sizeof	O
(	O
df_index_record	struct(long long,long long,long long,long long)
)	O
,	O
1	int
,	O
streams	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
1	int
)	O
{	O
perror	(*(char))->(void)
(	O
_	O
(	O
"index record file"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
new_position	long
;	O
}	O
