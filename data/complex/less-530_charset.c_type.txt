extern	O
int	O
bs_mode	int
;	O
public	O
int	O
utf_mode	int
=	O
0	int
;	O
struct	O
charset	struct(*(char),*(int),*(char))
{	O
char	O
*	O
name	*(char)
;	O
int	O
*	O
p_flag	*(int)
;	O
char	O
*	O
desc	*(char)
;	O
}	O
charsets	array(struct(*(char),*(int),*(char)))
[	O
]	O
=	O
{	O
{	O
"ascii"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.b"	*(char)
}	O
,	O
{	O
"utf-8"	*(char)
,	O
&	O
utf_mode	int
,	O
"8bcccbcc18b95.b126.bb"	*(char)
}	O
,	O
{	O
"iso8859"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.33b."	*(char)
}	O
,	O
{	O
"latin3"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.33b5.b8.b15.b4.b12.b18.b12.b."	*(char)
}	O
,	O
{	O
"arabic"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.33b.3b.7b2.13b.3b.b26.5b19.b"	*(char)
}	O
,	O
{	O
"greek"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.33b4.2b4.b3.b35.b44.b"	*(char)
}	O
,	O
{	O
"greek2005"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.33b14.b35.b44.b"	*(char)
}	O
,	O
{	O
"hebrew"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.33b.b29.32b28.2b2.b"	*(char)
}	O
,	O
{	O
"koi8-r"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.b."	*(char)
}	O
,	O
{	O
"KOI8-T"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.b8.b6.b8.b.b.5b7.3b4.b4.b3.b.b.3b."	*(char)
}	O
,	O
{	O
"georgianps"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.3b11.4b12.2b."	*(char)
}	O
,	O
{	O
"tcvn"	*(char)
,	O
NULL	O
,	O
"b..b...bcccbccbbb7.8b95.b48.5b."	*(char)
}	O
,	O
{	O
"TIS-620"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.b.4b.11b7.8b."	*(char)
}	O
,	O
{	O
"next"	*(char)
,	O
NULL	O
,	O
"8bcccbcc18b95.bb125.bb"	*(char)
}	O
,	O
{	O
"dos"	*(char)
,	O
NULL	O
,	O
"8bcccbcc12bc5b95.b."	*(char)
}	O
,	O
{	O
"windows-1251"	*(char)
,	O
NULL	O
,	O
"8bcccbcc12bc5b95.b24.b."	*(char)
}	O
,	O
{	O
"windows-1252"	*(char)
,	O
NULL	O
,	O
"8bcccbcc12bc5b95.b.b11.b.2b12.b."	*(char)
}	O
,	O
{	O
"windows-1255"	*(char)
,	O
NULL	O
,	O
"8bcccbcc12bc5b95.b.b8.b.5b9.b.4b."	*(char)
}	O
,	O
{	O
"ebcdic"	*(char)
,	O
NULL	O
,	O
"5bc6bcc7bcc41b.9b7.9b5.b..8b6.10b6.b9.7b9.8b8.17b3.3b9.7b9.8b8.6b10.b.b.b."	*(char)
}	O
,	O
{	O
"IBM-1047"	*(char)
,	O
NULL	O
,	O
"4cbcbc3b9cbccbccbb4c6bcc5b3cbbc4bc4bccbc191.b"	*(char)
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
struct	O
cs_alias	struct(*(char),*(char))
{	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
oname	*(char)
;	O
}	O
cs_aliases	array(struct(*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"UTF-8"	*(char)
,	O
"utf-8"	*(char)
}	O
,	O
{	O
"utf8"	*(char)
,	O
"utf-8"	*(char)
}	O
,	O
{	O
"UTF8"	*(char)
,	O
"utf-8"	*(char)
}	O
,	O
{	O
"ANSI_X3.4-1968"	*(char)
,	O
"ascii"	*(char)
}	O
,	O
{	O
"US-ASCII"	*(char)
,	O
"ascii"	*(char)
}	O
,	O
{	O
"latin1"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-1"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"latin9"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-15"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"latin2"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-2"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-3"	*(char)
,	O
"latin3"	*(char)
}	O
,	O
{	O
"latin4"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-4"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"cyrillic"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-5"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-6"	*(char)
,	O
"arabic"	*(char)
}	O
,	O
{	O
"ISO-8859-7"	*(char)
,	O
"greek"	*(char)
}	O
,	O
{	O
"IBM9005"	*(char)
,	O
"greek2005"	*(char)
}	O
,	O
{	O
"ISO-8859-8"	*(char)
,	O
"hebrew"	*(char)
}	O
,	O
{	O
"latin5"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-9"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"latin6"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-10"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"latin7"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-13"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"latin8"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-14"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"latin10"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"ISO-8859-16"	*(char)
,	O
"iso8859"	*(char)
}	O
,	O
{	O
"IBM437"	*(char)
,	O
"dos"	*(char)
}	O
,	O
{	O
"EBCDIC-US"	*(char)
,	O
"ebcdic"	*(char)
}	O
,	O
{	O
"IBM1047"	*(char)
,	O
"IBM-1047"	*(char)
}	O
,	O
{	O
"KOI8-R"	*(char)
,	O
"koi8-r"	*(char)
}	O
,	O
{	O
"KOI8-U"	*(char)
,	O
"koi8-r"	*(char)
}	O
,	O
{	O
"GEORGIAN-PS"	*(char)
,	O
"georgianps"	*(char)
}	O
,	O
{	O
"TCVN5712-1"	*(char)
,	O
"tcvn"	*(char)
}	O
,	O
{	O
"NEXTSTEP"	*(char)
,	O
"next"	*(char)
}	O
,	O
{	O
"windows"	*(char)
,	O
"windows-1252"	*(char)
}	O
,	O
{	O
"CP1251"	*(char)
,	O
"windows-1251"	*(char)
}	O
,	O
{	O
"CP1252"	*(char)
,	O
"windows-1252"	*(char)
}	O
,	O
{	O
"CP1255"	*(char)
,	O
"windows-1255"	*(char)
}	O
,	O
{	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
static	O
char	O
chardef	array(char)
[	O
256	int
]	O
;	O
static	O
char	O
*	O
binfmt	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
utfbinfmt	*(char)
=	O
NULL	O
;	O
public	O
int	O
binattr	int
=	O
AT_STANDOUT	O
;	O
static	O
void	O
ichardef	(*(char))->(void)
(	O
s	*(char)
)	O
char	O
*	O
s	*(char)
;	O
{	O
char	O
*	O
cp	*(char)
;	O
int	O
n	int
;	O
char	O
v	char
;	O
n	int
=	O
0	int
;	O
v	char
=	O
0	int
;	O
cp	*(char)
=	O
chardef	array(char)
;	O
while	O
(	O
*	O
s	*(char)
!=	O
'\0'	O
)	O
{	O
switch	O
(	O
*	O
s	*(char)
++	O
)	O
{	O
case	O
'.'	O
:	O
v	char
=	O
0	int
;	O
break	O
;	O
case	O
'c'	O
:	O
v	char
=	O
IS_CONTROL_CHAR	int
;	O
break	O
;	O
case	O
'b'	O
:	O
v	char
=	O
IS_BINARY_CHAR	int
|	O
IS_CONTROL_CHAR	int
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
n	int
=	O
(	O
10	int
*	O
n	int
)	O
+	O
(	O
s	*(char)
[	O
-	O
1	int
]	O
-	O
'0'	O
)	O
;	O
continue	O
;	O
default	O
:	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"invalid chardef"	*(char)
,	O
NULL_PARG	O
)	O
;	O
quit	(int)->(void)
(	O
QUIT_ERROR	int
)	O
;	O
}	O
do	O
{	O
if	O
(	O
cp	*(char)
>=	O
chardef	array(char)
+	O
sizeof	O
(	O
chardef	array(char)
)	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"chardef longer than 256"	*(char)
,	O
NULL_PARG	O
)	O
;	O
quit	(int)->(void)
(	O
QUIT_ERROR	int
)	O
;	O
}	O
*	O
cp	*(char)
++	O
=	O
v	char
;	O
}	O
while	O
(	O
--	O
n	int
>	O
0	int
)	O
;	O
n	int
=	O
0	int
;	O
}	O
while	O
(	O
cp	*(char)
<	O
chardef	array(char)
+	O
sizeof	O
(	O
chardef	array(char)
)	O
)	O
*	O
cp	*(char)
++	O
=	O
v	char
;	O
}	O
static	O
int	O
icharset	(*(char),int)->(int)
(	O
name	*(char)
,	O
no_error	int
)	O
char	O
*	O
name	*(char)
;	O
int	O
no_error	int
;	O
{	O
struct	O
charset	struct(*(char),*(int),*(char))
*	O
p	*(char)
;	O
struct	O
cs_alias	struct(*(char),*(char))
*	O
a	*(struct(*(char),*(char)))
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
||	O
*	O
name	*(char)
==	O
'\0'	O
)	O
return	O
(	O
0	int
)	O
;	O
for	O
(	O
a	*(struct(*(char),*(char)))
=	O
cs_aliases	array(struct(*(char),*(char)))
;	O
a	*(struct(*(char),*(char)))
->	O
name	*(char)
!=	O
NULL	O
;	O
a	*(struct(*(char),*(char)))
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
a	*(struct(*(char),*(char)))
->	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
name	*(char)
=	O
a	*(struct(*(char),*(char)))
->	O
oname	*(char)
;	O
break	O
;	O
}	O
}	O
for	O
(	O
p	*(char)
=	O
charsets	array(struct(*(char),*(int),*(char)))
;	O
p	*(char)
->	O
name	*(char)
!=	O
NULL	O
;	O
p	*(char)
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
p	*(char)
->	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
ichardef	(*(char))->(void)
(	O
p	*(char)
->	O
desc	*(char)
)	O
;	O
if	O
(	O
p	*(char)
->	O
p_flag	*(int)
!=	O
NULL	O
)	O
{	O
*	O
(	O
p	*(char)
->	O
p_flag	*(int)
)	O
=	O
1	int
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
no_error	int
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"invalid charset name"	*(char)
,	O
NULL_PARG	O
)	O
;	O
quit	(int)->(void)
(	O
QUIT_ERROR	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
ilocale	()->(void)
(	O
)	O
{	O
int	O
c	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
(	O
int	O
)	O
sizeof	O
(	O
chardef	array(char)
)	O
;	O
c	int
++	O
)	O
{	O
if	O
(	O
isprint	(int)->(int)
(	O
c	int
)	O
)	O
chardef	array(char)
[	O
c	int
]	O
=	O
0	int
;	O
else	O
if	O
(	O
iscntrl	(int)->(int)
(	O
c	int
)	O
)	O
chardef	array(char)
[	O
c	int
]	O
=	O
IS_CONTROL_CHAR	int
;	O
else	O
chardef	array(char)
[	O
c	int
]	O
=	O
IS_BINARY_CHAR	int
|	O
IS_CONTROL_CHAR	int
;	O
}	O
}	O
public	O
void	O
setfmt	(*(char),*(*(char)),*(int),*(char))->(void)
(	O
s	*(char)
,	O
fmtvarptr	*(*(char))
,	O
attrptr	*(int)
,	O
default_fmt	*(char)
)	O
char	O
*	O
s	*(char)
;	O
char	O
*	O
*	O
fmtvarptr	*(*(char))
;	O
int	O
*	O
attrptr	*(int)
;	O
char	O
*	O
default_fmt	*(char)
;	O
{	O
if	O
(	O
s	*(char)
&&	O
utf_mode	int
)	O
{	O
char	O
constant	O
*	O
t	*(char)
=	O
s	*(char)
;	O
while	O
(	O
*	O
t	*(char)
)	O
{	O
if	O
(	O
*	O
t	*(char)
<	O
' '	O
||	O
*	O
t	*(char)
>	O
'~'	O
)	O
{	O
s	*(char)
=	O
default_fmt	*(char)
;	O
goto	O
attr	int
;	O
}	O
t	*(char)
++	O
;	O
}	O
}	O
if	O
(	O
s	*(char)
==	O
NULL	O
||	O
*	O
s	*(char)
==	O
'\0'	O
||	O
(	O
*	O
s	*(char)
==	O
'*'	O
&&	O
(	O
s	*(char)
[	O
1	int
]	O
==	O
'\0'	O
||	O
s	*(char)
[	O
2	int
]	O
==	O
'\0'	O
||	O
strchr	(*(char),int)->(*(char))
(	O
s	*(char)
+	O
2	int
,	O
'n'	O
)	O
)	O
)	O
||	O
(	O
*	O
s	*(char)
!=	O
'*'	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
s	*(char)
,	O
'n'	O
)	O
)	O
)	O
s	*(char)
=	O
default_fmt	*(char)
;	O
attr	int
:	O
if	O
(	O
*	O
s	*(char)
==	O
'*'	O
&&	O
s	*(char)
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
switch	O
(	O
s	*(char)
[	O
1	int
]	O
)	O
{	O
case	O
'd'	O
:	O
*	O
attrptr	*(int)
=	O
AT_BOLD	O
;	O
break	O
;	O
case	O
'k'	O
:	O
*	O
attrptr	*(int)
=	O
AT_BLINK	O
;	O
break	O
;	O
case	O
's'	O
:	O
*	O
attrptr	*(int)
=	O
AT_STANDOUT	O
;	O
break	O
;	O
case	O
'u'	O
:	O
*	O
attrptr	*(int)
=	O
AT_UNDERLINE	O
;	O
break	O
;	O
default	O
:	O
*	O
attrptr	*(int)
=	O
AT_NORMAL	O
;	O
break	O
;	O
}	O
s	*(char)
+=	O
2	int
;	O
}	O
*	O
fmtvarptr	*(*(char))
=	O
s	*(char)
;	O
}	O
static	O
void	O
set_charset	()->(void)
(	O
)	O
{	O
char	O
*	O
s	*(char)
;	O
s	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LESSCHARSET"	*(char)
)	O
;	O
if	O
(	O
icharset	(*(char),int)->(int)
(	O
s	*(char)
,	O
0	int
)	O
)	O
return	O
;	O
s	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LESSCHARDEF"	*(char)
)	O
;	O
if	O
(	O
s	*(char)
!=	O
NULL	O
&&	O
*	O
s	*(char)
!=	O
'\0'	O
)	O
{	O
ichardef	(*(char))->(void)
(	O
s	*(char)
)	O
;	O
return	O
;	O
}	O
s	*(char)
=	O
nl_langinfo	(int)->(*(char))
(	O
CODESET	int
)	O
;	O
if	O
(	O
icharset	(*(char),int)->(int)
(	O
s	*(char)
,	O
1	int
)	O
)	O
return	O
;	O
if	O
(	O
(	O
s	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LC_ALL"	*(char)
)	O
)	O
!=	O
NULL	O
||	O
(	O
s	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LC_CTYPE"	*(char)
)	O
)	O
!=	O
NULL	O
||	O
(	O
s	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LANG"	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
s	*(char)
,	O
"UTF-8"	*(char)
)	O
!=	O
NULL	O
||	O
strstr	(*(char),*(char))->(*(char))
(	O
s	*(char)
,	O
"utf-8"	*(char)
)	O
!=	O
NULL	O
||	O
strstr	(*(char),*(char))->(*(char))
(	O
s	*(char)
,	O
"UTF8"	*(char)
)	O
!=	O
NULL	O
||	O
strstr	(*(char),*(char))->(*(char))
(	O
s	*(char)
,	O
"utf8"	*(char)
)	O
!=	O
NULL	O
)	O
if	O
(	O
icharset	(*(char),int)->(int)
(	O
"utf-8"	*(char)
,	O
1	int
)	O
)	O
return	O
;	O
}	O
ilocale	()->(void)
(	O
)	O
;	O
}	O
public	O
void	O
init_charset	()->(void)
(	O
)	O
{	O
char	O
*	O
s	*(char)
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
set_charset	()->(void)
(	O
)	O
;	O
s	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LESSBINFMT"	*(char)
)	O
;	O
setfmt	(*(char),*(*(char)),*(int),*(char))->(void)
(	O
s	*(char)
,	O
&	O
binfmt	*(char)
,	O
&	O
binattr	int
,	O
"*s<%02X>"	*(char)
)	O
;	O
s	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LESSUTFBINFMT"	*(char)
)	O
;	O
setfmt	(*(char),*(*(char)),*(int),*(char))->(void)
(	O
s	*(char)
,	O
&	O
utfbinfmt	*(char)
,	O
&	O
binattr	int
,	O
"<U+%04lX>"	*(char)
)	O
;	O
}	O
public	O
int	O
binary_char	(long)->(int)
(	O
c	int
)	O
LWCHAR	long
c	int
;	O
{	O
if	O
(	O
utf_mode	int
)	O
return	O
(	O
is_ubin_char	(long)->(int)
(	O
c	int
)	O
)	O
;	O
c	int
&=	O
0377	int
;	O
return	O
(	O
chardef	array(char)
[	O
c	int
]	O
&	O
IS_BINARY_CHAR	int
)	O
;	O
}	O
public	O
int	O
control_char	(long)->(int)
(	O
c	int
)	O
LWCHAR	long
c	int
;	O
{	O
c	int
&=	O
0377	int
;	O
return	O
(	O
chardef	array(char)
[	O
c	int
]	O
&	O
IS_CONTROL_CHAR	int
)	O
;	O
}	O
public	O
char	O
*	O
prchar	(long)->(*(char))
(	O
c	int
)	O
LWCHAR	long
c	int
;	O
{	O
static	O
char	O
buf	*(char)
[	O
32	int
]	O
;	O
c	int
&=	O
0377	int
;	O
if	O
(	O
(	O
c	int
<	O
128	int
||	O
!	O
utf_mode	int
)	O
&&	O
!	O
control_char	(long)->(int)
(	O
c	int
)	O
)	O
SNPRINTF1	O
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"%c"	*(char)
,	O
(	O
int	O
)	O
c	int
)	O
;	O
else	O
if	O
(	O
c	int
==	O
ESC	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"ESC"	*(char)
)	O
;	O
else	O
if	O
(	O
c	int
<	O
128	int
&&	O
!	O
control_char	(long)->(int)
(	O
c	int
^	O
0100	int
)	O
)	O
SNPRINTF1	O
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"^%c"	*(char)
,	O
(	O
int	O
)	O
(	O
c	int
^	O
0100	int
)	O
)	O
;	O
else	O
SNPRINTF1	O
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
binfmt	*(char)
,	O
c	int
)	O
;	O
return	O
(	O
buf	*(char)
)	O
;	O
}	O
public	O
char	O
*	O
prutfchar	(long)->(*(char))
(	O
ch	long
)	O
LWCHAR	long
ch	long
;	O
{	O
static	O
char	O
buf	*(char)
[	O
32	int
]	O
;	O
if	O
(	O
ch	long
==	O
ESC	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"ESC"	*(char)
)	O
;	O
else	O
if	O
(	O
ch	long
<	O
128	int
&&	O
control_char	(long)->(int)
(	O
ch	long
)	O
)	O
{	O
if	O
(	O
!	O
control_char	(long)->(int)
(	O
ch	long
^	O
0100	int
)	O
)	O
SNPRINTF1	O
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"^%c"	*(char)
,	O
(	O
(	O
char	O
)	O
ch	long
)	O
^	O
0100	int
)	O
;	O
else	O
SNPRINTF1	O
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
binfmt	*(char)
,	O
(	O
char	O
)	O
ch	long
)	O
;	O
}	O
else	O
if	O
(	O
is_ubin_char	(long)->(int)
(	O
ch	long
)	O
)	O
{	O
SNPRINTF1	O
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
utfbinfmt	*(char)
,	O
ch	long
)	O
;	O
}	O
else	O
{	O
char	O
*	O
p	*(char)
=	O
buf	*(char)
;	O
if	O
(	O
ch	long
>=	O
0x80000000	int
)	O
ch	long
=	O
0xFFFD	int
;	O
put_wchar	(*(*(char)),long)->(void)
(	O
&	O
p	*(char)
,	O
ch	long
)	O
;	O
*	O
p	*(char)
=	O
'\0'	O
;	O
}	O
return	O
(	O
buf	*(char)
)	O
;	O
}	O
public	O
int	O
utf_len	(char)->(int)
(	O
ch	long
)	O
unsigned	O
char	O
ch	long
;	O
{	O
if	O
(	O
(	O
ch	long
&	O
0x80	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
(	O
ch	long
&	O
0xE0	int
)	O
==	O
0xC0	int
)	O
return	O
2	int
;	O
if	O
(	O
(	O
ch	long
&	O
0xF0	int
)	O
==	O
0xE0	int
)	O
return	O
3	int
;	O
if	O
(	O
(	O
ch	long
&	O
0xF8	int
)	O
==	O
0xF0	int
)	O
return	O
4	int
;	O
if	O
(	O
(	O
ch	long
&	O
0xFC	int
)	O
==	O
0xF8	int
)	O
return	O
5	int
;	O
if	O
(	O
(	O
ch	long
&	O
0xFE	int
)	O
==	O
0xFC	int
)	O
return	O
6	int
;	O
return	O
1	int
;	O
}	O
public	O
int	O
is_utf8_well_formed	(*(char),int)->(int)
(	O
ss	*(char)
,	O
slen	int
)	O
char	O
*	O
ss	*(char)
;	O
int	O
slen	int
;	O
{	O
int	O
i	int
;	O
int	O
len	int
;	O
unsigned	O
char	O
*	O
s	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
ss	*(char)
;	O
if	O
(	O
IS_UTF8_INVALID	O
(	O
s	*(char)
[	O
0	int
]	O
)	O
)	O
return	O
(	O
0	int
)	O
;	O
len	int
=	O
utf_len	(char)->(int)
(	O
s	*(char)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
len	int
>	O
slen	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
len	int
==	O
1	int
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
len	int
==	O
2	int
)	O
{	O
if	O
(	O
s	*(char)
[	O
0	int
]	O
<	O
0xC2	int
)	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
unsigned	O
char	O
mask	char
;	O
mask	char
=	O
(	O
~	O
(	O
(	O
1	int
<<	O
(	O
8	int
-	O
len	int
)	O
)	O
-	O
1	int
)	O
)	O
&	O
0xFF	int
;	O
if	O
(	O
s	*(char)
[	O
0	int
]	O
==	O
mask	char
&&	O
(	O
s	*(char)
[	O
1	int
]	O
&	O
mask	char
)	O
==	O
0x80	int
)	O
return	O
(	O
0	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
IS_UTF8_TRAIL	O
(	O
s	*(char)
[	O
i	int
]	O
)	O
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
public	O
void	O
utf_skip_to_lead	(*(*(char)),*(char))->(void)
(	O
pp	*(*(char))
,	O
limit	*(char)
)	O
char	O
*	O
*	O
pp	*(*(char))
;	O
char	O
*	O
limit	*(char)
;	O
{	O
do	O
{	O
++	O
(	O
*	O
pp	*(*(char))
)	O
;	O
}	O
while	O
(	O
*	O
pp	*(*(char))
<	O
limit	*(char)
&&	O
!	O
IS_UTF8_LEAD	O
(	O
(	O
*	O
pp	*(*(char))
)	O
[	O
0	int
]	O
&	O
0377	int
)	O
&&	O
!	O
IS_ASCII_OCTET	O
(	O
(	O
*	O
pp	*(*(char))
)	O
[	O
0	int
]	O
)	O
)	O
;	O
}	O
public	O
LWCHAR	long
get_wchar	(*(char))->(long)
(	O
p	*(char)
)	O
constant	O
char	O
*	O
p	*(char)
;	O
{	O
switch	O
(	O
utf_len	(char)->(int)
(	O
p	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
case	O
1	int
:	O
default	O
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
p	*(char)
[	O
0	int
]	O
&	O
0xFF	int
)	O
;	O
case	O
2	int
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
(	O
(	O
p	*(char)
[	O
0	int
]	O
&	O
0x1F	int
)	O
<<	O
6	int
)	O
|	O
(	O
p	*(char)
[	O
1	int
]	O
&	O
0x3F	int
)	O
)	O
;	O
case	O
3	int
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
(	O
(	O
p	*(char)
[	O
0	int
]	O
&	O
0x0F	int
)	O
<<	O
12	int
)	O
|	O
(	O
(	O
p	*(char)
[	O
1	int
]	O
&	O
0x3F	int
)	O
<<	O
6	int
)	O
|	O
(	O
p	*(char)
[	O
2	int
]	O
&	O
0x3F	int
)	O
)	O
;	O
case	O
4	int
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
(	O
(	O
p	*(char)
[	O
0	int
]	O
&	O
0x07	int
)	O
<<	O
18	int
)	O
|	O
(	O
(	O
p	*(char)
[	O
1	int
]	O
&	O
0x3F	int
)	O
<<	O
12	int
)	O
|	O
(	O
(	O
p	*(char)
[	O
2	int
]	O
&	O
0x3F	int
)	O
<<	O
6	int
)	O
|	O
(	O
p	*(char)
[	O
3	int
]	O
&	O
0x3F	int
)	O
)	O
;	O
case	O
5	int
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
(	O
(	O
p	*(char)
[	O
0	int
]	O
&	O
0x03	int
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
p	*(char)
[	O
1	int
]	O
&	O
0x3F	int
)	O
<<	O
18	int
)	O
|	O
(	O
(	O
p	*(char)
[	O
2	int
]	O
&	O
0x3F	int
)	O
<<	O
12	int
)	O
|	O
(	O
(	O
p	*(char)
[	O
3	int
]	O
&	O
0x3F	int
)	O
<<	O
6	int
)	O
|	O
(	O
p	*(char)
[	O
4	int
]	O
&	O
0x3F	int
)	O
)	O
;	O
case	O
6	int
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
(	O
(	O
p	*(char)
[	O
0	int
]	O
&	O
0x01	int
)	O
<<	O
30	int
)	O
|	O
(	O
(	O
p	*(char)
[	O
1	int
]	O
&	O
0x3F	int
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
p	*(char)
[	O
2	int
]	O
&	O
0x3F	int
)	O
<<	O
18	int
)	O
|	O
(	O
(	O
p	*(char)
[	O
3	int
]	O
&	O
0x3F	int
)	O
<<	O
12	int
)	O
|	O
(	O
(	O
p	*(char)
[	O
4	int
]	O
&	O
0x3F	int
)	O
<<	O
6	int
)	O
|	O
(	O
p	*(char)
[	O
5	int
]	O
&	O
0x3F	int
)	O
)	O
;	O
}	O
}	O
public	O
void	O
put_wchar	(*(*(char)),long)->(void)
(	O
pp	*(*(char))
,	O
ch	long
)	O
char	O
*	O
*	O
pp	*(*(char))
;	O
LWCHAR	long
ch	long
;	O
{	O
if	O
(	O
!	O
utf_mode	int
||	O
ch	long
<	O
0x80	int
)	O
{	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
ch	long
;	O
}	O
else	O
if	O
(	O
ch	long
<	O
0x800	int
)	O
{	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0xC0	int
|	O
(	O
(	O
ch	long
>>	O
6	int
)	O
&	O
0x1F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
ch	long
&	O
0x3F	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
ch	long
<	O
0x10000	int
)	O
{	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0xE0	int
|	O
(	O
(	O
ch	long
>>	O
12	int
)	O
&	O
0x0F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
6	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
ch	long
&	O
0x3F	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
ch	long
<	O
0x200000	int
)	O
{	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0xF0	int
|	O
(	O
(	O
ch	long
>>	O
18	int
)	O
&	O
0x07	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
12	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
6	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
ch	long
&	O
0x3F	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
ch	long
<	O
0x4000000	int
)	O
{	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0xF0	int
|	O
(	O
(	O
ch	long
>>	O
24	int
)	O
&	O
0x03	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
18	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
12	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
6	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
ch	long
&	O
0x3F	int
)	O
)	O
;	O
}	O
else	O
{	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0xF0	int
|	O
(	O
(	O
ch	long
>>	O
30	int
)	O
&	O
0x01	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
24	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
18	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
12	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
6	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	*(*(char))
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
ch	long
&	O
0x3F	int
)	O
)	O
;	O
}	O
}	O
public	O
LWCHAR	long
step_char	(*(*(char)),int,*(char))->(long)
(	O
pp	*(*(char))
,	O
dir	int
,	O
limit	*(char)
)	O
char	O
*	O
*	O
pp	*(*(char))
;	O
signed	O
int	O
dir	int
;	O
constant	O
char	O
*	O
limit	*(char)
;	O
{	O
LWCHAR	long
ch	long
;	O
int	O
len	int
;	O
char	O
*	O
p	*(char)
=	O
*	O
pp	*(*(char))
;	O
if	O
(	O
!	O
utf_mode	int
)	O
{	O
if	O
(	O
dir	int
>	O
0	int
)	O
ch	long
=	O
(	O
LWCHAR	long
)	O
(	O
unsigned	O
char	O
)	O
(	O
(	O
p	*(char)
<	O
limit	*(char)
)	O
?	O
*	O
p	*(char)
++	O
:	O
0	int
)	O
;	O
else	O
ch	long
=	O
(	O
LWCHAR	long
)	O
(	O
unsigned	O
char	O
)	O
(	O
(	O
p	*(char)
>	O
limit	*(char)
)	O
?	O
*	O
--	O
p	*(char)
:	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
dir	int
>	O
0	int
)	O
{	O
len	int
=	O
utf_len	(char)->(int)
(	O
*	O
p	*(char)
)	O
;	O
if	O
(	O
p	*(char)
+	O
len	int
>	O
limit	*(char)
)	O
{	O
ch	long
=	O
0	int
;	O
p	*(char)
=	O
(	O
char	O
*	O
)	O
limit	*(char)
;	O
}	O
else	O
{	O
ch	long
=	O
get_wchar	(*(char))->(long)
(	O
p	*(char)
)	O
;	O
p	*(char)
+=	O
len	int
;	O
}	O
}	O
else	O
{	O
while	O
(	O
p	*(char)
>	O
limit	*(char)
&&	O
IS_UTF8_TRAIL	O
(	O
p	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
p	*(char)
--	O
;	O
if	O
(	O
p	*(char)
>	O
limit	*(char)
)	O
ch	long
=	O
get_wchar	(*(char))->(long)
(	O
--	O
p	*(char)
)	O
;	O
else	O
ch	long
=	O
0	int
;	O
}	O
*	O
pp	*(*(char))
=	O
p	*(char)
;	O
return	O
ch	long
;	O
}	O
DECLARE_RANGE_TABLE_START	O
(	O
compose	O
)	O
DECLARE_RANGE_TABLE_END	O
(	O
compose	O
)	O
DECLARE_RANGE_TABLE_START	O
(	O
ubin	int
)	O
DECLARE_RANGE_TABLE_END	O
(	O
ubin	int
)	O
DECLARE_RANGE_TABLE_START	O
(	O
wide	O
)	O
DECLARE_RANGE_TABLE_END	O
(	O
wide	O
)	O
DECLARE_RANGE_TABLE_START	O
(	O
fmt	*(char)
)	O
DECLARE_RANGE_TABLE_END	O
(	O
fmt	*(char)
)	O
static	O
struct	O
wchar_range	struct(long,long)
comb_table	array(struct(long,long))
[	O
]	O
=	O
{	O
{	O
0x0644	int
,	O
0x0622	int
}	O
,	O
{	O
0x0644	int
,	O
0x0623	int
}	O
,	O
{	O
0x0644	int
,	O
0x0625	int
}	O
,	O
{	O
0x0644	int
,	O
0x0627	int
}	O
,	O
}	O
;	O
static	O
int	O
is_in_table	(long,*(struct(*(struct(long,long)),int)))->(int)
(	O
ch	long
,	O
table	*(struct(long,long))
)	O
LWCHAR	long
ch	long
;	O
struct	O
wchar_range_table	struct(*(struct(long,long)),int)
*	O
table	*(struct(long,long))
;	O
{	O
int	O
hi	int
;	O
int	O
lo	int
;	O
if	O
(	O
ch	long
<	O
table	*(struct(long,long))
->	O
table	*(struct(long,long))
[	O
0	int
]	O
.	O
first	long
)	O
return	O
0	int
;	O
lo	int
=	O
0	int
;	O
hi	int
=	O
table	*(struct(long,long))
->	O
count	int
-	O
1	int
;	O
while	O
(	O
lo	int
<=	O
hi	int
)	O
{	O
int	O
mid	int
=	O
(	O
lo	int
+	O
hi	int
)	O
/	O
2	int
;	O
if	O
(	O
ch	long
>	O
table	*(struct(long,long))
->	O
table	*(struct(long,long))
[	O
mid	int
]	O
.	O
last	long
)	O
lo	int
=	O
mid	int
+	O
1	int
;	O
else	O
if	O
(	O
ch	long
<	O
table	*(struct(long,long))
->	O
table	*(struct(long,long))
[	O
mid	int
]	O
.	O
first	long
)	O
hi	int
=	O
mid	int
-	O
1	int
;	O
else	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
public	O
int	O
is_composing_char	(long)->(int)
(	O
ch	long
)	O
LWCHAR	long
ch	long
;	O
{	O
return	O
is_in_table	(long,*(struct(*(struct(long,long)),int)))->(int)
(	O
ch	long
,	O
&	O
compose_table	struct(*(struct(long,long)),int)
)	O
||	O
(	O
bs_mode	int
!=	O
BS_CONTROL	int
&&	O
is_in_table	(long,*(struct(*(struct(long,long)),int)))->(int)
(	O
ch	long
,	O
&	O
fmt_table	struct(*(struct(long,long)),int)
)	O
)	O
;	O
}	O
public	O
int	O
is_ubin_char	(long)->(int)
(	O
ch	long
)	O
LWCHAR	long
ch	long
;	O
{	O
int	O
ubin	int
=	O
is_in_table	(long,*(struct(*(struct(long,long)),int)))->(int)
(	O
ch	long
,	O
&	O
ubin_table	struct(*(struct(long,long)),int)
)	O
||	O
(	O
bs_mode	int
==	O
BS_CONTROL	int
&&	O
is_in_table	(long,*(struct(*(struct(long,long)),int)))->(int)
(	O
ch	long
,	O
&	O
fmt_table	struct(*(struct(long,long)),int)
)	O
)	O
;	O
return	O
ubin	int
;	O
}	O
public	O
int	O
is_wide_char	(long)->(int)
(	O
ch	long
)	O
LWCHAR	long
ch	long
;	O
{	O
return	O
is_in_table	(long,*(struct(*(struct(long,long)),int)))->(int)
(	O
ch	long
,	O
&	O
wide_table	struct(*(struct(long,long)),int)
)	O
;	O
}	O
public	O
int	O
is_combining_char	(long,long)->(int)
(	O
ch1	long
,	O
ch2	long
)	O
LWCHAR	long
ch1	long
;	O
LWCHAR	long
ch2	long
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
comb_table	array(struct(long,long))
)	O
/	O
sizeof	O
(	O
*	O
comb_table	array(struct(long,long))
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
ch1	long
==	O
comb_table	array(struct(long,long))
[	O
i	int
]	O
.	O
first	long
&&	O
ch2	long
==	O
comb_table	array(struct(long,long))
[	O
i	int
]	O
.	O
last	long
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
