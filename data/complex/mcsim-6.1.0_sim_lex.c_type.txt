PSTR	*(char)
vrgszLexTypes	O
[	O
]	O
=	O
{	O
"null-type??"	*(char)
,	O
"identifier"	*(char)
,	O
"integer"	*(char)
,	O
"integer-or-id"	*(char)
,	O
"floating-point"	*(char)
,	O
"float-or-id"	*(char)
,	O
"number"	*(char)
,	O
"number-or-id"	*(char)
,	O
"punctuation"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"quoted-string"	*(char)
,	O
""	*(char)
}	O
;	O
void	O
PreventLexSplit	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),int)->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
int	O
iOffset	int
)	O
{	O
long	O
lDelta	O
;	O
PBUF	*(char)
pbufEOB	O
=	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufOrg	*(char)
+	O
iOffset	int
;	O
PBUF	*(char)
pbufEOBOld	O
;	O
if	O
(	O
!	O
EOB	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
||	O
(	O
iOffset	int
==	O
BUFFER_SIZE	O
)	O
)	O
{	O
pbufEOBOld	O
=	O
pbufEOB	O
;	O
while	O
(	O
*	O
(	O
--	O
pbufEOB	O
)	O
!=	O
CH_EOLN	O
)	O
;	O
*	O
pbufEOB	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
lDelta	O
=	O
(	O
long	O
)	O
(	O
pbufEOB	O
-	O
pbufEOBOld	O
)	O
)	O
)	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
lDelta	O
,	O
SEEK_CUR	O
)	O
;	O
}	O
else	O
*	O
pbufEOB	O
=	O
'\0'	O
;	O
}	O
int	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
{	O
int	O
iReturn	O
=	O
0	int
;	O
int	O
iOffset	int
;	O
if	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
&&	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
&&	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufOrg	*(char)
)	O
{	O
if	O
(	O
(	O
iOffset	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufOrg	*(char)
,	O
1	int
,	O
BUFFER_SIZE	O
,	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
{	O
iReturn	O
=	O
(	O
int	O
)	O
iOffset	int
;	O
PreventLexSplit	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),int)->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
iOffset	int
)	O
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
=	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufOrg	*(char)
;	O
}	O
else	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
iReturn	O
=	O
EOF	O
;	O
else	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_FATAL	O
,	O
"Unexpected end of file."	*(char)
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
iReturn	O
)	O
;	O
}	O
BOOL	int
InitBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char))->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szFullPathname	*(char)
)	O
{	O
BOOL	int
bReturn	O
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
return	O
FALSE	O
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
iLineNum	int
=	O
1	int
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
iLNPrev	int
=	O
0	int
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
cErrors	int
=	O
0	int
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pInfo	*(void)
=	O
NULL	O
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
=	O
NULL	O
;	O
if	O
(	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
szFullPathname	*(char)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufOrg	*(char)
=	O
(	O
PBUF	*(char)
)	O
malloc	(long)->(*(void))
(	O
BUFFER_SIZE	O
)	O
)	O
)	O
bReturn	O
=	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
else	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"InitBuffer"	*(char)
,	O
NULL	O
)	O
;	O
}	O
else	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_FILENOTFOUND	O
|	O
RE_FATAL	O
,	O
szFullPathname	*(char)
,	O
NULL	O
)	O
;	O
return	O
(	O
bReturn	O
)	O
;	O
}	O
void	O
MakeStringBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pBuf	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pbufStr	O
,	O
PSTR	*(char)
sz	*(char)
)	O
{	O
pbufStr	O
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
pbufStr	O
->	O
pbufCur	*(char)
=	O
pbufStr	O
->	O
pbufOrg	*(char)
=	O
sz	*(char)
;	O
pbufStr	O
->	O
iLineNum	int
=	O
0	int
;	O
pbufStr	O
->	O
iLNPrev	int
=	O
0	int
;	O
pbufStr	O
->	O
pInfo	*(void)
=	O
(	O
pBuf	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
?	O
pBuf	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pInfo	*(void)
:	O
NULL	O
)	O
;	O
if	O
(	O
pBuf	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
{	O
pbufStr	O
->	O
iLineNum	int
=	O
pBuf	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
iLineNum	int
;	O
pbufStr	O
->	O
iLNPrev	int
=	O
TRUE	O
;	O
}	O
}	O
void	O
FlushBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
{	O
PBUF	*(char)
pbuf	O
=	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufOrg	*(char)
;	O
while	O
(	O
*	O
pbuf	O
)	O
printf	(*(char))->(int)
(	O
"%c"	*(char)
,	O
*	O
pbuf	O
++	O
)	O
;	O
printf	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
int	O
SkipWhitespace	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
{	O
char	O
c	O
;	O
int	O
fSkipped	O
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
return	O
0	int
;	O
if	O
(	O
!	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
&&	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
while	O
(	O
isspace	(int)->(int)
(	O
c	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
||	O
c	O
==	O
CH_COMMENT	O
)	O
{	O
fSkipped	O
=	O
1	int
;	O
if	O
(	O
c	O
==	O
CH_COMMENT	O
)	O
SkipComment	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
else	O
{	O
if	O
(	O
c	O
==	O
'\n'	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
iLineNum	int
++	O
;	O
if	O
(	O
!	O
*	O
(	O
++	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
&&	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
if	O
(	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
==	O
EOF	O
)	O
break	O
;	O
}	O
}	O
return	O
(	O
fSkipped	O
)	O
;	O
}	O
void	O
GetArrayBounds	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(long),*(long))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PLONG	*(long)
piLB	*(long)
,	O
PLONG	*(long)
piUB	*(long)
)	O
{	O
PSTRLEX	array(char)
szTmp	O
;	O
if	O
(	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
LX_INTEGER	O
)	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_INIT	O
|	O
RE_FATAL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
*	O
piLB	*(long)
=	O
atol	(*(char))->(long)
(	O
szTmp	O
)	O
;	O
if	O
(	O
*	O
piLB	*(long)
<	O
0	int
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_POSITIVE	O
|	O
RE_FATAL	O
,	O
szTmp	O
,	O
NULL	O
)	O
;	O
if	O
(	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(char)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
==	O
'-'	O
)	O
{	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
++	O
;	O
if	O
(	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
LX_INTEGER	O
)	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_INIT	O
|	O
RE_FATAL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
*	O
piUB	*(long)
=	O
atol	(*(char))->(long)
(	O
szTmp	O
)	O
+	O
1	int
;	O
if	O
(	O
*	O
piUB	*(long)
<=	O
*	O
piLB	*(long)
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_UNKNOWN	O
|	O
RE_FATAL	O
,	O
""	*(char)
,	O
"Upper bound must be higher than lower bound"	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
']'	O
)	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"]"	*(char)
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
']'	O
)	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"]"	*(char)
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
*	O
piUB	*(long)
=	O
*	O
piLB	*(long)
+	O
1	int
;	O
}	O
}	O
}	O
}	O
void	O
GetaString	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
int	O
i	O
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
||	O
!	O
szLex	*(char)
)	O
return	O
;	O
if	O
(	O
IsString	O
(	O
(	O
PSTR	*(char)
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
)	O
{	O
do	O
szLex	*(char)
[	O
i	O
++	O
]	O
=	O
*	O
++	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
;	O
while	O
(	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
&&	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
!=	O
CH_STRDELIM	O
)	O
&&	O
(	O
i	O
<	O
MAX_LEX	int
-	O
1	int
)	O
)	O
;	O
}	O
if	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
==	O
CH_STRDELIM	O
)	O
{	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
++	O
;	O
i	O
--	O
;	O
}	O
szLex	*(char)
[	O
i	O
]	O
=	O
'\0'	O
;	O
}	O
void	O
GetIdentifier	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
int	O
i	O
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
||	O
!	O
szLex	*(char)
)	O
return	O
;	O
if	O
(	O
isalpha	(int)->(int)
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
||	O
IsUnderscore	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
)	O
{	O
do	O
szLex	*(char)
[	O
i	O
++	O
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
++	O
;	O
while	O
(	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
&&	O
(	O
isalnum	(int)->(int)
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
||	O
IsUnderscore	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
)	O
&&	O
(	O
i	O
<	O
MAX_LEX	int
-	O
1	int
)	O
)	O
;	O
}	O
szLex	*(char)
[	O
i	O
]	O
=	O
'\0'	O
;	O
}	O
void	O
GetNumber	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),*(int))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
PINT	*(int)
piLexType	*(int)
)	O
{	O
int	O
i	O
=	O
0	int
;	O
char	O
c	O
;	O
BOOL	int
bHasSign	O
=	O
FALSE	O
;	O
BOOL	int
bLeadingDigits	O
=	O
FALSE	O
;	O
enum	O
States	O
{	O
Start	O
,	O
Digits1	O
,	O
Point	O
,	O
Digits2	O
,	O
Exp	O
,	O
ExpSign	O
,	O
Digits3	O
,	O
End	O
}	O
eState	O
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
||	O
!	O
szLex	*(char)
||	O
!	O
piLexType	*(int)
)	O
return	O
;	O
eState	O
=	O
Start	O
;	O
*	O
piLexType	*(int)
=	O
LX_NULL	O
;	O
while	O
(	O
(	O
c	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
&&	O
i	O
<	O
MAX_LEX	int
-	O
1	int
&&	O
eState	O
!=	O
End	O
)	O
{	O
switch	O
(	O
eState	O
)	O
{	O
case	O
Start	O
:	O
if	O
(	O
c	O
==	O
'.'	O
)	O
eState	O
=	O
Point	O
;	O
else	O
if	O
(	O
!	O
bHasSign	O
&&	O
IsSign	O
(	O
c	O
)	O
)	O
bHasSign	O
=	O
TRUE	O
;	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
)	O
{	O
bLeadingDigits	O
=	O
*	O
piLexType	*(int)
=	O
LX_INTEGER	O
;	O
eState	O
=	O
Digits1	O
;	O
}	O
else	O
eState	O
=	O
End	O
;	O
break	O
;	O
case	O
Digits1	O
:	O
if	O
(	O
c	O
==	O
'.'	O
)	O
eState	O
=	O
Point	O
;	O
else	O
if	O
(	O
c	O
==	O
'e'	O
||	O
c	O
==	O
'E'	O
)	O
eState	O
=	O
Exp	O
;	O
else	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
c	O
)	O
)	O
eState	O
=	O
End	O
;	O
break	O
;	O
case	O
Point	O
:	O
*	O
piLexType	*(int)
=	O
LX_FLOAT	O
;	O
if	O
(	O
bLeadingDigits	O
&&	O
(	O
c	O
==	O
'e'	O
||	O
c	O
==	O
'E'	O
)	O
)	O
eState	O
=	O
Exp	O
;	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
c	O
)	O
)	O
eState	O
=	O
Digits2	O
;	O
else	O
{	O
if	O
(	O
!	O
bLeadingDigits	O
)	O
*	O
piLexType	*(int)
=	O
LX_NULL	O
;	O
eState	O
=	O
End	O
;	O
}	O
break	O
;	O
case	O
Digits2	O
:	O
if	O
(	O
c	O
==	O
'e'	O
||	O
c	O
==	O
'E'	O
)	O
eState	O
=	O
Exp	O
;	O
else	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
c	O
)	O
)	O
eState	O
=	O
End	O
;	O
break	O
;	O
case	O
Exp	O
:	O
*	O
piLexType	*(int)
=	O
LX_FLOAT	O
;	O
if	O
(	O
IsSign	O
(	O
c	O
)	O
)	O
{	O
eState	O
=	O
ExpSign	O
;	O
break	O
;	O
}	O
case	O
ExpSign	O
:	O
if	O
(	O
isdigit	(int)->(int)
(	O
c	O
)	O
)	O
eState	O
=	O
Digits3	O
;	O
else	O
{	O
*	O
piLexType	*(int)
=	O
LX_NULL	O
;	O
eState	O
=	O
End	O
;	O
}	O
break	O
;	O
case	O
Digits3	O
:	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
c	O
)	O
)	O
eState	O
=	O
End	O
;	O
break	O
;	O
case	O
End	O
:	O
break	O
;	O
}	O
if	O
(	O
eState	O
!=	O
End	O
)	O
szLex	*(char)
[	O
i	O
++	O
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
++	O
;	O
}	O
szLex	*(char)
[	O
i	O
]	O
=	O
'\0'	O
;	O
}	O
void	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTRLEX	array(char)
szLex	*(char)
,	O
PINT	*(int)
piLexType	*(int)
)	O
{	O
char	O
c	O
;	O
BOOL	int
fDone	O
=	O
FALSE	O
;	O
*	O
piLexType	*(int)
=	O
LX_NULL	O
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
||	O
!	O
szLex	*(char)
||	O
!	O
piLexType	*(int)
||	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
return	O
;	O
while	O
(	O
!	O
fDone	O
)	O
{	O
fDone	O
=	O
TRUE	O
;	O
SkipWhitespace	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
if	O
(	O
!	O
EOB	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
)	O
{	O
c	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
;	O
if	O
(	O
c	O
==	O
CH_COMMENT	O
)	O
{	O
fDone	O
=	O
FALSE	O
;	O
SkipComment	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
}	O
else	O
if	O
(	O
isalpha	(int)->(int)
(	O
c	O
)	O
||	O
IsUnderscore	O
(	O
c	O
)	O
)	O
{	O
*	O
piLexType	*(int)
=	O
LX_IDENTIFIER	O
;	O
GetIdentifier	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
c	O
)	O
||	O
c	O
==	O
'.'	O
||	O
IsSign	O
(	O
c	O
)	O
)	O
{	O
GetNumber	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
piLexType	*(int)
)	O
;	O
if	O
(	O
IsSign	O
(	O
c	O
)	O
&&	O
!	O
*	O
piLexType	*(int)
)	O
{	O
szLex	*(char)
[	O
0	int
]	O
=	O
c	O
;	O
szLex	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
*	O
piLexType	*(int)
=	O
LX_PUNCT	O
;	O
}	O
}	O
else	O
if	O
(	O
c	O
==	O
CH_STRDELIM	O
)	O
{	O
*	O
piLexType	*(int)
=	O
LX_STRING	O
;	O
GetaString	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
)	O
;	O
}	O
else	O
{	O
*	O
piLexType	*(int)
=	O
LX_PUNCT	O
;	O
szLex	*(char)
[	O
0	int
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
++	O
;	O
szLex	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
}	O
}	O
BOOL	int
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTRLEX	array(char)
szLex	*(char)
,	O
int	O
iType	int
)	O
{	O
int	O
iLex	O
,	O
iErr	O
;	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
iLex	O
)	O
;	O
if	O
(	O
(	O
iErr	O
=	O
!	O
(	O
iType	int
&	O
iLex	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
vrgszLexTypes	O
[	O
iType	int
]	O
,	O
szLex	*(char)
)	O
;	O
return	O
(	O
iErr	O
)	O
;	O
}	O
void	O
SkipComment	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
{	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
return	O
;	O
if	O
(	O
!	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
while	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
++	O
!=	O
CH_EOLN	O
)	O
if	O
(	O
!	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
if	O
(	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
==	O
EOF	O
)	O
break	O
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
iLineNum	int
++	O
;	O
if	O
(	O
!	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
}	O
char	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(char)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
{	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
||	O
(	O
!	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
&&	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
==	O
EOF	O
)	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
return	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
;	O
}	O
int	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
char	O
chPunct	char
)	O
{	O
int	O
iReturn	O
,	O
iType	int
;	O
iReturn	O
=	O
SkipWhitespace	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
if	O
(	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(char)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
==	O
chPunct	char
)	O
{	O
iReturn	O
=	O
TRUE	O
;	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
iType	int
)	O
;	O
}	O
return	O
(	O
iReturn	O
)	O
;	O
}	O
int	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
char	O
chPunct	char
)	O
{	O
int	O
iType	int
;	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
iType	int
)	O
;	O
return	O
(	O
(	O
iType	int
==	O
LX_PUNCT	O
)	O
&&	O
szLex	*(char)
[	O
0	int
]	O
==	O
chPunct	char
)	O
;	O
}	O
int	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
char	O
chPunct	char
)	O
{	O
int	O
iReturn	O
;	O
iReturn	O
=	O
!	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
chPunct	char
)	O
;	O
if	O
(	O
iReturn	O
)	O
{	O
szLex	*(char)
[	O
1	int
]	O
=	O
chPunct	char
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_EXPECTED	O
,	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
iReturn	O
)	O
;	O
}	O
void	O
EatStatement	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
{	O
char	O
c	O
;	O
if	O
(	O
!	O
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
return	O
;	O
while	O
(	O
(	O
c	O
=	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(char)
(	O
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
)	O
&&	O
(	O
c	O
!=	O
CH_STMTTERM	O
)	O
)	O
{	O
if	O
(	O
c	O
==	O
CH_EOLN	O
)	O
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
iLineNum	int
++	O
;	O
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
++	O
;	O
}	O
if	O
(	O
c	O
)	O
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
++	O
;	O
}	O
void	O
GetStatement	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szStmt	*(char)
)	O
{	O
int	O
i	O
,	O
fDone	O
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
||	O
!	O
szStmt	*(char)
)	O
return	O
;	O
SkipWhitespace	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
i	O
=	O
0	int
;	O
if	O
(	O
!	O
EOB	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
)	O
{	O
while	O
(	O
!	O
fDone	O
)	O
{	O
if	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
)	O
{	O
if	O
(	O
!	O
(	O
fDone	O
=	O
(	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(char)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
==	O
CH_STMTTERM	O
)	O
)	O
)	O
{	O
if	O
(	O
i	O
<	O
MAX_EQN	int
-	O
2	int
)	O
{	O
if	O
(	O
(	O
szStmt	*(char)
[	O
i	O
++	O
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
++	O
)	O
==	O
CH_EOLN	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
iLineNum	int
++	O
;	O
}	O
else	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_EQNTOOLONG	O
|	O
RE_FATAL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
fDone	O
=	O
(	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
==	O
EOF	O
)	O
;	O
}	O
}	O
szStmt	*(char)
[	O
i	O
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
!	O
i	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"rvalue to assignment"	*(char)
,	O
NULL	O
)	O
;	O
}	O
int	O
NextListItem	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),int,int,char)->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
int	O
bIdTypes	O
,	O
int	O
fItemNum	O
,	O
char	O
cListTerm	O
)	O
{	O
int	O
iType	int
,	O
iReturn	O
=	O
0	int
;	O
if	O
(	O
!	O
fItemNum	O
||	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
)	O
{	O
if	O
(	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(char)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
!=	O
cListTerm	O
)	O
{	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
iType	int
&	O
bIdTypes	O
)	O
iReturn	O
=	O
1	int
;	O
else	O
iReturn	O
=	O
-	O
1	int
;	O
}	O
}	O
return	O
(	O
iReturn	O
)	O
;	O
}	O
BOOL	int
GetFuncArgs	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),int,*(int),*(char))->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
int	O
nArgs	O
,	O
int	O
rgiArgTypes	O
[	O
]	O
,	O
PSTR	*(char)
szArgs	O
)	O
{	O
BOOL	int
bOK	O
=	O
TRUE	O
;	O
int	O
i	O
,	O
iType	int
;	O
PSTRLEX	array(char)
szPunct	O
;	O
if	O
(	O
!	O
(	O
bOK	O
=	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szPunct	O
,	O
CH_LPAREN	O
)	O
)	O
)	O
{	O
szPunct	O
[	O
1	int
]	O
=	O
CH_LPAREN	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_EXPECTED	O
,	O
szPunct	O
,	O
NULL	O
)	O
;	O
}	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nArgs	O
&&	O
bOK	O
;	O
i	O
++	O
,	O
szArgs	O
+=	O
MAX_LEX	int
)	O
{	O
if	O
(	O
i	O
)	O
if	O
(	O
!	O
(	O
bOK	O
=	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szArgs	O
,	O
','	O
)	O
)	O
)	O
{	O
*	O
(	O
szArgs	O
+	O
1	int
)	O
=	O
','	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_EXPECTED	O
,	O
szArgs	O
,	O
NULL	O
)	O
;	O
return	O
(	O
bOK	O
)	O
;	O
}	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szArgs	O
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
(	O
bOK	O
&=	O
(	O
iType	int
&	O
rgiArgTypes	O
[	O
i	O
]	O
)	O
>	O
0	int
)	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
vrgszLexTypes	O
[	O
rgiArgTypes	O
[	O
i	O
]	O
]	O
,	O
szArgs	O
)	O
;	O
return	O
(	O
bOK	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
bOK	O
=	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szPunct	O
,	O
CH_RPAREN	O
)	O
)	O
)	O
{	O
szPunct	O
[	O
1	int
]	O
=	O
CH_RPAREN	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_EXPECTED	O
,	O
szPunct	O
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
bOK	O
)	O
;	O
}	O
void	O
UnrollEquation	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),long,*(char),*(char))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
long	O
index	(*(char),int)->(*(char))
,	O
PSTR	*(char)
szEqn	*(char)
,	O
PSTR	*(char)
szEqnU	*(char)
)	O
{	O
int	O
j	O
=	O
0	int
,	O
k	O
=	O
0	int
,	O
m	O
;	O
BOOL	int
bExpress	O
=	O
FALSE	O
;	O
PSTRLEX	array(char)
szExpression	O
;	O
while	O
(	O
(	O
szEqn	*(char)
[	O
j	O
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
k	O
<	O
MAX_EQN	int
-	O
1	int
)	O
)	O
{	O
if	O
(	O
bExpress	O
)	O
{	O
m	O
=	O
0	int
;	O
while	O
(	O
(	O
szEqn	*(char)
[	O
j	O
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
szEqn	*(char)
[	O
j	O
]	O
!=	O
']'	O
)	O
&&	O
(	O
m	O
<	O
MAX_EQN	int
-	O
1	int
)	O
)	O
{	O
szExpression	O
[	O
m	O
]	O
=	O
szEqn	*(char)
[	O
j	O
]	O
;	O
j	O
++	O
;	O
m	O
++	O
;	O
}	O
if	O
(	O
szEqn	*(char)
[	O
j	O
]	O
==	O
']'	O
)	O
{	O
j	O
++	O
;	O
bExpress	O
=	O
FALSE	O
;	O
}	O
if	O
(	O
(	O
szEqn	*(char)
[	O
j	O
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
m	O
==	O
MAX_EQN	int
-	O
1	int
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_EQNTOOLONG	O
|	O
RE_FATAL	O
,	O
NULL	O
,	O
"(Occured while unrolling a loop)"	*(char)
)	O
;	O
szExpression	O
[	O
m	O
]	O
=	O
'\0'	O
;	O
m	O
=	O
0	int
;	O
while	O
(	O
(	O
szExpression	O
[	O
m	O
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
m	O
<	O
MAX_EQN	int
-	O
1	int
)	O
)	O
{	O
szEqnU	*(char)
[	O
k	O
]	O
=	O
szExpression	O
[	O
m	O
]	O
;	O
k	O
++	O
;	O
m	O
++	O
;	O
}	O
}	O
else	O
switch	O
(	O
szEqn	*(char)
[	O
j	O
]	O
)	O
{	O
case	O
'['	O
:	O
szEqnU	*(char)
[	O
k	O
]	O
=	O
'_'	O
;	O
j	O
++	O
;	O
k	O
++	O
;	O
bExpress	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
']'	O
:	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_UNEXPECTED	O
|	O
RE_FATAL	O
,	O
"]"	*(char)
,	O
"(Could be nested brackets)"	*(char)
)	O
;	O
default	O
:	O
szEqnU	*(char)
[	O
k	O
]	O
=	O
szEqn	*(char)
[	O
j	O
]	O
;	O
j	O
++	O
;	O
k	O
++	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
szEqn	*(char)
[	O
j	O
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
k	O
==	O
MAX_EQN	int
-	O
1	int
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_EQNTOOLONG	O
|	O
RE_FATAL	O
,	O
NULL	O
,	O
"(Occured in UnrollEquation)"	*(char)
)	O
;	O
szEqnU	*(char)
[	O
k	O
]	O
=	O
'\0'	O
;	O
}	O
