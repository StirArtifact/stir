static	O
const	O
char	O
*	O
const	O
categories	array(*(char))
[	O
]	O
=	O
{	O
"books"	*(char)
,	O
"images"	*(char)
,	O
"music"	*(char)
,	O
"software"	*(char)
,	O
"videos"	*(char)
,	O
"other"	*(char)
,	O
NULL	O
,	O
}	O
;	O
struct	O
Language	struct(*(char),*(char))
{	O
const	O
char	O
*	O
dirname	*(char)
;	O
const	O
char	O
*	O
longname	*(char)
;	O
}	O
;	O
static	O
const	O
struct	O
Language	struct(*(char),*(char))
languages	array(struct(*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"no-lang"	*(char)
,	O
"No language specified"	*(char)
}	O
,	O
{	O
"en"	*(char)
,	O
"English"	*(char)
}	O
,	O
{	O
"de"	*(char)
,	O
"German"	*(char)
}	O
,	O
{	O
"fr"	*(char)
,	O
"French"	*(char)
}	O
,	O
{	O
"es"	*(char)
,	O
"Spanish"	*(char)
}	O
,	O
{	O
NULL	O
,	O
NULL	O
}	O
,	O
}	O
;	O
static	O
struct	O
MHD_Response	O
*	O
file_not_found_response	*(struct)
;	O
static	O
struct	O
MHD_Response	O
*	O
internal_error_response	*(struct)
;	O
static	O
struct	O
MHD_Response	O
*	O
cached_directory_response	*(struct)
;	O
static	O
struct	O
MHD_Response	O
*	O
request_refused_response	*(struct)
;	O
static	O
pthread_mutex_t	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
;	O
static	O
void	O
mark_as_html	(*(struct))->(void)
(	O
struct	O
MHD_Response	O
*	O
response	*(struct)
)	O
{	O
(	O
void	O
)	O
MHD_add_response_header	(*(struct),*(char),*(char))->(int)
(	O
response	*(struct)
,	O
MHD_HTTP_HEADER_CONTENT_TYPE	*(char)
,	O
"text/html"	*(char)
)	O
;	O
}	O
static	O
void	O
update_cached_response	(*(struct))->(void)
(	O
struct	O
MHD_Response	O
*	O
response	*(struct)
)	O
{	O
(	O
void	O
)	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
NULL	O
!=	O
cached_directory_response	*(struct)
)	O
MHD_destroy_response	(*(struct))->(void)
(	O
cached_directory_response	*(struct)
)	O
;	O
cached_directory_response	*(struct)
=	O
response	*(struct)
;	O
(	O
void	O
)	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
}	O
struct	O
ResponseDataContext	struct(*(char),long,long)
{	O
char	O
*	O
buf	*(char)
;	O
size_t	long
buf_len	long
;	O
size_t	long
off	long
;	O
}	O
;	O
static	O
int	O
list_directory	(*(struct(*(char),long,long)),*(char))->(int)
(	O
struct	O
ResponseDataContext	struct(*(char),long,long)
*	O
rdc	*(struct(*(char),long,long))
,	O
const	O
char	O
*	O
dirname	*(char)
)	O
{	O
char	O
fullname	array(char)
[	O
PATH_MAX	int
]	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
DIR	struct
*	O
dir	*(struct)
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
de	*(struct(long,long,short,char,array(char)))
;	O
if	O
(	O
NULL	O
==	O
(	O
dir	*(struct)
=	O
opendir	(*(char))->(*(struct))
(	O
dirname	*(char)
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
while	O
(	O
NULL	O
!=	O
(	O
de	*(struct(long,long,short,char,array(char)))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dir	*(struct)
)	O
)	O
)	O
{	O
if	O
(	O
'.'	O
==	O
de	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
0	int
]	O
)	O
continue	O
;	O
if	O
(	O
sizeof	O
(	O
fullname	array(char)
)	O
<=	O
(	O
unsigned	O
int	O
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
fullname	array(char)
,	O
sizeof	O
(	O
fullname	array(char)
)	O
,	O
"%s/%s"	*(char)
,	O
dirname	*(char)
,	O
de	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
)	O
continue	O
;	O
if	O
(	O
0	int
!=	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
fullname	array(char)
,	O
&	O
sbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
S_ISREG	O
(	O
sbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
continue	O
;	O
if	O
(	O
rdc	*(struct(*(char),long,long))
->	O
off	long
+	O
1024	int
>	O
rdc	*(struct(*(char),long,long))
->	O
buf_len	long
)	O
{	O
void	O
*	O
r	*(void)
;	O
if	O
(	O
(	O
2	int
*	O
rdc	*(struct(*(char),long,long))
->	O
buf_len	long
+	O
1024	int
)	O
<	O
rdc	*(struct(*(char),long,long))
->	O
buf_len	long
)	O
break	O
;	O
rdc	*(struct(*(char),long,long))
->	O
buf_len	long
=	O
2	int
*	O
rdc	*(struct(*(char),long,long))
->	O
buf_len	long
+	O
1024	int
;	O
if	O
(	O
NULL	O
==	O
(	O
r	*(void)
=	O
realloc	(*(void),long)->(*(void))
(	O
rdc	*(struct(*(char),long,long))
->	O
buf	*(char)
,	O
rdc	*(struct(*(char),long,long))
->	O
buf_len	long
)	O
)	O
)	O
break	O
;	O
rdc	*(struct(*(char),long,long))
->	O
buf	*(char)
=	O
r	*(void)
;	O
}	O
rdc	*(struct(*(char),long,long))
->	O
off	long
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
&	O
rdc	*(struct(*(char),long,long))
->	O
buf	*(char)
[	O
rdc	*(struct(*(char),long,long))
->	O
off	long
]	O
,	O
rdc	*(struct(*(char),long,long))
->	O
buf_len	long
-	O
rdc	*(struct(*(char),long,long))
->	O
off	long
,	O
"<li><a href=\"/%s\">%s</a></li>\n"	*(char)
,	O
fullname	array(char)
,	O
de	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
}	O
(	O
void	O
)	O
closedir	(*(struct))->(int)
(	O
dir	*(struct)
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
update_directory	()->(void)
(	O
)	O
{	O
static	O
size_t	long
initial_allocation	long
=	O
32	int
*	O
1024	int
;	O
struct	O
MHD_Response	O
*	O
response	*(struct)
;	O
struct	O
ResponseDataContext	struct(*(char),long,long)
rdc	*(struct(*(char),long,long))
;	O
unsigned	O
int	O
language_idx	int
;	O
unsigned	O
int	O
category_idx	int
;	O
const	O
struct	O
Language	struct(*(char),*(char))
*	O
language	*(struct(*(char),*(char)))
;	O
const	O
char	O
*	O
category	*(char)
;	O
char	O
dir_name	array(char)
[	O
128	int
]	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
rdc	*(struct(*(char),long,long))
.	O
buf_len	long
=	O
initial_allocation	long
;	O
if	O
(	O
NULL	O
==	O
(	O
rdc	*(struct(*(char),long,long))
.	O
buf	*(char)
=	O
malloc	(long)->(*(void))
(	O
rdc	*(struct(*(char),long,long))
.	O
buf_len	long
)	O
)	O
)	O
{	O
update_cached_response	(*(struct))->(void)
(	O
NULL	O
)	O
;	O
return	O
;	O
}	O
rdc	*(struct(*(char),long,long))
.	O
off	long
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
rdc	*(struct(*(char),long,long))
.	O
buf	*(char)
,	O
rdc	*(struct(*(char),long,long))
.	O
buf_len	long
,	O
"%s"	*(char)
,	O
INDEX_PAGE_HEADER	O
)	O
;	O
for	O
(	O
language_idx	int
=	O
0	int
;	O
NULL	O
!=	O
languages	array(struct(*(char),*(char)))
[	O
language_idx	int
]	O
.	O
dirname	*(char)
;	O
language_idx	int
++	O
)	O
{	O
language	*(struct(*(char),*(char)))
=	O
&	O
languages	array(struct(*(char),*(char)))
[	O
language_idx	int
]	O
;	O
if	O
(	O
0	int
!=	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
language	*(struct(*(char),*(char)))
->	O
dirname	*(char)
,	O
&	O
sbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
continue	O
;	O
rdc	*(struct(*(char),long,long))
.	O
off	long
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
&	O
rdc	*(struct(*(char),long,long))
.	O
buf	*(char)
[	O
rdc	*(struct(*(char),long,long))
.	O
off	long
]	O
,	O
rdc	*(struct(*(char),long,long))
.	O
buf_len	long
-	O
rdc	*(struct(*(char),long,long))
.	O
off	long
,	O
"<h2>%s</h2>\n"	*(char)
,	O
language	*(struct(*(char),*(char)))
->	O
longname	*(char)
)	O
;	O
for	O
(	O
category_idx	int
=	O
0	int
;	O
NULL	O
!=	O
categories	array(*(char))
[	O
category_idx	int
]	O
;	O
category_idx	int
++	O
)	O
{	O
category	*(char)
=	O
categories	array(*(char))
[	O
category_idx	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
dir_name	array(char)
,	O
sizeof	O
(	O
dir_name	array(char)
)	O
,	O
"%s/%s"	*(char)
,	O
language	*(struct(*(char),*(char)))
->	O
dirname	*(char)
,	O
category	*(char)
)	O
;	O
if	O
(	O
0	int
!=	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
dir_name	array(char)
,	O
&	O
sbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
continue	O
;	O
rdc	*(struct(*(char),long,long))
.	O
off	long
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
&	O
rdc	*(struct(*(char),long,long))
.	O
buf	*(char)
[	O
rdc	*(struct(*(char),long,long))
.	O
off	long
]	O
,	O
rdc	*(struct(*(char),long,long))
.	O
buf_len	long
-	O
rdc	*(struct(*(char),long,long))
.	O
off	long
,	O
"<h3>%s</h3>\n"	*(char)
,	O
category	*(char)
)	O
;	O
if	O
(	O
MHD_NO	int
==	O
list_directory	(*(struct(*(char),long,long)),*(char))->(int)
(	O
&	O
rdc	*(struct(*(char),long,long))
,	O
dir_name	array(char)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
rdc	*(struct(*(char),long,long))
.	O
buf	*(char)
)	O
;	O
update_cached_response	(*(struct))->(void)
(	O
NULL	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
rdc	*(struct(*(char),long,long))
.	O
off	long
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
&	O
rdc	*(struct(*(char),long,long))
.	O
buf	*(char)
[	O
rdc	*(struct(*(char),long,long))
.	O
off	long
]	O
,	O
rdc	*(struct(*(char),long,long))
.	O
buf_len	long
-	O
rdc	*(struct(*(char),long,long))
.	O
off	long
,	O
"%s"	*(char)
,	O
INDEX_PAGE_FOOTER	*(char)
)	O
;	O
initial_allocation	long
=	O
rdc	*(struct(*(char),long,long))
.	O
buf_len	long
;	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
rdc	*(struct(*(char),long,long))
.	O
off	long
,	O
rdc	*(struct(*(char),long,long))
.	O
buf	*(char)
,	O
MHD_RESPMEM_MUST_FREE	int
)	O
;	O
mark_as_html	(*(struct))->(void)
(	O
response	*(struct)
)	O
;	O
update_cached_response	(*(struct))->(void)
(	O
response	*(struct)
)	O
;	O
}	O
struct	O
UploadContext	struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct))
{	O
int	O
fd	int
;	O
char	O
*	O
filename	*(char)
;	O
char	O
*	O
language	*(struct(*(char),*(char)))
;	O
char	O
*	O
category	*(char)
;	O
struct	O
MHD_PostProcessor	O
*	O
pp	*(struct)
;	O
struct	O
MHD_Connection	O
*	O
connection	*(struct)
;	O
struct	O
MHD_Response	O
*	O
response	*(struct)
;	O
}	O
;	O
static	O
int	O
do_append	(*(*(char)),*(char),long)->(int)
(	O
char	O
*	O
*	O
ret	*(*(char))
,	O
const	O
char	O
*	O
data	*(char)
,	O
size_t	long
size	long
)	O
{	O
char	O
*	O
buf	*(char)
;	O
size_t	long
old_len	long
;	O
if	O
(	O
NULL	O
==	O
*	O
ret	*(*(char))
)	O
old_len	long
=	O
0	int
;	O
else	O
old_len	long
=	O
strlen	(*(char))->(long)
(	O
*	O
ret	*(*(char))
)	O
;	O
if	O
(	O
NULL	O
==	O
(	O
buf	*(char)
=	O
malloc	(long)->(*(void))
(	O
old_len	long
+	O
size	long
+	O
1	int
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
NULL	O
!=	O
*	O
ret	*(*(char))
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	*(char)
,	O
*	O
ret	*(*(char))
,	O
old_len	long
)	O
;	O
free	(*(void))->(void)
(	O
*	O
ret	*(*(char))
)	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
buf	*(char)
[	O
old_len	long
]	O
,	O
data	*(char)
,	O
size	long
)	O
;	O
buf	*(char)
[	O
old_len	long
+	O
size	long
]	O
=	O
'\0'	O
;	O
*	O
ret	*(*(char))
=	O
buf	*(char)
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
process_upload_data	(*(void),enum(int,int,int,int,int,int),*(char),*(char),*(char),*(char),*(char),long,long)->(int)
(	O
void	O
*	O
cls	*(void)
,	O
enum	O
MHD_ValueKind	enum(int,int,int,int,int,int)
kind	enum(int,int,int,int,int,int)
,	O
const	O
char	O
*	O
key	*(char)
,	O
const	O
char	O
*	O
filename	*(char)
,	O
const	O
char	O
*	O
content_type	*(char)
,	O
const	O
char	O
*	O
transfer_encoding	*(char)
,	O
const	O
char	O
*	O
data	*(char)
,	O
uint64_t	long
off	long
,	O
size_t	long
size	long
)	O
{	O
struct	O
UploadContext	struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct))
*	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
=	O
cls	*(void)
;	O
int	O
i	int
;	O
(	O
void	O
)	O
kind	enum(int,int,int,int,int,int)
;	O
(	O
void	O
)	O
content_type	*(char)
;	O
(	O
void	O
)	O
transfer_encoding	*(char)
;	O
(	O
void	O
)	O
off	long
;	O
if	O
(	O
0	int
==	O
strcmp	(*(char),*(char))->(int)
(	O
key	*(char)
,	O
"category"	*(char)
)	O
)	O
return	O
do_append	(*(*(char)),*(char),long)->(int)
(	O
&	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
category	*(char)
,	O
data	*(char)
,	O
size	long
)	O
;	O
if	O
(	O
0	int
==	O
strcmp	(*(char),*(char))->(int)
(	O
key	*(char)
,	O
"language"	*(char)
)	O
)	O
return	O
do_append	(*(*(char)),*(char),long)->(int)
(	O
&	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
language	*(struct(*(char),*(char)))
,	O
data	*(char)
,	O
size	long
)	O
;	O
if	O
(	O
0	int
!=	O
strcmp	(*(char),*(char))->(int)
(	O
key	*(char)
,	O
"upload"	*(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Ignoring unexpected form value `%s'\n"	*(char)
,	O
key	*(char)
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
if	O
(	O
NULL	O
==	O
filename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"No filename, aborting upload\n"	*(char)
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
NULL	O
==	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
category	*(char)
)	O
||	O
(	O
NULL	O
==	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
language	*(struct(*(char),*(char)))
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Missing form data for upload `%s'\n"	*(char)
,	O
filename	*(char)
)	O
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
response	*(struct)
=	O
request_refused_response	*(struct)
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
-	O
1	int
==	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
)	O
{	O
char	O
fn	array(char)
[	O
PATH_MAX	int
]	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
strstr	(*(char),*(char))->(*(char))
(	O
filename	*(char)
,	O
".."	*(char)
)	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	(*(char),int)->(*(char))
(	O
filename	*(char)
,	O
'/'	O
)	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	(*(char),int)->(*(char))
(	O
filename	*(char)
,	O
'\\'	O
)	O
)	O
)	O
{	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
response	*(struct)
=	O
request_refused_response	*(struct)
;	O
return	O
MHD_NO	int
;	O
}	O
(	O
void	O
)	O
mkdir	(*(char),int)->(int)
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
language	*(struct(*(char),*(char)))
,	O
S_IRWXU	O
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
fn	array(char)
,	O
sizeof	O
(	O
fn	array(char)
)	O
,	O
"%s/%s"	*(char)
,	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
language	*(struct(*(char),*(char)))
,	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
category	*(char)
)	O
;	O
(	O
void	O
)	O
mkdir	(*(char),int)->(int)
(	O
fn	array(char)
,	O
S_IRWXU	O
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
fn	array(char)
,	O
sizeof	O
(	O
fn	array(char)
)	O
,	O
"%s/%s/%s"	*(char)
,	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
language	*(struct(*(char),*(char)))
,	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
category	*(char)
,	O
filename	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
strlen	(*(char))->(long)
(	O
fn	array(char)
)	O
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
!	O
isprint	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
fn	array(char)
[	O
i	int
]	O
)	O
)	O
fn	array(char)
[	O
i	int
]	O
=	O
'_'	O
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
fn	array(char)
,	O
O_CREAT	int
|	O
O_EXCL	int
|	O
O_WRONLY	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
if	O
(	O
-	O
1	int
==	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error opening file `%s' for upload: %s\n"	*(char)
,	O
fn	array(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
response	*(struct)
=	O
request_refused_response	*(struct)
;	O
return	O
MHD_NO	int
;	O
}	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
filename	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
fn	array(char)
)	O
;	O
}	O
if	O
(	O
(	O
0	int
!=	O
size	long
)	O
&&	O
(	O
size	long
!=	O
(	O
size_t	long
)	O
write	*((*(void),*(char),long)->(long))
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
,	O
data	*(char)
,	O
size	long
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error writing to file `%s': %s\n"	*(char)
,	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
filename	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
response	*(struct)
=	O
internal_error_response	*(struct)
;	O
(	O
void	O
)	O
close	*((*(void))->(int))
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
)	O
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
=	O
-	O
1	int
;	O
if	O
(	O
NULL	O
!=	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
filename	*(char)
)	O
{	O
unlink	(*(char))->(int)
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
filename	*(char)
)	O
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
filename	*(char)
=	O
NULL	O
;	O
}	O
return	O
MHD_NO	int
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
response_completed_callback	(*(void),*(struct),*(*(void)),enum(int,int,int,int,int,int))->(void)
(	O
void	O
*	O
cls	*(void)
,	O
struct	O
MHD_Connection	O
*	O
connection	*(struct)
,	O
void	O
*	O
*	O
con_cls	*(*(void))
,	O
enum	O
MHD_RequestTerminationCode	enum(int,int,int,int,int,int)
toe	enum(int,int,int,int,int,int)
)	O
{	O
struct	O
UploadContext	struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct))
*	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
=	O
*	O
con_cls	*(*(void))
;	O
(	O
void	O
)	O
cls	*(void)
;	O
(	O
void	O
)	O
connection	*(struct)
;	O
(	O
void	O
)	O
toe	enum(int,int,int,int,int,int)
;	O
if	O
(	O
NULL	O
==	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
)	O
return	O
;	O
if	O
(	O
NULL	O
!=	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
pp	*(struct)
)	O
{	O
MHD_destroy_post_processor	(*(struct))->(int)
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
pp	*(struct)
)	O
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
pp	*(struct)
=	O
NULL	O
;	O
}	O
if	O
(	O
-	O
1	int
!=	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
)	O
{	O
(	O
void	O
)	O
close	*((*(void))->(int))
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
)	O
;	O
if	O
(	O
NULL	O
!=	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
filename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Upload of file `%s' failed (incomplete or aborted), removing file.\n"	*(char)
,	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
filename	*(char)
)	O
;	O
(	O
void	O
)	O
unlink	(*(char))->(int)
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
filename	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
NULL	O
!=	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
filename	*(char)
)	O
free	(*(void))->(void)
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
)	O
;	O
}	O
static	O
int	O
return_directory_response	(*(struct))->(int)
(	O
struct	O
MHD_Connection	O
*	O
connection	*(struct)
)	O
{	O
int	O
ret	*(*(char))
;	O
(	O
void	O
)	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
NULL	O
==	O
cached_directory_response	*(struct)
)	O
ret	*(*(char))
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_INTERNAL_SERVER_ERROR	int
,	O
internal_error_response	*(struct)
)	O
;	O
else	O
ret	*(*(char))
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_OK	int
,	O
cached_directory_response	*(struct)
)	O
;	O
(	O
void	O
)	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
ret	*(*(char))
;	O
}	O
static	O
int	O
generate_page	(*(void),*(struct),*(char),*(char),*(char),*(char),*(long),*(*(void)))->(int)
(	O
void	O
*	O
cls	*(void)
,	O
struct	O
MHD_Connection	O
*	O
connection	*(struct)
,	O
const	O
char	O
*	O
url	*(char)
,	O
const	O
char	O
*	O
method	*(char)
,	O
const	O
char	O
*	O
version	*(char)
,	O
const	O
char	O
*	O
upload_data	*(char)
,	O
size_t	long
*	O
upload_data_size	*(long)
,	O
void	O
*	O
*	O
ptr	*(void)
)	O
{	O
struct	O
MHD_Response	O
*	O
response	*(struct)
;	O
int	O
ret	*(*(char))
;	O
int	O
fd	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
buf	*(char)
;	O
(	O
void	O
)	O
cls	*(void)
;	O
(	O
void	O
)	O
version	*(char)
;	O
if	O
(	O
0	int
!=	O
strcmp	(*(char),*(char))->(int)
(	O
url	*(char)
,	O
"/"	*(char)
)	O
)	O
{	O
const	O
char	O
*	O
mime	*(char)
;	O
if	O
(	O
(	O
0	int
!=	O
strcmp	(*(char),*(char))->(int)
(	O
method	*(char)
,	O
MHD_HTTP_METHOD_GET	*(char)
)	O
)	O
&&	O
(	O
0	int
!=	O
strcmp	(*(char),*(char))->(int)
(	O
method	*(char)
,	O
MHD_HTTP_METHOD_HEAD	*(char)
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
fd	int
=	O
-	O
1	int
;	O
if	O
(	O
(	O
NULL	O
==	O
strstr	(*(char),*(char))->(*(char))
(	O
&	O
url	*(char)
[	O
1	int
]	O
,	O
".."	*(char)
)	O
)	O
&&	O
(	O
'/'	O
!=	O
url	*(char)
[	O
1	int
]	O
)	O
)	O
{	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
&	O
url	*(char)
[	O
1	int
]	O
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
(	O
-	O
1	int
!=	O
fd	int
)	O
&&	O
(	O
(	O
0	int
!=	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
&	O
buf	*(char)
)	O
)	O
||	O
(	O
!	O
S_ISREG	O
(	O
buf	*(char)
.	O
st_mode	int
)	O
)	O
)	O
)	O
{	O
(	O
void	O
)	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
-	O
1	int
==	O
fd	int
)	O
return	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_NOT_FOUND	int
,	O
file_not_found_response	*(struct)
)	O
;	O
mime	*(char)
=	O
NULL	O
;	O
if	O
(	O
NULL	O
==	O
(	O
response	*(struct)
=	O
MHD_create_response_from_fd	(long,int)->(*(struct))
(	O
buf	*(char)
.	O
st_size	long
,	O
fd	int
)	O
)	O
)	O
{	O
(	O
void	O
)	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
NULL	O
!=	O
mime	*(char)
)	O
(	O
void	O
)	O
MHD_add_response_header	(*(struct),*(char),*(char))->(int)
(	O
response	*(struct)
,	O
MHD_HTTP_HEADER_CONTENT_TYPE	*(char)
,	O
mime	*(char)
)	O
;	O
ret	*(*(char))
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_OK	int
,	O
response	*(struct)
)	O
;	O
MHD_destroy_response	(*(struct))->(void)
(	O
response	*(struct)
)	O
;	O
return	O
ret	*(*(char))
;	O
}	O
if	O
(	O
0	int
==	O
strcmp	(*(char),*(char))->(int)
(	O
method	*(char)
,	O
MHD_HTTP_METHOD_POST	*(char)
)	O
)	O
{	O
struct	O
UploadContext	struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct))
*	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
=	O
*	O
ptr	*(void)
;	O
if	O
(	O
NULL	O
==	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
)	O
{	O
if	O
(	O
NULL	O
==	O
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
UploadContext	struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct))
)	O
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
,	O
0	int
,	O
sizeof	O
(	O
struct	O
UploadContext	struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct))
)	O
)	O
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
=	O
-	O
1	int
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
connection	*(struct)
=	O
connection	*(struct)
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
pp	*(struct)
=	O
MHD_create_post_processor	(*(struct),long,*((*(void),enum(int,int,int,int,int,int),*(char),*(char),*(char),*(char),*(char),long,long)->(int)),*(void))->(*(struct))
(	O
connection	*(struct)
,	O
64	int
*	O
1024	int
,	O
&	O
process_upload_data	(*(void),enum(int,int,int,int,int,int),*(char),*(char),*(char),*(char),*(char),long,long)->(int)
,	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
)	O
;	O
if	O
(	O
NULL	O
==	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
pp	*(struct)
)	O
{	O
free	(*(void))->(void)
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
*	O
ptr	*(void)
=	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
;	O
return	O
MHD_YES	int
;	O
}	O
if	O
(	O
0	int
!=	O
*	O
upload_data_size	*(long)
)	O
{	O
if	O
(	O
NULL	O
==	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
response	*(struct)
)	O
(	O
void	O
)	O
MHD_post_process	(*(struct),*(char),long)->(int)
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
pp	*(struct)
,	O
upload_data	*(char)
,	O
*	O
upload_data_size	*(long)
)	O
;	O
*	O
upload_data_size	*(long)
=	O
0	int
;	O
return	O
MHD_YES	int
;	O
}	O
MHD_destroy_post_processor	(*(struct))->(int)
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
pp	*(struct)
)	O
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
pp	*(struct)
=	O
NULL	O
;	O
if	O
(	O
-	O
1	int
!=	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
)	O
{	O
close	*((*(void))->(int))
(	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
)	O
;	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
fd	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
NULL	O
!=	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
response	*(struct)
)	O
{	O
return	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_FORBIDDEN	int
,	O
uc	*(struct(int,*(char),*(char),*(char),*(struct),*(struct),*(struct)))
->	O
response	*(struct)
)	O
;	O
}	O
else	O
{	O
update_directory	()->(void)
(	O
)	O
;	O
return	O
return_directory_response	(*(struct))->(int)
(	O
connection	*(struct)
)	O
;	O
}	O
}	O
if	O
(	O
(	O
0	int
==	O
strcmp	(*(char),*(char))->(int)
(	O
method	*(char)
,	O
MHD_HTTP_METHOD_GET	*(char)
)	O
)	O
||	O
(	O
0	int
==	O
strcmp	(*(char),*(char))->(int)
(	O
method	*(char)
,	O
MHD_HTTP_METHOD_HEAD	*(char)
)	O
)	O
)	O
{	O
return	O
return_directory_response	(*(struct))->(int)
(	O
connection	*(struct)
)	O
;	O
}	O
return	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_FORBIDDEN	int
,	O
request_refused_response	*(struct)
)	O
;	O
}	O
static	O
void	O
catcher	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
(	O
void	O
)	O
sig	int
;	O
}	O
static	O
void	O
ignore_sigpipe	()->(void)
(	O
)	O
{	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
oldsig	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
sig	int
;	O
sig	int
.	O
sa_handler	*((int)->(void))
=	O
&	O
catcher	(int)->(void)
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
sig	int
.	O
sa_mask	struct(array(long))
)	O
;	O
sig	int
.	O
sa_flags	int
=	O
SA_INTERRUPT	int
;	O
if	O
(	O
0	int
!=	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGPIPE	int
,	O
&	O
sig	int
,	O
&	O
oldsig	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to install SIGPIPE handler: %s\n"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
const	O
*	O
argv	*(*(char))
)	O
{	O
struct	O
MHD_Daemon	O
*	O
d	*(struct)
;	O
unsigned	O
int	O
port	short
;	O
if	O
(	O
(	O
argc	int
!=	O
2	int
)	O
||	O
(	O
1	int
!=	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
"%u"	*(char)
,	O
&	O
port	short
)	O
)	O
||	O
(	O
UINT16_MAX	O
<	O
port	short
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s PORT\n"	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
ignore_sigpipe	()->(void)
(	O
)	O
;	O
(	O
void	O
)	O
pthread_mutex_init	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)),*(union(array(char),int)))->(int)
(	O
&	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
,	O
NULL	O
)	O
;	O
file_not_found_response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
strlen	(*(char))->(long)
(	O
FILE_NOT_FOUND_PAGE	*(char)
)	O
,	O
(	O
void	O
*	O
)	O
FILE_NOT_FOUND_PAGE	*(char)
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
mark_as_html	(*(struct))->(void)
(	O
file_not_found_response	*(struct)
)	O
;	O
request_refused_response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
strlen	(*(char))->(long)
(	O
REQUEST_REFUSED_PAGE	*(char)
)	O
,	O
(	O
void	O
*	O
)	O
REQUEST_REFUSED_PAGE	*(char)
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
mark_as_html	(*(struct))->(void)
(	O
request_refused_response	*(struct)
)	O
;	O
internal_error_response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
strlen	(*(char))->(long)
(	O
INTERNAL_ERROR_PAGE	*(char)
)	O
,	O
(	O
void	O
*	O
)	O
INTERNAL_ERROR_PAGE	*(char)
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
mark_as_html	(*(struct))->(void)
(	O
internal_error_response	*(struct)
)	O
;	O
update_directory	()->(void)
(	O
)	O
;	O
d	*(struct)
=	O
MHD_start_daemon	(int,short,*((*(void),*(struct(short,array(char))),int)->(int)),*(void),*((*(void),*(struct),*(char),*(char),*(char),*(char),*(long),*(*(void)))->(int)),*(void))->(*(struct))
(	O
MHD_USE_AUTO	int
|	O
MHD_USE_INTERNAL_POLLING_THREAD	int
|	O
MHD_USE_ERROR_LOG	int
,	O
port	short
,	O
NULL	O
,	O
NULL	O
,	O
&	O
generate_page	(*(void),*(struct),*(char),*(char),*(char),*(char),*(long),*(*(void)))->(int)
,	O
NULL	O
,	O
MHD_OPTION_CONNECTION_MEMORY_LIMIT	int
,	O
(	O
size_t	long
)	O
(	O
256	int
*	O
1024	int
)	O
,	O
MHD_OPTION_CONNECTION_TIMEOUT	int
,	O
(	O
unsigned	O
int	O
)	O
(	O
120	int
)	O
,	O
MHD_OPTION_THREAD_POOL_SIZE	int
,	O
(	O
unsigned	O
int	O
)	O
NUMBER_OF_THREADS	O
,	O
MHD_OPTION_NOTIFY_COMPLETED	int
,	O
&	O
response_completed_callback	(*(void),*(struct),*(*(void)),enum(int,int,int,int,int,int))->(void)
,	O
NULL	O
,	O
MHD_OPTION_END	int
)	O
;	O
if	O
(	O
NULL	O
==	O
d	*(struct)
)	O
return	O
1	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"HTTP server running. Press ENTER to stop the server\n"	*(char)
)	O
;	O
(	O
void	O
)	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
MHD_stop_daemon	(*(struct))->(void)
(	O
d	*(struct)
)	O
;	O
MHD_destroy_response	(*(struct))->(void)
(	O
file_not_found_response	*(struct)
)	O
;	O
MHD_destroy_response	(*(struct))->(void)
(	O
request_refused_response	*(struct)
)	O
;	O
MHD_destroy_response	(*(struct))->(void)
(	O
internal_error_response	*(struct)
)	O
;	O
update_cached_response	(*(struct))->(void)
(	O
NULL	O
)	O
;	O
(	O
void	O
)	O
pthread_mutex_destroy	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
