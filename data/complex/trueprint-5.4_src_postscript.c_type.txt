boolean	enum(int,int,int)
no_show_indent_level	enum(int,int,int)
;	O
boolean	enum(int,int,int)
no_show_line_number	enum(int,int,int)
;	O
typedef	O
enum	O
{	O
NO_LAYOUT	int
,	O
ONE_ON_ONE	int
,	O
TWO_ON_ONE	int
,	O
THREE_ON_ONE	int
,	O
FOUR_ON_ONE	int
}	O
page_layouts	enum(int,int,int,int,int)
;	O
static	O
unsigned	O
short	O
logical_pages_on_physical_page	short
;	O
static	O
long	O
physical_page_no	long
;	O
static	O
short	O
greenlines	short
;	O
static	O
boolean	enum(int,int,int)
no_holepunch	enum(int,int,int)
;	O
static	O
boolean	enum(int,int,int)
no_top_holepunch	enum(int,int,int)
;	O
static	O
boolean	enum(int,int,int)
page_furniture	enum(int,int,int)
;	O
static	O
int	O
interline_gap	int
;	O
static	O
boolean	enum(int,int,int)
include_headers	enum(int,int,int)
;	O
static	O
boolean	enum(int,int,int)
include_footers	enum(int,int,int)
;	O
static	O
short	O
pointsize	short
;	O
static	O
char	O
orientation	char
;	O
static	O
page_layouts	enum(int,int,int,int,int)
layout	enum(int,int,int,int,int)
;	O
static	O
boolean	enum(int,int,int)
rotate_alternate_sheets	enum(int,int,int)
;	O
static	O
boolean	enum(int,int,int)
no_cover_sheet	enum(int,int,int)
;	O
static	O
char	O
*	O
user_name	*(char)
;	O
static	O
unsigned	O
short	O
printable_width	short
;	O
static	O
unsigned	O
short	O
printable_height	short
;	O
static	O
unsigned	O
short	O
virtual_width	short
;	O
static	O
unsigned	O
short	O
virtual_height	short
;	O
static	O
unsigned	O
short	O
header_box_height	short
;	O
static	O
unsigned	O
short	O
footer_box_height	short
;	O
static	O
unsigned	O
short	O
logical_pages_rotated	short
;	O
static	O
unsigned	O
short	O
pos_left	short
;	O
static	O
unsigned	O
short	O
pos_centre_left	short
;	O
static	O
unsigned	O
short	O
pos_centre_right	short
;	O
static	O
unsigned	O
short	O
pos_right	short
;	O
static	O
unsigned	O
short	O
pos_bottom	short
;	O
static	O
unsigned	O
short	O
pos_centre_bottom	short
;	O
static	O
unsigned	O
short	O
pos_centre_top	short
;	O
static	O
unsigned	O
short	O
pos_top	short
;	O
static	O
unsigned	O
short	O
logical_page_no	short
;	O
static	O
unsigned	O
short	O
left_margin	short
;	O
static	O
unsigned	O
short	O
right_margin	short
;	O
static	O
unsigned	O
short	O
top_margin	short
;	O
static	O
unsigned	O
short	O
bottom_margin	short
;	O
static	O
boolean	enum(int,int,int)
left_page	enum(int,int,int)
,	O
right_page	enum(int,int,int)
;	O
static	O
char	O
no_of_sides	char
;	O
static	O
char	O
ps_level	char
;	O
static	O
void	O
balance_strings	(*(char),*(char),*(char),long,enum(int,int,int))->(void)
(	O
char	O
*	O
string1	*(char)
,	O
char	O
*	O
string2	*(char)
,	O
char	O
*	O
string3	*(char)
,	O
long	O
page_no	long
,	O
boolean	enum(int,int,int)
index_page	enum(int,int,int)
)	O
;	O
static	O
void	O
set_layout_default	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
set_layout_1	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
)	O
;	O
static	O
void	O
set_layout_2	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
)	O
;	O
static	O
void	O
set_layout_3	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
)	O
;	O
static	O
void	O
set_layout_4	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
)	O
;	O
static	O
boolean	enum(int,int,int)
PS_side_full	()->(enum(int,int,int))
(	O
void	O
)	O
;	O
static	O
void	O
set_no_of_sides	(*(char),*(char),char)->(void)
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
value	*(char)
)	O
;	O
static	O
void	O
set_no_of_sides_default	(char)->(void)
(	O
char	O
value	*(char)
)	O
;	O
void	O
setup_postscript	()->(void)
(	O
void	O
)	O
{	O
pointsize	short
=	O
-	O
1	int
;	O
short_option	(*(char),*(char),short,*(char),short,short,short,*(short),*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"p"	*(char)
,	O
"point-size"	*(char)
,	O
10	int
,	O
NULL	O
,	O
0	int
,	O
MINPOINTSIZE	int
,	O
MAXPOINTSIZE	int
,	O
&	O
pointsize	short
,	O
NULL	O
,	O
NULL	O
,	O
OPT_TEXT_FORMAT	int
,	O
"specify point size (default 10)"	*(char)
,	O
NULL	O
)	O
;	O
boolean_option	(*(char),*(char),*(char),enum(int,int,int),*(enum(int,int,int)),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"C"	*(char)
,	O
"no-cover-sheet"	*(char)
,	O
"cover-sheet"	*(char)
,	O
FALSE	int
,	O
&	O
no_cover_sheet	enum(int,int,int)
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PRINT	int
,	O
"don't print cover sheet"	*(char)
,	O
"print cover sheet"	*(char)
)	O
;	O
boolean_option	(*(char),*(char),*(char),enum(int,int,int),*(enum(int,int,int)),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"I"	*(char)
,	O
"no-holepunch"	*(char)
,	O
"holepunch"	*(char)
,	O
TRUE	int
,	O
&	O
no_holepunch	enum(int,int,int)
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FORMAT	int
,	O
"don't leave space for holepunch at the side of each page"	*(char)
,	O
"leave space for holepunch at the side of each page"	*(char)
)	O
;	O
boolean_option	(*(char),*(char),*(char),enum(int,int,int),*(enum(int,int,int)),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"J"	*(char)
,	O
"no-top-holepunch"	*(char)
,	O
"top-holepunch"	*(char)
,	O
TRUE	int
,	O
&	O
no_top_holepunch	enum(int,int,int)
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FORMAT	int
,	O
"don't leave space for holepunch at the top of each page"	*(char)
,	O
"leave space for holepunch at the top of each page"	*(char)
)	O
;	O
boolean_option	(*(char),*(char),*(char),enum(int,int,int),*(enum(int,int,int)),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"u"	*(char)
,	O
"page-furniture-lines"	*(char)
,	O
"no-page-furniture-lines"	*(char)
,	O
TRUE	int
,	O
&	O
page_furniture	enum(int,int,int)
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	int
,	O
"Draw lines around headers and footers and include left margin line"	*(char)
,	O
"No lines around headers or footers and no left margin line"	*(char)
)	O
;	O
greenlines	short
=	O
-	O
1	int
;	O
short_option	(*(char),*(char),short,*(char),short,short,short,*(short),*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"G"	*(char)
,	O
"gray-bands"	*(char)
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
MAXGREENLINES	int
,	O
&	O
greenlines	short
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	int
,	O
"<lines> emulate the old lineprinter paper with gray bands\n"	*(char)
"    across each page.  The value of <lines> gives the width of\n"	*(char)
"    the bands and the gaps between them"	*(char)
,	O
NULL	O
)	O
;	O
interline_gap	int
=	O
-	O
1	int
;	O
int_option	(*(char),*(char),int,*(char),int,int,int,*(int),*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"g"	*(char)
,	O
"leading"	*(char)
,	O
1	int
,	O
NULL	O
,	O
0	int
,	O
MININTERLINE_GAP	int
,	O
MAXINTERLINE_GAP	int
,	O
&	O
interline_gap	int
,	O
NULL	O
,	O
NULL	O
,	O
OPT_TEXT_FORMAT	int
,	O
"specify interline gap in points (default 1)"	*(char)
,	O
NULL	O
)	O
;	O
boolean_option	(*(char),*(char),*(char),enum(int,int,int),*(enum(int,int,int)),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"K"	*(char)
,	O
"headers"	*(char)
,	O
"no-headers"	*(char)
,	O
TRUE	int
,	O
&	O
include_headers	enum(int,int,int)
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	int
,	O
"include the header on each page"	*(char)
,	O
"suppress the header on each page"	*(char)
)	O
;	O
boolean_option	(*(char),*(char),*(char),enum(int,int,int),*(enum(int,int,int)),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"k"	*(char)
,	O
"footers"	*(char)
,	O
"no-footers"	*(char)
,	O
TRUE	int
,	O
&	O
include_footers	enum(int,int,int)
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	int
,	O
"include the footer on each page"	*(char)
,	O
"suppress the footer on each page"	*(char)
)	O
;	O
user_name	*(char)
=	O
NULL	O
;	O
string_option	(*(char),*(char),*(char),*(*(char)),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),enum(int,int,int,int,int,int),*(char))->(void)
(	O
"U"	*(char)
,	O
"username"	*(char)
,	O
NULL	O
,	O
&	O
user_name	*(char)
,	O
NULL	O
,	O
NULL	O
,	O
OPT_MISC	int
,	O
"set username for coversheet"	*(char)
)	O
;	O
boolean_option	(*(char),*(char),*(char),enum(int,int,int),*(enum(int,int,int)),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"i"	*(char)
,	O
"no-braces-depth"	*(char)
,	O
"braces-depth"	*(char)
,	O
FALSE	int
,	O
&	O
no_show_indent_level	enum(int,int,int)
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	int
,	O
"exclude the braces depth count"	*(char)
,	O
"include the braces depth count"	*(char)
)	O
;	O
boolean_option	(*(char),*(char),*(char),enum(int,int,int),*(enum(int,int,int)),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"n"	*(char)
,	O
"no-line-numbers"	*(char)
,	O
"line-numbers"	*(char)
,	O
FALSE	int
,	O
&	O
no_show_line_number	enum(int,int,int)
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	int
,	O
"exclude the line number count"	*(char)
,	O
"include the line number count"	*(char)
)	O
;	O
choice_option	(*(char),*(char),*(char),char,char,*(char),*((*(char),*(char),char)->(void)),*((char)->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"o"	*(char)
,	O
"portrait"	*(char)
,	O
"landscape"	*(char)
,	O
'p'	O
,	O
'l'	O
,	O
&	O
orientation	char
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FORMAT	int
,	O
"print using portrait orientation"	*(char)
,	O
"print using landscape orientation"	*(char)
)	O
;	O
no_of_sides	char
=	O
'0'	O
;	O
choice_option	(*(char),*(char),*(char),char,char,*(char),*((*(char),*(char),char)->(void)),*((char)->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"S"	*(char)
,	O
"single-sided"	*(char)
,	O
"double-sided"	*(char)
,	O
'1'	O
,	O
'2'	O
,	O
NULL	O
,	O
set_no_of_sides	(*(char),*(char),char)->(void)
,	O
set_no_of_sides_default	(char)->(void)
,	O
OPT_PAGE_FORMAT	int
,	O
"print single-sided"	*(char)
,	O
"print double-sided"	*(char)
)	O
;	O
ps_level	char
=	O
'2'	O
;	O
choice_option	(*(char),*(char),*(char),char,char,*(char),*((*(char),*(char),char)->(void)),*((char)->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
"R"	*(char)
,	O
"ps-level-two"	*(char)
,	O
"ps-level-one"	*(char)
,	O
'2'	O
,	O
'1'	O
,	O
&	O
ps_level	char
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FORMAT	int
,	O
"generate postscript level 2 code"	*(char)
,	O
"generate postscript level 1 code"	*(char)
)	O
;	O
layout	enum(int,int,int,int,int)
=	O
NO_LAYOUT	int
;	O
noparm_option	(*(char),*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),enum(int,int,int,int,int,int),*(char))->(void)
(	O
"1"	*(char)
,	O
"one-up"	*(char)
,	O
TRUE	int
,	O
&	O
set_layout_1	(*(char),*(char))->(void)
,	O
&	O
set_layout_default	()->(void)
,	O
OPT_PAGE_FORMAT	int
,	O
"print 1-on-1 (default)"	*(char)
)	O
;	O
noparm_option	(*(char),*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),enum(int,int,int,int,int,int),*(char))->(void)
(	O
"2"	*(char)
,	O
"two-up"	*(char)
,	O
FALSE	int
,	O
&	O
set_layout_2	(*(char),*(char))->(void)
,	O
NULL	O
,	O
OPT_PAGE_FORMAT	int
,	O
"print 2-on-1"	*(char)
)	O
;	O
noparm_option	(*(char),*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),enum(int,int,int,int,int,int),*(char))->(void)
(	O
"3"	*(char)
,	O
"two-tall-up"	*(char)
,	O
FALSE	int
,	O
&	O
set_layout_3	(*(char),*(char))->(void)
,	O
NULL	O
,	O
OPT_PAGE_FORMAT	int
,	O
"print 2-on-1 at 4-on-1 pointsize"	*(char)
)	O
;	O
noparm_option	(*(char),*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),enum(int,int,int,int,int,int),*(char))->(void)
(	O
"4"	*(char)
,	O
"four-up"	*(char)
,	O
FALSE	int
,	O
&	O
set_layout_4	(*(char),*(char))->(void)
,	O
NULL	O
,	O
OPT_PAGE_FORMAT	int
,	O
"print 4-on-1"	*(char)
)	O
;	O
boolean_option	(*(char),*(char),*(char),enum(int,int,int),*(enum(int,int,int)),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
NULL	O
,	O
"rotate-alternate-sheets"	*(char)
,	O
"no-rotate-alternate-sheets"	*(char)
,	O
FALSE	int
,	O
&	O
rotate_alternate_sheets	enum(int,int,int)
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	int
,	O
"rotate every other sheet 180 degrees. Only works in double-sided modes"	*(char)
,	O
"don't rotate every other sheet 180 degrees."	*(char)
)	O
;	O
}	O
void	O
init_postscript	()->(void)
(	O
void	O
)	O
{	O
physical_page_no	long
=	O
1	int
;	O
logical_page_no	short
=	O
0	int
;	O
right_page	enum(int,int,int)
=	O
TRUE	int
;	O
left_page	enum(int,int,int)
=	O
FALSE	int
;	O
}	O
void	O
set_layout_default	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
layout	enum(int,int,int,int,int)
!=	O
NO_LAYOUT	int
)	O
return	O
;	O
layout	enum(int,int,int,int,int)
=	O
ONE_ON_ONE	int
;	O
}	O
void	O
set_layout_1	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
layout	enum(int,int,int,int,int)
!=	O
NO_LAYOUT	int
)	O
return	O
;	O
layout	enum(int,int,int,int,int)
=	O
ONE_ON_ONE	int
;	O
}	O
void	O
set_layout_2	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
layout	enum(int,int,int,int,int)
!=	O
NO_LAYOUT	int
)	O
return	O
;	O
layout	enum(int,int,int,int,int)
=	O
TWO_ON_ONE	int
;	O
}	O
void	O
set_layout_3	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
layout	enum(int,int,int,int,int)
!=	O
NO_LAYOUT	int
)	O
return	O
;	O
layout	enum(int,int,int,int,int)
=	O
THREE_ON_ONE	int
;	O
}	O
void	O
set_layout_4	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
layout	enum(int,int,int,int,int)
!=	O
NO_LAYOUT	int
)	O
return	O
;	O
layout	enum(int,int,int,int,int)
=	O
FOUR_ON_ONE	int
;	O
}	O
void	O
PS_header	(*(char),enum(int,int,int))->(void)
(	O
char	O
*	O
version	*(char)
,	O
boolean	enum(int,int,int)
print_body	enum(int,int,int)
)	O
{	O
unsigned	O
int	O
file_index	int
;	O
printf	(*(char))->(int)
(	O
"%%!PS-Adobe-%c.0\n"	*(char)
,	O
ps_level	char
)	O
;	O
printf	(*(char))->(int)
(	O
"statusdict /setduplexmode known {\n"	*(char)
)	O
;	O
if	O
(	O
no_of_sides	char
==	O
'2'	O
)	O
{	O
printf	(*(char))->(int)
(	O
"  true "	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"  false "	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"statusdict /setduplexmode get exec\n} if\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/Ps	%d def\n"	*(char)
,	O
pointsize	short
)	O
;	O
printf	(*(char))->(int)
(	O
"/SPs	%d def\n"	*(char)
,	O
(	O
pointsize	short
*	O
3	int
)	O
/	O
4	int
)	O
;	O
printf	(*(char))->(int)
(	O
"/Lh	%d def\n"	*(char)
,	O
pointsize	short
+	O
interline_gap	int
)	O
;	O
printf	(*(char))->(int)
(	O
"/Rm	%d def\n"	*(char)
,	O
virtual_width	short
)	O
;	O
printf	(*(char))->(int)
(	O
"/Tm	%d def\n"	*(char)
,	O
virtual_height	short
)	O
;	O
printf	(*(char))->(int)
(	O
"/Bh	%d def\n"	*(char)
,	O
header_box_height	short
)	O
;	O
printf	(*(char))->(int)
(	O
"/Bf	%d def\n"	*(char)
,	O
footer_box_height	short
)	O
;	O
printf	(*(char))->(int)
(	O
"/CF	/Courier findfont Ps scalefont def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/IF	/Courier-Oblique findfont Ps scalefont def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/BF	/Courier-Bold findfont Ps scalefont def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/CFs	/Courier findfont SPs scalefont def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/IFs	/Courier-Oblique findfont SPs scalefont def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/BFs	/Courier-Bold findfont SPs scalefont def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/HF	/Helvetica findfont Ps scalefont def\n"	*(char)
)	O
;	O
if	O
(	O
(	O
no_show_line_number	enum(int,int,int)
==	O
FALSE	int
)	O
||	O
(	O
no_show_indent_level	enum(int,int,int)
==	O
FALSE	int
)	O
)	O
printf	(*(char))->(int)
(	O
"/Li CFs setfont (1234567890) stringwidth pop def\n"	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"/Li 0 def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/Nl	{ /Vpos Vpos Lh sub def } def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/Lpt	{ 0 Vpos moveto } def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/Gb	{\n"	*(char)
)	O
;	O
if	O
(	O
greenlines	short
!=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"		gsave /Cv Tm Bh sub def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"		{ Li Cv moveto Rm Li sub 0 rlineto 0 -%d Lh mul rlineto\n"	*(char)
,	O
greenlines	short
)	O
;	O
printf	(*(char))->(int)
(	O
"		  Rm Li sub neg 0 rlineto 0 %d Lh mul rlineto\n"	*(char)
,	O
greenlines	short
)	O
;	O
printf	(*(char))->(int)
(	O
"		  0.98 setgray fill\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"		  /Cv Cv %d Lh mul sub def\n"	*(char)
,	O
greenlines	short
*	O
2	int
)	O
;	O
printf	(*(char))->(int)
(	O
"		  Cv 0 lt { exit } if\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"		} loop\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"		grestore\n"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"		} def\n"	*(char)
)	O
;	O
if	O
(	O
page_furniture	enum(int,int,int)
)	O
{	O
printf	(*(char))->(int)
(	O
"/Ip	{ Gb .5 setlinewidth\n"	*(char)
)	O
;	O
if	O
(	O
include_headers	enum(int,int,int)
)	O
{	O
printf	(*(char))->(int)
(	O
"		0 Tm moveto 0 Bh neg rlineto Rm 0 rlineto 0 Bh rlineto closepath\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"		0 Tm moveto Rm 0 rlineto\n"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"		gsave .98 setgray fill grestore stroke\n"	*(char)
)	O
;	O
if	O
(	O
include_footers	enum(int,int,int)
)	O
{	O
printf	(*(char))->(int)
(	O
"		0 0 moveto 0 Bf rlineto Rm 0 rlineto 0 Bf neg rlineto closepath\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"		0 0 moveto Rm 0 rlineto\n"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"		gsave .98 setgray fill grestore stroke\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"		0 Bf moveto 0 Tm Bh sub lineto stroke newpath\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"		} def\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"/Ip { } def\n"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"/Cp	{ Ip .3 setlinewidth newpath\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"		Li 0 Bf add moveto Li Tm Bh sub lineto stroke newpath\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"		} def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/So	{ gsave dup stringwidth pop Ps 3 div 0 exch rmoveto 0 rlineto fill grestore } def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/Ul	{ gsave	dup stringwidth pop 0 -1 rmoveto 0 rlineto fill grestore } def\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/Bs	{ gsave	dup show grestore 0.5 0.5 rmoveto show } def\n"	*(char)
)	O
;	O
if	O
(	O
ps_level	char
==	O
'2'	O
)	O
{	O
printf	(*(char))->(int)
(	O
"<</PageSize [%d %d]>> setpagedevice\n"	*(char)
,	O
left_margin	short
+	O
right_margin	short
,	O
top_margin	short
+	O
bottom_margin	short
)	O
;	O
}	O
if	O
(	O
no_cover_sheet	enum(int,int,int)
==	O
FALSE	int
)	O
{	O
if	O
(	O
user_name	*(char)
==	O
NULL	O
)	O
{	O
dm	(char,int,*(char))->(void)
(	O
'h'	O
,	O
3	int
,	O
"postscript.c:PS_header() use_environment = %d\n"	*(char)
,	O
use_environment	enum(int,int,int)
)	O
;	O
if	O
(	O
!	O
use_environment	enum(int,int,int)
)	O
user_name	*(char)
=	O
"testuser"	*(char)
;	O
else	O
{	O
char	O
*	O
u	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"USER"	*(char)
)	O
;	O
if	O
(	O
u	*(char)
==	O
0	int
)	O
{	O
user_name	*(char)
=	O
""	*(char)
;	O
}	O
else	O
{	O
user_name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
u	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
*	O
user_name	*(char)
==	O
'\0'	O
)	O
user_name	*(char)
=	O
"Unknown user"	*(char)
;	O
dm	(char,int,*(char))->(void)
(	O
'h'	O
,	O
3	int
,	O
"postscript.c:PS_header() Username = %s\n"	*(char)
,	O
user_name	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"%%%%Page: Cover %ld\n"	*(char)
,	O
physical_page_no	long
++	O
)	O
;	O
printf	(*(char))->(int)
(	O
"70 70 moveto\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/Helvetica findfont 10 scalefont setfont\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"(Trueprint %s) show\n"	*(char)
,	O
version	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"70 725 moveto\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/Helvetica-Bold findfont 20 scalefont setfont\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"(For: %s) show\n"	*(char)
,	O
user_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"70 700 moveto\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"(Printed on: %s) show\n"	*(char)
,	O
expand_string	(*(char),enum(int,int,int))->(*(char))
(	O
"%L"	*(char)
,	O
TRUE	int
)	O
)	O
;	O
if	O
(	O
print_body	enum(int,int,int)
==	O
TRUE	int
)	O
{	O
printf	(*(char))->(int)
(	O
"70 675 moveto\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"(Last page number: %ld) show\n"	*(char)
,	O
total_pages	long
)	O
;	O
for	O
(	O
file_index	int
=	O
0	int
;	O
file_index	int
<	O
(	O
no_of_files	int
>	O
20	int
?	O
20	int
:	O
no_of_files	int
)	O
;	O
file_index	int
++	O
)	O
printf	(*(char))->(int)
(	O
"70 %d moveto (File: %s) show\n"	*(char)
,	O
650	int
-	O
(	O
file_index	int
*	O
25	int
)	O
,	O
file_name	(int)->(*(char))
(	O
file_index	int
)	O
)	O
;	O
if	O
(	O
no_of_files	int
>	O
20	int
)	O
printf	(*(char))->(int)
(	O
"70 150 moveto (Etc....) show\n"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"showpage\n"	*(char)
)	O
;	O
if	O
(	O
no_of_sides	char
==	O
'2'	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%%%%Page: Coverback %ld\n"	*(char)
,	O
physical_page_no	long
++	O
)	O
;	O
printf	(*(char))->(int)
(	O
"showpage\n"	*(char)
)	O
;	O
}	O
}	O
}	O
boolean	enum(int,int,int)
PS_side_full	()->(enum(int,int,int))
(	O
void	O
)	O
{	O
boolean	enum(int,int,int)
retval	enum(int,int,int)
=	O
FALSE	int
;	O
if	O
(	O
logical_page_no	short
!=	O
0	int
)	O
{	O
retval	enum(int,int,int)
=	O
(	O
(	O
logical_page_no	short
%	O
logical_pages_on_physical_page	short
)	O
==	O
0	int
)	O
;	O
}	O
dm	(char,int,*(char))->(void)
(	O
'O'	O
,	O
2	int
,	O
"postscript.c:PS_side_full() returning %d\n"	*(char)
,	O
retval	enum(int,int,int)
)	O
;	O
return	O
retval	enum(int,int,int)
;	O
}	O
boolean	enum(int,int,int)
PS_endpage	(enum(int,int,int))->(enum(int,int,int))
(	O
boolean	enum(int,int,int)
print_page	enum(int,int,int)
)	O
{	O
static	O
boolean	enum(int,int,int)
page_has_printing	enum(int,int,int)
=	O
FALSE	int
;	O
boolean	enum(int,int,int)
reached_end_of_sheet	enum(int,int,int)
;	O
if	O
(	O
print_page	enum(int,int,int)
)	O
{	O
page_has_printing	enum(int,int,int)
=	O
TRUE	int
;	O
}	O
reached_end_of_sheet	enum(int,int,int)
=	O
(	O
(	O
(	O
no_of_sides	char
==	O
'2'	O
)	O
&&	O
left_page	enum(int,int,int)
&&	O
(	O
(	O
logical_page_no	short
%	O
logical_pages_on_physical_page	short
)	O
==	O
0	int
)	O
)	O
||	O
(	O
(	O
no_of_sides	char
==	O
'1'	O
)	O
&&	O
(	O
(	O
logical_page_no	short
%	O
logical_pages_on_physical_page	short
)	O
==	O
0	int
)	O
)	O
)	O
;	O
if	O
(	O
PS_side_full	()->(enum(int,int,int))
(	O
)	O
)	O
{	O
physical_page_no	long
++	O
;	O
if	O
(	O
no_of_sides	char
==	O
'2'	O
)	O
{	O
left_page	enum(int,int,int)
=	O
!	O
left_page	enum(int,int,int)
;	O
right_page	enum(int,int,int)
=	O
!	O
right_page	enum(int,int,int)
;	O
}	O
if	O
(	O
pass	short
==	O
1	int
)	O
{	O
if	O
(	O
page_has_printing	enum(int,int,int)
)	O
{	O
printf	(*(char))->(int)
(	O
"showpage\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"erasepage initgraphics\n"	*(char)
)	O
;	O
}	O
}	O
page_has_printing	enum(int,int,int)
=	O
FALSE	int
;	O
}	O
return	O
reached_end_of_sheet	enum(int,int,int)
;	O
}	O
void	O
PS_startpage	(*(char),*(char),*(char),*(char),*(char),*(char),*(char),long,long,enum(int,int,int))->(void)
(	O
char	O
*	O
head1	*(char)
,	O
char	O
*	O
head2	*(char)
,	O
char	O
*	O
head3	*(char)
,	O
char	O
*	O
foot1	*(char)
,	O
char	O
*	O
foot2	*(char)
,	O
char	O
*	O
foot3	*(char)
,	O
char	O
*	O
msg_string	*(char)
,	O
long	O
page_no	long
,	O
long	O
hdr_total_pages	long
,	O
boolean	enum(int,int,int)
index_page	enum(int,int,int)
)	O
{	O
short	O
message_pointsize	short
;	O
char	O
*	O
message	*(char)
;	O
unsigned	O
short	O
gap	short
;	O
logical_page_no	short
++	O
;	O
dm	(char,int,*(char))->(void)
(	O
'O'	O
,	O
2	int
,	O
"postscript.c:PS_startpage(), logical page = %d, physical page = %d\n"	*(char)
,	O
logical_page_no	short
,	O
physical_page_no	long
)	O
;	O
if	O
(	O
pass	short
==	O
0	int
)	O
return	O
;	O
dm	(char,int,*(char))->(void)
(	O
'h'	O
,	O
4	int
,	O
"Printing page %s/%s/%s %s/%s/%s + %s, page %d, total %d, index %d\n"	*(char)
,	O
head1	*(char)
,	O
head2	*(char)
,	O
head3	*(char)
,	O
foot1	*(char)
,	O
foot2	*(char)
,	O
foot3	*(char)
,	O
msg_string	*(char)
,	O
page_no	long
,	O
hdr_total_pages	long
,	O
index_page	enum(int,int,int)
)	O
;	O
dm	(char,int,*(char))->(void)
(	O
'h'	O
,	O
4	int
,	O
"postscript.c:PS_startpage layout %d no_of_sides %c page_no %d\n"	*(char)
,	O
layout	enum(int,int,int,int,int)
,	O
no_of_sides	char
,	O
page_no	long
)	O
;	O
message	*(char)
=	O
expand_string	(*(char),enum(int,int,int))->(*(char))
(	O
msg_string	*(char)
,	O
index_page	enum(int,int,int)
)	O
;	O
if	O
(	O
!	O
no_holepunch	enum(int,int,int)
&&	O
right_page	enum(int,int,int)
)	O
gap	short
=	O
HOLEPUNCH_WIDTH	int
-	O
pos_left	short
;	O
else	O
gap	short
=	O
0	int
;	O
switch	O
(	O
layout	enum(int,int,int,int,int)
)	O
{	O
case	O
ONE_ON_ONE	int
:	O
printf	(*(char))->(int)
(	O
"%%%%Page: %d %ld\n"	*(char)
,	O
logical_page_no	short
,	O
physical_page_no	long
)	O
;	O
if	O
(	O
rotate_alternate_sheets	enum(int,int,int)
&&	O
left_page	enum(int,int,int)
)	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate 180 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
if	O
(	O
orientation	char
==	O
'l'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate 270 rotate\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
}	O
else	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
if	O
(	O
orientation	char
==	O
'l'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate 90 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
}	O
break	O
;	O
case	O
TWO_ON_ONE	int
:	O
switch	O
(	O
logical_page_no	short
&	O
1	int
)	O
{	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
"%%%%Page: %d %ld\n"	*(char)
,	O
logical_page_no	short
,	O
physical_page_no	long
)	O
;	O
printf	(*(char))->(int)
(	O
"gsave\n"	*(char)
)	O
;	O
if	O
(	O
rotate_alternate_sheets	enum(int,int,int)
&&	O
left_page	enum(int,int,int)
)	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .64 .64 scale 270 rotate\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .64 .64 scale 180 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_centre_bottom	short
)	O
;	O
}	O
else	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .64 .64 scale 90 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .64 .64 scale\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_centre_top	short
)	O
;	O
}	O
break	O
;	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
"grestore\n"	*(char)
)	O
;	O
if	O
(	O
rotate_alternate_sheets	enum(int,int,int)
&&	O
left_page	enum(int,int,int)
)	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .64 .64 scale 270 rotate\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_centre_bottom	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .64 .64 scale 180 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
}	O
else	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .64 .64 scale 90 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_centre_top	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .64 .64 scale\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
}	O
}	O
break	O
;	O
case	O
THREE_ON_ONE	int
:	O
switch	O
(	O
logical_page_no	short
&	O
1	int
)	O
{	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
"%%%%Page: %d %ld\n"	*(char)
,	O
logical_page_no	short
,	O
physical_page_no	long
)	O
;	O
printf	(*(char))->(int)
(	O
"gsave\n"	*(char)
)	O
;	O
if	O
(	O
rotate_alternate_sheets	enum(int,int,int)
&&	O
left_page	enum(int,int,int)
)	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 180 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 270 rotate\n"	*(char)
,	O
pos_centre_right	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
}	O
else	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 90 rotate\n"	*(char)
,	O
pos_centre_left	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
}	O
break	O
;	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
"grestore\n"	*(char)
)	O
;	O
if	O
(	O
rotate_alternate_sheets	enum(int,int,int)
&&	O
left_page	enum(int,int,int)
)	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 180 rotate\n"	*(char)
,	O
pos_centre_left	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 270 rotate\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
}	O
else	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale\n"	*(char)
,	O
pos_centre_right	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 90 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
}	O
}	O
break	O
;	O
case	O
FOUR_ON_ONE	int
:	O
switch	O
(	O
logical_page_no	short
&	O
3	int
)	O
{	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
"%%%%Page: %d %ld\n"	*(char)
,	O
logical_page_no	short
,	O
physical_page_no	long
)	O
;	O
printf	(*(char))->(int)
(	O
"gsave\n"	*(char)
)	O
;	O
if	O
(	O
rotate_alternate_sheets	enum(int,int,int)
&&	O
left_page	enum(int,int,int)
)	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 180 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_centre_bottom	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 270 rotate\n"	*(char)
,	O
pos_centre_right	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
}	O
else	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_centre_top	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 90 rotate\n"	*(char)
,	O
pos_centre_left	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
}	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
"grestore gsave\n"	*(char)
)	O
;	O
if	O
(	O
rotate_alternate_sheets	enum(int,int,int)
&&	O
left_page	enum(int,int,int)
)	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 180 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 270 rotate\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
}	O
else	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 90 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
}	O
break	O
;	O
case	O
3	int
:	O
printf	(*(char))->(int)
(	O
"grestore gsave\n"	*(char)
)	O
;	O
if	O
(	O
rotate_alternate_sheets	enum(int,int,int)
&&	O
left_page	enum(int,int,int)
)	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 180 rotate\n"	*(char)
,	O
pos_centre_left	short
+	O
gap	short
,	O
pos_centre_bottom	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 270 rotate\n"	*(char)
,	O
pos_centre_right	short
+	O
gap	short
,	O
pos_centre_bottom	short
)	O
;	O
}	O
else	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale\n"	*(char)
,	O
pos_centre_right	short
+	O
gap	short
,	O
pos_centre_top	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 90 rotate\n"	*(char)
,	O
pos_centre_left	short
+	O
gap	short
,	O
pos_centre_top	short
)	O
;	O
}	O
break	O
;	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
"grestore\n"	*(char)
)	O
;	O
if	O
(	O
rotate_alternate_sheets	enum(int,int,int)
&&	O
left_page	enum(int,int,int)
)	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 180 rotate\n"	*(char)
,	O
pos_centre_left	short
+	O
gap	short
,	O
pos_top	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 270 rotate\n"	*(char)
,	O
pos_left	short
+	O
gap	short
,	O
pos_centre_bottom	short
)	O
;	O
}	O
else	O
{	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale\n"	*(char)
,	O
pos_centre_right	short
+	O
gap	short
,	O
pos_bottom	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%d %d translate .5 .5 scale 90 rotate\n"	*(char)
,	O
pos_right	short
+	O
gap	short
,	O
pos_centre_top	short
)	O
;	O
}	O
}	O
break	O
;	O
case	O
NO_LAYOUT	int
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
index_page	enum(int,int,int)
&&	O
(	O
(	O
no_show_line_number	enum(int,int,int)
==	O
FALSE	int
)	O
||	O
(	O
no_show_indent_level	enum(int,int,int)
==	O
FALSE	int
)	O
)	O
)	O
printf	(*(char))->(int)
(	O
"Cp "	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"Ip "	*(char)
)	O
;	O
if	O
(	O
(	O
message	*(char)
!=	O
NULL	O
)	O
&&	O
(	O
strlen	(*(char))->(long)
(	O
message	*(char)
)	O
!=	O
0	int
)	O
)	O
{	O
message_pointsize	short
=	O
printable_width	short
/	O
strlen	(*(char))->(long)
(	O
message	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"gsave\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
".9 setgray\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Rm 2 div Tm 2 div translate "	*(char)
)	O
;	O
if	O
(	O
orientation	char
==	O
'l'	O
)	O
printf	(*(char))->(int)
(	O
"30 rotate\n"	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"60 rotate\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"/Courier-Bold findfont %d scalefont setfont "	*(char)
,	O
message_pointsize	short
)	O
;	O
printf	(*(char))->(int)
(	O
"-216 0 moveto (%s) show\n"	*(char)
,	O
message	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"grestore\n"	*(char)
)	O
;	O
}	O
if	O
(	O
include_headers	enum(int,int,int)
)	O
{	O
printf	(*(char))->(int)
(	O
"HF setfont /Ypos Tm Bh sub Ps 2 div add def\n"	*(char)
)	O
;	O
balance_strings	(*(char),*(char),*(char),long,enum(int,int,int))->(void)
(	O
head1	*(char)
,	O
head2	*(char)
,	O
head3	*(char)
,	O
page_no	long
,	O
index_page	enum(int,int,int)
)	O
;	O
}	O
if	O
(	O
include_footers	enum(int,int,int)
)	O
{	O
printf	(*(char))->(int)
(	O
"HF setfont /Ypos Ps 2 div def\n"	*(char)
)	O
;	O
balance_strings	(*(char),*(char),*(char),long,enum(int,int,int))->(void)
(	O
foot1	*(char)
,	O
foot2	*(char)
,	O
foot3	*(char)
,	O
page_no	long
,	O
index_page	enum(int,int,int)
)	O
;	O
}	O
if	O
(	O
index_page	enum(int,int,int)
)	O
{	O
printf	(*(char))->(int)
(	O
"CF setfont "	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"/Vpos Tm Bh sub Ps sub def\n"	*(char)
)	O
;	O
}	O
void	O
PS_end_output	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%%%%Trailer\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%%%%EOF\n"	*(char)
)	O
;	O
}	O
void	O
balance_strings	(*(char),*(char),*(char),long,enum(int,int,int))->(void)
(	O
char	O
*	O
string1	*(char)
,	O
char	O
*	O
string2	*(char)
,	O
char	O
*	O
string3	*(char)
,	O
long	O
page_no	long
,	O
boolean	enum(int,int,int)
index_page	enum(int,int,int)
)	O
{	O
char	O
*	O
s1	*(char)
,	O
*	O
s2	*(char)
,	O
*	O
s3	*(char)
;	O
if	O
(	O
right_page	enum(int,int,int)
)	O
{	O
s1	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
expand_string	(*(char),enum(int,int,int))->(*(char))
(	O
string1	*(char)
,	O
index_page	enum(int,int,int)
)	O
)	O
;	O
s2	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
expand_string	(*(char),enum(int,int,int))->(*(char))
(	O
string2	*(char)
,	O
index_page	enum(int,int,int)
)	O
)	O
;	O
s3	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
expand_string	(*(char),enum(int,int,int))->(*(char))
(	O
string3	*(char)
,	O
index_page	enum(int,int,int)
)	O
)	O
;	O
}	O
else	O
{	O
s1	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
expand_string	(*(char),enum(int,int,int))->(*(char))
(	O
string3	*(char)
,	O
index_page	enum(int,int,int)
)	O
)	O
;	O
s2	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
expand_string	(*(char),enum(int,int,int))->(*(char))
(	O
string2	*(char)
,	O
index_page	enum(int,int,int)
)	O
)	O
;	O
s3	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
expand_string	(*(char),enum(int,int,int))->(*(char))
(	O
string1	*(char)
,	O
index_page	enum(int,int,int)
)	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"Ps Ypos moveto\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"(%s) show "	*(char)
,	O
s1	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"currentpoint pop dup "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Rm Ps sub "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"(%s) stringwidth pop "	*(char)
,	O
s3	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"sub dup Ypos moveto\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"(%s) show\n"	*(char)
,	O
s3	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"exch sub 2 div add "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"(%s) stringwidth pop "	*(char)
,	O
s2	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"2 div sub Ypos moveto\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"(%s) show\n"	*(char)
,	O
s2	*(char)
)	O
;	O
}	O
void	O
PS_pagesize	(*(char),*(int),*(int))->(void)
(	O
char	O
*	O
printer	*(char)
,	O
int	O
*	O
width_ptr	*(int)
,	O
int	O
*	O
length_ptr	*(int)
)	O
{	O
float	O
margin_height	float
;	O
short	O
tmp_sides	short
;	O
printer_stats	(*(char),*(short),*(short),*(short),*(short),*(short))->(void)
(	O
printer	*(char)
,	O
&	O
tmp_sides	short
,	O
&	O
left_margin	short
,	O
&	O
right_margin	short
,	O
&	O
top_margin	short
,	O
&	O
bottom_margin	short
)	O
;	O
if	O
(	O
no_of_sides	char
==	O
'0'	O
)	O
{	O
if	O
(	O
tmp_sides	short
==	O
1	int
)	O
no_of_sides	char
=	O
'1'	O
;	O
else	O
no_of_sides	char
=	O
'2'	O
;	O
}	O
dm	(char,int,*(char))->(void)
(	O
'O'	O
,	O
3	int
,	O
"postscript.c:PS_pagesize left %d right %d top %d bottom %d\n"	*(char)
,	O
left_margin	short
,	O
right_margin	short
,	O
top_margin	short
,	O
bottom_margin	short
)	O
;	O
dm	(char,int,*(char))->(void)
(	O
'O'	O
,	O
3	int
,	O
"postscript.c:PS_pagesize pointsize %d\n"	*(char)
,	O
pointsize	short
)	O
;	O
if	O
(	O
HOLEPUNCH_WIDTH	int
<	O
left_margin	short
)	O
no_holepunch	enum(int,int,int)
=	O
TRUE	int
;	O
if	O
(	O
!	O
no_holepunch	enum(int,int,int)
)	O
printable_width	short
=	O
right_margin	short
-	O
HOLEPUNCH_WIDTH	int
;	O
else	O
printable_width	short
=	O
right_margin	short
-	O
left_margin	short
;	O
if	O
(	O
!	O
no_top_holepunch	enum(int,int,int)
)	O
printable_height	short
=	O
top_margin	short
-	O
bottom_margin	short
-	O
HOLEPUNCH_HEIGHT	int
;	O
else	O
printable_height	short
=	O
top_margin	short
-	O
bottom_margin	short
;	O
if	O
(	O
(	O
*	O
length_ptr	*(int)
==	O
-	O
1	int
)	O
&&	O
(	O
pointsize	short
==	O
0	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
layout	enum(int,int,int,int,int)
==	O
ONE_ON_ONE	int
)	O
{	O
logical_pages_on_physical_page	short
=	O
1	int
;	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
{	O
logical_pages_rotated	short
=	O
FALSE	int
;	O
virtual_width	short
=	O
printable_width	short
;	O
virtual_height	short
=	O
printable_height	short
;	O
}	O
else	O
{	O
logical_pages_rotated	short
=	O
TRUE	int
;	O
virtual_width	short
=	O
printable_height	short
;	O
virtual_height	short
=	O
printable_width	short
;	O
}	O
}	O
else	O
if	O
(	O
layout	enum(int,int,int,int,int)
==	O
TWO_ON_ONE	int
)	O
{	O
logical_pages_on_physical_page	short
=	O
2	int
;	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
{	O
logical_pages_rotated	short
=	O
TRUE	int
;	O
virtual_width	short
=	O
printable_height	short
/	O
2	int
*	O
1.56	int
-	O
3	int
;	O
virtual_height	short
=	O
printable_width	short
*	O
1.56	int
;	O
}	O
else	O
{	O
logical_pages_rotated	short
=	O
FALSE	int
;	O
virtual_width	short
=	O
printable_width	short
*	O
1.56	int
;	O
virtual_height	short
=	O
printable_height	short
/	O
2	int
*	O
1.56	int
-	O
3	int
;	O
}	O
}	O
else	O
if	O
(	O
layout	enum(int,int,int,int,int)
==	O
THREE_ON_ONE	int
)	O
{	O
logical_pages_on_physical_page	short
=	O
2	int
;	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
{	O
logical_pages_rotated	short
=	O
FALSE	int
;	O
virtual_width	short
=	O
printable_width	short
-	O
4	int
;	O
virtual_height	short
=	O
printable_height	short
*	O
2	int
;	O
}	O
else	O
{	O
logical_pages_rotated	short
=	O
TRUE	int
;	O
virtual_width	short
=	O
printable_height	short
*	O
2	int
;	O
virtual_height	short
=	O
printable_width	short
-	O
4	int
;	O
}	O
}	O
else	O
{	O
logical_pages_on_physical_page	short
=	O
4	int
;	O
if	O
(	O
orientation	char
==	O
'p'	O
)	O
{	O
logical_pages_rotated	short
=	O
FALSE	int
;	O
virtual_width	short
=	O
printable_width	short
-	O
4	int
;	O
virtual_height	short
=	O
printable_height	short
-	O
4	int
;	O
}	O
else	O
{	O
logical_pages_rotated	short
=	O
TRUE	int
;	O
virtual_width	short
=	O
printable_height	short
-	O
4	int
;	O
virtual_height	short
=	O
printable_width	short
-	O
4	int
;	O
}	O
}	O
pos_left	short
=	O
left_margin	short
;	O
pos_centre_left	short
=	O
left_margin	short
+	O
printable_width	short
/	O
2	int
-	O
2	int
;	O
pos_centre_right	short
=	O
left_margin	short
+	O
printable_width	short
/	O
2	int
+	O
2	int
;	O
pos_right	short
=	O
left_margin	short
+	O
printable_width	short
;	O
pos_bottom	short
=	O
bottom_margin	short
;	O
pos_centre_bottom	short
=	O
bottom_margin	short
+	O
printable_height	short
/	O
2	int
-	O
2	int
;	O
pos_centre_top	short
=	O
bottom_margin	short
+	O
printable_height	short
/	O
2	int
+	O
2	int
;	O
pos_top	short
=	O
bottom_margin	short
+	O
printable_height	short
;	O
dm	(char,int,*(char))->(void)
(	O
'O'	O
,	O
3	int
,	O
"postscript.c:PS_pagesize virtual width %d, virtual height %d\n"	*(char)
,	O
virtual_width	short
,	O
virtual_height	short
)	O
;	O
dm	(char,int,*(char))->(void)
(	O
'O'	O
,	O
3	int
,	O
"postscript.c:PS_pagesize specified width %d, specified length %d\n"	*(char)
,	O
*	O
width_ptr	*(int)
,	O
*	O
length_ptr	*(int)
)	O
;	O
if	O
(	O
!	O
include_headers	enum(int,int,int)
)	O
header_box_height	short
=	O
0	int
;	O
else	O
header_box_height	short
=	O
1.5	int
*	O
pointsize	short
;	O
if	O
(	O
!	O
include_footers	enum(int,int,int)
)	O
footer_box_height	short
=	O
0	int
;	O
else	O
footer_box_height	short
=	O
1.5	int
*	O
pointsize	short
;	O
margin_height	float
=	O
header_box_height	short
+	O
footer_box_height	short
;	O
if	O
(	O
*	O
length_ptr	*(int)
==	O
-	O
1	int
)	O
*	O
length_ptr	*(int)
=	O
(	O
virtual_height	short
-	O
margin_height	float
)	O
/	O
(	O
pointsize	short
+	O
interline_gap	int
)	O
;	O
else	O
pointsize	short
=	O
(	O
short	O
)	O
(	O
virtual_height	short
-	O
(	O
interline_gap	int
*	O
*	O
length_ptr	*(int)
)	O
)	O
/	O
(	O
3	int
+	O
*	O
length_ptr	*(int)
)	O
;	O
dm	(char,int,*(char))->(void)
(	O
'O'	O
,	O
3	int
,	O
"virtual_width = %d, pointsize = %d %d\n"	*(char)
,	O
virtual_width	short
,	O
pointsize	short
,	O
0.6	int
*	O
pointsize	short
)	O
;	O
if	O
(	O
*	O
width_ptr	*(int)
==	O
-	O
1	int
)	O
*	O
width_ptr	*(int)
=	O
1.66	int
*	O
virtual_width	short
/	O
pointsize	short
;	O
dm	(char,int,*(char))->(void)
(	O
'O'	O
,	O
3	int
,	O
"postscript.c:PS_pagesize width to be used %d, length to be used %d\n"	*(char)
,	O
*	O
width_ptr	*(int)
,	O
*	O
length_ptr	*(int)
)	O
;	O
if	O
(	O
(	O
(	O
no_show_line_number	enum(int,int,int)
==	O
FALSE	int
)	O
||	O
(	O
no_show_indent_level	enum(int,int,int)
==	O
FALSE	int
)	O
)	O
&&	O
(	O
*	O
width_ptr	*(int)
>=	O
8	int
)	O
)	O
(	O
*	O
width_ptr	*(int)
)	O
-=	O
8	int
;	O
dm	(char,int,*(char))->(void)
(	O
'O'	O
,	O
3	int
,	O
"postscript.c:PS_pagesize width to be used %d, length to be used %d\n"	*(char)
,	O
*	O
width_ptr	*(int)
,	O
*	O
length_ptr	*(int)
)	O
;	O
}	O
static	O
void	O
set_no_of_sides_default	(char)->(void)
(	O
char	O
value	*(char)
)	O
{	O
no_of_sides	char
=	O
'0'	O
;	O
}	O
static	O
void	O
set_no_of_sides	(*(char),*(char),char)->(void)
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
value	*(char)
)	O
{	O
no_of_sides	char
=	O
value	*(char)
;	O
}	O
