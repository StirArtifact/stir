static	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
eval_begin_rules	(*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
___P	O
(	O
(	O
State	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))))
*	O
state	*(int)
,	O
int	O
*	O
return_seen	*(int)
)	O
)	O
;	O
static	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
eval_end_rules	(*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
___P	O
(	O
(	O
State	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))))
*	O
state	*(int)
,	O
int	O
*	O
found_return	*(int)
)	O
)	O
;	O
void	O
process_file	(*(char))->(void)
(	O
fname	*(char)
)	O
char	O
*	O
fname	*(char)
;	O
{	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
int	O
return_seen	*(int)
=	O
0	int
;	O
start_state	*(char)
=	O
NULL	O
;	O
current_fname	*(char)
=	O
fname	*(char)
;	O
current_linenum	int
=	O
1	int
;	O
data_in_buffer	int
=	O
0	int
;	O
bufpos	int
=	O
0	int
;	O
eof_seen	int
=	O
0	int
;	O
enter_system_variable	(*(char),*(char))->(void)
(	O
"filename"	*(char)
,	O
fname	*(char)
)	O
;	O
data_in_buffer	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
inbuf	*(char)
,	O
1	int
,	O
INBUFSIZE	O
,	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
data_in_buffer	int
<	O
INBUFSIZE	O
)	O
eof_seen	int
=	O
1	int
;	O
if	O
(	O
start_state_arg	*(char)
)	O
start_state	*(char)
=	O
start_state_arg	*(char)
;	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
eval_statement_list	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
start_stmts	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
,	O
NULL	O
,	O
&	O
return_seen	*(int)
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
if	O
(	O
start_state	*(char)
==	O
NULL	O
)	O
{	O
while	O
(	O
data_in_buffer	int
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
inbuf	*(char)
,	O
1	int
,	O
data_in_buffer	int
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
data_in_buffer	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
inbuf	*(char)
,	O
1	int
,	O
INBUFSIZE	O
,	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
else	O
{	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
execute_state	(*(char))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
start_state	*(char)
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
}	O
}	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
execute_state	(*(char))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
name	*(char)
)	O
char	O
*	O
name	*(char)
;	O
{	O
State	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))))
*	O
state	*(int)
;	O
State	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))))
*	O
s	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
;	O
int	O
to_read	int
,	O
got	int
;	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
,	O
*	O
first_rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
unsigned	O
int	O
first_idx	int
;	O
unsigned	O
int	O
match_len	int
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
nvoid	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
Cons	struct(*(void),*(void))
*	O
r	*(struct(*(void),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
int	O
return_seen	*(int)
=	O
0	int
;	O
int	O
idx	int
;	O
state	*(int)
=	O
lookup_state	(*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))))
(	O
name	*(char)
)	O
;	O
if	O
(	O
state	*(int)
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: undefined state `%s'\n"	*(char)
)	O
,	O
program	*(char)
,	O
name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
eval_begin_rules	(*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
state	*(int)
,	O
&	O
return_seen	*(int)
)	O
;	O
if	O
(	O
return_seen	*(int)
)	O
goto	O
out	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
eol	int
;	O
if	O
(	O
bufpos	int
>=	O
data_in_buffer	int
)	O
{	O
if	O
(	O
eof_seen	int
)	O
break	O
;	O
data_in_buffer	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
inbuf	*(char)
,	O
1	int
,	O
INBUFSIZE	O
,	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
data_in_buffer	int
<	O
INBUFSIZE	O
)	O
eof_seen	int
=	O
1	int
;	O
bufpos	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
bufpos	int
>	O
0	int
&&	O
inbuf	*(char)
[	O
bufpos	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
current_linenum	int
++	O
;	O
for	O
(	O
eol	int
=	O
bufpos	int
;	O
eol	int
<	O
data_in_buffer	int
&&	O
inbuf	*(char)
[	O
eol	int
]	O
!=	O
'\n'	O
;	O
eol	int
++	O
)	O
;	O
if	O
(	O
eol	int
<	O
data_in_buffer	int
&&	O
inbuf	*(char)
[	O
eol	int
]	O
==	O
'\n'	O
)	O
eol	int
++	O
;	O
if	O
(	O
eol	int
>=	O
data_in_buffer	int
&&	O
!	O
eof_seen	int
&&	O
bufpos	int
>	O
0	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
inbuf	*(char)
,	O
inbuf	*(char)
+	O
bufpos	int
,	O
eol	int
-	O
bufpos	int
)	O
;	O
data_in_buffer	int
=	O
eol	int
-	O
bufpos	int
;	O
bufpos	int
=	O
0	int
;	O
to_read	int
=	O
INBUFSIZE	O
-	O
data_in_buffer	int
;	O
got	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
inbuf	*(char)
+	O
data_in_buffer	int
,	O
1	int
,	O
to_read	int
,	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
got	int
<	O
to_read	int
)	O
eof_seen	int
=	O
1	int
;	O
data_in_buffer	int
+=	O
got	int
;	O
continue	O
;	O
}	O
first_idx	int
=	O
eol	int
;	O
match_len	int
=	O
0	int
;	O
first_rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
NULL	O
;	O
current_match	*(struct(int,*(int),*(int)))
=	O
NULL	O
;	O
for	O
(	O
s	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
=	O
state	*(int)
;	O
s	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
;	O
s	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
=	O
s	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
->	O
super	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
)	O
{	O
for	O
(	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
s	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
->	O
rules	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
{	O
int	O
err	int
;	O
r	*(struct(*(void),*(void)))
=	O
(	O
Cons	struct(*(void),*(void))
*	O
)	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
)	O
r	*(struct(*(void),*(void)))
->	O
car	*(void)
;	O
if	O
(	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
==	O
RULE_BEGIN	O
||	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
==	O
RULE_END	O
)	O
continue	O
;	O
if	O
(	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
type	enum(int,int,int,int,int,int,int)
==	O
nSYMBOL	int
)	O
{	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
if	O
(	O
!	O
strhash_get	(*(struct),*(char),int,*(*(void)))->(int)
(	O
ns_vars	*(struct)
,	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
sym	*(char)
,	O
strlen	(*(char))->(long)
(	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
sym	*(char)
)	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
n	long
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: undefined variable `%s'\n"	*(char)
)	O
,	O
program	*(char)
,	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
sym	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
nREGEXP	int
)	O
continue	O
;	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
n	long
;	O
}	O
err	int
=	O
re_search	(*(struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int,int,int,*(struct(int,*(int),*(int))))->(int)
(	O
REGEXP	O
(	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
,	O
inbuf	*(char)
,	O
eol	int
,	O
bufpos	int
,	O
eol	int
-	O
bufpos	int
,	O
&	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
matches	struct(int,*(int),*(int))
)	O
;	O
if	O
(	O
err	int
<	O
0	int
)	O
continue	O
;	O
idx	int
=	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
matches	struct(int,*(int),*(int))
.	O
start	*(int)
[	O
0	int
]	O
;	O
if	O
(	O
idx	int
>=	O
0	int
&&	O
(	O
idx	int
<	O
first_idx	int
||	O
(	O
idx	int
==	O
first_idx	int
&&	O
(	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
matches	struct(int,*(int),*(int))
.	O
end	*(int)
[	O
0	int
]	O
-	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
matches	struct(int,*(int),*(int))
.	O
start	*(int)
[	O
0	int
]	O
>	O
match_len	int
)	O
)	O
)	O
)	O
{	O
first_idx	int
=	O
idx	int
;	O
first_rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
match_len	int
=	O
(	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
matches	struct(int,*(int),*(int))
.	O
end	*(int)
[	O
0	int
]	O
-	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
matches	struct(int,*(int),*(int))
.	O
start	*(int)
[	O
0	int
]	O
)	O
;	O
current_match	*(struct(int,*(int),*(int)))
=	O
&	O
exp	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
matches	struct(int,*(int),*(int))
;	O
current_match_buf	*(char)
=	O
inbuf	*(char)
;	O
}	O
}	O
}	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
inbuf	*(char)
+	O
bufpos	int
,	O
1	int
,	O
first_idx	int
-	O
bufpos	int
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
first_rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
{	O
bufpos	int
=	O
current_match	*(struct(int,*(int),*(int)))
->	O
end	*(int)
[	O
0	int
]	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
eval_statement_list	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
(	O
List	struct(*(struct(*(struct(*`,*`)),*(void))),*(struct(*(struct(*`,*`)),*(void))))
*	O
)	O
(	O
(	O
Cons	struct(*(void),*(void))
*	O
)	O
first_rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
)	O
->	O
cdr	*(void)
,	O
NULL	O
,	O
&	O
return_seen	*(int)
)	O
;	O
if	O
(	O
return_seen	*(int)
)	O
goto	O
out	O
;	O
}	O
else	O
bufpos	int
=	O
first_idx	int
;	O
}	O
out	O
:	O
{	O
int	O
found	int
=	O
0	int
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
result2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
result2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
eval_end_rules	(*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
state	*(int)
,	O
&	O
found	int
)	O
;	O
if	O
(	O
found	int
)	O
{	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
result2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
}	O
return	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
static	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
eval_begin_rules	(*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
state	*(int)
,	O
return_seen	*(int)
)	O
State	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))))
*	O
state	*(int)
;	O
int	O
*	O
return_seen	*(int)
;	O
{	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
nvoid	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
Cons	struct(*(void),*(void))
*	O
r	*(struct(*(void),*(void)))
;	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
if	O
(	O
state	*(int)
->	O
super_name	*(char)
&&	O
state	*(int)
->	O
super	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
==	O
NULL	O
)	O
{	O
state	*(int)
->	O
super	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
=	O
lookup_state	(*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))))
(	O
state	*(int)
->	O
super_name	*(char)
)	O
;	O
if	O
(	O
state	*(int)
->	O
super	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: undefined super state `%s'\n"	*(char)
)	O
,	O
program	*(char)
,	O
state	*(int)
->	O
super_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
state	*(int)
->	O
super	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
)	O
{	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
eval_begin_rules	(*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
state	*(int)
->	O
super	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
,	O
return_seen	*(int)
)	O
;	O
if	O
(	O
*	O
return_seen	*(int)
)	O
return	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
for	O
(	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
state	*(int)
->	O
rules	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
{	O
r	*(struct(*(void),*(void)))
=	O
(	O
Cons	struct(*(void),*(void))
*	O
)	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
if	O
(	O
r	*(struct(*(void),*(void)))
->	O
car	*(void)
==	O
RULE_BEGIN	O
)	O
{	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
eval_statement_list	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
(	O
List	struct(*(struct(*(struct(*`,*`)),*(void))),*(struct(*(struct(*`,*`)),*(void))))
*	O
)	O
r	*(struct(*(void),*(void)))
->	O
cdr	*(void)
,	O
NULL	O
,	O
return_seen	*(int)
)	O
;	O
if	O
(	O
*	O
return_seen	*(int)
)	O
break	O
;	O
}	O
}	O
return	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
static	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
eval_end_rules	(*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
state	*(int)
,	O
found_return	*(int)
)	O
State	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))))
*	O
state	*(int)
;	O
int	O
*	O
found_return	*(int)
;	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Cons	struct(*(void),*(void))
*	O
r	*(struct(*(void),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
nvoid	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
int	O
return_seen	*(int)
;	O
for	O
(	O
;	O
state	*(int)
;	O
state	*(int)
=	O
state	*(int)
->	O
super	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`)))))
)	O
for	O
(	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
state	*(int)
->	O
rules	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
{	O
r	*(struct(*(void),*(void)))
=	O
(	O
Cons	struct(*(void),*(void))
*	O
)	O
rule	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
if	O
(	O
r	*(struct(*(void),*(void)))
->	O
car	*(void)
==	O
RULE_END	O
)	O
{	O
*	O
found_return	*(int)
=	O
1	int
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
eval_statement_list	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
(	O
List	struct(*(struct(*(struct(*`,*`)),*(void))),*(struct(*(struct(*`,*`)),*(void))))
*	O
)	O
r	*(struct(*(void),*(void)))
->	O
cdr	*(void)
,	O
NULL	O
,	O
&	O
return_seen	*(int)
)	O
;	O
}	O
}	O
return	O
result	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
