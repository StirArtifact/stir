int	O
mu_auth_data_alloc	(*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))),*(char),*(char),int,int,*(char),*(char),*(char),*(char),int)->(int)
(	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
*	O
ptr	*(*(void))
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
,	O
uid_t	int
uid	int
,	O
gid_t	int
gid	int
,	O
const	O
char	O
*	O
gecos	*(char)
,	O
const	O
char	O
*	O
dir	*(char)
,	O
const	O
char	O
*	O
shell	*(char)
,	O
const	O
char	O
*	O
mailbox	*(char)
,	O
int	O
change_uid	int
)	O
{	O
size_t	long
size	*(long)
;	O
char	O
*	O
p	*(char)
;	O
char	O
*	O
tmp_mailbox_name	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
name	*(char)
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
)	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
=	O
"x"	*(char)
;	O
if	O
(	O
!	O
gecos	*(char)
)	O
gecos	*(char)
=	O
""	*(char)
;	O
if	O
(	O
!	O
dir	*(char)
)	O
dir	*(char)
=	O
"/nonexisting"	*(char)
;	O
if	O
(	O
!	O
shell	*(char)
)	O
shell	*(char)
=	O
"/dev/null"	*(char)
;	O
if	O
(	O
!	O
mailbox	*(char)
)	O
{	O
int	O
rc	int
=	O
mu_construct_user_mailbox_url	(*(*(char)),*(char))->(int)
(	O
&	O
tmp_mailbox_name	*(char)
,	O
name	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mailbox	*(char)
=	O
tmp_mailbox_name	*(char)
;	O
}	O
size	*(long)
=	O
sizeof	O
(	O
*	O
*	O
ptr	*(*(void))
)	O
+	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
gecos	*(char)
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
dir	*(char)
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
shell	*(char)
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
mailbox	*(char)
)	O
+	O
1	int
;	O
*	O
ptr	*(*(void))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
size	*(long)
)	O
;	O
if	O
(	O
!	O
*	O
ptr	*(*(void))
)	O
return	O
ENOMEM	int
;	O
p	*(char)
=	O
(	O
char	O
*	O
)	O
(	O
*	O
ptr	*(*(void))
+	O
1	int
)	O
;	O
COPY	O
(	O
name	*(char)
)	O
;	O
COPY	O
(	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
)	O
;	O
COPY	O
(	O
gecos	*(char)
)	O
;	O
COPY	O
(	O
dir	*(char)
)	O
;	O
COPY	O
(	O
shell	*(char)
)	O
;	O
COPY	O
(	O
mailbox	*(char)
)	O
;	O
(	O
*	O
ptr	*(*(void))
)	O
->	O
uid	int
=	O
uid	int
;	O
(	O
*	O
ptr	*(*(void))
)	O
->	O
gid	int
=	O
gid	int
;	O
(	O
*	O
ptr	*(*(void))
)	O
->	O
change_uid	int
=	O
change_uid	int
;	O
free	(*(void))->(void)
(	O
tmp_mailbox_name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
mu_auth_data_set_quota	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),long)->(void)
(	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
ptr	*(*(void))
,	O
mu_off_t	long
q	*(char)
)	O
{	O
ptr	*(*(void))
->	O
flags	int
|=	O
MU_AF_QUOTA	int
;	O
ptr	*(*(void))
->	O
quota	long
=	O
q	*(char)
;	O
}	O
void	O
mu_auth_data_free	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(void)
(	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
ptr	*(*(void))
)	O
{	O
free	(*(void))->(void)
(	O
ptr	*(*(void))
)	O
;	O
}	O
void	O
mu_auth_data_destroy	(*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))))->(void)
(	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
*	O
pptr	*(*(struct(*(char),*(char),*(char),*(struct))))
)	O
{	O
if	O
(	O
pptr	*(*(struct(*(char),*(char),*(char),*(struct))))
)	O
{	O
mu_auth_data_free	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(void)
(	O
*	O
pptr	*(*(struct(*(char),*(char),*(char),*(struct))))
)	O
;	O
*	O
pptr	*(*(struct(*(char),*(char),*(char),*(struct))))
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
append_auth_module	(*(*(struct)),*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
mu_list_t	*(struct)
*	O
pflist	*(*(struct))
,	O
struct	O
mu_auth_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
*	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
{	O
if	O
(	O
!	O
*	O
pflist	*(*(struct))
&&	O
mu_list_create	(*(*(struct)))->(int)
(	O
pflist	*(*(struct))
)	O
)	O
return	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
*	O
pflist	*(*(struct))
,	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
;	O
}	O
int	O
mu_auth_runlist	(*(struct),enum(int,int,int),*(void),*(void),*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))))->(int)
(	O
mu_list_t	*(struct)
flist	*(struct)
,	O
enum	O
mu_auth_mode	enum(int,int,int)
mode	int
,	O
const	O
void	O
*	O
key	*(*(void))
,	O
void	O
*	O
data	*(void)
,	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
*	O
return_data	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
{	O
int	O
status	int
=	O
MU_ERR_AUTH_FAILURE	O
;	O
int	O
rc	int
;	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
if	O
(	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
flist	*(struct)
,	O
&	O
itr	*(struct)
)	O
==	O
0	int
)	O
{	O
struct	O
mu_auth_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
*	O
ep	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
ep	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
;	O
if	O
(	O
!	O
ep	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
[	O
mode	int
]	O
)	O
continue	O
;	O
mu_debug	O
(	O
MU_DEBCAT_AUTH	int
,	O
MU_DEBUG_TRACE2	int
,	O
(	O
"Trying %s..."	*(char)
,	O
ep	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
name	*(char)
)	O
)	O
;	O
rc	int
=	O
ep	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
[	O
mode	int
]	O
(	O
return_data	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
key	*(*(void))
,	O
ep	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
data	*(void)
[	O
mode	int
]	O
,	O
data	*(void)
)	O
;	O
mu_debug	O
(	O
MU_DEBCAT_AUTH	int
,	O
MU_DEBUG_TRACE2	int
,	O
(	O
"%s yields %d=%s"	*(char)
,	O
ep	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
name	*(char)
,	O
rc	int
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
return_data	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
{	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
*	O
return_data	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
;	O
if	O
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
source	*(char)
==	O
NULL	O
)	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
source	*(char)
=	O
ep	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
name	*(char)
;	O
DEBUG_AUTH	O
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
;	O
}	O
status	int
=	O
rc	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
ENOSYS	int
&&	O
status	int
!=	O
0	int
)	O
;	O
else	O
if	O
(	O
status	int
!=	O
EAGAIN	int
)	O
status	int
=	O
rc	int
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
return	O
status	int
;	O
}	O
int	O
mu_auth_nosupport	(*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))),*(void),*(void),*(void))->(int)
(	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
*	O
return_data	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
MU_ARG_UNUSED	O
,	O
const	O
void	O
*	O
key	*(*(void))
MU_ARG_UNUSED	O
,	O
void	O
*	O
func_data	*(void)
MU_ARG_UNUSED	O
,	O
void	O
*	O
call_data	*(void)
MU_ARG_UNUSED	O
)	O
{	O
return	O
ENOSYS	int
;	O
}	O
static	O
mu_list_t	*(struct)
mu_getpw_modules	*(struct)
,	O
selected_getpw_modules	*(struct)
;	O
int	O
mu_get_auth	(*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))),enum(int,int),*(void))->(int)
(	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
enum	O
mu_auth_key_type	enum(int,int)
type	*(char)
,	O
const	O
void	O
*	O
key	*(*(void))
)	O
{	O
enum	O
mu_auth_mode	enum(int,int,int)
mode	int
;	O
if	O
(	O
!	O
mu_getpw_modules	*(struct)
)	O
mu_auth_begin_setup	()->(void)
(	O
)	O
;	O
switch	O
(	O
type	*(char)
)	O
{	O
case	O
mu_auth_key_name	int
:	O
mode	int
=	O
mu_auth_getpwnam	int
;	O
mu_debug	O
(	O
MU_DEBCAT_AUTH	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"Getting auth info for user %s"	*(char)
,	O
(	O
char	O
*	O
)	O
key	*(*(void))
)	O
)	O
;	O
break	O
;	O
case	O
mu_auth_key_uid	int
:	O
mode	int
=	O
mu_auth_getpwuid	int
;	O
mu_debug	O
(	O
MU_DEBCAT_AUTH	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"Getting auth info for UID %lu"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
*	O
(	O
uid_t	int
*	O
)	O
key	*(*(void))
)	O
)	O
;	O
break	O
;	O
default	O
:	O
mu_debug	O
(	O
MU_DEBCAT_AUTH	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Unknown mu_auth_key_type: %d"	*(char)
,	O
type	*(char)
)	O
)	O
;	O
return	O
EINVAL	int
;	O
}	O
return	O
mu_auth_runlist	(*(struct),enum(int,int,int),*(void),*(void),*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))))->(int)
(	O
mu_getpw_modules	*(struct)
,	O
mode	int
,	O
key	*(*(void))
,	O
NULL	O
,	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
;	O
}	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
mu_get_auth_by_name	(*(char))->(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
(	O
const	O
char	O
*	O
username	*(char)
)	O
{	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
NULL	O
;	O
mu_get_auth	(*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))),enum(int,int),*(void))->(int)
(	O
&	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
mu_auth_key_name	int
,	O
username	*(char)
)	O
;	O
return	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
;	O
}	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
mu_get_auth_by_uid	(int)->(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
(	O
uid_t	int
uid	int
)	O
{	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
NULL	O
;	O
mu_get_auth	(*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))),enum(int,int),*(void))->(int)
(	O
&	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
mu_auth_key_uid	int
,	O
&	O
uid	int
)	O
;	O
return	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
;	O
}	O
static	O
mu_list_t	*(struct)
mu_auth_modules	*(struct)
,	O
selected_auth_modules	*(struct)
;	O
int	O
mu_authenticate	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),*(char))->(int)
(	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth_data	*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))
,	O
const	O
char	O
*	O
pass	*(char)
)	O
{	O
if	O
(	O
!	O
auth_data	*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))
)	O
return	O
EINVAL	int
;	O
mu_debug	O
(	O
MU_DEBCAT_AUTH	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"mu_authenticate, user %s, source %s"	*(char)
,	O
auth_data	*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))
->	O
name	*(char)
,	O
auth_data	*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))
->	O
source	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
mu_auth_modules	*(struct)
)	O
mu_auth_begin_setup	()->(void)
(	O
)	O
;	O
return	O
mu_auth_runlist	(*(struct),enum(int,int,int),*(void),*(void),*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))))->(int)
(	O
mu_auth_modules	*(struct)
,	O
mu_auth_authenticate	int
,	O
auth_data	*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))
,	O
(	O
void	O
*	O
)	O
pass	*(char)
,	O
NULL	O
)	O
;	O
}	O
static	O
mu_list_t	*(struct)
module_list	*(struct)
;	O
static	O
void	O
module_list_init	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
!	O
module_list	*(struct)
)	O
{	O
if	O
(	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
module_list	*(struct)
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
module_list	*(struct)
,	O
&	O
mu_auth_generic_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*((*(void))->(void)))
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
module_list	*(struct)
,	O
&	O
mu_auth_system_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*((*(void))->(void)))
)	O
;	O
}	O
}	O
void	O
mu_auth_register_module	(*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
struct	O
mu_auth_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
*	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
{	O
module_list_init	()->(void)
(	O
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
module_list	*(struct)
,	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
;	O
}	O
static	O
struct	O
mu_auth_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
*	O
_locate	(*(char))->(*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
mu_auth_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
*	O
rp	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
=	O
NULL	O
;	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
if	O
(	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
module_list	*(struct)
,	O
&	O
itr	*(struct)
)	O
==	O
0	int
)	O
{	O
struct	O
mu_auth_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
*	O
p	*(char)
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
rp	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
&&	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
p	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(char)
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
rp	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
=	O
p	*(char)
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
return	O
rp	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
;	O
}	O
static	O
void	O
_add_module_list	(*(char),*((*(char))->(int)))->(void)
(	O
const	O
char	O
*	O
modlist	*(char)
,	O
int	O
(	O
*	O
fun	*((*(char),*(void))->(int))
)	O
(	O
const	O
char	O
*	O
name	*(char)
)	O
)	O
{	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
int	O
i	int
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_delim	*(char)
=	O
":"	*(char)
;	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
modlist	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_DELIM	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot split line `%s': %s"	*(char)
)	O
,	O
modlist	*(char)
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
fun	*((*(char),*(void))->(int))
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
||	O
errno	O
==	O
MU_ERR_NOENT	O
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"no such module: %s"	*(char)
)	O
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
)	O
;	O
else	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"failed to add module %s: %s"	*(char)
)	O
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
}	O
int	O
mu_authorization_add_module	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
mu_auth_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
*	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
=	O
_locate	(*(char))->(*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
{	O
errno	O
=	O
MU_ERR_NOENT	O
;	O
return	O
1	int
;	O
}	O
append_auth_module	(*(*(struct)),*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
&	O
selected_getpw_modules	*(struct)
,	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
;	O
return	O
0	int
;	O
}	O
void	O
mu_authorization_add_module_list	(*(char))->(void)
(	O
const	O
char	O
*	O
modlist	*(char)
)	O
{	O
_add_module_list	(*(char),*((*(char))->(int)))->(void)
(	O
modlist	*(char)
,	O
mu_authorization_add_module	(*(char))->(int)
)	O
;	O
}	O
void	O
mu_authorization_clear_list	()->(void)
(	O
)	O
{	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
selected_getpw_modules	*(struct)
)	O
;	O
}	O
int	O
mu_authentication_add_module	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
mu_auth_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
*	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
=	O
_locate	(*(char))->(*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
{	O
errno	O
=	O
MU_ERR_NOENT	O
;	O
return	O
1	int
;	O
}	O
append_auth_module	(*(*(struct)),*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
&	O
selected_auth_modules	*(struct)
,	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
;	O
return	O
0	int
;	O
}	O
void	O
mu_authentication_add_module_list	(*(char))->(void)
(	O
const	O
char	O
*	O
modlist	*(char)
)	O
{	O
_add_module_list	(*(char),*((*(char))->(int)))->(void)
(	O
modlist	*(char)
,	O
mu_authentication_add_module	(*(char))->(int)
)	O
;	O
}	O
void	O
mu_authentication_clear_list	()->(void)
(	O
)	O
{	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
selected_auth_modules	*(struct)
)	O
;	O
}	O
void	O
mu_auth_begin_setup	()->(void)
(	O
void	O
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
module_list_init	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
mu_auth_modules	*(struct)
)	O
{	O
if	O
(	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
module_list	*(struct)
,	O
&	O
itr	*(struct)
)	O
==	O
0	int
)	O
{	O
struct	O
mu_auth_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
*	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
;	O
append_auth_module	(*(*(struct)),*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
&	O
mu_auth_modules	*(struct)
,	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
}	O
if	O
(	O
!	O
mu_getpw_modules	*(struct)
)	O
{	O
if	O
(	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
module_list	*(struct)
,	O
&	O
itr	*(struct)
)	O
==	O
0	int
)	O
{	O
struct	O
mu_auth_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
*	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
;	O
append_auth_module	(*(*(struct)),*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
&	O
mu_getpw_modules	*(struct)
,	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
}	O
}	O
void	O
mu_auth_finish_setup	()->(void)
(	O
void	O
)	O
{	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
mu_auth_modules	*(struct)
)	O
;	O
mu_auth_modules	*(struct)
=	O
selected_auth_modules	*(struct)
;	O
selected_auth_modules	*(struct)
=	O
NULL	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
mu_getpw_modules	*(struct)
)	O
;	O
mu_getpw_modules	*(struct)
=	O
selected_getpw_modules	*(struct)
;	O
selected_getpw_modules	*(struct)
=	O
NULL	O
;	O
mu_auth_begin_setup	()->(void)
(	O
)	O
;	O
}	O
struct	O
settings	struct(*(struct),*(struct))
{	O
mu_list_t	*(struct)
opts	*(struct)
;	O
mu_list_t	*(struct)
commits	*(struct)
;	O
}	O
;	O
static	O
int	O
do_extend	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
mu_auth_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
*	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
=	O
item	*(void)
;	O
struct	O
settings	struct(*(struct),*(struct))
*	O
set	*(struct(*(struct),*(struct)))
=	O
data	*(void)
;	O
if	O
(	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
)	O
mu_list_append	(*(struct),*(void))->(int)
(	O
set	*(struct(*(struct),*(struct)))
->	O
opts	*(struct)
,	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
)	O
;	O
if	O
(	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
commit	*((*(void))->(void))
)	O
mu_list_append	(*(struct),*(void))->(int)
(	O
set	*(struct(*(struct),*(struct)))
->	O
commits	*(struct)
,	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
commit	*((*(void))->(void))
)	O
;	O
if	O
(	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
parser	*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int))
||	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
)	O
mu_config_root_register_section	(*(char),*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))))->(int)
(	O
NULL	O
,	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
name	*(char)
,	O
NULL	O
,	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
parser	*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int))
,	O
mod	*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
->	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
)	O
;	O
return	O
0	int
;	O
}	O
void	O
mu_auth_extend_settings	(*(struct),*(struct))->(void)
(	O
mu_list_t	*(struct)
opts	*(struct)
,	O
mu_list_t	*(struct)
commits	*(struct)
)	O
{	O
struct	O
settings	struct(*(struct),*(struct))
s	*(char)
;	O
s	*(char)
.	O
opts	*(struct)
=	O
opts	*(struct)
;	O
s	*(char)
.	O
commits	*(struct)
=	O
commits	*(struct)
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
module_list	*(struct)
,	O
do_extend	(*(void),*(void))->(int)
,	O
&	O
s	*(char)
)	O
;	O
}	O
