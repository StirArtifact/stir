struct	O
rec_type_s	struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char))))
{	O
char	O
*	O
name	*(char)
;	O
enum	O
rec_type_kind_e	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
kind	enum(int,int,int)
;	O
char	O
*	O
expr	*(char)
;	O
size_t	long
size	*(long)
;	O
union	O
{	O
size_t	long
max_size	long
;	O
int	O
range	array(int)
[	O
2	int
]	O
;	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
regexp	*(char)
;	O
char	O
*	O
recname	*(char)
;	O
char	O
*	O
*	O
names	*(*(char))
;	O
}	O
data	*(void)
;	O
}	O
;	O
struct	O
rec_type_reg_entry_s	struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char))))),*(char),bool)
{	O
char	O
*	O
type_name	*(char)
;	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
;	O
char	O
*	O
to_type	*(char)
;	O
bool	bool
visited_p	bool
;	O
}	O
;	O
struct	O
rec_type_reg_s	struct(long,*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool)))
{	O
size_t	long
num_types	long
;	O
struct	O
rec_type_reg_entry_s	struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char))))),*(char),bool)
*	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
;	O
}	O
;	O
static	O
enum	O
rec_type_kind_e	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
rec_type_parse_type_kind	(*(char))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
char	O
*	O
str	*(char)
)	O
;	O
static	O
bool	bool
rec_type_check_int	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_bool	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_range	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_real	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_size	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_line	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_regexp	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_date	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_email	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_enum	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_field	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_rec	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_type_check_uuid	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
const	O
char	O
*	O
rec_type_parse_size	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
;	O
static	O
const	O
char	O
*	O
rec_type_parse_enum	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
;	O
static	O
const	O
char	O
*	O
rec_type_parse_regexp_type	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
;	O
static	O
const	O
char	O
*	O
rec_type_parse_range	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
;	O
static	O
const	O
char	O
*	O
rec_type_parse_rec	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
;	O
bool	bool
rec_type_descr_p	(*(char))->(bool)
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
bool	bool
ret	bool
;	O
rec_type_t	*(struct)
aux_type	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
;	O
ret	bool
=	O
false	int
;	O
aux_type	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
=	O
rec_type_new	(*(char))->(*(struct))
(	O
str	*(char)
)	O
;	O
if	O
(	O
aux_type	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
{	O
ret	bool
=	O
true	int
;	O
rec_type_destroy	(*(struct))->(void)
(	O
aux_type	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
char	O
*	O
rec_type_descr_type	(*(char))->(*(char))
(	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
result	*(*(char))
=	O
NULL	O
;	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
rec_type_descr_p	(*(char))->(bool)
(	O
str	*(char)
)	O
)	O
{	O
p	*(void)
=	O
str	*(char)
;	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
rec_parse_regexp	(*(*(char)),*(char),*(*(char)))->(bool)
(	O
&	O
p	*(void)
,	O
"^"	*(char)
REC_FNAME_RE	*(char)
"(,"	*(char)
REC_FNAME_RE	*(char)
")*"	*(char)
,	O
&	O
name	*(char)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
result	*(*(char))
=	O
strdup	(*(char))->(*(char))
(	O
p	*(void)
)	O
;	O
}	O
return	O
result	*(*(char))
;	O
}	O
rec_type_t	*(struct)
rec_type_new	(*(char))->(*(struct))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
rec_type_t	*(struct)
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
;	O
const	O
char	O
*	O
p	*(void)
;	O
char	O
*	O
type_kind_str	*(char)
=	O
NULL	O
;	O
p	*(void)
=	O
str	*(char)
;	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
rec_type_s	struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char))))
)	O
)	O
;	O
if	O
(	O
!	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
{	O
goto	O
exit	(int)->(void)
;	O
}	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
->	O
name	*(char)
=	O
NULL	O
;	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
->	O
size	*(long)
=	O
0	int
;	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
!	O
rec_parse_regexp	(*(*(char)),*(char),*(*(char)))->(bool)
(	O
&	O
p	*(void)
,	O
"^"	*(char)
REC_TYPE_CLASS_RE	O
,	O
&	O
type_kind_str	*(char)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
=	O
NULL	O
;	O
goto	O
exit	(int)->(void)
;	O
}	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
->	O
kind	enum(int,int,int)
=	O
rec_type_parse_type_kind	(*(char))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
type_kind_str	*(char)
)	O
;	O
switch	O
(	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
->	O
kind	enum(int,int,int)
)	O
{	O
case	O
REC_TYPE_SIZE	int
:	O
{	O
p	*(void)
=	O
rec_type_parse_size	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
p	*(void)
,	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
=	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_ENUM	int
:	O
{	O
p	*(void)
=	O
rec_type_parse_enum	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
p	*(void)
,	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
=	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_REGEXP	int
:	O
{	O
p	*(void)
=	O
rec_type_parse_regexp_type	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
p	*(void)
,	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
=	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_RANGE	int
:	O
{	O
p	*(void)
=	O
rec_type_parse_range	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
p	*(void)
,	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
=	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_REC	int
:	O
{	O
p	*(void)
=	O
rec_type_parse_rec	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
p	*(void)
,	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
=	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_INT	int
:	O
case	O
REC_TYPE_BOOL	int
:	O
case	O
REC_TYPE_REAL	int
:	O
case	O
REC_TYPE_LINE	int
:	O
case	O
REC_TYPE_FIELD	int
:	O
case	O
REC_TYPE_DATE	int
:	O
case	O
REC_TYPE_EMAIL	int
:	O
case	O
REC_TYPE_UUID	int
:	O
{	O
break	O
;	O
}	O
case	O
REC_TYPE_NONE	int
:	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"internal error: rec-types: got REC_TYPE_NONE from rec_type_parse_type_kind() in rec_type_new().\n"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
{	O
while	O
(	O
*	O
p	*(void)
!=	O
'\0'	O
)	O
{	O
if	O
(	O
!	O
rec_blank_p	(char)->(bool)
(	O
*	O
p	*(void)
)	O
)	O
{	O
rec_type_destroy	(*(struct))->(void)
(	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
;	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
=	O
NULL	O
;	O
break	O
;	O
}	O
p	*(void)
++	O
;	O
}	O
}	O
exit	(int)->(void)
:	O
free	(*(void))->(void)
(	O
type_kind_str	*(char)
)	O
;	O
return	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
;	O
}	O
enum	O
rec_type_kind_e	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
rec_type_kind	(*(struct))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
return	O
type	enum(int,int,int,int)
->	O
kind	enum(int,int,int)
;	O
}	O
char	O
*	O
rec_type_kind_str	(*(struct))->(*(char))
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
char	O
*	O
res	*(char)
;	O
switch	O
(	O
type	enum(int,int,int,int)
->	O
kind	enum(int,int,int)
)	O
{	O
case	O
REC_TYPE_NONE	int
:	O
{	O
res	*(char)
=	O
""	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_INT	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_INT_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_BOOL	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_BOOL_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_RANGE	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_RANGE_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REAL	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_REAL_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_SIZE	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_SIZE_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_LINE	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_LINE_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REGEXP	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_REGEXP_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_DATE	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_DATE_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_EMAIL	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_EMAIL_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_ENUM	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_ENUM_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_FIELD	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_FIELD_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REC	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_REC_NAME	*(char)
;	O
break	O
;	O
}	O
case	O
REC_TYPE_UUID	int
:	O
{	O
res	*(char)
=	O
REC_TYPE_UUID_NAME	*(char)
;	O
break	O
;	O
}	O
default	O
:	O
{	O
res	*(char)
=	O
REC_TYPE_NONE	int
;	O
break	O
;	O
}	O
}	O
return	O
res	*(char)
;	O
}	O
bool	bool
rec_type_check	(*(struct),*(char),*(*(char)))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
char	O
*	O
*	O
error_str	*(*(char))
)	O
{	O
bool	bool
res	*(char)
;	O
rec_buf_t	*(struct)
errors	*(struct)
;	O
char	O
*	O
err_str	*(char)
;	O
size_t	long
errors_size	long
;	O
errors	*(struct)
=	O
rec_buf_new	(*(*(char)),*(long))->(*(struct))
(	O
&	O
err_str	*(char)
,	O
&	O
errors_size	long
)	O
;	O
res	*(char)
=	O
false	int
;	O
switch	O
(	O
type	enum(int,int,int,int)
->	O
kind	enum(int,int,int)
)	O
{	O
case	O
REC_TYPE_NONE	int
:	O
{	O
res	*(char)
=	O
true	int
;	O
break	O
;	O
}	O
case	O
REC_TYPE_INT	int
:	O
{	O
res	*(char)
=	O
rec_type_check_int	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_BOOL	int
:	O
{	O
res	*(char)
=	O
rec_type_check_bool	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_RANGE	int
:	O
{	O
res	*(char)
=	O
rec_type_check_range	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REAL	int
:	O
{	O
res	*(char)
=	O
rec_type_check_real	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_SIZE	int
:	O
{	O
res	*(char)
=	O
rec_type_check_size	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_LINE	int
:	O
{	O
res	*(char)
=	O
rec_type_check_line	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REGEXP	int
:	O
{	O
res	*(char)
=	O
rec_type_check_regexp	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_DATE	int
:	O
{	O
res	*(char)
=	O
rec_type_check_date	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_EMAIL	int
:	O
{	O
res	*(char)
=	O
rec_type_check_email	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_ENUM	int
:	O
{	O
res	*(char)
=	O
rec_type_check_enum	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_FIELD	int
:	O
{	O
res	*(char)
=	O
rec_type_check_field	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REC	int
:	O
{	O
res	*(char)
=	O
rec_type_check_rec	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_UUID	int
:	O
{	O
res	*(char)
=	O
rec_type_check_uuid	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
type	enum(int,int,int,int)
,	O
str	*(char)
,	O
errors	*(struct)
)	O
;	O
break	O
;	O
}	O
}	O
rec_buf_close	(*(struct))->(void)
(	O
errors	*(struct)
)	O
;	O
if	O
(	O
error_str	*(*(char))
)	O
{	O
*	O
error_str	*(*(char))
=	O
err_str	*(char)
;	O
}	O
else	O
{	O
free	(*(void))->(void)
(	O
err_str	*(char)
)	O
;	O
}	O
return	O
res	*(char)
;	O
}	O
void	O
rec_type_destroy	(*(struct))->(void)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
int	O
i	long
;	O
if	O
(	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
->	O
kind	enum(int,int,int)
==	O
REC_TYPE_ENUM	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
type	enum(int,int,int,int)
->	O
size	*(long)
;	O
i	long
++	O
)	O
{	O
free	(*(void))->(void)
(	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
names	*(*(char))
[	O
i	long
]	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
type	enum(int,int,int,int)
->	O
kind	enum(int,int,int)
==	O
REC_TYPE_REGEXP	int
)	O
{	O
regfree	O
(	O
&	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
regexp	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
type	enum(int,int,int,int)
->	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
type	enum(int,int,int,int)
)	O
;	O
}	O
}	O
rec_type_reg_t	*(struct)
rec_type_reg_new	()->(*(struct))
(	O
void	O
)	O
{	O
rec_type_reg_t	*(struct)
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
;	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
rec_type_reg_s	struct(long,*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool)))
)	O
)	O
;	O
if	O
(	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
)	O
{	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
->	O
num_types	long
=	O
0	int
;	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
=	O
NULL	O
;	O
}	O
return	O
new	*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char)))))
;	O
}	O
void	O
rec_type_reg_destroy	(*(struct))->(void)
(	O
rec_type_reg_t	*(struct)
reg	*(struct)
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
reg	*(struct)
->	O
num_types	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type	enum(int,int,int,int)
)	O
{	O
rec_type_destroy	(*(struct))->(void)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type	enum(int,int,int,int)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type_name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
to_type	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
)	O
;	O
free	(*(void))->(void)
(	O
reg	*(struct)
)	O
;	O
}	O
void	O
rec_type_reg_add	(*(struct),*(struct))->(void)
(	O
rec_type_reg_t	*(struct)
reg	*(struct)
,	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
size_t	long
i	long
;	O
const	O
char	O
*	O
type_name	*(char)
=	O
NULL	O
;	O
type_name	*(char)
=	O
rec_type_name	(*(struct))->(*(char))
(	O
type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
!	O
type_name	*(char)
)	O
{	O
return	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
reg	*(struct)
->	O
num_types	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type_name	*(char)
,	O
type_name	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type	enum(int,int,int,int)
)	O
{	O
rec_type_destroy	(*(struct))->(void)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type	enum(int,int,int,int)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type_name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
to_type	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
i	long
==	O
reg	*(struct)
->	O
num_types	long
)	O
{	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
=	O
realloc	(*(void),long)->(*(void))
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
,	O
(	O
(	O
i	long
/	O
REC_TYPE_REG_ALLOC_TYPES	int
)	O
+	O
1	int
)	O
*	O
(	O
sizeof	O
(	O
struct	O
rec_type_reg_entry_s	struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char))))),*(char),bool)
*	O
)	O
*	O
REC_TYPE_REG_ALLOC_TYPES	int
)	O
)	O
;	O
reg	*(struct)
->	O
num_types	long
++	O
;	O
}	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type_name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
rec_type_name	(*(struct))->(*(char))
(	O
type	enum(int,int,int,int)
)	O
)	O
;	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
to_type	*(char)
=	O
NULL	O
;	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
visited_p	bool
=	O
false	int
;	O
}	O
void	O
rec_type_reg_add_synonym	(*(struct),*(char),*(char))->(void)
(	O
rec_type_reg_t	*(struct)
reg	*(struct)
,	O
const	O
char	O
*	O
type_name	*(char)
,	O
const	O
char	O
*	O
to_type	*(char)
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
reg	*(struct)
->	O
num_types	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type_name	*(char)
,	O
type_name	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type	enum(int,int,int,int)
)	O
{	O
rec_type_destroy	(*(struct))->(void)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type	enum(int,int,int,int)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type_name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
to_type	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
i	long
==	O
reg	*(struct)
->	O
num_types	long
)	O
{	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
=	O
realloc	(*(void),long)->(*(void))
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
,	O
(	O
(	O
i	long
/	O
REC_TYPE_REG_ALLOC_TYPES	int
)	O
+	O
1	int
)	O
*	O
(	O
sizeof	O
(	O
struct	O
rec_type_reg_entry_s	struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),*(*(char))))),*(char),bool)
*	O
)	O
*	O
REC_TYPE_REG_ALLOC_TYPES	int
)	O
)	O
;	O
reg	*(struct)
->	O
num_types	long
++	O
;	O
}	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type_name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
type_name	*(char)
)	O
;	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
to_type	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
to_type	*(char)
)	O
;	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type	enum(int,int,int,int)
=	O
NULL	O
;	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
visited_p	bool
=	O
false	int
;	O
}	O
rec_type_t	*(struct)
rec_type_reg_get	(*(struct),*(char))->(*(struct))
(	O
rec_type_reg_t	*(struct)
reg	*(struct)
,	O
const	O
char	O
*	O
type_name	*(char)
)	O
{	O
size_t	long
i	long
;	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
=	O
NULL	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
reg	*(struct)
->	O
num_types	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type_name	*(char)
,	O
type_name	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type	enum(int,int,int,int)
)	O
{	O
type	enum(int,int,int,int)
=	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
type	enum(int,int,int,int)
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
visited_p	bool
)	O
{	O
break	O
;	O
}	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
visited_p	bool
=	O
true	int
;	O
type	enum(int,int,int,int)
=	O
rec_type_reg_get	(*(struct),*(char))->(*(struct))
(	O
reg	*(struct)
,	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
to_type	*(char)
)	O
;	O
}	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
reg	*(struct)
->	O
num_types	long
;	O
i	long
++	O
)	O
{	O
reg	*(struct)
->	O
types	*(struct(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct`,*`,*`))),*(char),bool))
[	O
i	long
]	O
.	O
visited_p	bool
=	O
false	int
;	O
}	O
return	O
type	enum(int,int,int,int)
;	O
}	O
const	O
char	O
*	O
rec_type_name	(*(struct))->(*(char))
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
return	O
type	enum(int,int,int,int)
->	O
name	*(char)
;	O
}	O
void	O
rec_type_set_name	(*(struct),*(char))->(void)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
type	enum(int,int,int,int)
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
}	O
bool	bool
rec_type_equal_p	(*(struct),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type1	*(struct)
,	O
rec_type_t	*(struct)
type2	int
)	O
{	O
bool	bool
ret	bool
;	O
size_t	long
i	long
;	O
ret	bool
=	O
true	int
;	O
if	O
(	O
type1	*(struct)
->	O
kind	enum(int,int,int)
!=	O
type2	int
->	O
kind	enum(int,int,int)
)	O
{	O
ret	bool
=	O
false	int
;	O
}	O
else	O
{	O
if	O
(	O
type1	*(struct)
->	O
kind	enum(int,int,int)
==	O
REC_TYPE_SIZE	int
)	O
{	O
ret	bool
=	O
(	O
type1	*(struct)
->	O
data	*(void)
.	O
max_size	long
==	O
type2	int
->	O
data	*(void)
.	O
max_size	long
)	O
;	O
}	O
else	O
if	O
(	O
type1	*(struct)
->	O
kind	enum(int,int,int)
==	O
REC_TYPE_RANGE	int
)	O
{	O
ret	bool
=	O
(	O
(	O
type1	*(struct)
->	O
data	*(void)
.	O
range	array(int)
[	O
0	int
]	O
==	O
type2	int
->	O
data	*(void)
.	O
range	array(int)
[	O
0	int
]	O
)	O
&&	O
(	O
type1	*(struct)
->	O
data	*(void)
.	O
range	array(int)
[	O
1	int
]	O
==	O
type2	int
->	O
data	*(void)
.	O
range	array(int)
[	O
1	int
]	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
type1	*(struct)
->	O
kind	enum(int,int,int)
==	O
REC_TYPE_ENUM	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
type1	*(struct)
->	O
size	*(long)
;	O
i	long
++	O
)	O
{	O
ret	bool
=	O
(	O
(	O
i	long
<	O
type2	int
->	O
size	*(long)
)	O
&&	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
type1	*(struct)
->	O
data	*(void)
.	O
names	*(*(char))
[	O
i	long
]	O
,	O
type2	int
->	O
data	*(void)
.	O
names	*(*(char))
[	O
i	long
]	O
)	O
==	O
0	int
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
type1	*(struct)
->	O
kind	enum(int,int,int)
==	O
REC_TYPE_REGEXP	int
)	O
{	O
ret	bool
=	O
false	int
;	O
}	O
}	O
return	O
ret	bool
;	O
}	O
int	O
rec_type_min	(*(struct))->(int)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
int	O
res	*(char)
;	O
if	O
(	O
type	enum(int,int,int,int)
->	O
kind	enum(int,int,int)
!=	O
REC_TYPE_RANGE	int
)	O
{	O
res	*(char)
=	O
-	O
1	int
;	O
}	O
else	O
{	O
res	*(char)
=	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
range	array(int)
[	O
0	int
]	O
;	O
}	O
return	O
res	*(char)
;	O
}	O
int	O
rec_type_max	(*(struct))->(int)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
int	O
res	*(char)
;	O
if	O
(	O
type	enum(int,int,int,int)
->	O
kind	enum(int,int,int)
!=	O
REC_TYPE_RANGE	int
)	O
{	O
res	*(char)
=	O
-	O
1	int
;	O
}	O
else	O
{	O
res	*(char)
=	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
range	array(int)
[	O
1	int
]	O
;	O
}	O
return	O
res	*(char)
;	O
}	O
const	O
char	O
*	O
rec_type_rec	(*(struct))->(*(char))
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
const	O
char	O
*	O
res	*(char)
=	O
NULL	O
;	O
if	O
(	O
type	enum(int,int,int,int)
->	O
kind	enum(int,int,int)
==	O
REC_TYPE_REC	int
)	O
{	O
res	*(char)
=	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
recname	*(char)
;	O
}	O
return	O
res	*(char)
;	O
}	O
int	O
rec_type_values_cmp	(*(struct),*(char),*(char))->(int)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
val1	*(char)
,	O
const	O
char	O
*	O
val2	*(char)
)	O
{	O
int	O
type_comparison	int
;	O
enum	O
rec_type_kind_e	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
kind	enum(int,int,int)
=	O
REC_TYPE_NONE	int
;	O
if	O
(	O
type	enum(int,int,int,int)
)	O
{	O
kind	enum(int,int,int)
=	O
type	enum(int,int,int,int)
->	O
kind	enum(int,int,int)
;	O
}	O
switch	O
(	O
kind	enum(int,int,int)
)	O
{	O
case	O
REC_TYPE_INT	int
:	O
case	O
REC_TYPE_RANGE	int
:	O
{	O
int	O
int1	int
,	O
int2	int
=	O
0	int
;	O
if	O
(	O
!	O
rec_atoi	(*(char),*(int))->(bool)
(	O
val1	*(char)
,	O
&	O
int1	int
)	O
||	O
!	O
rec_atoi	(*(char),*(int))->(bool)
(	O
val2	*(char)
,	O
&	O
int2	int
)	O
)	O
{	O
goto	O
lexi	O
;	O
}	O
if	O
(	O
int1	int
<	O
int2	int
)	O
{	O
type_comparison	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
int1	int
>	O
int2	int
)	O
{	O
type_comparison	int
=	O
1	int
;	O
}	O
else	O
{	O
type_comparison	int
=	O
0	int
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_REAL	int
:	O
{	O
double	O
real1	double
,	O
real2	double
=	O
0	int
;	O
if	O
(	O
!	O
rec_atod	(*(char),*(double))->(bool)
(	O
val1	*(char)
,	O
&	O
real1	double
)	O
||	O
!	O
rec_atod	(*(char),*(double))->(bool)
(	O
val2	*(char)
,	O
&	O
real2	double
)	O
)	O
{	O
goto	O
lexi	O
;	O
}	O
if	O
(	O
real1	double
<	O
real2	double
)	O
{	O
type_comparison	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
real1	double
>	O
real2	double
)	O
{	O
type_comparison	int
=	O
1	int
;	O
}	O
else	O
{	O
type_comparison	int
=	O
0	int
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_BOOL	int
:	O
{	O
bool	bool
bool1	bool
,	O
bool2	bool
=	O
false	int
;	O
bool1	bool
=	O
rec_match	(*(char),*(char))->(bool)
(	O
val1	*(char)
,	O
REC_TYPE_ZBLANKS_RE	O
"("	*(char)
REC_TYPE_BOOL_TRUE_VALUES_RE	*(char)
")"	*(char)
REC_TYPE_ZBLANKS_RE	O
)	O
;	O
bool2	bool
=	O
rec_match	(*(char),*(char))->(bool)
(	O
val2	*(char)
,	O
REC_TYPE_ZBLANKS_RE	O
"("	*(char)
REC_TYPE_BOOL_TRUE_VALUES_RE	*(char)
")"	*(char)
REC_TYPE_ZBLANKS_RE	O
)	O
;	O
if	O
(	O
!	O
bool1	bool
&&	O
bool2	bool
)	O
{	O
type_comparison	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
bool1	bool
==	O
bool2	bool
)	O
{	O
type_comparison	int
=	O
0	int
;	O
}	O
else	O
{	O
type_comparison	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_DATE	int
:	O
{	O
struct	O
timespec	struct(long,long)
op1	struct(long,long)
;	O
struct	O
timespec	struct(long,long)
op2	struct(long,long)
;	O
struct	O
timespec	struct(long,long)
diff	struct(long,long)
;	O
if	O
(	O
parse_datetime	(*(struct(long,long)),*(char),*(struct(long,long)))->(bool)
(	O
&	O
op1	struct(long,long)
,	O
val1	*(char)
,	O
NULL	O
)	O
&&	O
parse_datetime	(*(struct(long,long)),*(char),*(struct(long,long)))->(bool)
(	O
&	O
op2	struct(long,long)
,	O
val2	*(char)
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
(	O
op1	struct(long,long)
.	O
tv_sec	long
==	O
op2	struct(long,long)
.	O
tv_sec	long
)	O
&&	O
(	O
op1	struct(long,long)
.	O
tv_nsec	long
==	O
op2	struct(long,long)
.	O
tv_nsec	long
)	O
)	O
{	O
type_comparison	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
rec_timespec_subtract	(*(struct(long,long)),*(struct(long,long)),*(struct(long,long)))->(int)
(	O
&	O
diff	struct(long,long)
,	O
&	O
op1	struct(long,long)
,	O
&	O
op2	struct(long,long)
)	O
)	O
{	O
type_comparison	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
type_comparison	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
goto	O
lexi	O
;	O
}	O
break	O
;	O
}	O
default	O
:	O
{	O
lexi	O
:	O
type_comparison	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
val1	*(char)
,	O
val2	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
return	O
type_comparison	int
;	O
}	O
static	O
enum	O
rec_type_kind_e	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
rec_type_parse_type_kind	(*(char))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
char	O
*	O
str	*(char)
)	O
{	O
enum	O
rec_type_kind_e	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
res	*(char)
;	O
res	*(char)
=	O
REC_TYPE_NONE	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_INT_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_INT	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_BOOL_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_BOOL	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_RANGE_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_RANGE	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_REAL_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_REAL	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_SIZE_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_SIZE	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_LINE_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_LINE	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_REGEXP_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_REGEXP	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_DATE_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_DATE	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_EMAIL_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_EMAIL	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_ENUM_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_ENUM	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_FIELD_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_FIELD	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_REC_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_REC	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
REC_TYPE_UUID_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
res	*(char)
=	O
REC_TYPE_UUID	int
;	O
}	O
return	O
res	*(char)
;	O
}	O
static	O
bool	bool
rec_type_check_int	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	(*(char),*(char))->(bool)
(	O
str	*(char)
,	O
REC_TYPE_INT_VALUE_RE	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	*(struct)
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
_	O
(	O
"invalid integer."	*(char)
)	O
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_rec	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
return	O
true	int
;	O
}	O
static	O
bool	bool
rec_type_check_field	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	(*(char),*(char))->(bool)
(	O
str	*(char)
,	O
REC_TYPE_FIELD_VALUE_RE	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	*(struct)
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
_	O
(	O
"invalid 'field' value."	*(char)
)	O
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_uuid	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
int	O
ret	bool
;	O
uuid_t	array(char)
uu	array(char)
;	O
ret	bool
=	O
uuid_parse	(*(char),array(char))->(int)
(	O
str	*(char)
,	O
uu	array(char)
)	O
;	O
if	O
(	O
(	O
ret	bool
==	O
-	O
1	int
)	O
&&	O
errors	*(struct)
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
_	O
(	O
"invalid 'uuid' value."	*(char)
)	O
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
(	O
ret	bool
==	O
0	int
)	O
;	O
}	O
static	O
bool	bool
rec_type_check_bool	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	(*(char),*(char))->(bool)
(	O
str	*(char)
,	O
REC_TYPE_BOOL_VALUE_RE	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	*(struct)
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
_	O
(	O
"invalid 'bool' value."	*(char)
)	O
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_range	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
bool	bool
ret	bool
;	O
const	O
char	O
*	O
p	*(void)
;	O
int	O
num	*(int)
;	O
char	O
*	O
tmp	*(char)
;	O
p	*(void)
=	O
str	*(char)
;	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
!	O
rec_parse_int	(*(*(char)),*(int))->(bool)
(	O
&	O
p	*(void)
,	O
&	O
num	*(int)
)	O
)	O
{	O
if	O
(	O
errors	*(struct)
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
_	O
(	O
"invalid 'range' value."	*(char)
)	O
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
false	int
;	O
}	O
ret	bool
=	O
(	O
(	O
num	*(int)
>=	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
range	array(int)
[	O
0	int
]	O
)	O
&&	O
(	O
num	*(int)
<=	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
range	array(int)
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	*(struct)
)	O
{	O
if	O
(	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
tmp	*(char)
,	O
_	O
(	O
"expected an integer between %d and %d."	*(char)
)	O
,	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
range	array(int)
[	O
0	int
]	O
,	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
range	array(int)
[	O
1	int
]	O
)	O
!=	O
-	O
1	int
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
tmp	*(char)
,	O
errors	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
}	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_real	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	(*(char),*(char))->(bool)
(	O
str	*(char)
,	O
REC_TYPE_REAL_VALUE_RE	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	*(struct)
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
_	O
(	O
"invalid 'real' value."	*(char)
)	O
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_size	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
bool	bool
ret	bool
;	O
char	O
*	O
tmp	*(char)
;	O
ret	bool
=	O
(	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
<=	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
max_size	long
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	*(struct)
)	O
{	O
if	O
(	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
tmp	*(char)
,	O
_	O
(	O
"value too large.  Expected a size <= %zu."	*(char)
)	O
,	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
max_size	long
)	O
!=	O
-	O
1	int
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
tmp	*(char)
,	O
errors	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
}	O
}	O
return	O
(	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
<=	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
max_size	long
)	O
;	O
}	O
static	O
bool	bool
rec_type_check_line	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	(*(char),*(char))->(bool)
(	O
str	*(char)
,	O
REC_TYPE_LINE_VALUE_RE	*(char)
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	*(struct)
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
_	O
(	O
"invalid 'line' value."	*(char)
)	O
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_regexp	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
(	O
regexec	O
(	O
&	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
regexp	*(char)
,	O
str	*(char)
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
==	O
0	int
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	*(struct)
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
_	O
(	O
"value does not match the regexp."	*(char)
)	O
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_date	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
bool	bool
ret	bool
;	O
struct	O
timespec	struct(long,long)
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
""	*(char)
)	O
==	O
0	int
)	O
{	O
return	O
false	int
;	O
}	O
ret	bool
=	O
parse_datetime	(*(struct(long,long)),*(char),*(struct(long,long)))->(bool)
(	O
&	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
str	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	*(struct)
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
_	O
(	O
"invalid date."	*(char)
)	O
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_email	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	(*(char),*(char))->(bool)
(	O
str	*(char)
,	O
REC_TYPE_EMAIL_VALUE_RE	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	*(struct)
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
_	O
(	O
"invalid email."	*(char)
)	O
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_enum	(*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))),*(char),*(struct))->(bool)
(	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
size_t	long
i	long
;	O
const	O
char	O
*	O
p	*(void)
,	O
*	O
b	*(char)
;	O
char	O
name	*(char)
[	O
100	int
]	O
;	O
if	O
(	O
rec_match	(*(char),*(char))->(bool)
(	O
str	*(char)
,	O
REC_TYPE_ENUM_VALUE_RE	O
)	O
)	O
{	O
p	*(void)
=	O
str	*(char)
;	O
while	O
(	O
p	*(void)
&&	O
rec_blank_p	(char)->(bool)
(	O
*	O
p	*(void)
)	O
)	O
{	O
p	*(void)
++	O
;	O
}	O
b	*(char)
=	O
p	*(void)
;	O
while	O
(	O
p	*(void)
&&	O
(	O
rec_letter_p	(char)->(bool)
(	O
*	O
p	*(void)
)	O
||	O
rec_letter_p	(char)->(bool)
(	O
*	O
p	*(void)
)	O
||	O
rec_digit_p	(char)->(bool)
(	O
*	O
p	*(void)
)	O
||	O
(	O
*	O
p	*(void)
==	O
'_'	O
)	O
||	O
(	O
*	O
p	*(void)
==	O
'-'	O
)	O
)	O
)	O
{	O
name	*(char)
[	O
p	*(void)
-	O
b	*(char)
]	O
=	O
*	O
p	*(void)
;	O
p	*(void)
++	O
;	O
}	O
name	*(char)
[	O
p	*(void)
-	O
b	*(char)
]	O
=	O
'\0'	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
type	enum(int,int,int,int)
->	O
size	*(long)
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
names	*(*(char))
[	O
i	long
]	O
)	O
==	O
0	int
)	O
return	O
true	int
;	O
}	O
if	O
(	O
errors	*(struct)
)	O
{	O
rec_buf_puts	(*(char),*(struct))->(int)
(	O
_	O
(	O
"invalid enum value."	*(char)
)	O
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
false	int
;	O
}	O
static	O
const	O
char	O
*	O
rec_type_parse_size	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
int	O
size	*(long)
;	O
p	*(void)
=	O
str	*(char)
;	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
rec_parse_int	(*(*(char)),*(int))->(bool)
(	O
&	O
p	*(void)
,	O
&	O
size	*(long)
)	O
&&	O
(	O
size	*(long)
>=	O
0	int
)	O
)	O
{	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
max_size	long
=	O
size	*(long)
;	O
}	O
else	O
{	O
p	*(void)
=	O
NULL	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
static	O
const	O
char	O
*	O
rec_type_parse_enum	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
size_t	long
i	long
;	O
p	*(void)
=	O
str	*(char)
;	O
type	enum(int,int,int,int)
->	O
size	*(long)
=	O
0	int
;	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
names	*(*(char))
=	O
NULL	O
;	O
while	O
(	O
*	O
p	*(void)
)	O
{	O
if	O
(	O
(	O
type	enum(int,int,int,int)
->	O
size	*(long)
%	O
REC_ENUM_ALLOC_NAMES	int
)	O
==	O
0	int
)	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
names	*(*(char))
=	O
realloc	(*(void),long)->(*(void))
(	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
names	*(*(char))
,	O
(	O
(	O
type	enum(int,int,int,int)
->	O
size	*(long)
/	O
REC_ENUM_ALLOC_NAMES	int
)	O
+	O
1	int
)	O
*	O
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
REC_ENUM_ALLOC_NAMES	int
)	O
)	O
;	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'('	O
)	O
{	O
p	*(void)
++	O
;	O
while	O
(	O
*	O
p	*(void)
&&	O
(	O
*	O
p	*(void)
!=	O
')'	O
)	O
&&	O
(	O
*	O
p	*(void)
!=	O
'('	O
)	O
)	O
{	O
p	*(void)
++	O
;	O
}	O
if	O
(	O
*	O
p	*(void)
==	O
')'	O
)	O
{	O
p	*(void)
++	O
;	O
}	O
else	O
{	O
p	*(void)
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
p	*(void)
)	O
{	O
if	O
(	O
!	O
rec_parse_regexp	(*(*(char)),*(char),*(*(char)))->(bool)
(	O
&	O
p	*(void)
,	O
"^"	*(char)
REC_TYPE_ENUM_NAME_RE	*(char)
,	O
&	O
(	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
names	*(*(char))
[	O
type	enum(int,int,int,int)
->	O
size	*(long)
++	O
]	O
)	O
)	O
)	O
{	O
p	*(void)
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
type	enum(int,int,int,int)
->	O
size	*(long)
==	O
0	int
)	O
{	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
p	*(void)
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
type	enum(int,int,int,int)
->	O
size	*(long)
;	O
i	long
++	O
)	O
{	O
free	(*(void))->(void)
(	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
names	*(*(char))
[	O
i	long
]	O
)	O
;	O
}	O
}	O
return	O
p	*(void)
;	O
}	O
static	O
const	O
char	O
*	O
rec_type_parse_regexp_type	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
char	O
re	*(char)
[	O
200	int
]	O
;	O
bool	bool
end_regexp	bool
;	O
size_t	long
i	long
;	O
char	O
delim_char	char
;	O
p	*(void)
=	O
str	*(char)
;	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
end_regexp	bool
=	O
false	int
;	O
delim_char	char
=	O
*	O
p	*(void)
;	O
p	*(void)
++	O
;	O
i	long
=	O
0	int
;	O
while	O
(	O
*	O
p	*(void)
)	O
{	O
if	O
(	O
*	O
p	*(void)
==	O
delim_char	char
)	O
{	O
if	O
(	O
*	O
(	O
p	*(void)
+	O
1	int
)	O
==	O
delim_char	char
)	O
{	O
re	*(char)
[	O
i	long
++	O
]	O
=	O
delim_char	char
;	O
p	*(void)
++	O
;	O
}	O
else	O
{	O
p	*(void)
++	O
;	O
end_regexp	bool
=	O
true	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
re	*(char)
[	O
i	long
++	O
]	O
=	O
*	O
p	*(void)
;	O
}	O
p	*(void)
++	O
;	O
}	O
re	*(char)
[	O
i	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
end_regexp	bool
)	O
{	O
p	*(void)
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
regcomp	O
(	O
&	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
regexp	*(char)
,	O
re	*(char)
,	O
REG_EXTENDED	int
)	O
!=	O
0	int
)	O
{	O
p	*(void)
=	O
NULL	O
;	O
}	O
}	O
return	O
p	*(void)
;	O
}	O
static	O
const	O
char	O
*	O
rec_type_parse_rec	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
const	O
char	O
*	O
p	*(void)
=	O
str	*(char)
;	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
!	O
rec_parse_regexp	(*(*(char)),*(char),*(*(char)))->(bool)
(	O
&	O
p	*(void)
,	O
"^"	*(char)
REC_RECORD_TYPE_RE	O
,	O
&	O
(	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
recname	*(char)
)	O
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
static	O
bool	bool
rec_type_parse_range_point	(*(*(char)),*(int))->(bool)
(	O
const	O
char	O
*	O
*	O
str	*(char)
,	O
int	O
*	O
num	*(int)
)	O
{	O
if	O
(	O
rec_match	(*(char),*(char))->(bool)
(	O
*	O
str	*(char)
,	O
"^MIN"	*(char)
)	O
)	O
{	O
*	O
num	*(int)
=	O
INT_MIN	O
;	O
*	O
str	*(char)
+=	O
3	int
;	O
}	O
else	O
if	O
(	O
rec_match	(*(char),*(char))->(bool)
(	O
*	O
str	*(char)
,	O
"^MAX"	*(char)
)	O
)	O
{	O
*	O
num	*(int)
=	O
INT_MAX	O
;	O
*	O
str	*(char)
+=	O
3	int
;	O
}	O
else	O
if	O
(	O
!	O
rec_parse_int	(*(*(char)),*(int))->(bool)
(	O
str	*(char)
,	O
num	*(int)
)	O
)	O
{	O
return	O
false	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
const	O
char	O
*	O
rec_type_parse_range	(*(char),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),long,union(long,array(int),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),*(*`)))))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
p	*(void)
=	O
str	*(char)
;	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
!	O
rec_type_parse_range_point	(*(*(char)),*(int))->(bool)
(	O
&	O
p	*(void)
,	O
&	O
(	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
range	array(int)
[	O
0	int
]	O
)	O
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'\0'	O
)	O
{	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
range	array(int)
[	O
1	int
]	O
=	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
range	array(int)
[	O
0	int
]	O
;	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
range	array(int)
[	O
0	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
rec_type_parse_range_point	(*(*(char)),*(int))->(bool)
(	O
&	O
p	*(void)
,	O
&	O
(	O
type	enum(int,int,int,int)
->	O
data	*(void)
.	O
range	array(int)
[	O
1	int
]	O
)	O
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
}	O
return	O
p	*(void)
;	O
}	O
