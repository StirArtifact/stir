char	O
imap_docstring	array(char)
[	O
]	O
=	O
N_	O
(	O
"IMAP4 client shell"	*(char)
)	O
;	O
static	O
mu_imap_t	*(struct)
imap	*(struct)
;	O
static	O
int	O
uid_mode	int
;	O
static	O
enum	O
mu_imap_session_state	enum(int,int,int,int)
current_imap_state	()->(enum(int,int,int,int))
(	O
)	O
{	O
int	O
state	*(int)
;	O
if	O
(	O
imap	*(struct)
==	O
NULL	O
)	O
state	*(int)
=	O
MU_IMAP_SESSION_INIT	int
;	O
else	O
state	*(int)
=	O
mu_imap_session_state	enum(int,int,int,int)
(	O
imap	*(struct)
)	O
;	O
return	O
state	*(int)
;	O
}	O
static	O
void	O
imap_set_verbose	()->(void)
(	O
)	O
{	O
if	O
(	O
imap	*(struct)
)	O
{	O
if	O
(	O
QRY_VERBOSE	O
(	O
)	O
)	O
mu_imap_trace	(*(struct),int)->(int)
(	O
imap	*(struct)
,	O
MU_IMAP_TRACE_SET	int
)	O
;	O
else	O
mu_imap_trace	(*(struct),int)->(int)
(	O
imap	*(struct)
,	O
MU_IMAP_TRACE_CLR	int
)	O
;	O
}	O
}	O
void	O
imap_set_verbose_mask	()->(void)
(	O
)	O
{	O
if	O
(	O
imap	*(struct)
)	O
{	O
mu_imap_trace_mask	(*(struct),int,int)->(int)
(	O
imap	*(struct)
,	O
QRY_VERBOSE_MASK	O
(	O
MU_XSCRIPT_SECURE	int
)	O
?	O
MU_IMAP_TRACE_SET	int
:	O
MU_IMAP_TRACE_CLR	int
,	O
MU_XSCRIPT_SECURE	int
)	O
;	O
mu_imap_trace_mask	(*(struct),int,int)->(int)
(	O
imap	*(struct)
,	O
QRY_VERBOSE_MASK	O
(	O
MU_XSCRIPT_PAYLOAD	int
)	O
?	O
MU_IMAP_TRACE_SET	int
:	O
MU_IMAP_TRACE_CLR	int
,	O
MU_XSCRIPT_PAYLOAD	int
)	O
;	O
}	O
}	O
static	O
int	O
com_verbose	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
return	O
shell_verbose	(int,*(*(char)),*(()->(void)),*(()->(void)))->(int)
(	O
argc	long
,	O
argv	*(*(char))
,	O
imap_set_verbose	()->(void)
,	O
imap_set_verbose_mask	()->(void)
)	O
;	O
}	O
static	O
mu_msgset_t	*(struct)
parse_msgset	(*(char))->(*(struct))
(	O
const	O
char	O
*	O
arg	*(char)
)	O
{	O
int	O
status	int
;	O
mu_msgset_t	*(struct)
msgset	*(struct)
;	O
char	O
*	O
p	*(char)
;	O
status	int
=	O
mu_msgset_create	(*(*(struct)),*(struct),int)->(int)
(	O
&	O
msgset	*(struct)
,	O
NULL	O
,	O
MU_MSGSET_NUM	int
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_msgset_create"	*(char)
,	O
NULL	O
,	O
status	int
)	O
;	O
return	O
NULL	O
;	O
}	O
status	int
=	O
mu_msgset_parse_imap	(*(struct),int,*(char),*(*(char)))->(int)
(	O
msgset	*(struct)
,	O
MU_MSGSET_NUM	int
,	O
arg	*(char)
,	O
&	O
p	*(char)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"failed to parse message set near \"%s\": %s"	*(char)
)	O
,	O
p	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
mu_msgset_destroy	(*(*(struct)))->(void)
(	O
&	O
msgset	*(struct)
)	O
;	O
}	O
return	O
msgset	*(struct)
;	O
}	O
static	O
void	O
report_failure	(*(char),int)->(void)
(	O
const	O
char	O
*	O
what	*(char)
,	O
int	O
status	int
)	O
{	O
const	O
char	O
*	O
str	*(char)
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s failed: %s"	*(char)
)	O
,	O
what	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
if	O
(	O
mu_imap_strerror	(*(struct),*(*(char)))->(int)
(	O
imap	*(struct)
,	O
&	O
str	*(char)
)	O
==	O
0	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"server reply: %s"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
}	O
static	O
int	O
connect_argc	int
;	O
static	O
char	O
*	O
*	O
connect_argv	*(*(char))
;	O
static	O
char	O
*	O
username	*(char)
;	O
static	O
void	O
imap_prompt_env	()->(void)
(	O
void	O
)	O
{	O
mu_assoc_t	*(struct)
assoc	*(struct)
=	O
mutool_shell_prompt_assoc	()->(*(struct))
(	O
)	O
;	O
enum	O
mu_imap_session_state	enum(int,int,int,int)
state	*(int)
=	O
current_imap_state	()->(enum(int,int,int,int))
(	O
)	O
;	O
const	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
state	*(int)
>=	O
MU_IMAP_SESSION_AUTH	int
&&	O
username	*(char)
)	O
mu_assoc_install	(*(struct),*(char),*(void))->(int)
(	O
assoc	*(struct)
,	O
"user"	*(char)
,	O
username	*(char)
)	O
;	O
if	O
(	O
connect_argv	*(*(char))
)	O
mu_assoc_install	(*(struct),*(char),*(void))->(int)
(	O
assoc	*(struct)
,	O
"host"	*(char)
,	O
host	*(*(char))
)	O
;	O
if	O
(	O
mu_imap_session_state_str	(int,*(*(char)))->(int)
(	O
state	*(int)
,	O
&	O
p	*(char)
)	O
==	O
0	int
)	O
mu_assoc_install	(*(struct),*(char),*(void))->(int)
(	O
assoc	*(struct)
,	O
"status"	*(char)
,	O
(	O
void	O
*	O
)	O
p	*(char)
)	O
;	O
}	O
static	O
void	O
imap_preauth_callback	(*(void),int,long,*(void))->(void)
(	O
void	O
*	O
data	*(void)
,	O
int	O
code	int
,	O
size_t	long
sdat	long
,	O
void	O
*	O
pdat	*(void)
)	O
{	O
const	O
char	O
*	O
text	*(char)
=	O
pdat	*(void)
;	O
if	O
(	O
text	*(char)
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"session authenticated: %s"	*(char)
)	O
,	O
text	*(char)
)	O
;	O
else	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"session authenticated"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
imap_bye_callback	(*(void),int,long,*(void))->(void)
(	O
void	O
*	O
data	*(void)
,	O
int	O
code	int
,	O
size_t	long
sdat	long
,	O
void	O
*	O
pdat	*(void)
)	O
{	O
const	O
char	O
*	O
text	*(char)
=	O
pdat	*(void)
;	O
if	O
(	O
text	*(char)
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"server is closing connection: %s"	*(char)
)	O
,	O
text	*(char)
)	O
;	O
else	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"server is closing connection"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
imap_bad_callback	(*(void),int,long,*(void))->(void)
(	O
void	O
*	O
data	*(void)
,	O
int	O
code	int
,	O
size_t	long
sdat	long
,	O
void	O
*	O
pdat	*(void)
)	O
{	O
const	O
char	O
*	O
text	*(char)
=	O
pdat	*(void)
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_CRIT	O
,	O
"SERVER ALERT: %s"	*(char)
,	O
text	*(char)
)	O
;	O
}	O
static	O
void	O
format_email	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
mu_stream_t	*(struct)
str	*(char)
,	O
const	O
char	O
*	O
name	*(char)
,	O
mu_address_t	*(struct)
addr	int
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"  %s = "	*(char)
,	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
addr	int
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"NIL"	*(char)
)	O
;	O
else	O
mu_stream_format_address	(*(struct),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(int)
(	O
str	*(char)
,	O
addr	int
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
format_date	(*(struct),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))))->(void)
(	O
mu_stream_t	*(struct)
str	*(char)
,	O
char	O
*	O
name	*(char)
,	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
struct	O
mu_timezone	struct(int,*(char))
*	O
tz	*(struct(int,*(char)))
)	O
{	O
char	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
[	O
128	int
]	O
;	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
sizeof	O
(	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
,	O
"%a %b %e %H:%M:%S"	*(char)
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"  %s = %s"	*(char)
,	O
name	*(char)
,	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
if	O
(	O
tz	*(struct(int,*(char)))
->	O
tz_name	*(char)
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
" %s"	*(char)
,	O
tz	*(struct(int,*(char)))
->	O
tz_name	*(char)
)	O
;	O
else	O
{	O
int	O
off	int
=	O
tz	*(struct(int,*(char)))
->	O
utc_offset	int
;	O
if	O
(	O
off	int
<	O
0	int
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
" -"	*(char)
)	O
;	O
off	int
=	O
-	O
off	int
;	O
}	O
else	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
" +"	*(char)
)	O
;	O
off	int
/=	O
60	int
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"%02d%02d"	*(char)
,	O
off	int
/	O
60	int
,	O
off	int
%	O
60	int
)	O
;	O
}	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
print_param	(*(struct),*(char),*(struct),int)->(void)
(	O
mu_stream_t	*(struct)
ostr	*(struct)
,	O
const	O
char	O
*	O
prefix	array(*(char))
,	O
mu_assoc_t	*(struct)
assoc	*(struct)
,	O
int	O
indent	int
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
int	O
i	long
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*s%s:\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
prefix	array(*(char))
)	O
;	O
indent	int
+=	O
4	int
;	O
if	O
(	O
mu_assoc_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
assoc	*(struct)
,	O
&	O
itr	*(struct)
)	O
)	O
return	O
;	O
for	O
(	O
i	long
=	O
0	int
,	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
i	long
++	O
,	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
struct	O
mu_mime_param	struct(*(char),*(char),*(char))
*	O
p	*(char)
;	O
mu_iterator_current_kv	(*(struct),*(*(void)),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
name	*(char)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
p	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*s%d: %s=%s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
i	long
,	O
name	*(char)
,	O
p	*(char)
->	O
value	*(void)
)	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
struct	O
print_data	struct(*(struct),int,int)
{	O
mu_stream_t	*(struct)
ostr	*(struct)
;	O
int	O
num	long
;	O
int	O
level	int
;	O
}	O
;	O
static	O
void	O
print_bs	(*(struct),*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*`,*`,long),struct(*`)))),int)->(void)
(	O
mu_stream_t	*(struct)
ostr	*(struct)
,	O
struct	O
mu_bodystructure	struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct(struct(int,int,int,int,int,int,int,int,int,long,*`),struct(int,*`),*(char),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),*(char))),*(struct(enum(int,int,int,int),*(char),*(char),*(struct`),*(char),*(char),*(char),long,*(char),*(char),*(struct`),*(char),*(char),union(struct`,struct`,struct`))),long),struct(*(struct))))
*	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
,	O
int	O
level	int
)	O
;	O
static	O
int	O
print_item	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
mu_bodystructure	struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct(struct(int,int,int,int,int,int,int,int,int,long,*`),struct(int,*`),*(char),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),*(char))),*(struct(enum(int,int,int,int),*(char),*(char),*(struct`),*(char),*(char),*(char),long,*(char),*(char),*(struct`),*(char),*(char),union(struct`,struct`,struct`))),long),struct(*(struct))))
*	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
=	O
item	*(void)
;	O
struct	O
print_data	struct(*(struct),int,int)
*	O
pd	*(struct(*(struct),int,int))
=	O
data	*(void)
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
pd	*(struct(*(struct),int,int))
->	O
ostr	*(struct)
,	O
"%*sPart #%d\n"	*(char)
,	O
(	O
pd	*(struct(*(struct),int,int))
->	O
level	int
-	O
1	int
)	O
<<	O
2	int
,	O
""	*(char)
,	O
pd	*(struct(*(struct),int,int))
->	O
num	long
)	O
;	O
print_bs	(*(struct),*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*`,*`,long),struct(*`)))),int)->(void)
(	O
pd	*(struct(*(struct),int,int))
->	O
ostr	*(struct)
,	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
,	O
pd	*(struct(*(struct),int,int))
->	O
level	int
)	O
;	O
++	O
pd	*(struct(*(struct),int,int))
->	O
num	long
;	O
return	O
0	int
;	O
}	O
static	O
void	O
print_address	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(void)
(	O
mu_stream_t	*(struct)
ostr	*(struct)
,	O
const	O
char	O
*	O
title	*(char)
,	O
mu_address_t	*(struct)
addr	int
,	O
int	O
indent	int
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*s%s: "	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
title	*(char)
)	O
;	O
mu_stream_format_address	(*(struct),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(int)
(	O
mu_strout	*(struct)
,	O
addr	int
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
print_imapenvelope	(*(struct),*(struct(struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char))),int)->(void)
(	O
mu_stream_t	*(struct)
ostr	*(struct)
,	O
struct	O
mu_imapenvelope	struct(struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(char),*(char))
*	O
env	*(struct)
,	O
int	O
level	int
)	O
{	O
int	O
indent	int
=	O
(	O
level	int
<<	O
2	int
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sEnvelope:\n"	*(char)
,	O
indent	int
,	O
""	*(char)
)	O
;	O
indent	int
+=	O
4	int
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sTime: "	*(char)
,	O
indent	int
,	O
""	*(char)
)	O
;	O
mu_c_streamftime	(*(struct),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))))->(int)
(	O
mu_strout	*(struct)
,	O
"%c%n"	*(char)
,	O
&	O
env	*(struct)
->	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
&	O
env	*(struct)
->	O
tz	*(struct(int,*(char)))
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sSubject: %s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
env	*(struct)
->	O
subject	*(char)
)	O
)	O
;	O
print_address	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(void)
(	O
ostr	*(struct)
,	O
"From"	*(char)
,	O
env	*(struct)
->	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
indent	int
)	O
;	O
print_address	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(void)
(	O
ostr	*(struct)
,	O
"Sender"	*(char)
,	O
env	*(struct)
->	O
sender	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
indent	int
)	O
;	O
print_address	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(void)
(	O
ostr	*(struct)
,	O
"Reply-to"	*(char)
,	O
env	*(struct)
->	O
reply_to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
indent	int
)	O
;	O
print_address	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(void)
(	O
ostr	*(struct)
,	O
"To"	*(char)
,	O
env	*(struct)
->	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
indent	int
)	O
;	O
print_address	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(void)
(	O
ostr	*(struct)
,	O
"Cc"	*(char)
,	O
env	*(struct)
->	O
cc	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
indent	int
)	O
;	O
print_address	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(void)
(	O
ostr	*(struct)
,	O
"Bcc"	*(char)
,	O
env	*(struct)
->	O
bcc	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
indent	int
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sIn-Reply-To: %s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
env	*(struct)
->	O
in_reply_to	*(char)
)	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sMessage-ID: %s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
env	*(struct)
->	O
message_id	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
print_bs	(*(struct),*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*`,*`,long),struct(*`)))),int)->(void)
(	O
mu_stream_t	*(struct)
ostr	*(struct)
,	O
struct	O
mu_bodystructure	struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct(struct(int,int,int,int,int,int,int,int,int,long,*`),struct(int,*`),*(char),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),*(char))),*(struct(enum(int,int,int,int),*(char),*(char),*(struct`),*(char),*(char),*(char),long,*(char),*(char),*(struct`),*(char),*(char),union(struct`,struct`,struct`))),long),struct(*(struct))))
*	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
,	O
int	O
level	int
)	O
{	O
int	O
indent	int
=	O
level	int
<<	O
2	int
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sbody_type=%s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_type	*(char)
)	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sbody_subtype=%s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_subtype	*(char)
)	O
)	O
;	O
print_param	(*(struct),*(char),*(struct),int)->(void)
(	O
ostr	*(struct)
,	O
"Parameters"	*(char)
,	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_param	*(struct)
,	O
indent	int
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sbody_id=%s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_id	*(char)
)	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sbody_descr=%s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_descr	*(char)
)	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sbody_encoding=%s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_encoding	*(char)
)	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sbody_size=%lu\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
(	O
unsigned	O
long	O
)	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_size	long
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sbody_md5=%s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_md5	*(char)
)	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sbody_disposition=%s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_disposition	*(char)
)	O
)	O
;	O
print_param	(*(struct),*(char),*(struct),int)->(void)
(	O
ostr	*(struct)
,	O
"Disposition Parameters"	*(char)
,	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_disp_param	*(struct)
,	O
indent	int
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sbody_language=%s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_language	*(char)
)	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sbody_location=%s\n"	*(char)
,	O
indent	int
,	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_location	*(char)
)	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"%*sType "	*(char)
,	O
indent	int
,	O
""	*(char)
)	O
;	O
switch	O
(	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
body_message_type	enum(int,int,int,int)
)	O
{	O
case	O
mu_message_other	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"mu_message_other\n"	*(char)
)	O
;	O
break	O
;	O
case	O
mu_message_text	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"mu_message_text:\n%*sbody_lines=%lu\n"	*(char)
,	O
indent	int
+	O
4	int
,	O
""	*(char)
,	O
(	O
unsigned	O
long	O
)	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
v	array(*(char))
.	O
text	*(char)
.	O
body_lines	long
)	O
;	O
break	O
;	O
case	O
mu_message_rfc822	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"mu_message_rfc822:\n%*sbody_lines=%lu\n"	*(char)
,	O
indent	int
+	O
4	int
,	O
""	*(char)
,	O
(	O
unsigned	O
long	O
)	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
v	array(*(char))
.	O
rfc822	struct(*(struct(struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char))),*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char))),long)
.	O
body_lines	long
)	O
;	O
print_imapenvelope	(*(struct),*(struct(struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char))),int)->(void)
(	O
ostr	*(struct)
,	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
v	array(*(char))
.	O
rfc822	struct(*(struct(struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char))),*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char))),long)
.	O
body_env	*(struct(struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char),*(char)))
,	O
level	int
+	O
1	int
)	O
;	O
print_bs	(*(struct),*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*`,*`,long),struct(*`)))),int)->(void)
(	O
ostr	*(struct)
,	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
v	array(*(char))
.	O
rfc822	struct(*(struct(struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char))),*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char))),long)
.	O
body_struct	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char)))
,	O
level	int
+	O
1	int
)	O
;	O
break	O
;	O
case	O
mu_message_multipart	int
:	O
{	O
struct	O
print_data	struct(*(struct),int,int)
pd	*(struct(*(struct),int,int))
;	O
pd	*(struct(*(struct),int,int))
.	O
ostr	*(struct)
=	O
ostr	*(struct)
;	O
pd	*(struct(*(struct),int,int))
.	O
num	long
=	O
0	int
;	O
pd	*(struct(*(struct),int,int))
.	O
level	int
=	O
level	int
+	O
1	int
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
ostr	*(struct)
,	O
"mu_message_multipart:\n"	*(char)
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
->	O
v	array(*(char))
.	O
multipart	struct(*(struct))
.	O
body_parts	*(struct)
,	O
print_item	(*(void),*(void))->(int)
,	O
&	O
pd	*(struct(*(struct),int,int))
)	O
;	O
}	O
}	O
}	O
static	O
int	O
fetch_response_printer	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
union	O
mu_imap_fetch_response	union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*`,*`,long),struct(*`))))),struct(int,*(struct(struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char)))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long))
*	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
=	O
item	*(void)
;	O
mu_stream_t	*(struct)
str	*(char)
=	O
data	*(void)
;	O
switch	O
(	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
type	int
)	O
{	O
case	O
MU_IMAP_FETCH_BODY	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"BODY ["	*(char)
)	O
;	O
if	O
(	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
body	*(struct)
.	O
partv	*(long)
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
body	*(struct)
.	O
partc	long
;	O
i	long
++	O
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"%lu."	*(char)
,	O
(	O
unsigned	O
long	O
)	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
body	*(struct)
.	O
partv	*(long)
[	O
i	long
]	O
)	O
;	O
}	O
if	O
(	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
body	*(struct)
.	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"%s"	*(char)
,	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
body	*(struct)
.	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"]"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"\nBEGIN\n%s\nEND\n"	*(char)
,	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
body	*(struct)
.	O
text	*(char)
)	O
;	O
break	O
;	O
case	O
MU_IMAP_FETCH_BODYSTRUCTURE	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"BODYSTRUCTURE:\nBEGIN\n"	*(char)
)	O
;	O
print_bs	(*(struct),*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*`,*`,long),struct(*`)))),int)->(void)
(	O
str	*(char)
,	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
bodystructure	struct(int,*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*`,*`,long),struct(*`)))))
.	O
bs	*(struct(enum(int,int,int,int),*(char),*(char),*(struct),*(char),*(char),*(char),long,*(char),*(char),*(struct),*(char),*(char),union(struct(long),struct(*(struct`),*(struct`),long),struct(*(struct`)))))
,	O
0	int
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"END\n"	*(char)
)	O
;	O
break	O
;	O
case	O
MU_IMAP_FETCH_ENVELOPE	int
:	O
{	O
struct	O
mu_imapenvelope	struct(struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(char),*(char))
*	O
env	*(struct)
=	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
envelope	*(struct)
.	O
imapenvelope	*(struct(struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char),*(char)))
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"ENVELOPE:\n"	*(char)
)	O
;	O
format_date	(*(struct),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))))->(void)
(	O
str	*(char)
,	O
"date"	*(char)
,	O
&	O
env	*(struct)
->	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
&	O
env	*(struct)
->	O
tz	*(struct(int,*(char)))
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"  subject = %s\n"	*(char)
,	O
env	*(struct)
->	O
subject	*(char)
?	O
env	*(struct)
->	O
subject	*(char)
:	O
"NIL"	*(char)
)	O
;	O
format_email	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
str	*(char)
,	O
"from"	*(char)
,	O
env	*(struct)
->	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
;	O
format_email	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
str	*(char)
,	O
"sender"	*(char)
,	O
env	*(struct)
->	O
sender	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
format_email	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
str	*(char)
,	O
"reply-to"	*(char)
,	O
env	*(struct)
->	O
reply_to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
format_email	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
str	*(char)
,	O
"to"	*(char)
,	O
env	*(struct)
->	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
format_email	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
str	*(char)
,	O
"cc"	*(char)
,	O
env	*(struct)
->	O
cc	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
format_email	(*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
str	*(char)
,	O
"bcc"	*(char)
,	O
env	*(struct)
->	O
bcc	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"  in-reply-to = %s\n"	*(char)
,	O
env	*(struct)
->	O
in_reply_to	*(char)
?	O
env	*(struct)
->	O
in_reply_to	*(char)
:	O
"NIL"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"  message-id = %s\n"	*(char)
,	O
env	*(struct)
->	O
message_id	*(char)
?	O
env	*(struct)
->	O
message_id	*(char)
:	O
"NIL"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
MU_IMAP_FETCH_FLAGS	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"  flags = "	*(char)
)	O
;	O
mu_imap_format_flags	(*(struct),int,int)->(int)
(	O
str	*(char)
,	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
flags	int
.	O
flags	int
,	O
1	int
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"\n"	*(char)
)	O
;	O
break	O
;	O
case	O
MU_IMAP_FETCH_INTERNALDATE	int
:	O
format_date	(*(struct),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))))->(void)
(	O
str	*(char)
,	O
"internaldate"	*(char)
,	O
&	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
internaldate	struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)))
.	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
&	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
internaldate	struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char)))
.	O
tz	*(struct(int,*(char)))
)	O
;	O
break	O
;	O
case	O
MU_IMAP_FETCH_RFC822_SIZE	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"  size = %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
rfc822_size	struct(int,long)
.	O
size	long
)	O
;	O
break	O
;	O
case	O
MU_IMAP_FETCH_UID	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"  UID = %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
uid	int
.	O
uid	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
imap_fetch_callback	(*(void),int,long,*(void))->(void)
(	O
void	O
*	O
data	*(void)
,	O
int	O
code	int
,	O
size_t	long
sdat	long
,	O
void	O
*	O
pdat	*(void)
)	O
{	O
mu_stream_t	*(struct)
str	*(char)
=	O
data	*(void)
;	O
mu_list_t	*(struct)
list	*(struct)
=	O
pdat	*(void)
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"Message #%lu:\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
sdat	long
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
list	*(struct)
,	O
fetch_response_printer	(*(void),*(void))->(int)
,	O
str	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"\n\n"	*(char)
)	O
;	O
}	O
static	O
int	O
com_uid	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
bv	int
;	O
if	O
(	O
argc	long
==	O
1	int
)	O
mu_printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
uid_mode	int
?	O
_	O
(	O
"UID is on"	*(char)
)	O
:	O
_	O
(	O
"UID is off"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
get_bool	(*(char),*(int))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
bv	int
)	O
==	O
0	int
)	O
uid_mode	int
=	O
bv	int
;	O
else	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"invalid boolean value"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_disconnect	(int,*(*(char)))->(int)
(	O
int	O
argc	long
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
MU_ARG_UNUSED	O
)	O
{	O
if	O
(	O
imap	*(struct)
)	O
{	O
mu_imap_disconnect	(*(struct))->(int)
(	O
imap	*(struct)
)	O
;	O
mu_imap_destroy	(*(*(struct)))->(void)
(	O
&	O
imap	*(struct)
)	O
;	O
mu_argcv_free	(long,*(*(char)))->(void)
(	O
connect_argc	int
,	O
connect_argv	*(*(char))
)	O
;	O
connect_argc	int
=	O
0	int
;	O
connect_argv	*(*(char))
=	O
NULL	O
;	O
imap_prompt_env	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
com_connect	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
status	int
;	O
int	O
tls	int
=	O
0	int
;	O
int	O
i	long
=	O
1	int
;	O
enum	O
mu_imap_session_state	enum(int,int,int,int)
state	*(int)
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
argc	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	long
]	O
,	O
"-tls"	*(char)
)	O
==	O
0	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"TLS not supported"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
break	O
;	O
}	O
argc	long
-=	O
i	long
;	O
argv	*(*(char))
+=	O
i	long
;	O
state	*(int)
=	O
current_imap_state	()->(enum(int,int,int,int))
(	O
)	O
;	O
if	O
(	O
state	*(int)
!=	O
MU_IMAP_SESSION_INIT	int
)	O
com_disconnect	(int,*(*(char)))->(int)
(	O
0	int
,	O
NULL	O
)	O
;	O
status	int
=	O
mu_imap_create	(*(*(struct)))->(int)
(	O
&	O
imap	*(struct)
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
mu_stream_t	*(struct)
tcp	*(struct)
;	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
sa	*(struct(short,array(char)))
;	O
struct	O
mu_sockaddr_hints	struct(int,int,int,int,short)
hints	*(struct(*(char),*(char)))
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	*(struct(*(char),*(char)))
,	O
0	int
,	O
sizeof	O
(	O
hints	*(struct(*(char),*(char)))
)	O
)	O
;	O
hints	*(struct(*(char),*(char)))
.	O
flags	int
=	O
MU_AH_DETECT_FAMILY	int
;	O
hints	*(struct(*(char),*(char)))
.	O
port	int
=	O
tls	int
?	O
MU_IMAP_DEFAULT_SSL_PORT	int
:	O
MU_IMAP_DEFAULT_PORT	int
;	O
hints	*(struct(*(char),*(char)))
.	O
protocol	int
=	O
IPPROTO_TCP	int
;	O
hints	*(struct(*(char),*(char)))
.	O
socktype	int
=	O
SOCK_STREAM	int
;	O
status	int
=	O
mu_sockaddr_from_node	(*(*(struct(*(struct`),*(struct`),*(struct`),int,*(char)))),*(char),*(char),*(struct(int,int,int,int,short)))->(int)
(	O
&	O
sa	*(struct(short,array(char)))
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
hints	*(struct(*(char),*(char)))
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
status	int
=	O
mu_tcp_stream_create_from_sa	(*(*(struct)),*(struct),*(struct),int)->(int)
(	O
&	O
tcp	*(struct)
,	O
sa	*(struct(short,array(char)))
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
)	O
mu_sockaddr_free	(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))->(void)
(	O
sa	*(struct(short,array(char)))
)	O
;	O
}	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
mu_imap_set_carrier	(*(struct),*(struct))->(int)
(	O
imap	*(struct)
,	O
tcp	*(struct)
)	O
;	O
if	O
(	O
QRY_VERBOSE	O
(	O
)	O
)	O
{	O
imap_set_verbose	()->(void)
(	O
)	O
;	O
imap_set_verbose_mask	()->(void)
(	O
)	O
;	O
}	O
mu_imap_register_callback_function	(*(struct),int,*((*(void),int,long,*(void))->(void)),*(void))->(void)
(	O
imap	*(struct)
,	O
MU_IMAP_CB_PREAUTH	int
,	O
imap_preauth_callback	(*(void),int,long,*(void))->(void)
,	O
NULL	O
)	O
;	O
mu_imap_register_callback_function	(*(struct),int,*((*(void),int,long,*(void))->(void)),*(void))->(void)
(	O
imap	*(struct)
,	O
MU_IMAP_CB_BYE	int
,	O
imap_bye_callback	(*(void),int,long,*(void))->(void)
,	O
NULL	O
)	O
;	O
mu_imap_register_callback_function	(*(struct),int,*((*(void),int,long,*(void))->(void)),*(void))->(void)
(	O
imap	*(struct)
,	O
MU_IMAP_CB_BAD	int
,	O
imap_bad_callback	(*(void),int,long,*(void))->(void)
,	O
NULL	O
)	O
;	O
mu_imap_register_callback_function	(*(struct),int,*((*(void),int,long,*(void))->(void)),*(void))->(void)
(	O
imap	*(struct)
,	O
MU_IMAP_CB_FETCH	int
,	O
imap_fetch_callback	(*(void),int,long,*(void))->(void)
,	O
mu_strout	*(struct)
)	O
;	O
status	int
=	O
mu_imap_connect	(*(struct))->(int)
(	O
imap	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
const	O
char	O
*	O
err	int
;	O
mu_error	(*(char))->(int)
(	O
"Failed to connect: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
if	O
(	O
mu_imap_strerror	(*(struct),*(*(char)))->(int)
(	O
imap	*(struct)
,	O
&	O
err	int
)	O
)	O
mu_error	(*(char))->(int)
(	O
"server response: %s"	*(char)
,	O
err	int
)	O
;	O
mu_imap_destroy	(*(*(struct)))->(void)
(	O
&	O
imap	*(struct)
)	O
;	O
}	O
}	O
else	O
mu_imap_destroy	(*(*(struct)))->(void)
(	O
&	O
imap	*(struct)
)	O
;	O
}	O
else	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Failed to create imap connection: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
if	O
(	O
!	O
status	int
)	O
{	O
connect_argc	int
=	O
argc	long
;	O
connect_argv	*(*(char))
=	O
mu_calloc	(long,long)->(*(void))
(	O
argc	long
+	O
1	int
,	O
sizeof	O
(	O
*	O
connect_argv	*(*(char))
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
argc	long
;	O
i	long
++	O
)	O
connect_argv	*(*(char))
[	O
i	long
]	O
=	O
mu_strdup	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
i	long
]	O
)	O
;	O
connect_argv	*(*(char))
[	O
i	long
]	O
=	O
NULL	O
;	O
imap_prompt_env	()->(void)
(	O
)	O
;	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
com_starttls	(int,*(*(char)))->(int)
(	O
int	O
argc	long
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
MU_ARG_UNUSED	O
)	O
{	O
int	O
status	int
=	O
mu_imap_starttls	(*(struct))->(int)
(	O
imap	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"starttls"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_logout	(int,*(*(char)))->(int)
(	O
int	O
argc	long
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
MU_ARG_UNUSED	O
)	O
{	O
int	O
status	int
=	O
0	int
;	O
if	O
(	O
imap	*(struct)
)	O
{	O
if	O
(	O
mu_imap_logout	(*(struct))->(int)
(	O
imap	*(struct)
)	O
==	O
0	int
)	O
{	O
status	int
=	O
com_disconnect	(int,*(*(char)))->(int)
(	O
0	int
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
mu_printf	(*(char))->(int)
(	O
"Try 'exit' to leave %s\n"	*(char)
,	O
mu_program_name	*(char)
)	O
;	O
}	O
}	O
else	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"Try 'exit' to leave %s\n"	*(char)
)	O
,	O
mu_program_name	*(char)
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
com_capability	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_iterator_t	*(struct)
iterator	*(struct)
=	O
NULL	O
;	O
int	O
status	int
=	O
0	int
;	O
int	O
reread	int
=	O
0	int
;	O
int	O
i	long
=	O
1	int
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
argc	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	long
]	O
,	O
"-reread"	*(char)
)	O
==	O
0	int
)	O
reread	int
=	O
1	int
;	O
else	O
break	O
;	O
}	O
if	O
(	O
i	long
<	O
argc	long
)	O
{	O
if	O
(	O
reread	int
)	O
{	O
status	int
=	O
mu_imap_capability	(*(struct),int,*(*(struct)))->(int)
(	O
imap	*(struct)
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
}	O
for	O
(	O
;	O
i	long
<	O
argc	long
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
elt	*(char)
;	O
int	O
rc	int
=	O
mu_imap_capability_test	(*(struct),*(char),*(*(char)))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
i	long
]	O
,	O
&	O
elt	*(char)
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
*	O
elt	*(char)
)	O
mu_printf	(*(char))->(int)
(	O
"%s: %s\n"	*(char)
,	O
argv	*(*(char))
[	O
i	long
]	O
,	O
elt	*(char)
)	O
;	O
else	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"%s is set\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	long
]	O
)	O
;	O
break	O
;	O
case	O
MU_ERR_NOENT	O
:	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"%s is not set\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	long
]	O
)	O
;	O
break	O
;	O
default	O
:	O
return	O
rc	int
;	O
}	O
}	O
}	O
else	O
{	O
status	int
=	O
mu_imap_capability	(*(struct),int,*(*(struct)))->(int)
(	O
imap	*(struct)
,	O
reread	int
,	O
&	O
iterator	*(struct)
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
iterator	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
iterator	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
iterator	*(struct)
)	O
)	O
{	O
char	O
*	O
capa	*(struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
=	O
NULL	O
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
iterator	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
capa	*(struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
)	O
;	O
mu_printf	(*(char))->(int)
(	O
"CAPA: %s\n"	*(char)
,	O
capa	*(struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
?	O
capa	*(struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
:	O
""	*(char)
)	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
iterator	*(struct)
)	O
;	O
}	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
com_login	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
status	int
;	O
char	O
*	O
pwd	*(char)
,	O
*	O
passbuf	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
imap	*(struct)
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"you need to connect first"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argc	long
==	O
2	int
)	O
{	O
if	O
(	O
!	O
mutool_shell_interactive	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"login: password required"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
status	int
=	O
mu_getpass	(*(struct),*(struct),*(char),*(*(char)))->(int)
(	O
mu_strin	*(struct)
,	O
mu_strout	*(struct)
,	O
_	O
(	O
"Password:"	*(char)
)	O
,	O
&	O
passbuf	*(char)
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
pwd	*(char)
=	O
passbuf	*(char)
;	O
}	O
else	O
pwd	*(char)
=	O
argv	*(*(char))
[	O
2	int
]	O
;	O
status	int
=	O
mu_imap_login	(*(struct),*(char),*(char))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
pwd	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
pwd	*(char)
,	O
0	int
,	O
strlen	(*(char))->(long)
(	O
pwd	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
passbuf	*(char)
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
username	*(char)
)	O
;	O
username	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
imap_prompt_env	()->(void)
(	O
)	O
;	O
}	O
else	O
report_failure	(*(char),int)->(void)
(	O
"login"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_id	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_assoc_t	*(struct)
assoc	*(struct)
;	O
char	O
*	O
test	*(*((int,int)->(int)))
=	O
NULL	O
;	O
int	O
status	int
;	O
argv	*(*(char))
++	O
;	O
if	O
(	O
argv	*(*(char))
[	O
0	int
]	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
"-test"	*(char)
)	O
==	O
0	int
)	O
{	O
argv	*(*(char))
++	O
;	O
if	O
(	O
argv	*(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"id -test requires an argument"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
test	*(*((int,int)->(int)))
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
argv	*(*(char))
++	O
;	O
}	O
status	int
=	O
mu_imap_id	(*(struct),*(*(char)),*(*(struct)))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
+	O
1	int
,	O
&	O
assoc	*(struct)
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
if	O
(	O
test	*(*((int,int)->(int)))
)	O
{	O
char	O
*	O
val	array(int)
=	O
mu_assoc_get	(*(struct),*(char))->(*(void))
(	O
assoc	*(struct)
,	O
test	*(*((int,int)->(int)))
)	O
;	O
if	O
(	O
val	array(int)
)	O
{	O
mu_printf	(*(char))->(int)
(	O
"%s: %s\n"	*(char)
,	O
test	*(*((int,int)->(int)))
,	O
val	array(int)
)	O
;	O
}	O
else	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"%s is not set\n"	*(char)
)	O
,	O
test	*(*((int,int)->(int)))
)	O
;	O
}	O
else	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
mu_assoc_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
assoc	*(struct)
,	O
&	O
itr	*(struct)
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
char	O
*	O
key	*(*(void))
;	O
char	O
*	O
val	array(int)
;	O
mu_iterator_current_kv	(*(struct),*(*(void)),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
key	*(*(void))
,	O
(	O
void	O
*	O
*	O
)	O
&	O
val	array(int)
)	O
;	O
mu_printf	(*(char))->(int)
(	O
"ID: %s %s\n"	*(char)
,	O
key	*(*(void))
,	O
val	array(int)
)	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
mu_assoc_destroy	(*(*(struct)))->(void)
(	O
&	O
assoc	*(struct)
)	O
;	O
}	O
return	O
status	int
;	O
}	O
static	O
void	O
print_imap_stats	(*(struct(int,int,int,long,long,long,long,long)))->(void)
(	O
struct	O
mu_imap_stat	struct(int,int,int,long,long,long,long,long)
*	O
st	*(struct(long,long,long))
)	O
{	O
if	O
(	O
st	*(struct(long,long,long))
->	O
flags	int
&	O
MU_IMAP_STAT_DEFINED_FLAGS	int
)	O
{	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"Flags defined: "	*(char)
)	O
)	O
;	O
mu_imap_format_flags	(*(struct),int,int)->(int)
(	O
mu_strout	*(struct)
,	O
st	*(struct(long,long,long))
->	O
defined_flags	int
,	O
0	int
)	O
;	O
mu_printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
st	*(struct(long,long,long))
->	O
flags	int
&	O
MU_IMAP_STAT_PERMANENT_FLAGS	int
)	O
{	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"Flags permanent: "	*(char)
)	O
)	O
;	O
mu_imap_format_flags	(*(struct),int,int)->(int)
(	O
mu_strout	*(struct)
,	O
st	*(struct(long,long,long))
->	O
permanent_flags	int
,	O
0	int
)	O
;	O
mu_printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
st	*(struct(long,long,long))
->	O
flags	int
&	O
MU_IMAP_STAT_MESSAGE_COUNT	int
)	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"Total messages: %lu\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
st	*(struct(long,long,long))
->	O
message_count	long
)	O
;	O
if	O
(	O
st	*(struct(long,long,long))
->	O
flags	int
&	O
MU_IMAP_STAT_RECENT_COUNT	int
)	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"Recent messages: %lu\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
st	*(struct(long,long,long))
->	O
recent_count	long
)	O
;	O
if	O
(	O
st	*(struct(long,long,long))
->	O
flags	int
&	O
MU_IMAP_STAT_FIRST_UNSEEN	int
)	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"First unseen message: %lu\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
st	*(struct(long,long,long))
->	O
first_unseen	long
)	O
;	O
if	O
(	O
st	*(struct(long,long,long))
->	O
flags	int
&	O
MU_IMAP_STAT_UIDNEXT	int
)	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"Next UID: %lu\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
st	*(struct(long,long,long))
->	O
uidnext	long
)	O
;	O
if	O
(	O
st	*(struct(long,long,long))
->	O
flags	int
&	O
MU_IMAP_STAT_UIDVALIDITY	int
)	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"UID validity: %lu\n"	*(char)
)	O
,	O
st	*(struct(long,long,long))
->	O
uidvalidity	long
)	O
;	O
}	O
static	O
int	O
select_mbox	(int,*(*(char)),int)->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
writable	int
)	O
{	O
int	O
status	int
;	O
struct	O
mu_imap_stat	struct(int,int,int,long,long,long,long,long)
st	*(struct(long,long,long))
;	O
status	int
=	O
mu_imap_select	(*(struct),*(char),int,*(struct(int,int,int,long,long,long,long,long)))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
writable	int
,	O
&	O
st	*(struct(long,long,long))
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
print_imap_stats	(*(struct(int,int,int,long,long,long,long,long)))->(void)
(	O
&	O
st	*(struct(long,long,long))
)	O
;	O
imap_prompt_env	()->(void)
(	O
)	O
;	O
}	O
else	O
report_failure	(*(char),int)->(void)
(	O
"select"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_select	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
return	O
select_mbox	(int,*(*(char)),int)->(int)
(	O
argc	long
,	O
argv	*(*(char))
,	O
1	int
)	O
;	O
}	O
static	O
int	O
com_examine	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
return	O
select_mbox	(int,*(*(char)),int)->(int)
(	O
argc	long
,	O
argv	*(*(char))
,	O
0	int
)	O
;	O
}	O
static	O
int	O
com_status	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
struct	O
mu_imap_stat	struct(int,int,int,long,long,long,long,long)
st	*(struct(long,long,long))
;	O
int	O
i	long
,	O
flag	int
;	O
int	O
status	int
;	O
st	*(struct(long,long,long))
.	O
flags	int
=	O
0	int
;	O
for	O
(	O
i	long
=	O
2	int
;	O
i	long
<	O
argc	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
mu_kwd_xlat_name_ci	(*(struct(*(char),int)),*(char),*(int))->(int)
(	O
_mu_imap_status_name_table	array(struct(*(char),int))
,	O
argv	*(*(char))
[	O
i	long
]	O
,	O
&	O
flag	int
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"unknown data item: %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	long
]	O
)	O
;	O
return	O
0	int
;	O
}	O
st	*(struct(long,long,long))
.	O
flags	int
|=	O
flag	int
;	O
}	O
status	int
=	O
mu_imap_status	(*(struct),*(char),*(struct(int,int,int,long,long,long,long,long)))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
st	*(struct(long,long,long))
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
print_imap_stats	(*(struct(int,int,int,long,long,long,long,long)))->(void)
(	O
&	O
st	*(struct(long,long,long))
)	O
;	O
}	O
else	O
report_failure	(*(char),int)->(void)
(	O
"status"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_noop	(int,*(*(char)))->(int)
(	O
int	O
argc	long
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
MU_ARG_UNUSED	O
)	O
{	O
int	O
status	int
=	O
mu_imap_noop	(*(struct))->(int)
(	O
imap	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"noop"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_check	(int,*(*(char)))->(int)
(	O
int	O
argc	long
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
MU_ARG_UNUSED	O
)	O
{	O
int	O
status	int
=	O
mu_imap_check	(*(struct))->(int)
(	O
imap	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"check"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_fetch	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_stream_t	*(struct)
out	*(struct)
=	O
mutool_open_pager	()->(*(struct))
(	O
)	O
;	O
mu_msgset_t	*(struct)
msgset	*(struct)
=	O
parse_msgset	(*(char))->(*(struct))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
msgset	*(struct)
)	O
{	O
int	O
status	int
;	O
mu_imap_register_callback_function	(*(struct),int,*((*(void),int,long,*(void))->(void)),*(void))->(void)
(	O
imap	*(struct)
,	O
MU_IMAP_CB_FETCH	int
,	O
imap_fetch_callback	(*(void),int,long,*(void))->(void)
,	O
out	*(struct)
)	O
;	O
status	int
=	O
mu_imap_fetch	(*(struct),int,*(struct),*(char))->(int)
(	O
imap	*(struct)
,	O
uid_mode	int
,	O
msgset	*(struct)
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
out	*(struct)
)	O
;	O
mu_imap_register_callback_function	(*(struct),int,*((*(void),int,long,*(void))->(void)),*(void))->(void)
(	O
imap	*(struct)
,	O
MU_IMAP_CB_FETCH	int
,	O
imap_fetch_callback	(*(void),int,long,*(void))->(void)
,	O
mu_strout	*(struct)
)	O
;	O
mu_msgset_free	(*(struct))->(void)
(	O
msgset	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"fetch"	*(char)
,	O
status	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
com_store	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_msgset_t	*(struct)
msgset	*(struct)
=	O
parse_msgset	(*(char))->(*(struct))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
msgset	*(struct)
)	O
{	O
int	O
status	int
=	O
mu_imap_store	(*(struct),int,*(struct),*(char))->(int)
(	O
imap	*(struct)
,	O
uid_mode	int
,	O
msgset	*(struct)
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"store"	*(char)
,	O
status	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
com_close	(int,*(*(char)))->(int)
(	O
int	O
argc	long
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
MU_ARG_UNUSED	O
)	O
{	O
int	O
status	int
=	O
mu_imap_close	(*(struct))->(int)
(	O
imap	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"close"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_unselect	(int,*(*(char)))->(int)
(	O
int	O
argc	long
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
MU_ARG_UNUSED	O
)	O
{	O
int	O
status	int
=	O
mu_imap_noop	(*(struct))->(int)
(	O
imap	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"unselect"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_delete	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
status	int
=	O
mu_imap_delete	(*(struct),*(char))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"delete"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_rename	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
status	int
=	O
mu_imap_rename	(*(struct),*(char),*(char))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"rename"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_expunge	(int,*(*(char)))->(int)
(	O
int	O
argc	long
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
MU_ARG_UNUSED	O
)	O
{	O
int	O
status	int
=	O
mu_imap_expunge	(*(struct))->(int)
(	O
imap	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"expunge"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_create	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
status	int
=	O
mu_imap_mailbox_create	(*(struct),*(char))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"create"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_subscribe	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
status	int
=	O
mu_imap_subscribe	(*(struct),*(char))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"subscribe"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_unsubscribe	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
status	int
=	O
mu_imap_unsubscribe	(*(struct),*(char))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"unsubscribe"	*(char)
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_append	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
tmbuf	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
NULL	O
;	O
struct	O
mu_timezone	struct(int,*(char))
tzbuf	struct(int,*(char))
,	O
*	O
tz	*(struct(int,*(char)))
=	O
NULL	O
;	O
int	O
flags	int
=	O
0	int
;	O
mu_stream_t	*(struct)
stream	*(struct)
;	O
int	O
rc	int
,	O
i	long
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
argc	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	long
]	O
,	O
"-time"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
++	O
i	long
==	O
argc	long
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"-time requires argument"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
mu_scan_datetime	(*(char),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))),*(*(char)))->(int)
(	O
argv	*(*(char))
[	O
i	long
]	O
,	O
MU_DATETIME_INTERNALDATE	*(char)
,	O
&	O
tmbuf	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
&	O
tzbuf	struct(int,*(char))
,	O
&	O
p	*(char)
)	O
;	O
if	O
(	O
rc	int
||	O
*	O
p	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot parse time"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
&	O
tmbuf	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
tz	*(struct(int,*(char)))
=	O
&	O
tzbuf	struct(int,*(char))
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	long
]	O
,	O
"-flag"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
++	O
i	long
==	O
argc	long
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"-flag requires argument"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
mu_imap_flag_to_attribute	(*(char),*(int))->(int)
(	O
argv	*(*(char))
[	O
i	long
]	O
,	O
&	O
flags	int
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"unrecognized flag: %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	long
]	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	long
]	O
,	O
"--"	*(char)
)	O
==	O
0	int
)	O
{	O
i	long
++	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
argv	*(*(char))
[	O
i	long
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"unrecognized option: %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	long
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
argc	long
-	O
i	long
!=	O
2	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"wrong number of arguments"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
stream	*(struct)
,	O
argv	*(*(char))
[	O
i	long
+	O
1	int
]	O
,	O
MU_STREAM_READ	int
|	O
MU_STREAM_SEEK	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open file %s: %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	long
+	O
1	int
]	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
mu_imap_append_stream	(*(struct),*(char),int,*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))),*(struct))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
i	long
]	O
,	O
flags	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
tz	*(struct(int,*(char)))
,	O
stream	*(struct)
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
stream	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
report_failure	(*(char),int)->(void)
(	O
"append"	*(char)
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_copy	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_msgset_t	*(struct)
msgset	*(struct)
=	O
parse_msgset	(*(char))->(*(struct))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
msgset	*(struct)
)	O
{	O
int	O
status	int
=	O
mu_imap_copy	(*(struct),int,*(struct),*(char))->(int)
(	O
imap	*(struct)
,	O
uid_mode	int
,	O
msgset	*(struct)
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
mu_msgset_free	(*(struct))->(void)
(	O
msgset	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
report_failure	(*(char),int)->(void)
(	O
"copy"	*(char)
,	O
status	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
com_search	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_msgset_t	*(struct)
mset	*(struct)
;	O
size_t	long
count	long
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_imap_search	(*(struct),int,*(char),*(*(struct)))->(int)
(	O
imap	*(struct)
,	O
uid_mode	int
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
mset	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
report_failure	(*(char),int)->(void)
(	O
"search"	*(char)
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
mu_msgset_count	(*(struct),*(long))->(int)
(	O
mset	*(struct)
,	O
&	O
count	long
)	O
;	O
if	O
(	O
rc	int
==	O
EINVAL	int
||	O
count	long
==	O
0	int
)	O
{	O
mu_printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
_	O
(	O
"no matches"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
mu_printf	(*(char))->(int)
(	O
"%lu matches:"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
count	long
)	O
;	O
mu_msgset_imap_print	(*(struct),*(struct))->(int)
(	O
mu_strout	*(struct)
,	O
mset	*(struct)
)	O
;	O
mu_printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
mu_msgset_free	(*(struct))->(void)
(	O
mset	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
print_list_item	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
mu_list_response	struct(int,int,int,*(char),*(struct))
*	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
=	O
item	*(void)
;	O
mu_stream_t	*(struct)
out	*(struct)
=	O
data	*(void)
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"%c%c %c %4d %s\n"	*(char)
,	O
(	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
type	int
&	O
MU_FOLDER_ATTRIBUTE_DIRECTORY	int
)	O
?	O
'd'	O
:	O
'-'	O
,	O
(	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
type	int
&	O
MU_FOLDER_ATTRIBUTE_FILE	int
)	O
?	O
'f'	O
:	O
'-'	O
,	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
separator	int
?	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
separator	int
:	O
MU_HIERARCHY_DELIMITER	char
,	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
depth	int
,	O
resp	*(union(int,struct(int,*(long),long,*(char),*(struct),*(char)),struct(int,*(struct(enum(int,int,int,int),*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,*`,union`))),struct(int,*(struct(struct`,struct`,*`,*`,*`,*`,*`,*`,*`,*`,*`))),struct(int,int),struct(int,struct(int,int,int,int,int,int,int,int,int,long,*(char)),struct(int,*(char))),struct(int,long),struct(int,long)))
->	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_list	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_list_t	*(struct)
list	*(struct)
;	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
out	*(struct)
;	O
rc	int
=	O
mu_imap_list_new	(*(struct),*(char),*(char),*(*(struct)))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argv	*(*(char))
[	O
2	int
]	O
,	O
&	O
list	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
report_failure	(*(char),int)->(void)
(	O
"list"	*(char)
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
out	*(struct)
=	O
mutool_open_pager	()->(*(struct))
(	O
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
list	*(struct)
,	O
print_list_item	(*(void),*(void))->(int)
,	O
out	*(struct)
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
out	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_lsub	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_list_t	*(struct)
list	*(struct)
;	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
out	*(struct)
;	O
rc	int
=	O
mu_imap_lsub_new	(*(struct),*(char),*(char),*(*(struct)))->(int)
(	O
imap	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argv	*(*(char))
[	O
2	int
]	O
,	O
&	O
list	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
report_failure	(*(char),int)->(void)
(	O
"lsub"	*(char)
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
out	*(struct)
=	O
mutool_open_pager	()->(*(struct))
(	O
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
list	*(struct)
,	O
print_list_item	(*(void),*(void))->(int)
,	O
out	*(struct)
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
out	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
mutool_command	struct(*(char),int,int,int,*((int,*(*(char)))->(int)),*(char),*(char))
imap_comtab	array(struct(*(char),int,int,int,*((int,*(*(char)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"capability"	*(char)
,	O
1	int
,	O
-	O
1	int
,	O
0	int
,	O
com_capability	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"[-reread] [NAME...]"	*(char)
)	O
,	O
N_	O
(	O
"list server capabilities"	*(char)
)	O
}	O
,	O
{	O
"verbose"	*(char)
,	O
1	int
,	O
4	int
,	O
0	int
,	O
com_verbose	(int,*(*(char)))->(int)
,	O
"[on|off|mask|unmask] [secure [payload]]"	*(char)
,	O
N_	O
(	O
"control the protocol tracing"	*(char)
)	O
}	O
,	O
{	O
"connect"	*(char)
,	O
1	int
,	O
4	int
,	O
0	int
,	O
com_connect	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"[-tls] HOSTNAME [PORT]"	*(char)
)	O
,	O
N_	O
(	O
"open connection"	*(char)
)	O
}	O
,	O
{	O
"disconnect"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
com_disconnect	(int,*(*(char)))->(int)
,	O
NULL	O
,	O
N_	O
(	O
"close connection"	*(char)
)	O
}	O
,	O
{	O
"starttls"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
com_starttls	(int,*(*(char)))->(int)
,	O
NULL	O
,	O
N_	O
(	O
"Establish TLS encrypted channel"	*(char)
)	O
}	O
,	O
{	O
"login"	*(char)
,	O
2	int
,	O
3	int
,	O
0	int
,	O
com_login	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"USER [PASS]"	*(char)
)	O
,	O
N_	O
(	O
"login to the server"	*(char)
)	O
}	O
,	O
{	O
"logout"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
com_logout	(int,*(*(char)))->(int)
,	O
NULL	O
,	O
N_	O
(	O
"quit imap session"	*(char)
)	O
}	O
,	O
{	O
"id"	*(char)
,	O
1	int
,	O
-	O
1	int
,	O
0	int
,	O
com_id	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"[-test KW] [ARG [ARG...]]"	*(char)
)	O
,	O
N_	O
(	O
"send ID command"	*(char)
)	O
}	O
,	O
{	O
"noop"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
com_noop	(int,*(*(char)))->(int)
,	O
NULL	O
,	O
N_	O
(	O
"no operation (keepalive)"	*(char)
)	O
}	O
,	O
{	O
"check"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
com_check	(int,*(*(char)))->(int)
,	O
NULL	O
,	O
N_	O
(	O
"request a server checkpoint"	*(char)
)	O
}	O
,	O
{	O
"select"	*(char)
,	O
1	int
,	O
2	int
,	O
0	int
,	O
com_select	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"[MBOX]"	*(char)
)	O
,	O
N_	O
(	O
"select a mailbox"	*(char)
)	O
}	O
,	O
{	O
"examine"	*(char)
,	O
1	int
,	O
2	int
,	O
0	int
,	O
com_examine	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"[MBOX]"	*(char)
)	O
,	O
N_	O
(	O
"examine a mailbox"	*(char)
)	O
}	O
,	O
{	O
"status"	*(char)
,	O
3	int
,	O
-	O
1	int
,	O
0	int
,	O
com_status	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"MBOX KW [KW...]"	*(char)
)	O
,	O
N_	O
(	O
"get mailbox status"	*(char)
)	O
}	O
,	O
{	O
"fetch"	*(char)
,	O
3	int
,	O
3	int
,	O
CMD_COALESCE_EXTRA_ARGS	int
,	O
com_fetch	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"MSGSET ITEMS"	*(char)
)	O
,	O
N_	O
(	O
"fetch message data"	*(char)
)	O
}	O
,	O
{	O
"store"	*(char)
,	O
3	int
,	O
3	int
,	O
CMD_COALESCE_EXTRA_ARGS	int
,	O
com_store	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"MSGSET ITEMS"	*(char)
)	O
,	O
N_	O
(	O
"alter mailbox data"	*(char)
)	O
}	O
,	O
{	O
"close"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
com_close	(int,*(*(char)))->(int)
,	O
NULL	O
,	O
N_	O
(	O
"close the mailbox (with expunge)"	*(char)
)	O
}	O
,	O
{	O
"unselect"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
com_unselect	(int,*(*(char)))->(int)
,	O
NULL	O
,	O
N_	O
(	O
"close the mailbox (without expunge)"	*(char)
)	O
}	O
,	O
{	O
"delete"	*(char)
,	O
2	int
,	O
2	int
,	O
0	int
,	O
com_delete	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"MAILBOX"	*(char)
)	O
,	O
N_	O
(	O
"delete the mailbox"	*(char)
)	O
}	O
,	O
{	O
"rename"	*(char)
,	O
3	int
,	O
3	int
,	O
0	int
,	O
com_rename	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"OLD-NAME NEW-NAME"	*(char)
)	O
,	O
N_	O
(	O
"rename existing mailbox"	*(char)
)	O
}	O
,	O
{	O
"expunge"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
com_expunge	(int,*(*(char)))->(int)
,	O
NULL	O
,	O
N_	O
(	O
"permanently remove messages marked for deletion"	*(char)
)	O
}	O
,	O
{	O
"create"	*(char)
,	O
2	int
,	O
2	int
,	O
0	int
,	O
com_create	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"MAILBOX"	*(char)
)	O
,	O
N_	O
(	O
"create new mailbox"	*(char)
)	O
}	O
,	O
{	O
"append"	*(char)
,	O
3	int
,	O
-	O
1	int
,	O
0	int
,	O
com_append	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"[-time DATETIME] [-flag FLAG] MAILBOX FILE"	*(char)
)	O
,	O
N_	O
(	O
"append message text from FILE to MAILBOX"	*(char)
)	O
}	O
,	O
{	O
"copy"	*(char)
,	O
3	int
,	O
3	int
,	O
0	int
,	O
com_copy	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"MSGSET MAILBOX"	*(char)
)	O
,	O
N_	O
(	O
"Copy messages from MSGSET to MAILBOX"	*(char)
)	O
}	O
,	O
{	O
"list"	*(char)
,	O
3	int
,	O
3	int
,	O
0	int
,	O
com_list	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"REF MBOX"	*(char)
)	O
,	O
N_	O
(	O
"List matching mailboxes"	*(char)
)	O
}	O
,	O
{	O
"lsub"	*(char)
,	O
3	int
,	O
3	int
,	O
0	int
,	O
com_lsub	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"REF MBOX"	*(char)
)	O
,	O
N_	O
(	O
"List subscribed mailboxes"	*(char)
)	O
}	O
,	O
{	O
"subscribe"	*(char)
,	O
2	int
,	O
2	int
,	O
0	int
,	O
com_subscribe	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"MBOX"	*(char)
)	O
,	O
N_	O
(	O
"Subscribe to a mailbox"	*(char)
)	O
}	O
,	O
{	O
"unsubscribe"	*(char)
,	O
2	int
,	O
2	int
,	O
0	int
,	O
com_unsubscribe	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"MBOX"	*(char)
)	O
,	O
N_	O
(	O
"Remove mailbox from subscription list"	*(char)
)	O
}	O
,	O
{	O
"uid"	*(char)
,	O
1	int
,	O
2	int
,	O
0	int
,	O
com_uid	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"[on|off]"	*(char)
)	O
,	O
N_	O
(	O
"control UID mode"	*(char)
)	O
}	O
,	O
{	O
"search"	*(char)
,	O
2	int
,	O
2	int
,	O
CMD_COALESCE_EXTRA_ARGS	int
,	O
com_search	(int,*(*(char)))->(int)
,	O
N_	O
(	O
"args..."	*(char)
)	O
,	O
N_	O
(	O
"search the mailbox"	*(char)
)	O
}	O
,	O
{	O
"quit"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
com_logout	(int,*(*(char)))->(int)
,	O
NULL	O
,	O
N_	O
(	O
"same as `logout'"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_action_getopt	(*(int),*(*(*(char))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char),*(char))->(void)
(	O
&	O
argc	long
,	O
&	O
argv	*(*(char))
,	O
NULL	O
,	O
imap_docstring	array(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
argc	long
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mutool_shell_prompt	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
"imap> "	*(char)
)	O
;	O
imap_prompt_env	()->(void)
(	O
)	O
;	O
mutool_shell	(*(char),*(struct(*(char),int,int,int,*((int,*`)->(int)),*(char),*(char))))->(int)
(	O
"imap"	*(char)
,	O
imap_comtab	array(struct(*(char),int,int,int,*((int,*(*(char)))->(int)),*(char),*(char)))
)	O
;	O
return	O
0	int
;	O
}	O
