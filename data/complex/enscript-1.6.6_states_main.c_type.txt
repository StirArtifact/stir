char	O
*	O
program	*(char)
;	O
StringHashPtr	*(struct)
ns_prims	*(struct)
=	O
NULL	O
;	O
StringHashPtr	*(struct)
ns_vars	*(struct)
=	O
NULL	O
;	O
StringHashPtr	*(struct)
ns_subs	*(struct)
=	O
NULL	O
;	O
StringHashPtr	*(struct)
ns_states	*(struct)
=	O
NULL	O
;	O
List	struct(*(struct(*(struct(*`,*`)),*(void))),*(struct(*(struct(*`,*`)),*(void))))
*	O
global_stmts	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
=	O
NULL	O
;	O
List	struct(*(struct(*(struct(*`,*`)),*(void))),*(struct(*(struct(*`,*`)),*(void))))
*	O
start_stmts	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
=	O
NULL	O
;	O
List	struct(*(struct(*(struct(*`,*`)),*(void))),*(struct(*(struct(*`,*`)),*(void))))
*	O
startrules	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
=	O
NULL	O
;	O
List	struct(*(struct(*(struct(*`,*`)),*(void))),*(struct(*(struct(*`,*`)),*(void))))
*	O
namerules	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
=	O
NULL	O
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
nvoid	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
NULL	O
;	O
FILE	struct
*	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
char	O
*	O
inbuf	*(char)
=	O
NULL	O
;	O
unsigned	O
int	O
data_in_buffer	int
;	O
unsigned	O
int	O
bufpos	int
;	O
int	O
eof_seen	int
;	O
char	O
*	O
current_fname	*(char)
;	O
unsigned	O
int	O
current_linenum	int
;	O
struct	O
re_registers	struct(int,*(int),*(int))
*	O
current_match	*(struct(int,*(int),*(int)))
=	O
NULL	O
;	O
char	O
*	O
current_match_buf	*(char)
=	O
NULL	O
;	O
VariableDef	struct(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char),*(char))
*	O
vardefs	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
NULL	O
;	O
VariableDef	struct(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char),*(char))
*	O
vardefs_tail	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
NULL	O
;	O
char	O
*	O
defs_file	*(char)
=	O
"states.st"	*(char)
;	O
unsigned	O
int	O
linenum	int
=	O
1	int
;	O
char	O
*	O
yyin_name	*(char)
;	O
FILE	struct
*	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
char	O
*	O
path	*(char)
=	O
NULL	O
;	O
char	O
*	O
start_state_arg	*(char)
=	O
NULL	O
;	O
char	O
*	O
start_state	*(char)
;	O
unsigned	O
int	O
verbose	int
=	O
0	int
;	O
WarningLevel	enum(int,int)
warning_level	enum(int,int)
=	O
WARN_LIGHT	int
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"define"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"file"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"output"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"path"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"state"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"verbose"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
"warning"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'W'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
char	O
version	array(char)
[	O
256	int
]	O
;	O
static	O
void	O
usage	()->(void)
___P	O
(	O
(	O
void	O
)	O
)	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
argc	int
,	O
argv	*(*(char))
)	O
int	O
argc	int
;	O
char	O
*	O
argv	*(*(char))
[	O
]	O
;	O
{	O
int	O
c	int
;	O
VariableDef	struct(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char),*(char))
*	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
program	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
program	*(char)
==	O
NULL	O
)	O
program	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
else	O
program	*(char)
++	O
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
program	*(char)
;	O
sprintf	(*(char),*(char))->(int)
(	O
version	array(char)
,	O
_	O
(	O
"states for %s"	*(char)
)	O
,	O
PACKAGE_STRING	*(char)
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_MESSAGES	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
ns_prims	*(struct)
=	O
strhash_init	()->(*(struct))
(	O
)	O
;	O
ns_vars	*(struct)
=	O
strhash_init	()->(*(struct))
(	O
)	O
;	O
ns_subs	*(struct)
=	O
strhash_init	()->(*(struct))
(	O
)	O
;	O
ns_states	*(struct)
=	O
strhash_init	()->(*(struct))
(	O
)	O
;	O
global_stmts	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
=	O
list	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
start_stmts	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
=	O
list	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
startrules	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
=	O
list	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
namerules	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
=	O
list	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
nvoid	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nVOID	int
)	O
;	O
inbuf	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
INBUFSIZE	O
)	O
;	O
init_primitives	()->(void)
(	O
)	O
;	O
re_set_syntax	(long)->(long)
(	O
RE_SYNTAX_GNU_AWK	O
|	O
RE_INTERVALS	O
)	O
;	O
enter_system_variable	(*(char),*(char))->(void)
(	O
"program"	*(char)
,	O
program	*(char)
)	O
;	O
enter_system_variable	(*(char),*(char))->(void)
(	O
"version"	*(char)
,	O
version	array(char)
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
option_index	int
=	O
0	int
;	O
c	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"D:f:ho:p:s:vVW:"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
&	O
option_index	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'D'	O
:	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
(	O
VariableDef	struct(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char),*(char))
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
)	O
;	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
sym	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
sym	*(char)
,	O
optarg	*(char)
)	O
;	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
val	array(int)
=	O
strchr	(*(char),int)->(*(char))
(	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
sym	*(char)
,	O
'='	O
)	O
;	O
if	O
(	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
val	array(int)
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: malformed variable definition \"%s\"\n"	*(char)
)	O
,	O
program	*(char)
,	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
sym	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
*	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
val	array(int)
=	O
'\0'	O
;	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
val	array(int)
++	O
;	O
if	O
(	O
vardefs	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
vardefs_tail	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
else	O
vardefs	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
vardefs_tail	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
break	O
;	O
case	O
'f'	O
:	O
defs_file	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
optarg	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: couldn't create output file \"%s\": %s\n"	*(char)
)	O
,	O
program	*(char)
,	O
optarg	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'p'	O
:	O
path	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
's'	O
:	O
start_state_arg	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
'V'	O
:	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
version	array(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'W'	O
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"light"	*(char)
)	O
==	O
0	int
)	O
warning_level	enum(int,int)
=	O
WARN_LIGHT	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"all"	*(char)
)	O
==	O
0	int
)	O
warning_level	enum(int,int)
=	O
WARN_ALL	int
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: unknown warning level `%s'\n"	*(char)
)	O
,	O
program	*(char)
,	O
optarg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'?'	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	*(char)
)	O
,	O
program	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"Hey! main() didn't handle option \"%c\" (%d)"	*(char)
,	O
c	int
,	O
c	int
)	O
;	O
if	O
(	O
optarg	*(char)
)	O
printf	(*(char))->(int)
(	O
" with arg %s"	*(char)
,	O
optarg	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
}	O
{	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
v	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
,	O
*	O
n	long
;	O
int	O
i	int
;	O
v	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nARRAY	int
)	O
;	O
v	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
allocated	long
=	O
argc	int
-	O
optind	int
+	O
1	int
;	O
v	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
=	O
argc	int
-	O
optind	int
;	O
v	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
=	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
v	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
allocated	long
,	O
sizeof	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
optind	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
data	*(void)
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nSTRING	int
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
data	*(void)
=	O
STDIN_NAME	*(char)
;	O
else	O
data	*(void)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
strlen	(*(char))->(long)
(	O
data	*(void)
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
xstrdup	(*(char))->(*(char))
(	O
data	*(void)
)	O
;	O
v	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
[	O
i	int
-	O
optind	int
]	O
=	O
n	long
;	O
}	O
if	O
(	O
!	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
ns_vars	*(struct)
,	O
"argv"	*(char)
,	O
4	int
,	O
v	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
,	O
(	O
void	O
*	O
*	O
)	O
&	O
n	long
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: out of memory\n"	*(char)
)	O
,	O
program	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
n	long
)	O
;	O
}	O
if	O
(	O
path	*(char)
==	O
NULL	O
)	O
{	O
char	O
*	O
cp	*(char)
;	O
cp	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
defs_file	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
cp	*(char)
)	O
{	O
path	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
cp	*(char)
-	O
defs_file	*(char)
+	O
3	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
path	*(char)
,	O
".%c%.*s"	*(char)
,	O
PATH_SEPARATOR	char
,	O
cp	*(char)
-	O
defs_file	*(char)
,	O
defs_file	*(char)
)	O
;	O
}	O
else	O
path	*(char)
=	O
"."	*(char)
;	O
}	O
load_states_file	(*(char))->(void)
(	O
defs_file	*(char)
)	O
;	O
for	O
(	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
vardefs	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
{	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
val	array(int)
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
old_val	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
val	array(int)
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nSTRING	int
)	O
;	O
val	array(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
strlen	(*(char))->(long)
(	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
val	array(int)
)	O
;	O
val	array(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
xstrdup	(*(char))->(*(char))
(	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
val	array(int)
)	O
;	O
if	O
(	O
!	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
ns_vars	*(struct)
,	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
sym	*(char)
,	O
strlen	(*(char))->(long)
(	O
vardef	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
sym	*(char)
)	O
,	O
val	array(int)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
old_val	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: out of memory\n"	*(char)
)	O
,	O
program	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
old_val	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
}	O
if	O
(	O
optind	int
==	O
argc	int
)	O
{	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
process_file	(*(char))->(void)
(	O
STDIN_NAME	*(char)
)	O
;	O
}	O
else	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
{	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
process_file	(*(char))->(void)
(	O
STDIN_NAME	*(char)
)	O
;	O
}	O
else	O
{	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: couldn't open input file `%s': %s\n"	*(char)
)	O
,	O
program	*(char)
,	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
process_file	(*(char))->(void)
(	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
if	O
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
usage	()->(void)
(	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION]... [FILE]...\nMandatory arguments to long options are mandatory for short options too.\n"	*(char)
)	O
,	O
program	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -D, --define=VAR=VAL       define variable VAR to have value VAL\n  -f, --file=NAME            read state definitions from file NAME\n  -h, --help                 print this help and exit\n  -o, --output=NAME          save output to file NAME\n  -p, --path=PATH            set the load path to PATH\n  -s, --state=NAME           start from state NAME\n  -v, --verbose              increase the program verbosity\n  -V, --version              print version number\n  -W, --warning=LEVEL        set the warning level to LEVEL\n"	*(char)
)	O
)	O
;	O
}	O
