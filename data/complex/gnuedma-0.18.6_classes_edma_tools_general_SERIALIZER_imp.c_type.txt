typedef	O
struct	O
{	O
EDMAT_BUFFER	struct(long,long,*(void))
buffer	struct(long,long,*(void))
;	O
}	O
DtSERIALIZER	struct(struct(long,long,*(void)))
;	O
typedef	O
struct	O
{	O
ESint32	int
type	long
;	O
ESint32	int
size	int
;	O
unsigned	O
char	O
data	array(char)
[	O
1	int
]	O
;	O
}	O
PROP_RECORD	struct(int,int,array(char))
;	O
typedef	O
struct	O
{	O
EChar	char
class_name	array(char)
[	O
EDMA_CLASS_NAME_LEN	int
]	O
;	O
PROP_RECORD	struct(int,int,array(char))
data	array(char)
[	O
1	int
]	O
;	O
}	O
OBJECT_RECORD	struct(array(char),array(struct(int,int,array(char))))
;	O
ESint32	int
EDMAPROC	O
SERIALIZERmarshallOrS32	(int,int)->(int)
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
)	O
{	O
DtSERIALIZER	struct(struct(long,long,*(void)))
*	O
m	*(struct(struct(long,long,*(void))))
;	O
CLASSID	int
cid	int
;	O
ESint32	int
n_prop	int
;	O
unsigned	O
char	O
*	O
data	array(char)
;	O
EUint32	long
type	long
,	O
size	int
,	O
new_size	long
,	O
old_size	long
,	O
i	int
;	O
EChar	char
prop_name	array(char)
[	O
EDMA_PROP_NAME_LEN	O
]	O
;	O
EDMAT_BUFFER	struct(long,long,*(void))
aux	struct(long,long,*(void))
;	O
unsigned	O
char	O
base_type	array(char)
[	O
8	int
]	O
;	O
PROP_RECORD	struct(int,int,array(char))
*	O
item	*(struct(int,int,array(char)))
;	O
m	*(struct(struct(long,long,*(void))))
=	O
(	O
DtSERIALIZER	struct(struct(long,long,*(void)))
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
(	O
cid	int
=	O
edma_get_obj_class_id	(int)->(int)
(	O
id	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"** ERROR ** Can't get class id for object %d"	*(char)
,	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
n_prop	int
=	O
edma_get_prop_num	(int)->(int)
(	O
cid	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"** ERROR ** Can't get number of properties "	*(char)
"for class id %ld"	*(char)
,	O
cid	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
,	O
sizeof	O
(	O
OBJECT_RECORD	struct(array(char),array(struct(int,int,array(char))))
)	O
)	O
;	O
edma_get_class_name	(int,*(char))->(int)
(	O
cid	int
,	O
(	O
(	O
OBJECT_RECORD	struct(array(char),array(struct(int,int,array(char))))
*	O
)	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
.	O
dat	*(void)
)	O
->	O
class_name	array(char)
)	O
;	O
new_size	long
=	O
0	int
;	O
old_size	long
=	O
EDMA_CLASS_NAME_LEN	int
;	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
.	O
dat	*(void)
=	O
NULL	O
;	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
.	O
Size	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
edma_get_prop_name	(int,long,*(char))->(int)
(	O
cid	int
,	O
i	int
,	O
prop_name	array(char)
)	O
;	O
type	long
=	O
edma_get_prop_type_id	(int,long)->(int)
(	O
cid	int
,	O
i	int
)	O
;	O
size	int
=	O
edma_get_type_size	(long)->(int)
(	O
type	long
)	O
;	O
switch	O
(	O
type	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
edma_rprop3	(int,*(char))->(int)
(	O
id	int
,	O
prop_name	array(char)
,	O
&	O
aux	struct(long,long,*(void))
)	O
;	O
size	int
=	O
aux	struct(long,long,*(void))
.	O
Size	long
;	O
break	O
;	O
}	O
new_size	long
=	O
old_size	long
+	O
sizeof	O
(	O
PROP_RECORD	struct(int,int,array(char))
)	O
+	O
size	int
;	O
edma_buffer_realloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
,	O
new_size	long
)	O
;	O
item	*(struct(int,int,array(char)))
=	O
(	O
PROP_RECORD	struct(int,int,array(char))
*	O
)	O
(	O
(	O
EPByte	*(char)
)	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
.	O
dat	*(void)
+	O
old_size	long
)	O
;	O
item	*(struct(int,int,array(char)))
->	O
type	long
=	O
type	long
;	O
item	*(struct(int,int,array(char)))
->	O
size	int
=	O
size	int
;	O
switch	O
(	O
type	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
data	array(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
aux	struct(long,long,*(void))
.	O
dat	*(void)
;	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
item	*(struct(int,int,array(char)))
->	O
data	array(char)
,	O
data	array(char)
,	O
size	int
)	O
;	O
break	O
;	O
default	O
:	O
edma_rprop3	(int,*(char))->(int)
(	O
id	int
,	O
prop_name	array(char)
,	O
&	O
base_type	array(char)
)	O
;	O
data	array(char)
=	O
base_type	array(char)
;	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
item	*(struct(int,int,array(char)))
->	O
data	array(char)
,	O
data	array(char)
,	O
size	int
)	O
;	O
break	O
;	O
}	O
old_size	long
=	O
new_size	long
;	O
}	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"%s"	*(char)
,	O
"-------------------------------------------"	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Class name : %s"	*(char)
,	O
(	O
EPChar	*(char)
)	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
.	O
dat	*(void)
)	O
;	O
item	*(struct(int,int,array(char)))
=	O
(	O
PROP_RECORD	struct(int,int,array(char))
*	O
)	O
(	O
(	O
OBJECT_RECORD	struct(array(char),array(struct(int,int,array(char))))
*	O
)	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
.	O
dat	*(void)
)	O
->	O
data	array(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Type = %ld Size = %ld"	*(char)
,	O
item	*(struct(int,int,array(char)))
->	O
type	long
,	O
item	*(struct(int,int,array(char)))
->	O
size	int
)	O
;	O
item	*(struct(int,int,array(char)))
=	O
(	O
PROP_RECORD	struct(int,int,array(char))
*	O
)	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
item	*(struct(int,int,array(char)))
+	O
item	*(struct(int,int,array(char)))
->	O
size	int
+	O
sizeof	O
(	O
PROP_RECORD	struct(int,int,array(char))
)	O
)	O
;	O
}	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Marshall done!!! <------------------------->"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
SERIALIZERunmarshallsOrS32	(int,*(int))->(int)
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
*	O
id	int
)	O
{	O
DtSERIALIZER	struct(struct(long,long,*(void)))
*	O
m	*(struct(struct(long,long,*(void))))
;	O
PROP_RECORD	struct(int,int,array(char))
*	O
item	*(struct(int,int,array(char)))
;	O
ESint32	int
i	int
,	O
n_prop	int
;	O
EDMAT_BUFFER	struct(long,long,*(void))
*	O
aux	struct(long,long,*(void))
;	O
CLASSID	int
cid	int
;	O
m	*(struct(struct(long,long,*(void))))
=	O
(	O
DtSERIALIZER	struct(struct(long,long,*(void)))
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Class name : %s"	*(char)
,	O
(	O
EPChar	*(char)
)	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
.	O
dat	*(void)
)	O
;	O
if	O
(	O
(	O
cid	int
=	O
edma_get_class_id	(*(char))->(int)
(	O
(	O
EPChar	*(char)
)	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
.	O
dat	*(void)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Wrong class name. Data inconsistent"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
n_prop	int
=	O
edma_get_prop_num	(int)->(int)
(	O
cid	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"** ERROR ** Can't get number of properties "	*(char)
"for class id %ld"	*(char)
,	O
cid	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
item	*(struct(int,int,array(char)))
=	O
(	O
PROP_RECORD	struct(int,int,array(char))
*	O
)	O
(	O
(	O
OBJECT_RECORD	struct(array(char),array(struct(int,int,array(char))))
*	O
)	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
.	O
dat	*(void)
)	O
->	O
data	array(char)
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Pointer : %p [%d] properties to read"	*(char)
,	O
item	*(struct(int,int,array(char)))
,	O
n_prop	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Type = %ld Size = %ld"	*(char)
,	O
item	*(struct(int,int,array(char)))
->	O
type	long
,	O
item	*(struct(int,int,array(char)))
->	O
size	int
)	O
;	O
switch	O
(	O
item	*(struct(int,int,array(char)))
->	O
type	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
aux	struct(long,long,*(void))
=	O
(	O
EDMAT_BUFFER	struct(long,long,*(void))
*	O
)	O
malloc	(int)->(*(void))
(	O
sizeof	O
(	O
EDMAT_BUFFER	struct(long,long,*(void))
)	O
)	O
;	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
aux	struct(long,long,*(void))
,	O
item	*(struct(int,int,array(char)))
->	O
size	int
)	O
;	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
aux	struct(long,long,*(void))
->	O
dat	*(void)
,	O
item	*(struct(int,int,array(char)))
->	O
data	array(char)
,	O
item	*(struct(int,int,array(char)))
->	O
size	int
)	O
;	O
_edma_wprop1_pargs	(int,long,*(void))->(*(void))
(	O
*	O
id	int
,	O
i	int
,	O
aux	struct(long,long,*(void))
)	O
;	O
break	O
;	O
default	O
:	O
_edma_wprop1_pargs	(int,long,*(void))->(*(void))
(	O
*	O
id	int
,	O
i	int
,	O
item	*(struct(int,int,array(char)))
->	O
data	array(char)
)	O
;	O
}	O
item	*(struct(int,int,array(char)))
=	O
(	O
PROP_RECORD	struct(int,int,array(char))
*	O
)	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
item	*(struct(int,int,array(char)))
+	O
item	*(struct(int,int,array(char)))
->	O
size	int
+	O
sizeof	O
(	O
PROP_RECORD	struct(int,int,array(char))
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
SERIALIZERsaveZrS32	(int,*(char))->(int)
(	O
OBJID	int
IdObj	int
,	O
EPChar	*(char)
fname	*(char)
)	O
{	O
DtSERIALIZER	struct(struct(long,long,*(void)))
*	O
m	*(struct(struct(long,long,*(void))))
;	O
OBJID	int
id	int
;	O
ESint32	int
len	int
;	O
m	*(struct(struct(long,long,*(void))))
=	O
(	O
DtSERIALIZER	struct(struct(long,long,*(void)))
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
(	O
id	int
=	O
edma_new_obj	(*(char))->(int)
(	O
"NFILE"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[ERROR] Can't create 'NFILE' object"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"open"	*(char)
,	O
fname	*(char)
,	O
"wb"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Can't open %s file to save data"	*(char)
,	O
fname	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	int
=	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
.	O
Size	long
;	O
if	O
(	O
(	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"write"	*(char)
,	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
,	O
&	O
len	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Can't write data to file"	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"close"	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
SERIALIZERloadZrS32	(int,*(char))->(int)
(	O
OBJID	int
IdObj	int
,	O
EPChar	*(char)
fname	*(char)
)	O
{	O
DtSERIALIZER	struct(struct(long,long,*(void)))
*	O
m	*(struct(struct(long,long,*(void))))
;	O
OBJID	int
id	int
;	O
ESint32	int
len	int
;	O
m	*(struct(struct(long,long,*(void))))
=	O
(	O
DtSERIALIZER	struct(struct(long,long,*(void)))
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
(	O
id	int
=	O
edma_new_obj	(*(char))->(int)
(	O
"NFILE"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[ERROR] Can't create 'NFILE' object"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"open"	*(char)
,	O
fname	*(char)
,	O
"rb"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Can't open %s file to read data"	*(char)
,	O
fname	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	int
=	O
(	O
ESint32	int
)	O
edma_smet3	(*(char),*(char))->(*(void))
(	O
"FILESYSTEM"	*(char)
,	O
"GetFileSize"	*(char)
,	O
fname	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[INFO] About to read %ld bytes from file %s"	*(char)
,	O
len	int
,	O
fname	*(char)
)	O
;	O
if	O
(	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
.	O
dat	*(void)
)	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
)	O
;	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
,	O
len	int
)	O
;	O
if	O
(	O
(	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"read"	*(char)
,	O
&	O
m	*(struct(struct(long,long,*(void))))
->	O
buffer	struct(long,long,*(void))
,	O
&	O
len	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Can't write data to file"	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"close"	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
0	int
;	O
}	O
