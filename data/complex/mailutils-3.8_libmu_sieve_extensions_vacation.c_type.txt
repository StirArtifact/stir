static	O
int	O
build_mime	(*(struct),*(*(struct)),*(struct),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_mime_t	*(struct)
*	O
pmime	*(*(struct))
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
mu_mime_t	*(struct)
mime	*(struct)
=	O
NULL	O
;	O
mu_message_t	*(struct)
newmsg	*(*(struct))
;	O
mu_stream_t	*(struct)
stream	*(struct)
,	O
input	*(char)
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
mu_body_t	*(struct)
body	*(struct)
;	O
const	O
char	O
*	O
header	*(struct)
=	O
"Content-Type: text/plain;charset="	*(char)
MU_SIEVE_CHARSET	*(char)
"\n"	*(char)
"Content-Transfer-Encoding: 8bit\n\n"	*(char)
;	O
int	O
rc	int
;	O
mu_mime_create	(*(*(struct)),*(struct),int)->(int)
(	O
&	O
mime	*(struct)
,	O
NULL	O
,	O
0	int
)	O
;	O
mu_message_create	(*(*(struct)),*(void))->(int)
(	O
&	O
newmsg	*(*(struct))
,	O
NULL	O
)	O
;	O
mu_message_get_body	(*(struct),*(*(struct)))->(int)
(	O
newmsg	*(*(struct))
,	O
&	O
body	*(struct)
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_static_memory_stream_create	(*(*(struct)),*(void),long)->(int)
(	O
&	O
input	*(char)
,	O
text	*(char)
,	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
)	O
)	O
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot create temporary stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_mime_destroy	(*(*(struct)))->(void)
(	O
&	O
mime	*(struct)
)	O
;	O
mu_message_destroy	(*(*(struct)),*(void))->(void)
(	O
&	O
newmsg	*(*(struct))
,	O
NULL	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"mime"	*(char)
,	O
SVT_VOID	int
,	O
NULL	O
)	O
)	O
{	O
mu_stream_t	*(struct)
fstr	*(struct)
;	O
rc	int
=	O
mu_filter_create	(*(*(struct)),*(struct),*(char),int,int)->(int)
(	O
&	O
fstr	*(struct)
,	O
input	*(char)
,	O
"base64"	*(char)
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
input	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
header	*(struct)
=	O
"Content-Type: text/plain;charset="	*(char)
MU_SIEVE_CHARSET	*(char)
"\n"	*(char)
"Content-Transfer-Encoding: base64\n\n"	*(char)
;	O
input	*(char)
=	O
fstr	*(struct)
;	O
}	O
}	O
rc	int
=	O
mu_body_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
body	*(struct)
,	O
&	O
stream	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot get input body stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_mime_destroy	(*(*(struct)))->(void)
(	O
&	O
mime	*(struct)
)	O
;	O
mu_message_destroy	(*(*(struct)),*(void))->(void)
(	O
&	O
newmsg	*(*(struct))
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
input	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
stream	*(struct)
,	O
input	*(char)
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
input	*(char)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
stream	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"stream copy failed: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_mime_destroy	(*(*(struct)))->(void)
(	O
&	O
mime	*(struct)
)	O
;	O
mu_message_destroy	(*(*(struct)),*(void))->(void)
(	O
&	O
newmsg	*(*(struct))
,	O
NULL	O
)	O
;	O
return	O
1	int
;	O
}	O
mu_header_create	(*(*(struct)),*(char),long)->(int)
(	O
&	O
hdr	*(struct)
,	O
header	*(struct)
,	O
strlen	(*(char))->(long)
(	O
header	*(struct)
)	O
)	O
;	O
mu_message_set_header	(*(struct),*(struct),*(void))->(int)
(	O
newmsg	*(*(struct))
,	O
hdr	*(struct)
,	O
NULL	O
)	O
;	O
mu_mime_add_part	(*(struct),*(struct))->(int)
(	O
mime	*(struct)
,	O
newmsg	*(*(struct))
)	O
;	O
mu_message_unref	(*(struct))->(void)
(	O
newmsg	*(*(struct))
)	O
;	O
*	O
pmime	*(*(struct))
=	O
mime	*(struct)
;	O
return	O
0	int
;	O
}	O
static	O
int	O
diag	(*(struct))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_sieve_log_action	(*(struct),*(char),*(char))->(void)
(	O
mach	*(struct)
,	O
"VACATION"	*(char)
,	O
NULL	O
)	O
;	O
return	O
mu_sieve_is_dry_run	(*(struct))->(int)
(	O
mach	*(struct)
)	O
;	O
}	O
struct	O
addr_data	struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(char))
{	O
mu_address_t	*(struct)
addr	int
;	O
char	O
*	O
my_address	*(char)
;	O
}	O
;	O
static	O
int	O
_compare	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
addr_data	struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(char))
*	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
=	O
data	*(void)
;	O
int	O
rc	int
=	O
mu_address_contains_email	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),*(char))->(int)
(	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
->	O
addr	int
,	O
item	*(void)
)	O
;	O
if	O
(	O
rc	int
)	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
->	O
my_address	*(char)
=	O
item	*(void)
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
match_addresses	(*(struct),*(struct),*(char),*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))),*(*(char)))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_header_t	*(struct)
hdr	*(struct)
,	O
char	O
*	O
email	*(char)
,	O
mu_sieve_value_t	struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long)))
*	O
addresses	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
,	O
char	O
const	O
*	O
*	O
my_address	*(char)
)	O
{	O
int	O
match	int
=	O
0	int
;	O
const	O
char	O
*	O
str	*(char)
;	O
struct	O
addr_data	struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))),*(char))
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
;	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
.	O
my_address	*(char)
=	O
NULL	O
;	O
if	O
(	O
mu_header_sget_value	O
(	O
hdr	*(struct)
,	O
MU_HEADER_TO	*(char)
,	O
&	O
str	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
.	O
addr	int
,	O
str	*(char)
)	O
)	O
{	O
if	O
(	O
_compare	(*(void),*(void))->(int)
(	O
email	*(char)
,	O
&	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
)	O
)	O
match	int
=	O
1	int
;	O
else	O
if	O
(	O
addresses	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
)	O
match	int
+=	O
mu_sieve_vlist_do	(*(struct),*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))),*((*(void),*(void))->(int)),*(void))->(int)
(	O
mach	*(struct)
,	O
addresses	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
,	O
_compare	(*(void),*(void))->(int)
,	O
&	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
)	O
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
.	O
addr	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
match	int
&&	O
mu_header_sget_value	O
(	O
hdr	*(struct)
,	O
MU_HEADER_CC	*(char)
,	O
&	O
str	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
.	O
addr	int
,	O
str	*(char)
)	O
)	O
{	O
if	O
(	O
_compare	(*(void),*(void))->(int)
(	O
email	*(char)
,	O
&	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
)	O
)	O
match	int
=	O
1	int
;	O
else	O
if	O
(	O
addresses	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
)	O
match	int
+=	O
mu_sieve_vlist_do	(*(struct),*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))),*((*(void),*(void))->(int)),*(void))->(int)
(	O
mach	*(struct)
,	O
addresses	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
,	O
_compare	(*(void),*(void))->(int)
,	O
&	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
)	O
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
.	O
addr	int
)	O
;	O
}	O
}	O
*	O
my_address	*(char)
=	O
ad	*(struct(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))),*(char)))
.	O
my_address	*(char)
;	O
return	O
match	int
;	O
}	O
struct	O
regex_data	struct(*(struct),*(char))
{	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
;	O
char	O
*	O
email	*(char)
;	O
}	O
;	O
static	O
int	O
regex_comparator	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
preg	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
int	O
rc	int
;	O
struct	O
regex_data	struct(*(struct),*(char))
*	O
d	*(struct(*(struct),*(char)))
=	O
data	*(void)
;	O
if	O
(	O
regcomp	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int)->(int)
(	O
&	O
preg	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
item	*(void)
,	O
REG_EXTENDED	int
|	O
REG_NOSUB	O
|	O
REG_NEWLINE	O
|	O
REG_ICASE	O
)	O
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
d	*(struct(*(struct),*(char)))
->	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot compile regular expression \"%s\""	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
d	*(struct(*(struct),*(char)))
->	O
mach	*(struct)
)	O
,	O
(	O
char	O
*	O
)	O
item	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
regexec	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),long,array(struct(int,int)),int)->(int)
(	O
&	O
preg	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
d	*(struct(*(struct),*(char)))
->	O
email	*(char)
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
==	O
0	int
;	O
regfree	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(void)
(	O
&	O
preg	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
noreply_address_p	(*(struct),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
char	O
*	O
email	*(char)
)	O
{	O
int	O
i	long
,	O
rc	int
=	O
0	int
;	O
mu_sieve_value_t	struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long)))
*	O
arg	*(char)
;	O
struct	O
regex_data	struct(*(struct),*(char))
rd	struct(*(struct),*(char))
;	O
static	O
char	O
*	O
noreply_sender	array(*(char))
[	O
]	O
=	O
{	O
".*-REQUEST@.*"	*(char)
,	O
".*-RELAY@.*"	*(char)
,	O
".*-OWNER@.*"	*(char)
,	O
"^OWNER-.*"	*(char)
,	O
"^postmaster@.*"	*(char)
,	O
"^UUCP@.*"	*(char)
,	O
"^MAILER@.*"	*(char)
,	O
"^MAILER-DAEMON@.*"	*(char)
,	O
NULL	O
}	O
;	O
rd	struct(*(struct),*(char))
.	O
mach	*(struct)
=	O
mach	*(struct)
;	O
rd	struct(*(struct),*(char))
.	O
email	*(char)
=	O
email	*(char)
;	O
for	O
(	O
i	long
=	O
0	int
;	O
rc	int
==	O
0	int
&&	O
noreply_sender	array(*(char))
[	O
i	long
]	O
;	O
i	long
++	O
)	O
rc	int
=	O
regex_comparator	(*(void),*(void))->(int)
(	O
noreply_sender	array(*(char))
[	O
i	long
]	O
,	O
&	O
rd	struct(*(struct),*(char))
)	O
;	O
if	O
(	O
!	O
rc	int
&&	O
(	O
arg	*(char)
=	O
mu_sieve_get_tag_untyped	(*(struct),*(char))->(*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))))
(	O
mach	*(struct)
,	O
"noreply"	*(char)
)	O
)	O
!=	O
NULL	O
)	O
rc	int
=	O
mu_sieve_vlist_do	(*(struct),*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))),*((*(void),*(void))->(int)),*(void))->(int)
(	O
mach	*(struct)
,	O
arg	*(char)
,	O
regex_comparator	(*(void),*(void))->(int)
,	O
&	O
rd	struct(*(struct),*(char))
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
bulk_precedence_p	(*(struct))->(int)
(	O
mu_header_t	*(struct)
hdr	*(struct)
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
const	O
char	O
*	O
str	*(char)
;	O
if	O
(	O
mu_header_sget_value	O
(	O
hdr	*(struct)
,	O
MU_HEADER_PRECEDENCE	*(char)
,	O
&	O
str	*(char)
)	O
==	O
0	int
)	O
{	O
rc	int
=	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"bulk"	*(char)
)	O
==	O
0	int
||	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"junk"	*(char)
)	O
==	O
0	int
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
test_and_update_prop	(*(struct),*(char),long,int,*(struct))->(int)
(	O
mu_property_t	*(struct)
prop	*(struct)
,	O
const	O
char	O
*	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
time_t	long
now	*(long)
,	O
unsigned	O
int	O
days	int
,	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
const	O
char	O
*	O
result	*(struct)
;	O
char	O
*	O
timebuf	*(char)
;	O
time_t	long
last	*(char)
;	O
int	O
rc	int
=	O
mu_property_sget_value	(*(struct),*(char),*(*(char)))->(int)
(	O
prop	*(struct)
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
&	O
result	*(struct)
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
MU_ERR_NOENT	O
:	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
days	int
==	O
0	int
)	O
return	O
1	int
;	O
last	*(char)
=	O
(	O
time_t	long
)	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
result	*(struct)
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
last	*(char)
+	O
(	O
24	int
*	O
60	int
*	O
60	int
*	O
days	int
)	O
>	O
now	*(long)
)	O
return	O
1	int
;	O
break	O
;	O
default	O
:	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"%lu: mu_property_sget_value: %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
timebuf	*(char)
,	O
"%lu"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
now	*(long)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"%lu: mu_asprintf: %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
mu_property_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
prop	*(struct)
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
timebuf	*(char)
,	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
timebuf	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"%lu: mu_property_set_value: %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
mu_property_save	(*(struct))->(int)
(	O
prop	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"%lu: mu_property_save: %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
check_db	(*(struct),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
char	O
*	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
{	O
mu_property_t	*(struct)
prop	*(struct)
;	O
char	O
*	O
file	*(char)
;	O
unsigned	O
int	O
days	int
;	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
str	*(char)
;	O
mu_locker_t	*(struct)
locker	*(struct)
;	O
const	O
char	O
*	O
dbfile	*(char)
=	O
"~/.vacation"	*(char)
;	O
size_t	long
n	*(long)
;	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"days"	*(char)
,	O
SVT_NUMBER	int
,	O
&	O
n	*(long)
)	O
)	O
{	O
days	int
=	O
n	*(long)
;	O
if	O
(	O
days	int
>	O
DAYS_MAX	int
)	O
days	int
=	O
DAYS_MAX	int
;	O
}	O
else	O
days	int
=	O
DAYS_DEFAULT	int
;	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"database"	*(char)
,	O
SVT_STRING	int
,	O
&	O
dbfile	*(char)
)	O
;	O
file	*(char)
=	O
mu_tilde_expansion	(*(char),int,*(char))->(*(char))
(	O
dbfile	*(char)
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
file	*(char)
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot build db file name"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
rc	int
=	O
mu_locker_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
locker	*(struct)
,	O
file	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot lock %s: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
file	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
str	*(char)
,	O
file	*(char)
,	O
MU_STREAM_RDWR	O
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"%lu: mu_file_stream_create(%s): %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
file	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_locker_destroy	(*(*(struct)))->(void)
(	O
&	O
locker	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
rc	int
=	O
mu_property_create_init	(*(*(struct)),*((*(struct))->(int)),*(void))->(int)
(	O
&	O
prop	*(struct)
,	O
mu_assoc_property_init	(*(struct))->(int)
,	O
str	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"%lu: mu_property_create_init: %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_locker_destroy	(*(*(struct)))->(void)
(	O
&	O
locker	*(struct)
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
rc	int
=	O
mu_locker_lock	(*(struct))->(int)
(	O
locker	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"%lu: cannot lock vacation database: %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_property_destroy	(*(*(struct)))->(void)
(	O
&	O
prop	*(struct)
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
rc	int
=	O
test_and_update_prop	(*(struct),*(char),long,int,*(struct))->(int)
(	O
prop	*(struct)
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
time	struct(long,long)
(	O
NULL	O
)	O
,	O
days	int
,	O
mach	*(struct)
)	O
;	O
mu_property_destroy	(*(*(struct)))->(void)
(	O
&	O
prop	*(struct)
)	O
;	O
mu_locker_unlock	(*(struct))->(int)
(	O
locker	*(struct)
)	O
;	O
mu_locker_destroy	(*(*(struct)))->(void)
(	O
&	O
locker	*(struct)
)	O
;	O
if	O
(	O
rc	int
==	O
-	O
1	int
)	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
void	O
re_subject	(*(struct),*(*(char)))->(void)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
char	O
*	O
*	O
psubject	*(*(char))
)	O
{	O
char	O
*	O
subject	*(char)
;	O
char	O
*	O
prefix	array(*(char))
=	O
"Re"	*(char)
;	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"reply_prefix"	*(char)
,	O
SVT_STRING	int
,	O
&	O
prefix	array(*(char))
)	O
;	O
subject	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
*	O
psubject	*(*(char))
)	O
+	O
strlen	(*(char))->(long)
(	O
prefix	array(*(char))
)	O
+	O
3	int
)	O
;	O
if	O
(	O
!	O
subject	*(char)
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: not enough memory"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
)	O
;	O
return	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
subject	*(char)
,	O
prefix	array(*(char))
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
subject	*(char)
,	O
": "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
subject	*(char)
,	O
*	O
psubject	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
*	O
psubject	*(*(char))
)	O
;	O
*	O
psubject	*(*(char))
=	O
subject	*(char)
;	O
}	O
static	O
void	O
vacation_subject	(*(struct),*(struct),*(struct))->(void)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
mu_header_t	*(struct)
newhdr	*(struct)
)	O
{	O
char	O
*	O
value	*(void)
;	O
char	O
*	O
subject	*(char)
;	O
int	O
subject_allocated	int
=	O
0	int
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"subject"	*(char)
,	O
SVT_STRING	int
,	O
&	O
subject	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
==	O
0	int
&&	O
mu_header_aget_value_unfold	O
(	O
hdr	*(struct)
,	O
MU_HEADER_SUBJECT	*(char)
,	O
&	O
value	*(void)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
int	O
rc	int
=	O
mu_rfc2047_decode	(*(char),*(char),*(*(char)))->(int)
(	O
MU_SIEVE_CHARSET	*(char)
,	O
value	*(void)
,	O
&	O
p	*(char)
)	O
;	O
subject_allocated	int
=	O
1	int
;	O
if	O
(	O
rc	int
)	O
{	O
subject	*(char)
=	O
value	*(void)
;	O
value	*(void)
=	O
NULL	O
;	O
}	O
else	O
{	O
subject	*(char)
=	O
p	*(char)
;	O
}	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"reply_regex"	*(char)
,	O
SVT_STRING	int
,	O
&	O
p	*(char)
)	O
)	O
{	O
char	O
*	O
err	long
=	O
NULL	O
;	O
rc	int
=	O
mu_unre_set_regex	(*(char),int,*(*(char)))->(int)
(	O
p	*(char)
,	O
0	int
,	O
&	O
err	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot compile reply prefix regexp: %s: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
,	O
mu_prstr	(*(char))->(*(char))
(	O
err	long
)	O
)	O
;	O
}	O
}	O
if	O
(	O
mu_unre_subject	(*(char),*(*(char)))->(int)
(	O
subject	*(char)
,	O
NULL	O
)	O
)	O
re_subject	(*(struct),*(*(char)))->(void)
(	O
mach	*(struct)
,	O
&	O
subject	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
value	*(void)
)	O
;	O
}	O
else	O
subject	*(char)
=	O
"Re: Your mail"	*(char)
;	O
if	O
(	O
mu_rfc2047_encode	(*(char),*(char),*(char),*(*(char)))->(int)
(	O
MU_SIEVE_CHARSET	*(char)
,	O
"quoted-printable"	*(char)
,	O
subject	*(char)
,	O
&	O
value	*(void)
)	O
)	O
mu_header_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
newhdr	*(struct)
,	O
MU_HEADER_SUBJECT	*(char)
,	O
subject	*(char)
,	O
1	int
)	O
;	O
else	O
{	O
mu_header_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
newhdr	*(struct)
,	O
MU_HEADER_SUBJECT	*(char)
,	O
value	*(void)
,	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
value	*(void)
)	O
;	O
}	O
if	O
(	O
subject_allocated	int
)	O
free	(*(void))->(void)
(	O
subject	*(char)
)	O
;	O
}	O
static	O
int	O
header_split	(*(char),*(*(char)),*(*(char)))->(int)
(	O
const	O
char	O
*	O
str	*(char)
,	O
char	O
*	O
*	O
hname	*(*(char))
,	O
char	O
*	O
*	O
hval	*(*(char))
)	O
{	O
char	O
*	O
p	*(char)
,	O
*	O
q	*(char)
,	O
*	O
fn	*((*(void))->(void))
,	O
*	O
fv	*(char)
;	O
size_t	long
n	*(long)
;	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
str	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
q	*(char)
)	O
return	O
MU_ERR_FORMAT	O
;	O
for	O
(	O
p	*(char)
=	O
q	*(char)
;	O
p	*(char)
>	O
str	*(char)
&&	O
mu_isspace	O
(	O
p	*(char)
[	O
-	O
1	int
]	O
)	O
;	O
--	O
p	*(char)
)	O
;	O
if	O
(	O
p	*(char)
==	O
str	*(char)
)	O
return	O
MU_ERR_FORMAT	O
;	O
n	*(long)
=	O
p	*(char)
-	O
str	*(char)
;	O
fn	*((*(void))->(void))
=	O
malloc	(long)->(*(void))
(	O
n	*(long)
+	O
1	int
)	O
;	O
if	O
(	O
!	O
fn	*((*(void))->(void))
)	O
return	O
ENOMEM	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
fn	*((*(void))->(void))
,	O
str	*(char)
,	O
n	*(long)
)	O
;	O
fn	*((*(void))->(void))
[	O
n	*(long)
]	O
=	O
0	int
;	O
for	O
(	O
++	O
q	*(char)
;	O
*	O
q	*(char)
&&	O
mu_isspace	O
(	O
*	O
q	*(char)
)	O
;	O
++	O
q	*(char)
)	O
;	O
fv	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
q	*(char)
)	O
;	O
if	O
(	O
!	O
fv	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
fn	*((*(void))->(void))
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
*	O
hname	*(*(char))
=	O
fn	*((*(void))->(void))
;	O
*	O
hval	*(*(char))
=	O
fv	*(char)
;	O
return	O
0	int
;	O
}	O
struct	O
header_closure	struct(*(struct),*(struct))
{	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
}	O
;	O
static	O
int	O
add_header	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
char	O
const	O
*	O
str	*(char)
=	O
item	*(void)
;	O
struct	O
header_closure	struct(*(struct),*(struct))
*	O
hc	*(struct(*(struct),*(struct)))
=	O
data	*(void)
;	O
char	O
*	O
fn	*((*(void))->(void))
,	O
*	O
fv	*(char)
;	O
int	O
rc	int
;	O
rc	int
=	O
header_split	(*(char),*(*(char)),*(*(char)))->(int)
(	O
str	*(char)
,	O
&	O
fn	*((*(void))->(void))
,	O
&	O
fv	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
hc	*(struct(*(struct),*(struct)))
->	O
mach	*(struct)
,	O
_	O
(	O
"%lu: can't add header \"%s\": %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
hc	*(struct(*(struct),*(struct)))
->	O
mach	*(struct)
)	O
,	O
str	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
mu_header_append	(*(struct),*(char),*(char))->(int)
(	O
hc	*(struct(*(struct),*(struct)))
->	O
hdr	*(struct)
,	O
fn	*((*(void))->(void))
,	O
fv	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
fn	*((*(void))->(void))
)	O
;	O
free	(*(void))->(void)
(	O
fv	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
hc	*(struct(*(struct),*(struct)))
->	O
mach	*(struct)
,	O
_	O
(	O
"%lu: can't add header \"%s\": %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
hc	*(struct(*(struct),*(struct)))
->	O
mach	*(struct)
)	O
,	O
str	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
vacation_reply	(*(struct),*(struct),*(char),*(char),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
char	O
const	O
*	O
text	*(char)
,	O
char	O
const	O
*	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
char	O
const	O
*	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
{	O
mu_mime_t	*(struct)
mime	*(struct)
=	O
NULL	O
;	O
mu_message_t	*(struct)
newmsg	*(*(struct))
;	O
mu_header_t	*(struct)
newhdr	*(struct)
;	O
mu_address_t	*(struct)
to_addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
NULL	O
,	O
from_addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
NULL	O
;	O
char	O
*	O
value	*(void)
;	O
mu_mailer_t	*(struct)
mailer	*(struct)
;	O
int	O
rc	int
;	O
mu_sieve_value_t	struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long)))
*	O
val	*(char)
;	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"file"	*(char)
,	O
SVT_VOID	int
,	O
NULL	O
)	O
)	O
{	O
mu_stream_t	*(struct)
instr	*(struct)
;	O
rc	int
=	O
mu_mapfile_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
instr	*(struct)
,	O
text	*(char)
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot open message file %s: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
text	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"rfc2822"	*(char)
,	O
SVT_VOID	int
,	O
NULL	O
)	O
)	O
{	O
rc	int
=	O
mu_stream_to_message	(*(struct),*(*(struct)))->(int)
(	O
instr	*(struct)
,	O
&	O
newmsg	*(*(struct))
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
instr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot read message from file %s: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
text	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
mu_stream_t	*(struct)
text_stream	*(struct)
;	O
mu_transport_t	*(void)
trans	*(char)
[	O
2	int
]	O
;	O
rc	int
=	O
mu_memory_stream_create	(*(*(struct)),int)->(int)
(	O
&	O
text_stream	*(struct)
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_unref	(*(struct))->(void)
(	O
instr	*(struct)
)	O
;	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot create memory stream: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
text_stream	*(struct)
,	O
instr	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
instr	*(struct)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
rc	int
=	O
mu_stream_write	(*(struct),*(void),long,*(long))->(int)
(	O
text_stream	*(struct)
,	O
""	*(char)
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: failed reading from %s: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
text	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
text_stream	*(struct)
,	O
MU_IOCTL_TRANSPORT	int
,	O
MU_IOCTL_OP_GET	int
,	O
trans	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_unref	(*(struct))->(void)
(	O
text_stream	*(struct)
)	O
;	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"%lu: mu_stream_ioctl: %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
build_mime	(*(struct),*(*(struct)),*(struct),*(char))->(int)
(	O
mach	*(struct)
,	O
&	O
mime	*(struct)
,	O
msg	*(struct)
,	O
(	O
char	O
const	O
*	O
)	O
trans	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
mu_stream_unref	(*(struct))->(void)
(	O
text_stream	*(struct)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
mu_mime_get_message	(*(struct),*(*(struct)))->(int)
(	O
mime	*(struct)
,	O
&	O
newmsg	*(*(struct))
)	O
;	O
mu_message_unref	(*(struct))->(void)
(	O
newmsg	*(*(struct))
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
text_stream	*(struct)
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
build_mime	(*(struct),*(*(struct)),*(struct),*(char))->(int)
(	O
mach	*(struct)
,	O
&	O
mime	*(struct)
,	O
msg	*(struct)
,	O
text	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
mu_mime_get_message	(*(struct),*(*(struct)))->(int)
(	O
mime	*(struct)
,	O
&	O
newmsg	*(*(struct))
)	O
;	O
mu_message_unref	(*(struct))->(void)
(	O
newmsg	*(*(struct))
)	O
;	O
}	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
newmsg	*(*(struct))
,	O
&	O
newhdr	*(struct)
)	O
;	O
rc	int
=	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
to_addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot create recipient address <%s>: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
else	O
{	O
mu_header_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
newhdr	*(struct)
,	O
MU_HEADER_TO	*(char)
,	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
1	int
)	O
;	O
val	*(char)
=	O
mu_sieve_get_tag_untyped	(*(struct),*(char))->(*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))))
(	O
mach	*(struct)
,	O
"header"	*(char)
)	O
;	O
if	O
(	O
val	*(char)
)	O
{	O
struct	O
header_closure	struct(*(struct),*(struct))
hc	*(struct(*(struct),*(struct)))
;	O
hc	*(struct(*(struct),*(struct)))
.	O
mach	*(struct)
=	O
mach	*(struct)
;	O
hc	*(struct(*(struct),*(struct)))
.	O
hdr	*(struct)
=	O
newhdr	*(struct)
;	O
mu_sieve_vlist_do	(*(struct),*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))),*((*(void),*(void))->(int)),*(void))->(int)
(	O
mach	*(struct)
,	O
val	*(char)
,	O
add_header	(*(void),*(void))->(int)
,	O
&	O
hc	*(struct(*(struct),*(struct)))
)	O
;	O
}	O
vacation_subject	(*(struct),*(struct),*(struct))->(void)
(	O
mach	*(struct)
,	O
msg	*(struct)
,	O
newhdr	*(struct)
)	O
;	O
if	O
(	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
{	O
if	O
(	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
from_addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
)	O
from_addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
NULL	O
;	O
}	O
else	O
{	O
from_addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
NULL	O
;	O
}	O
if	O
(	O
mu_rfc2822_in_reply_to	(*(struct),*(*(char)))->(int)
(	O
msg	*(struct)
,	O
&	O
value	*(void)
)	O
==	O
0	int
)	O
{	O
mu_header_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
newhdr	*(struct)
,	O
MU_HEADER_IN_REPLY_TO	*(char)
,	O
value	*(void)
,	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
value	*(void)
)	O
;	O
}	O
if	O
(	O
mu_rfc2822_references	(*(struct),*(*(char)))->(int)
(	O
msg	*(struct)
,	O
&	O
value	*(void)
)	O
==	O
0	int
)	O
{	O
mu_header_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
newhdr	*(struct)
,	O
MU_HEADER_REFERENCES	*(char)
,	O
value	*(void)
,	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
value	*(void)
)	O
;	O
}	O
mailer	*(struct)
=	O
mu_sieve_get_mailer	(*(struct))->(*(struct))
(	O
mach	*(struct)
)	O
;	O
if	O
(	O
mailer	*(struct)
)	O
{	O
rc	int
=	O
mu_mailer_send_message	(*(struct),*(struct),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(int)
(	O
mailer	*(struct)
,	O
newmsg	*(*(struct))
,	O
from_addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
to_addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
}	O
else	O
rc	int
=	O
MU_ERR_FAILURE	O
;	O
}	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
to_addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
from_addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
mu_mime_destroy	(*(*(struct)))->(void)
(	O
&	O
mime	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
sieve_action_vacation	(*(struct))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
text	*(char)
,	O
*	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
=	O
NULL	O
;	O
char	O
const	O
*	O
return_address	*(char)
;	O
mu_message_t	*(struct)
msg	*(struct)
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
char	O
*	O
my_address	*(char)
;	O
if	O
(	O
diag	(*(struct))->(int)
(	O
mach	*(struct)
)	O
)	O
return	O
0	int
;	O
mu_sieve_get_arg	(*(struct),long,enum(int,int,int,int,int),*(void))->(void)
(	O
mach	*(struct)
,	O
0	int
,	O
SVT_STRING	int
,	O
&	O
text	*(char)
)	O
;	O
msg	*(struct)
=	O
mu_sieve_get_message	(*(struct))->(*(struct))
(	O
mach	*(struct)
)	O
;	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
;	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"sender"	*(char)
,	O
SVT_STRING	int
,	O
&	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
)	O
{	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
=	O
strdup	(*(char))->(*(char))
(	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
;	O
if	O
(	O
!	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"%lu: %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
ENOMEM	int
)	O
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
rc	int
=	O
mu_sieve_get_message_sender	(*(struct),*(*(char)))->(int)
(	O
msg	*(struct)
,	O
&	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
)	O
!=	O
0	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot get sender address: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
my_address	*(char)
=	O
mu_get_user_email	(*(char))->(*(char))
(	O
NULL	O
)	O
;	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"always_reply"	*(char)
,	O
SVT_VOID	int
,	O
NULL	O
)	O
)	O
return_address	*(char)
=	O
my_address	*(char)
;	O
else	O
{	O
mu_sieve_value_t	struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long)))
*	O
val	*(char)
=	O
mu_sieve_get_tag_untyped	(*(struct),*(char))->(*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))))
(	O
mach	*(struct)
,	O
"aliases"	*(char)
)	O
;	O
if	O
(	O
match_addresses	(*(struct),*(struct),*(char),*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))),*(*(char)))->(int)
(	O
mach	*(struct)
,	O
hdr	*(struct)
,	O
my_address	*(char)
,	O
val	*(char)
,	O
&	O
return_address	*(char)
)	O
==	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
my_address	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
noreply_address_p	(*(struct),*(char))->(int)
(	O
mach	*(struct)
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
||	O
bulk_precedence_p	(*(struct))->(int)
(	O
hdr	*(struct)
)	O
||	O
check_db	(*(struct),*(char))->(int)
(	O
mach	*(struct)
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
)	O
{	O
free	(*(void))->(void)
(	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
;	O
free	(*(void))->(void)
(	O
my_address	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"return_address"	*(char)
,	O
SVT_STRING	int
,	O
&	O
return_address	*(char)
)	O
;	O
rc	int
=	O
vacation_reply	(*(struct),*(struct),*(char),*(char),*(char))->(int)
(	O
mach	*(struct)
,	O
msg	*(struct)
,	O
text	*(char)
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
return_address	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
;	O
free	(*(void))->(void)
(	O
my_address	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
-	O
1	int
)	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
mu_sieve_tag_def_t	struct(*(char),enum(int,int,int,int,int))
vacation_tags	array(struct(*(char),enum(int,int,int,int,int)))
[	O
]	O
=	O
{	O
{	O
"days"	*(char)
,	O
SVT_NUMBER	int
}	O
,	O
{	O
"subject"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"aliases"	*(char)
,	O
SVT_STRING_LIST	int
}	O
,	O
{	O
"noreply"	*(char)
,	O
SVT_STRING_LIST	int
}	O
,	O
{	O
"reply_regex"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"reply_prefix"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"sender"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"database"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"mime"	*(char)
,	O
SVT_VOID	int
}	O
,	O
{	O
"file"	*(char)
,	O
SVT_VOID	int
}	O
,	O
{	O
"always_reply"	*(char)
,	O
SVT_VOID	int
}	O
,	O
{	O
"return_address"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"header"	*(char)
,	O
SVT_STRING_LIST	int
}	O
,	O
{	O
"rfc2822"	*(char)
,	O
SVT_VOID	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
mu_sieve_tag_group_t	struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct))->(int)))
vacation_tag_groups	array(struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct))->(int))))
[	O
]	O
=	O
{	O
{	O
vacation_tags	array(struct(*(char),enum(int,int,int,int,int)))
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
mu_sieve_data_type	enum(int,int,int,int,int)
vacation_args	array(enum(int,int,int,int,int))
[	O
]	O
=	O
{	O
SVT_STRING	int
,	O
SVT_VOID	int
}	O
;	O
int	O
SIEVE_EXPORT	O
(	O
vacation	O
,	O
init	O
)	O
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_sieve_register_action	(*(struct),*(char),*((*(struct))->(int)),*(enum(int,int,int,int,int)),*(struct(*(struct(*`,enum(int,int,int,int,int))),*((*`)->(int)))),int)->(void)
(	O
mach	*(struct)
,	O
"vacation"	*(char)
,	O
sieve_action_vacation	(*(struct))->(int)
,	O
vacation_args	array(enum(int,int,int,int,int))
,	O
vacation_tag_groups	array(struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct))->(int))))
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
