static	O
object	O
setf	()->(int)
(	O
object	O
,	O
object	O
)	O
;	O
object	O
sLsetf	int
;	O
object	O
sLget	int
;	O
object	O
sLgetf	int
;	O
object	O
sLaref	int
;	O
object	O
sLsvref	int
;	O
object	O
sLelt	int
;	O
object	O
sLchar	int
;	O
object	O
sLschar	int
;	O
object	O
sLfill_pointer	int
;	O
object	O
sLgethash	int
;	O
object	O
sLcar	int
;	O
object	O
sLcdr	int
;	O
object	O
sLpush	int
;	O
object	O
sLpop	int
;	O
object	O
sLincf	int
;	O
object	O
sLdecf	int
;	O
object	O
sSstructure_access	int
;	O
object	O
sSsetf_lambda	int
;	O
object	O
sSclear_compiler_properties	int
;	O
object	O
sLwarn	int
;	O
object	O
sSAinhibit_macro_specialA	int
;	O
void	O
setq	(int,int)->(void)
(	O
object	O
sym	int
,	O
object	O
val	int
)	O
{	O
object	O
vd	O
;	O
enum	O
stype	O
type	enum
;	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
type	enum
=	O
(	O
enum	O
stype	O
)	O
sym	int
->	O
s	O
.	O
s_stype	O
;	O
if	O
(	O
type	enum
==	O
stp_special	O
)	O
sym	int
->	O
s	O
.	O
s_dbind	O
=	O
val	int
;	O
else	O
if	O
(	O
type	enum
==	O
stp_constant	O
)	O
FEinvalid_variable	()->(int)
(	O
"Cannot assign to the constant ~S."	*(char)
,	O
sym	int
)	O
;	O
else	O
{	O
vd	O
=	O
lex_var_sch	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
MMnull	()->(int)
(	O
vd	O
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
vd	O
)	O
)	O
)	O
sym	int
->	O
s	O
.	O
s_dbind	O
=	O
val	int
;	O
else	O
MMcadr	()->(int)
(	O
vd	O
)	O
=	O
val	int
;	O
}	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fsetq	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
ans	O
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
if	O
(	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
form	int
)	O
)	O
)	O
FEinvalid_form	()->(int)
(	O
"No value for ~S."	*(char)
,	O
form	int
->	O
c	O
.	O
c_car	O
)	O
;	O
setq	(int,int)->(void)
(	O
MMcar	()->(int)
(	O
form	int
)	O
,	O
ans	O
=	O
Ieval	()->(int)
(	O
MMcadr	()->(int)
(	O
form	int
)	O
)	O
)	O
;	O
form	int
=	O
MMcddr	()->(int)
(	O
form	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	()->(int)
(	O
form	int
)	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
ans	O
;	O
vs_base	O
=	O
top	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
;	O
}	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fpsetq	int
)	O
(	O
object	O
arg	int
)	O
{	O
object	O
*	O
old_top	O
=	O
vs_top	O
;	O
object	O
*	O
top	O
;	O
object	O
argsv	O
=	O
arg	int
;	O
for	O
(	O
top	O
=	O
old_top	O
;	O
!	O
endp	()->(int)
(	O
arg	int
)	O
;	O
arg	int
=	O
MMcddr	()->(int)
(	O
arg	int
)	O
,	O
top	O
++	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
arg	int
)	O
)	O
)	O
FEinvalid_form	()->(int)
(	O
"No value for ~S."	*(char)
,	O
arg	int
->	O
c	O
.	O
c_car	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
Ieval	()->(int)
(	O
MMcadr	()->(int)
(	O
arg	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
;	O
}	O
for	O
(	O
arg	int
=	O
argsv	O
,	O
top	O
=	O
old_top	O
;	O
!	O
endp	()->(int)
(	O
arg	int
)	O
;	O
arg	int
=	O
MMcddr	()->(int)
(	O
arg	int
)	O
,	O
top	O
++	O
)	O
setq	(int,int)->(void)
(	O
MMcar	()->(int)
(	O
arg	int
)	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
=	O
vs_top	O
=	O
old_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
DEFUNO_NEW	()->(int)
(	O
"SET"	*(char)
,	O
object	O
,	O
fLset	O
,	O
LISP	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lset	O
,	O
(	O
object	O
symbol	O
,	O
object	O
value	O
)	O
,	O
""	*(char)
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
symbol	O
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
symbol	O
)	O
;	O
if	O
(	O
(	O
enum	O
stype	O
)	O
symbol	O
->	O
s	O
.	O
s_stype	O
==	O
stp_constant	O
)	O
FEinvalid_variable	()->(int)
(	O
"Cannot assign to the constant ~S."	*(char)
,	O
symbol	O
)	O
;	O
symbol	O
->	O
s	O
.	O
s_dbind	O
=	O
value	O
;	O
RETURN1	()->(int)
(	O
value	O
)	O
;	O
}	O
DEFUNO_NEW	()->(int)
(	O
"FSET"	*(char)
,	O
object	O
,	O
fSfset	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
siLfset	O
,	O
(	O
object	O
sym	int
,	O
object	O
function	O
)	O
,	O
""	*(char)
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
{	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_mflag	O
)	O
{	O
if	O
(	O
symbol_value	()->(int)
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
sym	int
->	O
s	O
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
}	O
else	O
if	O
(	O
symbol_value	()->(int)
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
FEerror	()->(int)
(	O
"~S, a special form, cannot be redefined."	*(char)
,	O
1	int
,	O
sym	int
)	O
;	O
}	O
sym	int
=	O
clear_compiler_properties	()->(int)
(	O
sym	int
,	O
function	O
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_hpack	O
==	O
lisp_package	O
&&	O
sym	int
->	O
s	O
.	O
s_gfdef	O
!=	O
OBJNULL	O
&&	O
!	O
raw_image	O
)	O
{	O
ifuncall2	()->(int)
(	O
sLwarn	int
,	O
make_simple_string	()->(int)
(	O
"~S is being redefined."	*(char)
)	O
,	O
sym	int
)	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
function	O
)	O
==	O
t_cfun	O
||	O
type_of	()->(int)
(	O
function	O
)	O
==	O
t_sfun	O
||	O
type_of	()->(int)
(	O
function	O
)	O
==	O
t_vfun	O
||	O
type_of	()->(int)
(	O
function	O
)	O
==	O
t_gfun	O
||	O
type_of	()->(int)
(	O
function	O
)	O
==	O
t_cclosure	O
||	O
type_of	()->(int)
(	O
function	O
)	O
==	O
t_closure	O
||	O
type_of	()->(int)
(	O
function	O
)	O
==	O
t_afun	O
)	O
{	O
sym	int
->	O
s	O
.	O
s_gfdef	O
=	O
function	O
;	O
sym	int
->	O
s	O
.	O
s_mflag	O
=	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
car	()->(int)
(	O
function	O
)	O
==	O
sLspecial	O
)	O
FEerror	()->(int)
(	O
"Cannot define a special form."	*(char)
,	O
0	int
)	O
;	O
else	O
if	O
(	O
function	O
->	O
c	O
.	O
c_car	O
==	O
sLmacro	O
)	O
{	O
sym	int
->	O
s	O
.	O
s_gfdef	O
=	O
function	O
->	O
c	O
.	O
c_cdr	O
;	O
sym	int
->	O
s	O
.	O
s_mflag	O
=	O
TRUE	O
;	O
}	O
else	O
{	O
sym	int
->	O
s	O
.	O
s_gfdef	O
=	O
function	O
;	O
sym	int
->	O
s	O
.	O
s_mflag	O
=	O
FALSE	O
;	O
}	O
RETURN1	()->(int)
(	O
function	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fmultiple_value_setq	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
vars	O
;	O
int	O
n	int
,	O
i	int
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
||	O
endp	()->(int)
(	O
form	int
->	O
c	O
.	O
c_cdr	O
)	O
||	O
!	O
endp	()->(int)
(	O
form	int
->	O
c	O
.	O
c_cdr	O
->	O
c	O
.	O
c_cdr	O
)	O
)	O
FEinvalid_form	()->(int)
(	O
"~S is an illegal argument to MULTIPLE-VALUE-SETQ"	*(char)
,	O
form	int
)	O
;	O
vars	O
=	O
form	int
->	O
c	O
.	O
c_car	O
;	O
fcall	O
.	O
values	O
[	O
0	int
]	O
=	O
Ieval	()->(int)
(	O
form	int
->	O
c	O
.	O
c_cdr	O
->	O
c	O
.	O
c_car	O
)	O
;	O
n	int
=	O
fcall	O
.	O
nvalues	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
!	O
endp	()->(int)
(	O
vars	O
)	O
;	O
i	int
++	O
,	O
vars	O
=	O
vars	O
->	O
c	O
.	O
c_cdr	O
)	O
if	O
(	O
i	int
<	O
n	int
)	O
setq	(int,int)->(void)
(	O
vars	O
->	O
c	O
.	O
c_car	O
,	O
fcall	O
.	O
values	O
[	O
i	int
]	O
)	O
;	O
else	O
setq	(int,int)->(void)
(	O
vars	O
->	O
c	O
.	O
c_car	O
,	O
Cnil	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
fcall	O
.	O
values	O
[	O
0	int
]	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
DEFUNO_NEW	()->(int)
(	O
"MAKUNBOUND"	*(char)
,	O
object	O
,	O
fLmakunbound	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lmakunbound	O
,	O
(	O
object	O
sym	int
)	O
,	O
""	*(char)
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
(	O
enum	O
stype	O
)	O
sym	int
->	O
s	O
.	O
s_stype	O
==	O
stp_constant	O
)	O
FEinvalid_variable	()->(int)
(	O
"Cannot unbind the constant ~S."	*(char)
,	O
sym	int
)	O
;	O
sym	int
->	O
s	O
.	O
s_dbind	O
=	O
OBJNULL	O
;	O
RETURN1	()->(int)
(	O
sym	int
)	O
;	O
}	O
object	O
sStraced	int
;	O
DEFUNO_NEW	()->(int)
(	O
"FMAKUNBOUND"	*(char)
,	O
object	O
,	O
fLfmakunbound	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lfmakunbound	O
,	O
(	O
object	O
sym	int
)	O
,	O
""	*(char)
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
{	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_mflag	O
)	O
{	O
if	O
(	O
symbol_value	()->(int)
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
sym	int
->	O
s	O
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
}	O
else	O
if	O
(	O
symbol_value	()->(int)
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
FEerror	()->(int)
(	O
"~S, a special form, cannot be redefined."	*(char)
,	O
1	int
,	O
sym	int
)	O
;	O
}	O
remf	()->(int)
(	O
&	O
(	O
sym	int
->	O
s	O
.	O
s_plist	O
)	O
,	O
sStraced	int
)	O
;	O
clear_compiler_properties	()->(int)
(	O
sym	int
,	O
Cnil	O
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_hpack	O
==	O
lisp_package	O
&&	O
sym	int
->	O
s	O
.	O
s_gfdef	O
!=	O
OBJNULL	O
&&	O
!	O
raw_image	O
)	O
{	O
ifuncall2	()->(int)
(	O
sLwarn	int
,	O
make_simple_string	()->(int)
(	O
"~S is being redefined."	*(char)
)	O
,	O
sym	int
)	O
;	O
}	O
sym	int
->	O
s	O
.	O
s_gfdef	O
=	O
OBJNULL	O
;	O
sym	int
->	O
s	O
.	O
s_mflag	O
=	O
FALSE	O
;	O
RETURN1	()->(int)
(	O
sym	int
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fsetf	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
result	O
,	O
*	O
t	O
,	O
*	O
t1	O
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
if	O
(	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
form	int
)	O
)	O
)	O
FEinvalid_form	()->(int)
(	O
"No value for ~S."	*(char)
,	O
form	int
->	O
c	O
.	O
c_car	O
)	O
;	O
result	O
=	O
setf	()->(int)
(	O
MMcar	()->(int)
(	O
form	int
)	O
,	O
MMcadr	()->(int)
(	O
form	int
)	O
)	O
;	O
form	int
=	O
MMcddr	()->(int)
(	O
form	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	()->(int)
(	O
form	int
)	O
)	O
;	O
t	O
=	O
vs_base	O
;	O
t1	O
=	O
vs_top	O
;	O
vs_top	O
=	O
vs_base	O
=	O
top	O
;	O
for	O
(	O
;	O
t	O
<	O
t1	O
;	O
t	O
++	O
)	O
vs_push	()->(int)
(	O
*	O
t	O
)	O
;	O
}	O
}	O
static	O
object	O
setf	()->(int)
(	O
object	O
place	int
,	O
object	O
form	int
)	O
{	O
object	O
fun	O
;	O
object	O
*	O
vs	O
=	O
vs_top	O
;	O
void	O
(	O
*	O
f	*(()->(void))
)	O
(	O
)	O
;	O
object	O
args	O
;	O
object	O
x	O
,	O
result	O
,	O
y	O
;	O
int	O
i	int
;	O
extern	O
void	O
siLelt_set	()->(void)
(	O
)	O
;	O
extern	O
void	O
siLchar_set	()->(void)
(	O
)	O
;	O
extern	O
void	O
siLhash_set	()->(void)
(	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
place	int
)	O
!=	O
t_cons	O
)	O
{	O
setq	(int,int)->(void)
(	O
place	int
,	O
result	O
=	O
Ieval	()->(int)
(	O
form	int
)	O
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
return	O
result	O
;	O
}	O
fun	O
=	O
place	int
->	O
c	O
.	O
c_car	O
;	O
if	O
(	O
type_of	()->(int)
(	O
fun	O
)	O
!=	O
t_symbol	O
)	O
goto	O
OTHERWISE	O
;	O
args	O
=	O
place	int
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
fun	O
==	O
sLget	int
)	O
{	O
object	O
sym	int
,	O
val	int
,	O
key	O
;	O
sym	int
=	O
Ieval	()->(int)
(	O
car	()->(int)
(	O
args	O
)	O
)	O
;	O
key	O
=	O
Ieval	()->(int)
(	O
car	()->(int)
(	O
Mcdr	()->(int)
(	O
args	O
)	O
)	O
)	O
;	O
val	int
=	O
Ieval	()->(int)
(	O
form	int
)	O
;	O
return	O
putprop	()->(int)
(	O
sym	int
,	O
val	int
,	O
key	O
)	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLgetf	int
)	O
Ieval	()->(int)
(	O
Mcaddr	()->(int)
(	O
args	O
)	O
)	O
;	O
if	O
(	O
fun	O
==	O
sLaref	int
)	O
{	O
f	*(()->(void))
=	O
siLaset	O
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLsvref	int
)	O
{	O
f	*(()->(void))
=	O
siLsvset	O
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLelt	int
)	O
{	O
f	*(()->(void))
=	O
siLelt_set	()->(void)
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLchar	int
)	O
{	O
f	*(()->(void))
=	O
siLchar_set	()->(void)
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLschar	int
)	O
{	O
f	*(()->(void))
=	O
siLchar_set	()->(void)
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLfill_pointer	int
)	O
{	O
f	*(()->(void))
=	O
siLfill_pointer_set	O
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLgethash	int
)	O
{	O
f	*(()->(void))
=	O
siLhash_set	()->(void)
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLcar	int
)	O
{	O
x	O
=	O
Ieval	()->(int)
(	O
Mcar	()->(int)
(	O
args	O
)	O
)	O
;	O
result	O
=	O
Ieval	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	O
)	O
!=	O
t_cons	O
)	O
FEerror	()->(int)
(	O
"~S is not a cons."	*(char)
,	O
1	int
,	O
x	O
)	O
;	O
Mcar	()->(int)
(	O
x	O
)	O
=	O
result	O
;	O
return	O
result	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLcdr	int
)	O
{	O
x	O
=	O
Ieval	()->(int)
(	O
Mcar	()->(int)
(	O
args	O
)	O
)	O
;	O
result	O
=	O
Ieval	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	O
)	O
!=	O
t_cons	O
)	O
FEerror	()->(int)
(	O
"~S is not a cons."	*(char)
,	O
1	int
,	O
x	O
)	O
;	O
Mcdr	()->(int)
(	O
x	O
)	O
=	O
result	O
;	O
return	O
result	O
;	O
}	O
x	O
=	O
getf	()->(int)
(	O
fun	O
->	O
s	O
.	O
s_plist	O
,	O
sSstructure_access	int
,	O
Cnil	O
)	O
;	O
if	O
(	O
x	O
==	O
Cnil	O
||	O
type_of	()->(int)
(	O
x	O
)	O
!=	O
t_cons	O
)	O
goto	O
OTHERWISE	O
;	O
if	O
(	O
getf	()->(int)
(	O
fun	O
->	O
s	O
.	O
s_plist	O
,	O
sSsetf_lambda	int
,	O
Cnil	O
)	O
==	O
Cnil	O
)	O
goto	O
OTHERWISE	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	O
->	O
c	O
.	O
c_cdr	O
)	O
!=	O
t_fixnum	O
)	O
goto	O
OTHERWISE	O
;	O
i	int
=	O
fix	()->(int)
(	O
x	O
->	O
c	O
.	O
c_cdr	O
)	O
;	O
x	O
=	O
x	O
->	O
c	O
.	O
c_car	O
;	O
y	O
=	O
Ieval	()->(int)
(	O
Mcar	()->(int)
(	O
args	O
)	O
)	O
;	O
result	O
=	O
Ieval	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
x	O
==	O
sLvector	O
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
y	O
)	O
!=	O
t_vector	O
||	O
i	int
>=	O
y	O
->	O
v	O
.	O
v_fillp	O
)	O
goto	O
OTHERWISE	O
;	O
y	O
->	O
v	O
.	O
v_self	O
[	O
i	int
]	O
=	O
result	O
;	O
}	O
else	O
if	O
(	O
x	O
==	O
sLlist	O
)	O
{	O
for	O
(	O
x	O
=	O
y	O
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
x	O
=	O
cdr	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	O
)	O
!=	O
t_cons	O
)	O
goto	O
OTHERWISE	O
;	O
x	O
->	O
c	O
.	O
c_car	O
=	O
result	O
;	O
}	O
else	O
{	O
structure_set	()->(int)
(	O
y	O
,	O
x	O
,	O
i	int
,	O
result	O
)	O
;	O
}	O
return	O
result	O
;	O
EVAL	O
:	O
for	O
(	O
;	O
!	O
endp	()->(int)
(	O
args	O
)	O
;	O
args	O
=	O
args	O
->	O
c	O
.	O
c_cdr	O
)	O
{	O
eval_push	O
(	O
args	O
->	O
c	O
.	O
c_car	O
)	O
;	O
}	O
eval_push	O
(	O
form	int
)	O
;	O
vs_base	O
=	O
vs	O
;	O
(	O
*	O
f	*(()->(void))
)	O
(	O
)	O
;	O
return	O
vs_base	O
[	O
0	int
]	O
;	O
OTHERWISE	O
:	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
sLsetf	int
)	O
;	O
vs_push	()->(int)
(	O
place	int
)	O
;	O
vs_push	()->(int)
(	O
form	int
)	O
;	O
result	O
=	O
vs_top	O
[	O
-	O
1	int
]	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
VS_PUSH_ENV	O
;	O
if	O
(	O
!	O
sLsetf	int
->	O
s	O
.	O
s_mflag	O
||	O
sLsetf	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Where is SETF?"	*(char)
,	O
0	int
)	O
;	O
funcall	()->(int)
(	O
sLsetf	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
return	O
Ieval	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fpush	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
var	O
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
form	int
)	O
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcddr	()->(int)
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	()->(int)
(	O
form	int
)	O
;	O
var	O
=	O
MMcadr	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
var	O
)	O
!=	O
t_cons	O
)	O
{	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
form	int
)	O
)	O
;	O
form	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
eval	()->(int)
(	O
var	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
form	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
setq	(int,int)->(void)
(	O
var	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
sLpush	int
)	O
;	O
vs_push	()->(int)
(	O
form	int
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
VS_PUSH_ENV	O
;	O
if	O
(	O
!	O
sLpush	int
->	O
s	O
.	O
s_mflag	O
||	O
sLpush	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Where is PUSH?"	*(char)
,	O
0	int
)	O
;	O
funcall	()->(int)
(	O
sLpush	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
eval	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fpop	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
var	O
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	()->(int)
(	O
form	int
)	O
;	O
var	O
=	O
MMcar	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
var	O
)	O
!=	O
t_cons	O
)	O
{	O
eval	()->(int)
(	O
var	O
)	O
;	O
setq	(int,int)->(void)
(	O
var	O
,	O
cdr	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
car	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
sLpop	int
)	O
;	O
vs_push	()->(int)
(	O
form	int
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
VS_PUSH_ENV	O
;	O
if	O
(	O
!	O
sLpop	int
->	O
s	O
.	O
s_mflag	O
||	O
sLpop	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Where is POP?"	*(char)
,	O
0	int
)	O
;	O
funcall	()->(int)
(	O
sLpop	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
eval	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fincf	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
var	O
;	O
object	O
one_plus	()->(int)
(	O
object	O
x	O
)	O
,	O
number_plus	()->(int)
(	O
object	O
x	O
,	O
object	O
y	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
form	int
)	O
)	O
&&	O
!	O
endp	()->(int)
(	O
MMcddr	()->(int)
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	()->(int)
(	O
form	int
)	O
;	O
var	O
=	O
MMcar	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
var	O
)	O
!=	O
t_cons	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
form	int
)	O
)	O
)	O
{	O
eval	()->(int)
(	O
var	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
one_plus	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
setq	(int,int)->(void)
(	O
var	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
eval	()->(int)
(	O
MMcadr	()->(int)
(	O
form	int
)	O
)	O
;	O
form	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
eval	()->(int)
(	O
var	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_plus	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
form	int
)	O
;	O
setq	(int,int)->(void)
(	O
var	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
sLincf	int
)	O
;	O
vs_push	()->(int)
(	O
form	int
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
VS_PUSH_ENV	O
;	O
if	O
(	O
!	O
sLincf	int
->	O
s	O
.	O
s_mflag	O
||	O
sLincf	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Where is INCF?"	*(char)
,	O
0	int
)	O
;	O
funcall	()->(int)
(	O
sLincf	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
eval	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fdecf	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
var	O
;	O
object	O
one_minus	()->(int)
(	O
object	O
x	O
)	O
,	O
number_minus	()->(int)
(	O
object	O
x	O
,	O
object	O
y	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
form	int
)	O
)	O
&&	O
!	O
endp	()->(int)
(	O
MMcddr	()->(int)
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	()->(int)
(	O
form	int
)	O
;	O
var	O
=	O
MMcar	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
var	O
)	O
!=	O
t_cons	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
form	int
)	O
)	O
)	O
{	O
eval	()->(int)
(	O
var	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
one_minus	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
setq	(int,int)->(void)
(	O
var	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
eval	()->(int)
(	O
MMcadr	()->(int)
(	O
form	int
)	O
)	O
;	O
form	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
eval	()->(int)
(	O
var	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_minus	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
form	int
)	O
;	O
setq	(int,int)->(void)
(	O
var	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
sLdecf	int
)	O
;	O
vs_push	()->(int)
(	O
form	int
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
VS_PUSH_ENV	O
;	O
if	O
(	O
!	O
sLdecf	int
->	O
s	O
.	O
s_mflag	O
||	O
sLdecf	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Where is DECF?"	*(char)
,	O
0	int
)	O
;	O
funcall	()->(int)
(	O
sLdecf	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
eval	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
DEF_ORDINARY	()->(int)
(	O
"CLEAR-COMPILER-PROPERTIES"	*(char)
,	O
sSclear_compiler_properties	int
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEFUN_NEW	()->(int)
(	O
"CLEAR-COMPILER-PROPERTIES"	*(char)
,	O
object	O
,	O
fSclear_compiler_properties	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
,	O
object	O
x1	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
DEF_ORDINARY	()->(int)
(	O
"AREF"	*(char)
,	O
sLaref	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CAR"	*(char)
,	O
sLcar	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CDR"	*(char)
,	O
sLcdr	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CHAR"	*(char)
,	O
sLchar	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"DECF"	*(char)
,	O
sLdecf	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"ELT"	*(char)
,	O
sLelt	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FILL-POINTER"	*(char)
,	O
sLfill_pointer	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"GET"	*(char)
,	O
sLget	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"GETF"	*(char)
,	O
sLgetf	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"GETHASH"	*(char)
,	O
sLgethash	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"INCF"	*(char)
,	O
sLincf	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"POP"	*(char)
,	O
sLpop	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PUSH"	*(char)
,	O
sLpush	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SCHAR"	*(char)
,	O
sLschar	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SETF"	*(char)
,	O
sLsetf	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SETF-LAMBDA"	*(char)
,	O
sSsetf_lambda	int
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STRUCTURE-ACCESS"	*(char)
,	O
sSstructure_access	int
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SVREF"	*(char)
,	O
sLsvref	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"TRACED"	*(char)
,	O
sStraced	int
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"VECTOR"	*(char)
,	O
sLvector	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
void	O
gcl_init_assignment	()->(void)
(	O
void	O
)	O
{	O
make_special_form	()->(int)
(	O
"SETQ"	*(char)
,	O
Fsetq	int
)	O
;	O
make_special_form	()->(int)
(	O
"PSETQ"	*(char)
,	O
Fpsetq	int
)	O
;	O
make_special_form	()->(int)
(	O
"MULTIPLE-VALUE-SETQ"	*(char)
,	O
Fmultiple_value_setq	int
)	O
;	O
sLsetf	int
=	O
make_special_form	()->(int)
(	O
"SETF"	*(char)
,	O
Fsetf	int
)	O
;	O
sLpush	int
=	O
make_special_form	()->(int)
(	O
"PUSH"	*(char)
,	O
Fpush	int
)	O
;	O
sLpop	int
=	O
make_special_form	()->(int)
(	O
"POP"	*(char)
,	O
Fpop	int
)	O
;	O
sLincf	int
=	O
make_special_form	()->(int)
(	O
"INCF"	*(char)
,	O
Fincf	int
)	O
;	O
sLdecf	int
=	O
make_special_form	()->(int)
(	O
"DECF"	*(char)
,	O
Fdecf	int
)	O
;	O
}	O
