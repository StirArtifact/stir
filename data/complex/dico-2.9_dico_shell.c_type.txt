int	O
interactive	int
;	O
char	O
*	O
prompt	*(char)
;	O
static	O
void	O
ds_prefix	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
;	O
static	O
void	O
ds_help	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
;	O
static	O
void	O
ds_quiet	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
;	O
static	O
void	O
ds_prompt	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
;	O
static	O
char	O
*	O
*	O
no_compl	(int,*(*(char)),int)->(*(*(char)))
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
)	O
;	O
char	O
*	O
helptext	array(array(*(char)))
[	O
]	O
[	O
2	int
]	O
=	O
{	O
{	O
N_	O
(	O
"WORD"	*(char)
)	O
,	O
N_	O
(	O
"Define WORD."	*(char)
)	O
}	O
,	O
{	O
N_	O
(	O
"/WORD"	*(char)
)	O
,	O
N_	O
(	O
"Match WORD."	*(char)
)	O
}	O
,	O
{	O
"/"	*(char)
,	O
N_	O
(	O
"Redisplay previous matches."	*(char)
)	O
}	O
,	O
{	O
N_	O
(	O
"NUMBER"	*(char)
)	O
,	O
N_	O
(	O
"Define NUMBERth match."	*(char)
)	O
}	O
,	O
}	O
;	O
struct	O
funtab	struct(*(char),int,int,*(char),*(char),*((int,*(*(char)))->(void)),*((int,*(*(char)),int)->(*(*(char)))))
funtab	struct(*(char),int,int,*(char),*(char),*((int,*(*(char)))->(void)),*((int,*(*(char)),int)->(*(*(char)))))
[	O
]	O
=	O
{	O
{	O
"open"	*(char)
,	O
1	int
,	O
3	int
,	O
N_	O
(	O
"[HOST [PORT]]"	*(char)
)	O
,	O
N_	O
(	O
"Connect to a DICT server."	*(char)
)	O
,	O
ds_open	(int,*(*(char)))->(void)
,	O
no_compl	(int,*(*(char)),int)->(*(*(char)))
}	O
,	O
{	O
"close"	*(char)
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"Close the connection."	*(char)
)	O
,	O
ds_close	(int,*(*(char)))->(void)
,	O
}	O
,	O
{	O
"database"	*(char)
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[NAME]"	*(char)
)	O
,	O
N_	O
(	O
"Set or display current database name."	*(char)
)	O
,	O
ds_database	(int,*(*(char)))->(void)
,	O
ds_compl_database	(int,*(*(char)),int)->(*(*(char)))
}	O
,	O
{	O
"strategy"	*(char)
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[NAME]"	*(char)
)	O
,	O
N_	O
(	O
"Set or display current strategy."	*(char)
)	O
,	O
ds_strategy	(int,*(*(char)))->(void)
,	O
ds_compl_strategy	(int,*(*(char)),int)->(*(*(char)))
}	O
,	O
{	O
"distance"	*(char)
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[NUM]"	*(char)
)	O
,	O
N_	O
(	O
"Set or query Levenshtein distance (server-dependent)."	*(char)
)	O
,	O
ds_distance	(int,*(*(char)))->(void)
,	O
no_compl	(int,*(*(char)),int)->(*(*(char)))
}	O
,	O
{	O
"ls"	*(char)
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"List available matching strategies"	*(char)
)	O
,	O
ds_show_strat	(int,*(*(char)))->(void)
,	O
}	O
,	O
{	O
"ld"	*(char)
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"List all accessible databases"	*(char)
)	O
,	O
ds_show_db	(int,*(*(char)))->(void)
,	O
}	O
,	O
{	O
"info"	*(char)
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[DB]"	*(char)
)	O
,	O
N_	O
(	O
"Display the information about the database."	*(char)
)	O
,	O
ds_show_info	(int,*(*(char)))->(void)
,	O
ds_compl_database	(int,*(*(char)),int)->(*(*(char)))
}	O
,	O
{	O
"prefix"	*(char)
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[CHAR]"	*(char)
)	O
,	O
N_	O
(	O
"Set or display command prefix."	*(char)
)	O
,	O
ds_prefix	(int,*(*(char)))->(void)
,	O
}	O
,	O
{	O
"transcript"	*(char)
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[BOOL]"	*(char)
)	O
,	O
N_	O
(	O
"Set or display session transcript mode."	*(char)
)	O
,	O
ds_transcript	(int,*(*(char)))->(void)
,	O
no_compl	(int,*(*(char)),int)->(*(*(char)))
}	O
,	O
{	O
"verbose"	*(char)
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[NUMBER]"	*(char)
)	O
,	O
N_	O
(	O
"Set or display verbosity level."	*(char)
)	O
,	O
ds_verbose	(int,*(*(char)))->(void)
,	O
no_compl	(int,*(*(char)),int)->(*(*(char)))
}	O
,	O
{	O
"prompt"	*(char)
,	O
2	int
,	O
2	int
,	O
N_	O
(	O
"STRING"	*(char)
)	O
,	O
N_	O
(	O
"Change command line prompt."	*(char)
)	O
,	O
ds_prompt	(int,*(*(char)))->(void)
,	O
no_compl	(int,*(*(char)),int)->(*(*(char)))
}	O
,	O
{	O
"pager"	*(char)
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"STRING"	*(char)
)	O
,	O
N_	O
(	O
"Change or display pager settings."	*(char)
)	O
,	O
ds_pager	(int,*(*(char)))->(void)
,	O
no_compl	(int,*(*(char)),int)->(*(*(char)))
}	O
,	O
{	O
"autologin"	*(char)
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[FILE]"	*(char)
)	O
,	O
N_	O
(	O
"Set or display autologin file name."	*(char)
)	O
,	O
ds_autologin	(int,*(*(char)))->(void)
,	O
}	O
,	O
{	O
"sasl"	*(char)
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[BOOL]"	*(char)
)	O
,	O
N_	O
(	O
"Enable SASL authentication."	*(char)
)	O
,	O
ds_sasl	(int,*(*(char)))->(void)
,	O
no_compl	(int,*(*(char)),int)->(*(*(char)))
}	O
,	O
{	O
"help"	*(char)
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"Display this help text."	*(char)
)	O
,	O
ds_help	(int,*(*(char)))->(void)
,	O
}	O
,	O
{	O
"version"	*(char)
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"Print program version."	*(char)
)	O
,	O
ds_version	(int,*(*(char)))->(void)
,	O
}	O
,	O
{	O
"warranty"	*(char)
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"Print copyright statement."	*(char)
)	O
,	O
ds_warranty	(int,*(*(char)))->(void)
,	O
}	O
,	O
{	O
"quiet"	*(char)
,	O
2	int
,	O
2	int
,	O
NULL	O
,	O
NULL	O
,	O
ds_quiet	(int,*(*(char)))->(void)
}	O
,	O
{	O
"quit"	*(char)
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"Quit the shell."	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
funtab	struct(*(char),int,int,*(char),*(char),*((int,*(*(char)))->(void)),*((int,*(*(char)),int)->(*(*(char)))))
*	O
find_funtab	(*(char))->(*(struct(*(char),int,int,*(char),*(char),*((int,*`)->(void)),*((int,*`,int)->(*`)))))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
funtab	struct(*(char),int,int,*(char),*(char),*((int,*(*(char)))->(void)),*((int,*(*(char)),int)->(*(*(char)))))
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
funtab	struct(*(char),int,int,*(char),*(char),*((int,*(*(char)))->(void)),*((int,*(*(char)),int)->(*(*(char)))))
;	O
p	*(void)
->	O
name	*(char)
;	O
p	*(void)
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
p	*(void)
;	O
return	O
NULL	O
;	O
}	O
int	O
cmdprefix	int
;	O
char	O
special_prefixes	array(char)
[	O
2	int
]	O
;	O
static	O
void	O
ds_prefix	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Command prefix is %c\n"	*(char)
)	O
,	O
cmdprefix	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
!	O
argv	*(*(char))
[	O
1	int
]	O
[	O
1	int
]	O
&&	O
argv	*(*(char))
[	O
1	int
]	O
[	O
0	int
]	O
!=	O
'#'	O
&&	O
ispunct	(int)->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
[	O
0	int
]	O
)	O
)	O
)	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"Expected a single punctuation character"	*(char)
)	O
)	O
;	O
else	O
{	O
cmdprefix	int
=	O
argv	*(*(char))
[	O
1	int
]	O
[	O
0	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
special_prefixes	array(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
}	O
}	O
static	O
void	O
ds_help	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
static	O
size_t	long
nlines	long
;	O
dico_stream_t	*(struct)
str	*(char)
;	O
struct	O
funtab	struct(*(char),int,int,*(char),*(char),*((int,*(*(char)))->(void)),*((int,*(*(char)),int)->(*(*(char)))))
*	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
;	O
size_t	long
i	long
;	O
if	O
(	O
nlines	long
==	O
0	int
)	O
{	O
nlines	long
=	O
DICO_ARRAY_SIZE	O
(	O
helptext	array(array(*(char)))
)	O
+	O
1	int
;	O
for	O
(	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
=	O
funtab	struct(*(char),int,int,*(char),*(char),*((int,*(*(char)))->(void)),*((int,*(*(char)),int)->(*(*(char)))))
;	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
name	*(char)
;	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
++	O
)	O
{	O
if	O
(	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
docstring	*(char)
)	O
nlines	long
++	O
;	O
}	O
}	O
str	*(char)
=	O
create_pager_stream	(long)->(*(struct))
(	O
nlines	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
DICO_ARRAY_SIZE	O
(	O
helptext	array(array(*(char)))
)	O
;	O
i	long
++	O
)	O
{	O
stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"%-24s %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
helptext	array(array(*(char)))
[	O
i	long
]	O
[	O
0	int
]	O
)	O
,	O
gettext	(*(char))->(*(char))
(	O
helptext	array(array(*(char)))
[	O
i	long
]	O
[	O
1	int
]	O
)	O
)	O
;	O
}	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(char)
,	O
"\n"	*(char)
,	O
1	int
)	O
;	O
for	O
(	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
=	O
funtab	struct(*(char),int,int,*(char),*(char),*((int,*(*(char)))->(void)),*((int,*(*(char)),int)->(*(*(char)))))
;	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
name	*(char)
;	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
++	O
)	O
{	O
int	O
len	long
=	O
0	int
;	O
const	O
char	O
*	O
args	*(struct)
;	O
if	O
(	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
docstring	*(char)
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
cmdprefix	int
)	O
{	O
stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"%c"	*(char)
,	O
cmdprefix	int
)	O
;	O
len	long
++	O
;	O
}	O
stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"%s "	*(char)
,	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
name	*(char)
)	O
;	O
len	long
+=	O
strlen	(*(char))->(long)
(	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
name	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
argdoc	*(char)
)	O
args	*(struct)
=	O
gettext	(*(char))->(*(char))
(	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
argdoc	*(char)
)	O
;	O
else	O
args	*(struct)
=	O
""	*(char)
;	O
if	O
(	O
len	long
<	O
24	int
)	O
len	long
=	O
24	int
-	O
len	long
;	O
else	O
len	long
=	O
0	int
;	O
stream_printf	(*(struct),*(char))->(int)
(	O
str	*(char)
,	O
"%-*s %s\n"	*(char)
,	O
len	long
,	O
args	*(struct)
,	O
gettext	(*(char))->(*(char))
(	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
docstring	*(char)
)	O
)	O
;	O
}	O
dico_stream_close	(*(struct))->(int)
(	O
str	*(char)
)	O
;	O
dico_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
str	*(char)
)	O
;	O
}	O
static	O
void	O
ds_quiet	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
set_bool	(*(int),*(char))->(int)
(	O
&	O
quiet_option	int
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
}	O
typedef	O
int	O
(	O
*	O
script_getln_fn	*((*(void),*(*(char)))->(int))
)	O
(	O
void	O
*	O
data	*(void)
,	O
char	O
*	O
*	O
buf	*(void)
)	O
;	O
int	O
line	int
=	O
0	int
;	O
const	O
char	O
*	O
filename	*(char)
;	O
void	O
script_diag	(int,int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
int	O
category	int
,	O
int	O
errcode	int
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
const	O
char	O
*	O
pfx	*(char)
;	O
char	O
*	O
newfmt	*(char)
;	O
if	O
(	O
category	int
==	O
L_WARN	int
)	O
pfx	*(char)
=	O
_	O
(	O
"warning: "	*(char)
)	O
;	O
else	O
pfx	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
filename	*(char)
)	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
newfmt	*(char)
,	O
"%s%s"	*(char)
,	O
pfx	*(char)
?	O
pfx	*(char)
:	O
""	*(char)
,	O
fmt	*(char)
)	O
;	O
else	O
{	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
newfmt	*(char)
,	O
"%s:%d: %s%s"	*(char)
,	O
filename	*(char)
,	O
line	int
,	O
pfx	*(char)
?	O
pfx	*(char)
:	O
""	*(char)
,	O
fmt	*(char)
)	O
;	O
}	O
dico_vlog	(int,int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
category	int
,	O
errcode	int
,	O
newfmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
free	(*(void))->(void)
(	O
newfmt	*(char)
)	O
;	O
}	O
void	O
script_warning	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
script_diag	(int,int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
L_WARN	int
,	O
0	int
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
script_error	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
script_diag	(int,int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
static	O
int	O
is_command	(*(*(char)))->(int)
(	O
char	O
*	O
*	O
ptr	*(void)
)	O
{	O
if	O
(	O
!	O
cmdprefix	int
)	O
return	O
1	int
;	O
if	O
(	O
(	O
*	O
ptr	*(void)
)	O
[	O
0	int
]	O
==	O
cmdprefix	int
)	O
{	O
++	O
*	O
ptr	*(void)
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
parse_script_file	(*(char),*((*(void),*(*(char)))->(int)),*(void))->(void)
(	O
const	O
char	O
*	O
fname	*(char)
,	O
script_getln_fn	*((*(void),*(*(char)))->(int))
getln	*((*(void),*(*(char)))->(int))
,	O
void	O
*	O
data	*(void)
)	O
{	O
char	O
*	O
buf	*(void)
=	O
NULL	O
;	O
struct	O
dico_tokbuf	struct(*(char),long,long,*(*(char)),int,int)
tb	*(struct(*(char),long,long,*(*(char)),int,int))
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
filename	*(char)
=	O
fname	*(char)
;	O
line	int
=	O
0	int
;	O
dico_tokenize_begin	(*(struct(*(char),long,long,*(*(char)),int,int)))->(void)
(	O
&	O
tb	*(struct(*(char),long,long,*(*(char)),int,int))
)	O
;	O
while	O
(	O
getln	*((*(void),*(*(char)))->(int))
(	O
data	*(void)
,	O
&	O
buf	*(void)
)	O
)	O
{	O
char	O
*	O
p	*(void)
,	O
*	O
start	*(int)
;	O
char	O
*	O
xargv	array(*(char))
[	O
3	int
]	O
;	O
line	int
++	O
;	O
start	*(int)
=	O
skipws	(*(char))->(*(char))
(	O
buf	*(void)
)	O
;	O
dico_trim_nl	(*(char))->(long)
(	O
start	*(int)
)	O
;	O
if	O
(	O
*	O
start	*(int)
==	O
0	int
||	O
*	O
start	*(int)
==	O
'#'	O
)	O
continue	O
;	O
xdico_tokenize_string	(*(struct(*(char),long,long,*(*(char)),int,int)),*(char))->(void)
(	O
&	O
tb	*(struct(*(char),long,long,*(*(char)),int,int))
,	O
start	*(int)
)	O
;	O
argc	int
=	O
tb	*(struct(*(char),long,long,*(*(char)),int,int))
.	O
tb_tokc	int
;	O
argv	*(*(char))
=	O
tb	*(struct(*(char),long,long,*(*(char)),int,int))
.	O
tb_tokv	*(*(char))
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
continue	O
;	O
p	*(void)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
switch	O
(	O
p	*(void)
[	O
0	int
]	O
)	O
{	O
case	O
'/'	O
:	O
xargv	array(*(char))
[	O
0	int
]	O
=	O
"match"	*(char)
;	O
xargv	array(*(char))
[	O
1	int
]	O
=	O
skipws	(*(char))->(*(char))
(	O
start	*(int)
+	O
1	int
)	O
;	O
xargv	array(*(char))
[	O
2	int
]	O
=	O
NULL	O
;	O
ds_match	(int,*(*(char)))->(void)
(	O
2	int
,	O
xargv	array(*(char))
)	O
;	O
continue	O
;	O
case	O
'?'	O
:	O
ds_help	(int,*(*(char)))->(void)
(	O
0	int
,	O
NULL	O
)	O
;	O
continue	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
char	O
*	O
q	*(char)
;	O
size_t	long
num	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
&	O
q	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
q	*(char)
==	O
0	int
)	O
{	O
ds_define_nth	(long)->(void)
(	O
num	int
)	O
;	O
continue	O
;	O
}	O
}	O
}	O
if	O
(	O
is_command	(*(*(char)))->(int)
(	O
&	O
p	*(void)
)	O
)	O
{	O
struct	O
funtab	struct(*(char),int,int,*(char),*(char),*((int,*(*(char)))->(void)),*((int,*(*(char)),int)->(*(*(char)))))
*	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
=	O
find_funtab	(*(char))->(*(struct(*(char),int,int,*(char),*(char),*((int,*`)->(void)),*((int,*`,int)->(*`)))))
(	O
p	*(void)
)	O
;	O
if	O
(	O
!	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
)	O
{	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"unknown command"	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
argmin	int
==	O
0	int
)	O
{	O
argc	int
=	O
2	int
;	O
xargv	array(*(char))
[	O
0	int
]	O
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
xargv	array(*(char))
[	O
1	int
]	O
=	O
skipws	(*(char))->(*(char))
(	O
buf	*(void)
+	O
strlen	(*(char))->(long)
(	O
xargv	array(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
xargv	array(*(char))
[	O
2	int
]	O
=	O
NULL	O
;	O
argv	*(*(char))
=	O
xargv	array(*(char))
;	O
}	O
else	O
if	O
(	O
argc	int
<	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
argmin	int
)	O
{	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"not enough arguments"	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
argc	int
>	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
argmax	int
)	O
{	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
fun	*((int,*(*(char)))->(void))
)	O
ft	*(struct(*(char),int,int,*(char),*(char),*((int,*(*`))->(void)),*((int,*(*`),int)->(*(*`)))))
->	O
fun	*((int,*(*(char)))->(void))
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
else	O
{	O
ds_silent_close	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
xargv	array(*(char))
[	O
0	int
]	O
=	O
"define"	*(char)
;	O
xargv	array(*(char))
[	O
1	int
]	O
=	O
start	*(int)
;	O
xargv	array(*(char))
[	O
2	int
]	O
=	O
NULL	O
;	O
ds_define	(int,*(*(char)))->(void)
(	O
2	int
,	O
xargv	array(*(char))
)	O
;	O
}	O
}	O
dico_tokenize_end	(*(struct(*(char),long,long,*(*(char)),int,int)))->(void)
(	O
&	O
tb	*(struct(*(char),long,long,*(*(char)),int,int))
)	O
;	O
}	O
struct	O
init_script	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),long)
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
buf	*(void)
;	O
size_t	long
size	long
;	O
}	O
;	O
int	O
script_getline	(*(void),*(*(char)))->(int)
(	O
void	O
*	O
data	*(void)
,	O
char	O
*	O
*	O
buf	*(void)
)	O
{	O
struct	O
init_script	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),long)
*	O
p	*(void)
=	O
data	*(void)
;	O
int	O
rc	int
=	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
p	*(void)
->	O
buf	*(void)
,	O
&	O
p	*(void)
->	O
size	long
,	O
p	*(void)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
buf	*(void)
=	O
p	*(void)
->	O
buf	*(void)
;	O
return	O
rc	int
>	O
0	int
;	O
}	O
void	O
parse_init_script	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
init_script	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),long)
scr	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
;	O
scr	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
scr	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"Cannot open init file %s"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
scr	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
.	O
buf	*(void)
=	O
NULL	O
;	O
scr	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
.	O
size	long
=	O
0	int
;	O
parse_script_file	(*(char),*((*(void),*(*(char)))->(int)),*(void))->(void)
(	O
name	*(char)
,	O
script_getline	(*(void),*(*(char)))->(int)
,	O
&	O
scr	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
scr	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
scr	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
.	O
buf	*(void)
)	O
;	O
}	O
void	O
parse_init_scripts	()->(void)
(	O
void	O
)	O
{	O
char	O
*	O
name	*(char)
=	O
dico_full_file_name	(*(char),*(char))->(*(char))
(	O
get_homedir	()->(*(char))
(	O
)	O
,	O
".dico"	*(char)
)	O
;	O
parse_init_script	(*(char))->(void)
(	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
parse_init_script	(*(char))->(void)
(	O
".dico"	*(char)
)	O
;	O
}	O
static	O
void	O
ds_prompt	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
prompt	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
}	O
char	O
*	O
*	O
dict_completion_matches	(int,*(*(char)),int,*((*(char),int)->(*(char))))->(*(*(char)))
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
,	O
char	O
*	O
(	O
*	O
generator	*((*(char),int)->(*(char)))
)	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
)	O
{	O
}	O
static	O
char	O
*	O
*	O
no_compl	(int,*(*(char)),int)->(*(*(char)))
(	O
int	O
argc	int
DICO_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
DICO_ARG_UNUSED	O
,	O
int	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
DICO_ARG_UNUSED	O
)	O
{	O
return	O
NULL	O
;	O
}	O
void	O
shell_init	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long)))->(void)
(	O
struct	O
init_script	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),long)
*	O
p	*(void)
)	O
{	O
interactive	int
=	O
isatty	(int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
;	O
p	*(void)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
p	*(void)
->	O
buf	*(void)
=	O
NULL	O
;	O
p	*(void)
->	O
size	long
=	O
0	int
;	O
}	O
void	O
shell_finish	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long)))->(void)
(	O
struct	O
init_script	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),long)
*	O
p	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
p	*(void)
->	O
buf	*(void)
)	O
;	O
}	O
int	O
shell_getline	(*(void),*(*(char)))->(int)
(	O
void	O
*	O
data	*(void)
,	O
char	O
*	O
*	O
buf	*(void)
)	O
{	O
if	O
(	O
interactive	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
prompt	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
return	O
script_getline	(*(void),*(*(char)))->(int)
(	O
data	*(void)
,	O
buf	*(void)
)	O
;	O
}	O
void	O
dico_shell	()->(void)
(	O
void	O
)	O
{	O
struct	O
init_script	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),long)
dat	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
;	O
shell_init	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long)))->(void)
(	O
&	O
dat	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
)	O
;	O
if	O
(	O
interactive	int
)	O
{	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
prompt	*(char)
,	O
DICO_PROMPT	*(char)
)	O
;	O
if	O
(	O
!	O
quiet_option	int
)	O
shell_banner	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
cmdprefix	int
)	O
cmdprefix	int
=	O
'.'	O
;	O
parse_script_file	(*(char),*((*(void),*(*(char)))->(int)),*(void))->(void)
(	O
NULL	O
,	O
shell_getline	(*(void),*(*(char)))->(int)
,	O
&	O
dat	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
)	O
;	O
shell_finish	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long)))->(void)
(	O
&	O
dat	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long)
)	O
;	O
}	O
