int	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
char	O
*	O
line	*(char)
,	O
char	O
*	O
flagstring	*(char)
,	O
int	O
*	O
i	*(int)
,	O
int	O
*	O
num	*(int)
)	O
;	O
int	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
char	O
*	O
line	*(char)
,	O
char	O
*	O
flagstring	*(char)
,	O
char	O
*	O
*	O
s	*(*(char))
,	O
int	O
*	O
num	*(int)
)	O
;	O
void	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
char	O
*	O
value	int
,	O
char	O
*	O
*	O
s	*(*(char))
,	O
int	O
*	O
num	*(int)
)	O
;	O
void	O
optint	(*(char),*(int),*(int))->(void)
(	O
char	O
*	O
value	int
,	O
int	O
*	O
i	*(int)
,	O
int	O
*	O
num	*(int)
)	O
;	O
void	O
*	O
xstrdup	(*(char))->(*(void))
(	O
char	O
*	O
s	*(*(char))
)	O
;	O
extern	O
int	O
h_errno	O
;	O
extern	O
char	O
*	O
optarg	*(char)
;	O
extern	O
int	O
optind	int
,	O
opterr	int
,	O
optopt	int
;	O
void	O
usage	()->(void)
(	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"GNU Proxyknife %s, a customizable proxy hunter.\nUsage: proxyknife [OPTION]...\nSpecial options:\n-V,  --version    display the version of Proxyknife and exit.\n     --help       print this help.\n\nAll of the following options need arguments if no declarations.\n\nCommandline only options:\n-f \tthe argument is configuration file.\n\nConfiguration options:\n-d \tdebug, turn on debug output.\n   \tNotice: no argument for this option.\n-t \tthreads\n-g \tuser_agent\n-I \tproxyknifeintype, the type of proxylist(local file or url).\n-i \tproxyknifein, the proxylist file or url used as input of proxyknife.\n   \t'-' meanings stdin.\n-m \tmytype, the type of myproxy.\n-h \tmyhost, the IPV4 address or host name of myproxy.\n-p \tmyport, the port of myproxy.\n-u \tmyuser, the username of myproxy if need.\n-s \tmypass, the password of myproxy if need.\n-c \tchecksite, the target site used to check testproxies. Google by default.\n-C \tcheckreqin, the file including req string.\n-k \tkey, the keyword used to check whether testproxies give correct response.\n-r \trcvtimeo, socket recv timeout in seconds.\n-n \tsndtimeo, socket send timeout in seconds.\n-S \tmyconreplysize\n-T \ttestconreplysize\n-G \ttesttagreplysize\n-H \thttptestmethod\n-5 \tsocks5testmethod, reserved now\n-4 \tsocks4testmethod, reserved now\n-l \tlogfilename\n-o \tproxyknifeout, the result is also printed to this file.\n\nMail Bug reports and suggestions to <bug-proxyknife@gnu.org>.\n"	*(char)
)	O
,	O
VERSION	*(char)
)	O
;	O
}	O
void	O
READCONF	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
FILE	struct
*	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
proxyknife_conf	*(char)
=	O
NULL	O
;	O
char	O
*	O
line	*(char)
;	O
int	O
linelen	int
;	O
int	O
stringlen	int
;	O
ssize_t	long
read	*((*(void),*(char),long)->(long))
;	O
char	O
*	O
offset	long
;	O
char	O
*	O
p	*(*(void))
,	O
*	O
q	*(char)
;	O
int	O
set_mytype	int
=	O
0	int
,	O
set_httptestmethod	int
=	O
0	int
,	O
set_socks5testmethod	int
=	O
0	int
,	O
set_socks4testmethod	int
=	O
0	int
;	O
int	O
set_myport	int
=	O
0	int
,	O
set_myhost	int
=	O
0	int
;	O
int	O
set_myuser	int
=	O
0	int
,	O
set_mypass	int
=	O
0	int
;	O
int	O
set_proxyknifein	int
=	O
0	int
,	O
set_proxyknifeout	int
=	O
0	int
,	O
set_proxyknifeintype	int
=	O
0	int
;	O
int	O
set_debug	int
=	O
0	int
;	O
int	O
set_threads	int
=	O
0	int
;	O
int	O
set_checksite	int
=	O
0	int
,	O
set_key	int
=	O
0	int
,	O
set_logfilename	int
=	O
0	int
;	O
int	O
set_user_agent	int
=	O
0	int
,	O
set_myconreplysize	int
=	O
0	int
,	O
set_testconreplysize	int
=	O
0	int
;	O
int	O
set_testtagreplysize	int
=	O
0	int
,	O
set_rcvtimeo	int
=	O
0	int
,	O
set_sndtimeo	int
=	O
0	int
;	O
int	O
set_checkreqin	int
=	O
0	int
;	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
h	*(struct(*(char),*(*(char)),int,int,*(*(char))))
;	O
int	O
slash	int
,	O
colon	int
;	O
unsigned	O
char	O
*	O
filename	*(char)
,	O
*	O
home	*(char)
;	O
int	O
filenamelen	int
;	O
int	O
c	int
;	O
int	O
digit_optind	int
=	O
0	int
;	O
int	O
this_option_optind	int
=	O
optind	int
?	O
optind	int
:	O
1	int
;	O
int	O
option_index	int
=	O
0	int
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"help"	*(char)
,	O
0	int
,	O
NULL	O
,	O
129	int
}	O
,	O
{	O
"version"	*(char)
,	O
0	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mytype	int
=	O
DIRECT	int
;	O
test	struct(int,int,int,int,int)
.	O
httptestmethod	int
=	O
HTTP_GET	int
;	O
test	struct(int,int,int,int,int)
.	O
socks5testmethod	int
=	O
SOCKS5_CONNECT	int
;	O
test	struct(int,int,int,int,int)
.	O
socks4testmethod	int
=	O
SOCKS4_CONNECT	int
;	O
threads	int
=	O
THREADS	int
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
=	O
xstrdup	(*(char))->(*(void))
(	O
CHECKSITE	*(char)
)	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
key	*(char)
=	O
xstrdup	(*(char))->(*(void))
(	O
KEY	*(char)
)	O
;	O
logfilename	*(char)
=	O
xstrdup	(*(char))->(*(void))
(	O
LOGFILENAME	*(char)
)	O
;	O
user_agent	*(char)
=	O
xstrdup	(*(char))->(*(void))
(	O
USER_AGENT	*(char)
)	O
;	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myconreplysize	int
=	O
MYCONREPLYSIZE	int
;	O
test	struct(int,int,int,int,int)
.	O
testconreplysize	int
=	O
TESTCONREPLYSIZE	int
;	O
test	struct(int,int,int,int,int)
.	O
testtagreplysize	int
=	O
TESTTAGREPLYSIZE	int
;	O
rcvtimeo	int
=	O
RCVTIMEO	int
;	O
sndtimeo	int
=	O
SNDTIMEO	int
;	O
while	O
(	O
1	int
)	O
{	O
c	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"Vdf:i:I:o:t:g:m:p:h:u:s:c:C:k:r:n:S:T:G:H:5:4:l:"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
&	O
option_index	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
129	int
:	O
usage	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
"1"	*(char)
,	O
&	O
debug	int
,	O
&	O
set_debug	int
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
proxyknife_conf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
+	O
1	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
proxyknife_conf	*(char)
,	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
+	O
1	int
,	O
0	int
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
proxyknife_conf	*(char)
,	O
optarg	*(char)
,	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"GNU Proxyknife %s\n\nCopyright (C) 2005, 2006, 2007 %s <skyroam@gmail.com>.\nProxyknife is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.\n"	*(char)
)	O
,	O
VERSION	*(char)
,	O
_	O
(	O
"Jia Wang"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
'i'	O
:	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
proxyknife_in	*(char)
,	O
&	O
set_proxyknifein	int
)	O
;	O
break	O
;	O
case	O
'I'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
proxyknife_in_type	int
,	O
&	O
set_proxyknifeintype	int
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
proxyknife_out	*(char)
,	O
&	O
set_proxyknifeout	int
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
threads	int
,	O
&	O
set_threads	int
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
user_agent	*(char)
,	O
&	O
set_user_agent	int
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mytype	int
)	O
,	O
&	O
set_mytype	int
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myport	int
)	O
,	O
&	O
set_myport	int
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myhost	*(char)
)	O
,	O
&	O
set_myhost	int
)	O
;	O
break	O
;	O
case	O
'u'	O
:	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myuser	*(char)
)	O
,	O
&	O
set_myuser	int
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mypass	*(char)
)	O
,	O
&	O
set_mypass	int
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
)	O
,	O
&	O
set_checksite	int
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
checkreqin	*(char)
)	O
,	O
&	O
set_checkreqin	int
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
key	*(char)
)	O
,	O
&	O
set_key	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
rcvtimeo	int
)	O
,	O
&	O
set_rcvtimeo	int
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
sndtimeo	int
)	O
,	O
&	O
set_sndtimeo	int
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myconreplysize	int
)	O
,	O
&	O
set_myconreplysize	int
)	O
;	O
break	O
;	O
case	O
'T'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
test	struct(int,int,int,int,int)
.	O
testconreplysize	int
)	O
,	O
&	O
set_testconreplysize	int
)	O
;	O
break	O
;	O
case	O
'G'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
test	struct(int,int,int,int,int)
.	O
testtagreplysize	int
)	O
,	O
&	O
set_testtagreplysize	int
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
test	struct(int,int,int,int,int)
.	O
httptestmethod	int
)	O
,	O
&	O
set_httptestmethod	int
)	O
;	O
break	O
;	O
case	O
'5'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
test	struct(int,int,int,int,int)
.	O
socks5testmethod	int
)	O
,	O
&	O
set_socks5testmethod	int
)	O
;	O
break	O
;	O
case	O
'4'	O
:	O
optint	(*(char),*(int),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
test	struct(int,int,int,int,int)
.	O
socks4testmethod	int
)	O
,	O
&	O
set_socks4testmethod	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
(	O
logfilename	*(char)
)	O
,	O
&	O
set_logfilename	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
proxyknife_conf	*(char)
!=	O
NULL	O
)	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
proxyknife_conf	*(char)
,	O
"r"	*(char)
)	O
;	O
else	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
if	O
(	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
if	O
(	O
debug	int
)	O
perror	(*(char))->(void)
(	O
__FILE__	O
" READCONF:fopen:the configuration file in commandline"	*(char)
)	O
;	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
PROXYKNIFE_CONF	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
if	O
(	O
debug	int
)	O
perror	(*(char))->(void)
(	O
__FILE__	O
" "	*(char)
"READCONF:fopen:"	*(char)
PROXYKNIFE_CONF	*(char)
)	O
;	O
home	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
;	O
if	O
(	O
home	*(char)
!=	O
NULL	O
)	O
{	O
filenamelen	int
=	O
strlen	(*(char))->(long)
(	O
home	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
PROXYKNIFE_CONF	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
"/."	*(char)
)	O
;	O
filename	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
filenamelen	int
+	O
1	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
filename	*(char)
,	O
0	int
,	O
filenamelen	int
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
filename	*(char)
,	O
filenamelen	int
+	O
1	int
,	O
"%s/.%s"	*(char)
,	O
home	*(char)
,	O
PROXYKNIFE_CONF	*(char)
)	O
;	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
if	O
(	O
debug	int
)	O
perror	(*(char))->(void)
(	O
"READCONF:fopen:~/."	*(char)
PROXYKNIFE_CONF	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
debug	int
)	O
printf	(*(char))->(int)
(	O
"Using ~/."	*(char)
PROXYKNIFE_CONF	*(char)
"\n"	*(char)
)	O
;	O
}	O
xfree	(*(*(void)))->(void)
(	O
(	O
void	O
*	O
*	O
)	O
&	O
filename	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"READCONF:Using "	*(char)
PROXYKNIFE_CONF	*(char)
"\n"	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"READCONF:Using %s\n"	*(char)
,	O
proxyknife_conf	*(char)
)	O
;	O
}	O
if	O
(	O
proxyknife_conf	*(char)
!=	O
NULL	O
)	O
xfree	(*(*(void)))->(void)
(	O
(	O
void	O
*	O
*	O
)	O
&	O
proxyknife_conf	*(char)
)	O
;	O
if	O
(	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
filename	*(char)
=	O
SYSTEM_PROXYKNIFECONF	O
;	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
if	O
(	O
debug	int
)	O
{	O
perror	(*(char))->(void)
(	O
"READCONF:fopen:/etc/"	*(char)
PROXYKNIFE_CONF	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"READCONF:Can't find the configuration file!Use commadline options only!\n"	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
debug	int
)	O
printf	(*(char))->(int)
(	O
"Using "	*(char)
SYSTEM_PROXYKNIFECONF	O
"\n"	*(char)
)	O
;	O
}	O
}	O
slash	int
=	O
'/'	O
;	O
colon	int
=	O
':'	O
;	O
if	O
(	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
while	O
(	O
1	int
)	O
{	O
line	*(char)
=	O
NULL	O
;	O
linelen	int
=	O
80	int
;	O
read	*((*(void),*(char),long)->(long))
=	O
getaline	(*(*(char)),*(int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
(	O
unsigned	O
char	O
*	O
*	O
)	O
&	O
line	*(char)
,	O
&	O
linelen	int
,	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
read	*((*(void),*(char),long)->(long))
==	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
read	*((*(void),*(char),long)->(long))
>	O
0	int
)	O
{	O
if	O
(	O
line	*(char)
[	O
0	int
]	O
==	O
'#'	O
)	O
{	O
xfree	(*(*(void)))->(void)
(	O
(	O
void	O
*	O
*	O
)	O
&	O
line	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
line	*(char)
[	O
read	*((*(void),*(char),long)->(long))
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	*(char)
[	O
read	*((*(void),*(char),long)->(long))
-	O
1	int
]	O
=	O
0	int
;	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"threads="	*(char)
,	O
&	O
threads	int
,	O
&	O
set_threads	int
)	O
||	O
!	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
line	*(char)
,	O
"user_agent="	*(char)
,	O
&	O
user_agent	*(char)
,	O
&	O
set_user_agent	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"mytype="	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mytype	int
)	O
,	O
&	O
set_mytype	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"myport="	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myport	int
)	O
,	O
&	O
set_myport	int
)	O
||	O
!	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
line	*(char)
,	O
"myhost="	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myhost	*(char)
)	O
,	O
&	O
set_myhost	int
)	O
||	O
!	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
line	*(char)
,	O
"myuser="	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myuser	*(char)
)	O
,	O
&	O
set_myuser	int
)	O
||	O
!	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
line	*(char)
,	O
"mypass="	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mypass	*(char)
)	O
,	O
&	O
set_mypass	int
)	O
||	O
!	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
line	*(char)
,	O
"checksite="	*(char)
,	O
&	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
)	O
,	O
&	O
set_checksite	int
)	O
||	O
!	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
line	*(char)
,	O
"checkreqin="	*(char)
,	O
&	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
checkreqin	*(char)
)	O
,	O
&	O
set_checkreqin	int
)	O
||	O
!	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
line	*(char)
,	O
"key="	*(char)
,	O
&	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
key	*(char)
)	O
,	O
&	O
set_key	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"rcvtimeo="	*(char)
,	O
&	O
(	O
rcvtimeo	int
)	O
,	O
&	O
set_rcvtimeo	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"sndtimeo="	*(char)
,	O
&	O
(	O
sndtimeo	int
)	O
,	O
&	O
set_sndtimeo	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"myconreplysize="	*(char)
,	O
&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myconreplysize	int
)	O
,	O
&	O
set_myconreplysize	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"testconreplysize="	*(char)
,	O
&	O
(	O
test	struct(int,int,int,int,int)
.	O
testconreplysize	int
)	O
,	O
&	O
set_testconreplysize	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"testtagreplysize="	*(char)
,	O
&	O
(	O
test	struct(int,int,int,int,int)
.	O
testtagreplysize	int
)	O
,	O
&	O
set_testtagreplysize	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"httptestmethod="	*(char)
,	O
&	O
(	O
test	struct(int,int,int,int,int)
.	O
httptestmethod	int
)	O
,	O
&	O
set_httptestmethod	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"socks5testmethod="	*(char)
,	O
&	O
(	O
test	struct(int,int,int,int,int)
.	O
socks5testmethod	int
)	O
,	O
&	O
set_socks5testmethod	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"socks4testmethod="	*(char)
,	O
&	O
(	O
test	struct(int,int,int,int,int)
.	O
socks4testmethod	int
)	O
,	O
&	O
set_socks4testmethod	int
)	O
||	O
!	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
line	*(char)
,	O
"logfilename="	*(char)
,	O
&	O
(	O
logfilename	*(char)
)	O
,	O
&	O
set_logfilename	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"proxyknifeintype="	*(char)
,	O
&	O
(	O
proxyknife_in_type	int
)	O
,	O
&	O
set_proxyknifeintype	int
)	O
||	O
!	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
line	*(char)
,	O
"proxyknifein="	*(char)
,	O
&	O
(	O
proxyknife_in	*(char)
)	O
,	O
&	O
set_proxyknifein	int
)	O
||	O
!	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
line	*(char)
,	O
"proxyknifeout="	*(char)
,	O
&	O
(	O
proxyknife_out	*(char)
)	O
,	O
&	O
set_proxyknifeout	int
)	O
||	O
!	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
line	*(char)
,	O
"debug="	*(char)
,	O
&	O
debug	int
,	O
&	O
set_debug	int
)	O
;	O
}	O
if	O
(	O
line	*(char)
)	O
xfree	(*(*(void)))->(void)
(	O
(	O
void	O
*	O
*	O
)	O
&	O
line	*(char)
)	O
;	O
}	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
conf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
__FILE__	O
": READCONF:fclose: configuration file"	*(char)
)	O
;	O
xexit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
if	O
(	O
set_mytype	int
*	O
set_httptestmethod	int
*	O
set_socks5testmethod	int
*	O
set_socks4testmethod	int
*	O
set_rcvtimeo	int
*	O
set_sndtimeo	int
*	O
set_checksite	int
*	O
set_key	int
*	O
set_user_agent	int
*	O
set_threads	int
*	O
set_myconreplysize	int
*	O
set_testconreplysize	int
*	O
set_testtagreplysize	int
*	O
set_logfilename	int
)	O
{	O
if	O
(	O
debug	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: READCONF:not all parameters reset:"	*(char)
,	O
progname	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"set flags are checked:\n"	*(char)
"\tmytype:%d\n"	*(char)
"\thttptestmethod:%d\n"	*(char)
"\tsocks5testmethod:%d\n"	*(char)
"\tsocks4testmethod:%d\n"	*(char)
"\trcvtimeo:%d\n"	*(char)
"\tsndtimeo:%d\n"	*(char)
"\tchecksite:%d\n"	*(char)
"\tkey:%d\n"	*(char)
"\tuser_agent:%d\n"	*(char)
"\tthreads:%d\n"	*(char)
"\tmyconreplysize:%d\n"	*(char)
"\ttestconreplysize:%d\n"	*(char)
"\ttesttagreplysize:%d\n"	*(char)
"\tlogfilename:%d\n"	*(char)
,	O
set_mytype	int
,	O
set_httptestmethod	int
,	O
set_socks5testmethod	int
,	O
set_socks4testmethod	int
,	O
set_rcvtimeo	int
,	O
set_sndtimeo	int
,	O
set_checksite	int
,	O
set_key	int
,	O
set_user_agent	int
,	O
set_threads	int
,	O
set_myconreplysize	int
,	O
set_testconreplysize	int
,	O
set_testtagreplysize	int
,	O
set_logfilename	int
)	O
;	O
}	O
}	O
if	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mytype	int
!=	O
DIRECT	int
)	O
{	O
if	O
(	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mytype	int
==	O
HTTP_CONNECT_AUTH	int
)	O
||	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mytype	int
==	O
SOCKS5_CONNECT_AUTH	int
)	O
)	O
{	O
if	O
(	O
(	O
set_myuser	int
==	O
0	int
)	O
||	O
(	O
set_mypass	int
==	O
0	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: READCONF:Parameters:myuser or mypass isn't set\n"	*(char)
,	O
progname	*(char)
)	O
;	O
xexit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mytype	int
!=	O
HTTP_CONNECT	int
)	O
&&	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mytype	int
!=	O
SOCKS5_CONNECT	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: READCONF: Parameters:mytype %d is not supported now!\n"	*(char)
,	O
progname	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mytype	int
)	O
;	O
xexit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
set_myhost	int
*	O
set_myport	int
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: READCONF:Parameters:myhost or myport isn't set!\n"	*(char)
,	O
progname	*(char)
)	O
;	O
xexit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
{	O
}	O
p	*(*(void))
=	O
strstr	(*(char),*(char))->(*(char))
(	O
(	O
const	O
char	O
*	O
)	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
,	O
(	O
const	O
char	O
*	O
)	O
"://"	*(char)
)	O
;	O
if	O
(	O
p	*(*(void))
==	O
NULL	O
)	O
{	O
if	O
(	O
debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s %s: READCONF: No '://' found in %s\n"	*(char)
,	O
progname	*(char)
,	O
__FILE__	O
,	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
)	O
;	O
p	*(*(void))
=	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
;	O
}	O
else	O
{	O
stringlen	int
=	O
p	*(*(void))
-	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
;	O
if	O
(	O
stringlen	int
!=	O
0	int
)	O
{	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
protocol	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
stringlen	int
+	O
1	int
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
protocol	*(char)
,	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
,	O
stringlen	int
)	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
protocol	*(char)
[	O
stringlen	int
]	O
=	O
'\0'	O
;	O
}	O
p	*(*(void))
+=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
"://"	*(char)
)	O
;	O
}	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(*(void))
,	O
colon	int
)	O
;	O
if	O
(	O
q	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s %s: READCONF: No ':' found in %s\n"	*(char)
,	O
progname	*(char)
,	O
__FILE__	O
,	O
p	*(*(void))
)	O
;	O
xexit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
stringlen	int
=	O
q	*(char)
-	O
p	*(*(void))
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targethost	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
stringlen	int
+	O
1	int
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targethost	*(char)
,	O
p	*(*(void))
,	O
stringlen	int
)	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targethost	*(char)
[	O
stringlen	int
]	O
=	O
'\0'	O
;	O
p	*(*(void))
=	O
q	*(char)
+	O
1	int
;	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(*(void))
,	O
slash	int
)	O
;	O
if	O
(	O
q	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s %s: READCONF: No '/' found in %s\n"	*(char)
,	O
progname	*(char)
,	O
__FILE__	O
,	O
p	*(*(void))
)	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetpath	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
2	int
)	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetpath	*(char)
[	O
0	int
]	O
=	O
'/'	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetpath	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
stringlen	int
=	O
strlen	(*(char))->(long)
(	O
p	*(*(void))
)	O
;	O
}	O
else	O
{	O
stringlen	int
=	O
strlen	(*(char))->(long)
(	O
q	*(char)
)	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetpath	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
stringlen	int
+	O
1	int
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetpath	*(char)
,	O
q	*(char)
,	O
stringlen	int
)	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetpath	*(char)
[	O
stringlen	int
]	O
=	O
'\0'	O
;	O
stringlen	int
=	O
q	*(char)
-	O
p	*(*(void))
;	O
}	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetport	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
stringlen	int
+	O
1	int
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetport	*(char)
,	O
p	*(*(void))
,	O
stringlen	int
)	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetport	*(char)
[	O
stringlen	int
]	O
=	O
'\0'	O
;	O
h	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targethost	*(char)
)	O
;	O
if	O
(	O
h	*(struct(*(char),*(*(char)),int,int,*(*(char))))
==	O
NULL	O
)	O
{	O
herror	(*(char))->(void)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targethost	*(char)
)	O
;	O
xexit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetaddr	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
=	O
*	O
(	O
struct	O
in_addr	struct(int)
*	O
)	O
(	O
h	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addr	O
)	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetaddr	struct(short,short,struct(int),array(char))
.	O
sin_port	short
=	O
htons	(short)->(short)
(	O
atoi	(*(char))->(int)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetport	*(char)
)	O
)	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetaddr	struct(short,short,struct(int),array(char))
.	O
sin_family	short
=	O
AF_INET	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetaddr	struct(short,short,struct(int),array(char))
.	O
sin_zero	array(char)
)	O
,	O
0	int
,	O
sizeof	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetaddr	struct(short,short,struct(int),array(char))
.	O
sin_zero	array(char)
)	O
)	O
;	O
if	O
(	O
proxyknife_in	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
proxyknife_in_type	int
==	O
IN_HTTP	int
)	O
{	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
PROXYKNIFE_DEFAULT_LISTSITE	*(char)
,	O
&	O
proxyknife_in	*(char)
,	O
&	O
set_proxyknifein	int
)	O
;	O
}	O
else	O
{	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
PROXYKNIFE_IN	*(char)
,	O
&	O
proxyknife_in	*(char)
,	O
&	O
set_proxyknifein	int
)	O
;	O
}	O
}	O
if	O
(	O
proxyknife_out	*(char)
==	O
NULL	O
)	O
{	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
PROXYKNIFE_OUT	*(char)
,	O
&	O
proxyknife_out	*(char)
,	O
&	O
set_proxyknifeout	int
)	O
;	O
}	O
if	O
(	O
debug	int
)	O
{	O
printf	(*(char))->(int)
(	O
"setting:\n"	*(char)
"\tlogfilename=%s\n"	*(char)
"\ttarget=%s\n"	*(char)
"\ttargethost=%s\n"	*(char)
"\ttargetport=%s\n"	*(char)
"\ttargetpath=%s\n"	*(char)
"\tkey=%s\n"	*(char)
"\thttptestmethod=%d\n"	*(char)
"\tsocks5testmethod=%d\n"	*(char)
"\tsocks4testmethod=%d\n"	*(char)
"\tthreads=%d\n"	*(char)
"\tuser_agent=%s\n"	*(char)
"\trcvtimeo=%d\n"	*(char)
"\tsndtimeo=%d\n"	*(char)
"\ttestconreplysize=%d\n"	*(char)
"\ttesttagreplysize=%d\n"	*(char)
"\tproxyknife_in_type=%d\n"	*(char)
"\tproxyknife_in=%s\n"	*(char)
"\tproxyknife_out=%s\n"	*(char)
"\tdebug=%d\n"	*(char)
,	O
logfilename	*(char)
,	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
,	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targethost	*(char)
,	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetport	*(char)
,	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetpath	*(char)
,	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
key	*(char)
,	O
test	struct(int,int,int,int,int)
.	O
httptestmethod	int
,	O
test	struct(int,int,int,int,int)
.	O
socks5testmethod	int
,	O
test	struct(int,int,int,int,int)
.	O
socks4testmethod	int
,	O
threads	int
,	O
user_agent	*(char)
,	O
rcvtimeo	int
,	O
sndtimeo	int
,	O
test	struct(int,int,int,int,int)
.	O
testconreplysize	int
,	O
test	struct(int,int,int,int,int)
.	O
testtagreplysize	int
,	O
proxyknife_in_type	int
,	O
proxyknife_in	*(char)
,	O
proxyknife_out	*(char)
,	O
debug	int
)	O
;	O
switch	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mytype	int
)	O
{	O
case	O
DIRECT	int
:	O
printf	(*(char))->(int)
(	O
"\tmytype=DIRECT\n"	*(char)
)	O
;	O
break	O
;	O
case	O
HTTP_CONNECT	int
:	O
printf	(*(char))->(int)
(	O
"\tmytype=HTTP_CONNECT\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\tmyhost=%s\n\tmyport=%d\n"	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myhost	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myport	int
)	O
;	O
break	O
;	O
case	O
HTTP_CONNECT_AUTH	int
:	O
printf	(*(char))->(int)
(	O
"\tmytype=HTTP_CONNECT_AUTH\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\tmyhost=%s\n\tmyport=%d\n"	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myhost	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myport	int
)	O
;	O
printf	(*(char))->(int)
(	O
"\tmyuser=%s\n\tmypass=%s\n"	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myuser	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mypass	*(char)
)	O
;	O
break	O
;	O
case	O
SOCKS5_CONNECT	int
:	O
printf	(*(char))->(int)
(	O
"\tmytype=SOCKS5_CONNECT\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\tmyhost=%s\n\tmyport=%d\n"	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myhost	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myport	int
)	O
;	O
break	O
;	O
case	O
SOCKS5_CONNECT_AUTH	int
:	O
printf	(*(char))->(int)
(	O
"\tmytype=SOCKS5_CONNECT_AUTH\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\tmyhost=%s\n\tmyport=%d\n"	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myhost	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myport	int
)	O
;	O
printf	(*(char))->(int)
(	O
"\tmyuser=%s\n\tmypass=%s\n"	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myuser	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mypass	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s:READCONF:Parameters:invalid mytype:%d!This shouldn't happen!\n"	*(char)
,	O
progname	*(char)
,	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mytype	int
)	O
;	O
xexit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
int	O
readint	(*(char),*(char),*(int),*(int))->(int)
(	O
char	O
*	O
line	*(char)
,	O
char	O
*	O
flagstring	*(char)
,	O
int	O
*	O
i	*(int)
,	O
int	O
*	O
num	*(int)
)	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
line	*(char)
,	O
flagstring	*(char)
,	O
strlen	(*(char))->(long)
(	O
flagstring	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
*	O
num	*(int)
)	O
{	O
if	O
(	O
debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Duplicate configuration:%s -- ignored!\n"	*(char)
,	O
line	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
*	O
i	*(int)
=	O
atoi	(*(char))->(int)
(	O
line	*(char)
+	O
strlen	(*(char))->(long)
(	O
flagstring	*(char)
)	O
)	O
;	O
(	O
*	O
num	*(int)
)	O
++	O
;	O
return	O
0	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
readstr	(*(char),*(char),*(*(char)),*(int))->(int)
(	O
char	O
*	O
line	*(char)
,	O
char	O
*	O
flagstring	*(char)
,	O
char	O
*	O
*	O
s	*(*(char))
,	O
int	O
*	O
num	*(int)
)	O
{	O
int	O
flagsize	int
,	O
len	int
;	O
flagsize	int
=	O
strlen	(*(char))->(long)
(	O
flagstring	*(char)
)	O
;	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
line	*(char)
,	O
flagstring	*(char)
,	O
flagsize	int
)	O
)	O
{	O
if	O
(	O
*	O
num	*(int)
)	O
{	O
if	O
(	O
debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Duplicate configuration:%s -- ignored!\n"	*(char)
,	O
line	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
len	int
=	O
strlen	(*(char))->(long)
(	O
line	*(char)
)	O
-	O
flagsize	int
+	O
1	int
;	O
*	O
s	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
len	int
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
*	O
s	*(*(char))
,	O
line	*(char)
+	O
flagsize	int
,	O
len	int
)	O
;	O
(	O
*	O
num	*(int)
)	O
++	O
;	O
return	O
0	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
void	O
*	O
xstrdup	(*(char))->(*(void))
(	O
char	O
*	O
s	*(*(char))
)	O
{	O
int	O
len	int
;	O
char	O
*	O
p	*(*(void))
;	O
assert	O
(	O
s	*(*(char))
!=	O
NULL	O
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
s	*(*(char))
)	O
;	O
assert	O
(	O
len	int
!=	O
0	int
)	O
;	O
len	int
++	O
;	O
p	*(*(void))
=	O
xmalloc	(long)->(*(void))
(	O
len	int
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
p	*(*(void))
,	O
s	*(*(char))
,	O
len	int
)	O
;	O
return	O
p	*(*(void))
;	O
}	O
void	O
optstr	(*(char),*(*(char)),*(int))->(void)
(	O
char	O
*	O
value	int
,	O
char	O
*	O
*	O
s	*(*(char))
,	O
int	O
*	O
num	*(int)
)	O
{	O
int	O
len	int
;	O
if	O
(	O
*	O
num	*(int)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
__FILE__	O
": Duplication commandline options: %s!\n"	*(char)
,	O
value	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
value	int
!=	O
NULL	O
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
value	int
)	O
+	O
1	int
;	O
*	O
s	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
len	int
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
*	O
s	*(*(char))
,	O
value	int
,	O
len	int
)	O
;	O
(	O
*	O
num	*(int)
)	O
++	O
;	O
}	O
}	O
void	O
optint	(*(char),*(int),*(int))->(void)
(	O
char	O
*	O
value	int
,	O
int	O
*	O
i	*(int)
,	O
int	O
*	O
num	*(int)
)	O
{	O
if	O
(	O
*	O
num	*(int)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Duplicate commandline options :%s \n"	*(char)
,	O
value	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
*	O
i	*(int)
=	O
atoi	(*(char))->(int)
(	O
value	int
)	O
;	O
(	O
*	O
num	*(int)
)	O
++	O
;	O
}	O
}	O
