void	O
ComputeRotationMatrix	(double,*(struct(double,double,double)),*(struct(array(array(double)))))->(void)
(	O
double	O
r	*(struct(double,double,double))
,	O
VPoint	struct(double,double,double)
*	O
e	*(struct(double,double,double))
,	O
VMatrix	struct(array(array(double)))
*	O
m	array(array(double))
)	O
;	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
ScalePolygon	(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)),*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)),double)->(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
(	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
in	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
,	O
VPoint	struct(double,double,double)
*	O
offset	*(struct(double,double,double))
,	O
VPoint	struct(double,double,double)
*	O
scale	int
,	O
VPoint	struct(double,double,double)
*	O
e	*(struct(double,double,double))
,	O
double	O
r	*(struct(double,double,double))
)	O
{	O
int	O
numVtces	short
=	O
in	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
numVtces	short
,	O
i	int
;	O
VPoint	struct(double,double,double)
*	O
vert	*(struct(double,double,double))
;	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
;	O
VPoint	struct(double,double,double)
a	*(struct(double,double,double))
,	O
b	*(struct(double,double,double))
,	O
tmp	struct(double,double,double)
,	O
offset1	struct(double,double,double)
;	O
VMatrix	struct(array(array(double)))
m	array(array(double))
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
=	O
(	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
)	O
Vmalloc	(int)->(*(char))
(	O
sizeof	O
(	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
)	O
)	O
;	O
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
=	O
*	O
in	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
numVtces	short
=	O
numVtces	short
;	O
vert	*(struct(double,double,double))
=	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
vertex	*(struct(double,double,double))
=	O
(	O
VPoint	struct(double,double,double)
*	O
)	O
Vmalloc	(int)->(*(char))
(	O
sizeof	O
(	O
VPoint	struct(double,double,double)
)	O
*	O
numVtces	short
)	O
;	O
ComputeRotationMatrix	(double,*(struct(double,double,double)),*(struct(array(array(double)))))->(void)
(	O
r	*(struct(double,double,double))
,	O
e	*(struct(double,double,double))
,	O
&	O
m	array(array(double))
)	O
;	O
VTransform_	(*(struct(double,double,double)),*(struct(array(array(double)))),*(struct(double,double,double)))->(void)
(	O
offset	*(struct(double,double,double))
,	O
&	O
m	array(array(double))
,	O
&	O
offset1	struct(double,double,double)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numVtces	short
;	O
++	O
i	int
)	O
{	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
vertex	*(struct(double,double,double))
[	O
i	int
]	O
=	O
in	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
vertex	*(struct(double,double,double))
[	O
i	int
]	O
;	O
VTransform_	(*(struct(double,double,double)),*(struct(array(array(double)))),*(struct(double,double,double)))->(void)
(	O
&	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
vertex	*(struct(double,double,double))
[	O
i	int
]	O
,	O
&	O
m	array(array(double))
,	O
&	O
tmp	struct(double,double,double)
)	O
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
vertex	*(struct(double,double,double))
[	O
i	int
]	O
.	O
x	double
=	O
tmp	struct(double,double,double)
.	O
x	double
*	O
scale	int
->	O
x	double
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
vertex	*(struct(double,double,double))
[	O
i	int
]	O
.	O
y	double
=	O
tmp	struct(double,double,double)
.	O
y	double
*	O
scale	int
->	O
y	double
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
vertex	*(struct(double,double,double))
[	O
i	int
]	O
.	O
z	double
=	O
tmp	struct(double,double,double)
.	O
z	double
*	O
scale	int
->	O
z	double
;	O
}	O
if	O
(	O
(	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
flags	short
&	O
PolyNormalValid	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
flags	short
&	O
PolyClipBackface	int
)	O
!=	O
0	int
||	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
backColor	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
!=	O
(	O
VColor	struct(*(char),short,short,*(struct(*(char),short,short,*(struct(*`,short,short,*`)))))
*	O
)	O
NULL	O
)	O
{	O
a	*(struct(double,double,double))
.	O
x	double
=	O
vert	*(struct(double,double,double))
[	O
0	int
]	O
.	O
x	double
-	O
vert	*(struct(double,double,double))
[	O
1	int
]	O
.	O
x	double
;	O
a	*(struct(double,double,double))
.	O
y	double
=	O
vert	*(struct(double,double,double))
[	O
0	int
]	O
.	O
y	double
-	O
vert	*(struct(double,double,double))
[	O
1	int
]	O
.	O
y	double
;	O
a	*(struct(double,double,double))
.	O
z	double
=	O
vert	*(struct(double,double,double))
[	O
0	int
]	O
.	O
z	double
-	O
vert	*(struct(double,double,double))
[	O
1	int
]	O
.	O
z	double
;	O
b	*(struct(double,double,double))
.	O
x	double
=	O
vert	*(struct(double,double,double))
[	O
2	int
]	O
.	O
x	double
-	O
vert	*(struct(double,double,double))
[	O
1	int
]	O
.	O
x	double
;	O
b	*(struct(double,double,double))
.	O
y	double
=	O
vert	*(struct(double,double,double))
[	O
2	int
]	O
.	O
y	double
-	O
vert	*(struct(double,double,double))
[	O
1	int
]	O
.	O
y	double
;	O
b	*(struct(double,double,double))
.	O
z	double
=	O
vert	*(struct(double,double,double))
[	O
2	int
]	O
.	O
z	double
-	O
vert	*(struct(double,double,double))
[	O
1	int
]	O
.	O
z	double
;	O
VCrossProd	(*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)))->(void)
(	O
&	O
a	*(struct(double,double,double))
,	O
&	O
b	*(struct(double,double,double))
,	O
&	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
normal	struct(double,double,double)
)	O
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
flags	short
|=	O
PolyNormalValid	int
;	O
}	O
}	O
return	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
;	O
}	O
void	O
ComputeRotationMatrix	(double,*(struct(double,double,double)),*(struct(array(array(double)))))->(void)
(	O
double	O
r	*(struct(double,double,double))
,	O
VPoint	struct(double,double,double)
*	O
e	*(struct(double,double,double))
,	O
VMatrix	struct(array(array(double)))
*	O
m	array(array(double))
)	O
{	O
double	O
one64th	double
=	O
1.0	int
/	O
64.0	int
,	O
ma	double
;	O
VPoint	struct(double,double,double)
Ax	struct(double,double,double)
,	O
Ay	struct(double,double,double)
,	O
Wy	struct(double,double,double)
=	O
{	O
0	int
,	O
1	int
,	O
0	int
}	O
,	O
Wz	struct(double,double,double)
=	O
{	O
0	int
,	O
0	int
,	O
1	int
}	O
;	O
VMatrix	struct(array(array(double)))
tm	struct(array(array(double)))
,	O
tm1	struct(array(array(double)))
;	O
VIdentMatrix	(*(struct(array(array(double)))))->(void)
(	O
&	O
tm	struct(array(array(double)))
)	O
;	O
if	O
(	O
r	*(struct(double,double,double))
!=	O
0.0	int
)	O
{	O
VRotate	(*(struct(array(array(double)))),int,double)->(*(struct(array(array(double)))))
(	O
&	O
tm	struct(array(array(double)))
,	O
ZRotation	int
,	O
r	*(struct(double,double,double))
*	O
M_PI	int
/	O
180.0	int
)	O
;	O
}	O
if	O
(	O
fabs	(double)->(double)
(	O
e	*(struct(double,double,double))
->	O
x	double
)	O
<	O
one64th	double
&&	O
fabs	(double)->(double)
(	O
e	*(struct(double,double,double))
->	O
y	double
)	O
<	O
one64th	double
)	O
{	O
VCrossProd	(*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)))->(void)
(	O
&	O
Wy	struct(double,double,double)
,	O
e	*(struct(double,double,double))
,	O
&	O
Ax	struct(double,double,double)
)	O
;	O
}	O
else	O
{	O
VCrossProd	(*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)))->(void)
(	O
&	O
Wz	struct(double,double,double)
,	O
e	*(struct(double,double,double))
,	O
&	O
Ax	struct(double,double,double)
)	O
;	O
}	O
ma	double
=	O
sqrt	(double)->(double)
(	O
Ax	struct(double,double,double)
.	O
x	double
*	O
Ax	struct(double,double,double)
.	O
x	double
+	O
Ax	struct(double,double,double)
.	O
y	double
*	O
Ax	struct(double,double,double)
.	O
y	double
+	O
Ax	struct(double,double,double)
.	O
z	double
*	O
Ax	struct(double,double,double)
.	O
z	double
)	O
;	O
Ax	struct(double,double,double)
.	O
x	double
/=	O
ma	double
;	O
Ax	struct(double,double,double)
.	O
y	double
/=	O
ma	double
;	O
Ax	struct(double,double,double)
.	O
z	double
/=	O
ma	double
;	O
VCrossProd	(*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)))->(void)
(	O
e	*(struct(double,double,double))
,	O
&	O
Ax	struct(double,double,double)
,	O
&	O
Ay	struct(double,double,double)
)	O
;	O
ma	double
=	O
sqrt	(double)->(double)
(	O
Ay	struct(double,double,double)
.	O
x	double
*	O
Ay	struct(double,double,double)
.	O
x	double
+	O
Ay	struct(double,double,double)
.	O
y	double
*	O
Ay	struct(double,double,double)
.	O
y	double
+	O
Ay	struct(double,double,double)
.	O
z	double
*	O
Ay	struct(double,double,double)
.	O
z	double
)	O
;	O
Ay	struct(double,double,double)
.	O
x	double
/=	O
ma	double
;	O
Ay	struct(double,double,double)
.	O
y	double
/=	O
ma	double
;	O
Ay	struct(double,double,double)
.	O
z	double
/=	O
ma	double
;	O
VIdentMatrix	(*(struct(array(array(double)))))->(void)
(	O
m	array(array(double))
)	O
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
0	int
]	O
=	O
Ax	struct(double,double,double)
.	O
x	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
0	int
]	O
=	O
Ax	struct(double,double,double)
.	O
y	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
0	int
]	O
=	O
Ax	struct(double,double,double)
.	O
z	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
1	int
]	O
=	O
Ay	struct(double,double,double)
.	O
x	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
1	int
]	O
=	O
Ay	struct(double,double,double)
.	O
y	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
1	int
]	O
=	O
Ay	struct(double,double,double)
.	O
z	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
2	int
]	O
=	O
e	*(struct(double,double,double))
->	O
x	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
2	int
]	O
=	O
e	*(struct(double,double,double))
->	O
y	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
2	int
]	O
=	O
e	*(struct(double,double,double))
->	O
z	double
;	O
VMatrixMultByRank	(*(struct(array(array(double)))),*(struct(array(array(double)))),*(struct(array(array(double)))),int)->(void)
(	O
&	O
tm	struct(array(array(double)))
,	O
m	array(array(double))
,	O
&	O
tm1	struct(array(array(double)))
,	O
3	int
)	O
;	O
*	O
m	array(array(double))
=	O
tm1	struct(array(array(double)))
;	O
}	O
