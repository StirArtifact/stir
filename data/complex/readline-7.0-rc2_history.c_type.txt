static	O
char	O
*	O
hist_inittime	()->(*(char))
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
*	O
the_history	*(*(struct(*(char),*(char),*(void))))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
*	O
)	O
NULL	O
;	O
static	O
int	O
history_stifled	int
;	O
static	O
int	O
history_size	int
;	O
int	O
history_max_entries	int
;	O
int	O
max_input_history	int
;	O
int	O
history_offset	int
;	O
int	O
history_length	int
;	O
int	O
history_base	int
=	O
1	int
;	O
HISTORY_STATE	struct(*(*(struct(*(char),*(char),*(void)))),int,int,int,int)
*	O
history_get_history_state	()->(*(struct(*(*(struct`)),int,int,int,int)))
(	O
)	O
{	O
HISTORY_STATE	struct(*(*(struct(*(char),*(char),*(void)))),int,int,int,int)
*	O
state	*(int)
;	O
state	*(int)
=	O
(	O
HISTORY_STATE	struct(*(*(struct(*(char),*(char),*(void)))),int,int,int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
HISTORY_STATE	struct(*(*(struct(*(char),*(char),*(void)))),int,int,int,int)
)	O
)	O
;	O
state	*(int)
->	O
entries	*(*(struct(*(char),*(char),*(void))))
=	O
the_history	*(*(struct(*(char),*(char),*(void))))
;	O
state	*(int)
->	O
offset	long
=	O
history_offset	int
;	O
state	*(int)
->	O
length	int
=	O
history_length	int
;	O
state	*(int)
->	O
size	int
=	O
history_size	int
;	O
state	*(int)
->	O
flags	int
=	O
0	int
;	O
if	O
(	O
history_stifled	int
)	O
state	*(int)
->	O
flags	int
|=	O
HS_STIFLED	int
;	O
return	O
(	O
state	*(int)
)	O
;	O
}	O
void	O
history_set_history_state	(*(struct(*(*(struct`)),int,int,int,int)))->(void)
(	O
state	*(int)
)	O
HISTORY_STATE	struct(*(*(struct(*(char),*(char),*(void)))),int,int,int,int)
*	O
state	*(int)
;	O
{	O
the_history	*(*(struct(*(char),*(char),*(void))))
=	O
state	*(int)
->	O
entries	*(*(struct(*(char),*(char),*(void))))
;	O
history_offset	int
=	O
state	*(int)
->	O
offset	long
;	O
history_length	int
=	O
state	*(int)
->	O
length	int
;	O
history_size	int
=	O
state	*(int)
->	O
size	int
;	O
if	O
(	O
state	*(int)
->	O
flags	int
&	O
HS_STIFLED	int
)	O
history_stifled	int
=	O
1	int
;	O
}	O
void	O
using_history	()->(void)
(	O
)	O
{	O
history_offset	int
=	O
history_length	int
;	O
}	O
int	O
history_total_bytes	()->(int)
(	O
)	O
{	O
register	O
int	O
i	int
,	O
result	int
;	O
for	O
(	O
i	int
=	O
result	int
=	O
0	int
;	O
the_history	*(*(struct(*(char),*(char),*(void))))
&&	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
result	int
+=	O
HISTENT_BYTES	O
(	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
i	int
]	O
)	O
;	O
return	O
(	O
result	int
)	O
;	O
}	O
int	O
where_history	()->(int)
(	O
)	O
{	O
return	O
(	O
history_offset	int
)	O
;	O
}	O
int	O
history_set_pos	(int)->(int)
(	O
pos	int
)	O
int	O
pos	int
;	O
{	O
if	O
(	O
pos	int
>	O
history_length	int
||	O
pos	int
<	O
0	int
||	O
!	O
the_history	*(*(struct(*(char),*(char),*(void))))
)	O
return	O
(	O
0	int
)	O
;	O
history_offset	int
=	O
pos	int
;	O
return	O
(	O
1	int
)	O
;	O
}	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
*	O
history_list	()->(*(*(struct(*(char),*(char),*(void)))))
(	O
)	O
{	O
return	O
(	O
the_history	*(*(struct(*(char),*(char),*(void))))
)	O
;	O
}	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
current_history	()->(*(struct(*(char),*(char),*(void))))
(	O
)	O
{	O
return	O
(	O
(	O
history_offset	int
==	O
history_length	int
)	O
||	O
the_history	*(*(struct(*(char),*(char),*(void))))
==	O
0	int
)	O
?	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
:	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
history_offset	int
]	O
;	O
}	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
previous_history	()->(*(struct(*(char),*(char),*(void))))
(	O
)	O
{	O
return	O
history_offset	int
?	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
--	O
history_offset	int
]	O
:	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
;	O
}	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
next_history	()->(*(struct(*(char),*(char),*(void))))
(	O
)	O
{	O
return	O
(	O
history_offset	int
==	O
history_length	int
)	O
?	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
:	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
++	O
history_offset	int
]	O
;	O
}	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
history_get	(int)->(*(struct(*(char),*(char),*(void))))
(	O
offset	long
)	O
int	O
offset	long
;	O
{	O
int	O
local_index	int
;	O
local_index	int
=	O
offset	long
-	O
history_base	int
;	O
return	O
(	O
local_index	int
>=	O
history_length	int
||	O
local_index	int
<	O
0	int
||	O
the_history	*(*(struct(*(char),*(char),*(void))))
==	O
0	int
)	O
?	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
:	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
local_index	int
]	O
;	O
}	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
alloc_history_entry	(*(char),*(char))->(*(struct(*(char),*(char),*(void))))
(	O
string	*(char)
,	O
ts	*(char)
)	O
char	O
*	O
string	*(char)
;	O
char	O
*	O
ts	*(char)
;	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
temp	*(struct(*(char),*(char),*(void)))
;	O
temp	*(struct(*(char),*(char),*(void)))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
)	O
)	O
;	O
temp	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
=	O
string	*(char)
?	O
savestring	O
(	O
string	*(char)
)	O
:	O
string	*(char)
;	O
temp	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
temp	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
=	O
ts	*(char)
;	O
return	O
temp	*(struct(*(char),*(char),*(void)))
;	O
}	O
time_t	long
history_get_time	(*(struct(*(char),*(char),*(void))))->(long)
(	O
hist	*(struct(*(char),*(char),*(void)))
)	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
hist	*(struct(*(char),*(char),*(void)))
;	O
{	O
char	O
*	O
ts	*(char)
;	O
time_t	long
t	long
;	O
if	O
(	O
hist	*(struct(*(char),*(char),*(void)))
==	O
0	int
||	O
hist	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
==	O
0	int
)	O
return	O
0	int
;	O
ts	*(char)
=	O
hist	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
;	O
if	O
(	O
ts	*(char)
[	O
0	int
]	O
!=	O
history_comment_char	char
)	O
return	O
0	int
;	O
errno	O
=	O
0	int
;	O
t	long
=	O
(	O
time_t	long
)	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
ts	*(char)
+	O
1	int
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
return	O
(	O
time_t	long
)	O
0	int
;	O
return	O
t	long
;	O
}	O
static	O
char	O
*	O
hist_inittime	()->(*(char))
(	O
)	O
{	O
time_t	long
t	long
;	O
char	O
ts	*(char)
[	O
64	int
]	O
,	O
*	O
ret	*(char)
;	O
t	long
=	O
(	O
time_t	long
)	O
time	struct(long,long)
(	O
(	O
time_t	long
*	O
)	O
0	int
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
ts	*(char)
,	O
sizeof	O
(	O
ts	*(char)
)	O
-	O
1	int
,	O
"X%lu"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
t	long
)	O
;	O
ret	*(char)
=	O
savestring	O
(	O
ts	*(char)
)	O
;	O
ret	*(char)
[	O
0	int
]	O
=	O
history_comment_char	char
;	O
return	O
ret	*(char)
;	O
}	O
void	O
add_history	(*(char))->(void)
(	O
string	*(char)
)	O
const	O
char	O
*	O
string	*(char)
;	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
temp	*(struct(*(char),*(char),*(void)))
;	O
if	O
(	O
history_stifled	int
&&	O
(	O
history_length	int
==	O
history_max_entries	int
)	O
)	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
history_length	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
0	int
]	O
)	O
(	O
void	O
)	O
free_history_entry	(*(struct(*(char),*(char),*(void))))->(*(void))
(	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
0	int
]	O
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
the_history	*(*(struct(*(char),*(char),*(void))))
,	O
the_history	*(*(struct(*(char),*(char),*(void))))
+	O
1	int
,	O
history_length	int
*	O
sizeof	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
)	O
;	O
history_base	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
history_size	int
==	O
0	int
)	O
{	O
if	O
(	O
history_stifled	int
&&	O
history_max_entries	int
>	O
0	int
)	O
history_size	int
=	O
history_max_entries	int
+	O
2	int
;	O
else	O
history_size	int
=	O
DEFAULT_HISTORY_INITIAL_SIZE	int
;	O
the_history	*(*(struct(*(char),*(char),*(void))))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
history_size	int
*	O
sizeof	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
)	O
;	O
history_length	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
history_length	int
==	O
(	O
history_size	int
-	O
1	int
)	O
)	O
{	O
history_size	int
+=	O
DEFAULT_HISTORY_GROW_SIZE	int
;	O
the_history	*(*(struct(*(char),*(char),*(void))))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
the_history	*(*(struct(*(char),*(char),*(void))))
,	O
history_size	int
*	O
sizeof	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
)	O
;	O
}	O
history_length	int
++	O
;	O
}	O
}	O
temp	*(struct(*(char),*(char),*(void)))
=	O
alloc_history_entry	(*(char),*(char))->(*(struct(*(char),*(char),*(void))))
(	O
(	O
char	O
*	O
)	O
string	*(char)
,	O
hist_inittime	()->(*(char))
(	O
)	O
)	O
;	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
history_length	int
]	O
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
;	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
history_length	int
-	O
1	int
]	O
=	O
temp	*(struct(*(char),*(char),*(void)))
;	O
}	O
void	O
add_history_time	(*(char))->(void)
(	O
string	*(char)
)	O
const	O
char	O
*	O
string	*(char)
;	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
hs	*(struct(*(char),*(char),*(void)))
;	O
if	O
(	O
string	*(char)
==	O
0	int
||	O
history_length	int
<	O
1	int
)	O
return	O
;	O
hs	*(struct(*(char),*(char),*(void)))
=	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
history_length	int
-	O
1	int
]	O
;	O
FREE	O
(	O
hs	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
)	O
;	O
hs	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
=	O
savestring	O
(	O
string	*(char)
)	O
;	O
}	O
histdata_t	*(void)
free_history_entry	(*(struct(*(char),*(char),*(void))))->(*(void))
(	O
hist	*(struct(*(char),*(char),*(void)))
)	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
hist	*(struct(*(char),*(char),*(void)))
;	O
{	O
histdata_t	*(void)
x	*(void)
;	O
if	O
(	O
hist	*(struct(*(char),*(char),*(void)))
==	O
0	int
)	O
return	O
(	O
(	O
histdata_t	*(void)
)	O
0	int
)	O
;	O
FREE	O
(	O
hist	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
)	O
;	O
FREE	O
(	O
hist	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
)	O
;	O
x	*(void)
=	O
hist	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
;	O
xfree	(*(void))->(void)
(	O
hist	*(struct(*(char),*(char),*(void)))
)	O
;	O
return	O
(	O
x	*(void)
)	O
;	O
}	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
copy_history_entry	(*(struct(*(char),*(char),*(void))))->(*(struct(*(char),*(char),*(void))))
(	O
hist	*(struct(*(char),*(char),*(void)))
)	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
hist	*(struct(*(char),*(char),*(void)))
;	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
ret	*(char)
;	O
char	O
*	O
ts	*(char)
;	O
if	O
(	O
hist	*(struct(*(char),*(char),*(void)))
==	O
0	int
)	O
return	O
hist	*(struct(*(char),*(char),*(void)))
;	O
ret	*(char)
=	O
alloc_history_entry	(*(char),*(char))->(*(struct(*(char),*(char),*(void))))
(	O
hist	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
ts	*(char)
=	O
hist	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
?	O
savestring	O
(	O
hist	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
)	O
:	O
hist	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
;	O
ret	*(char)
->	O
timestamp	*(char)
=	O
ts	*(char)
;	O
ret	*(char)
->	O
data	*(void)
=	O
hist	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
;	O
return	O
ret	*(char)
;	O
}	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
replace_history_entry	(int,*(char),*(void))->(*(struct(*(char),*(char),*(void))))
(	O
which	int
,	O
line	*(char)
,	O
data	*(void)
)	O
int	O
which	int
;	O
const	O
char	O
*	O
line	*(char)
;	O
histdata_t	*(void)
data	*(void)
;	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
temp	*(struct(*(char),*(char),*(void)))
,	O
*	O
old_value	*(struct(*(char),*(char),*(void)))
;	O
if	O
(	O
which	int
<	O
0	int
||	O
which	int
>=	O
history_length	int
)	O
return	O
(	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
)	O
;	O
temp	*(struct(*(char),*(char),*(void)))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
)	O
)	O
;	O
old_value	*(struct(*(char),*(char),*(void)))
=	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
which	int
]	O
;	O
temp	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
=	O
savestring	O
(	O
line	*(char)
)	O
;	O
temp	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
=	O
data	*(void)
;	O
temp	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
=	O
savestring	O
(	O
old_value	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
)	O
;	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
which	int
]	O
=	O
temp	*(struct(*(char),*(char),*(void)))
;	O
return	O
(	O
old_value	*(struct(*(char),*(char),*(void)))
)	O
;	O
}	O
void	O
_hs_append_history_line	(int,*(char))->(void)
(	O
which	int
,	O
line	*(char)
)	O
int	O
which	int
;	O
const	O
char	O
*	O
line	*(char)
;	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
hent	*(struct(*(char),*(char),*(void)))
;	O
size_t	long
newlen	long
,	O
curlen	long
;	O
char	O
*	O
newline	*(char)
;	O
hent	*(struct(*(char),*(char),*(void)))
=	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
which	int
]	O
;	O
curlen	long
=	O
strlen	(*(char))->(long)
(	O
hent	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
)	O
;	O
newlen	long
=	O
curlen	long
+	O
strlen	(*(char))->(long)
(	O
line	*(char)
)	O
+	O
2	int
;	O
newline	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
hent	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
,	O
newlen	long
)	O
;	O
if	O
(	O
newline	*(char)
)	O
{	O
hent	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
=	O
newline	*(char)
;	O
hent	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
[	O
curlen	long
++	O
]	O
=	O
'\n'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
hent	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
+	O
curlen	long
,	O
line	*(char)
)	O
;	O
}	O
}	O
void	O
_hs_replace_history_data	(int,*(*(void)),*(*(void)))->(void)
(	O
which	int
,	O
old	*(*(void))
,	O
new	*(*(void))
)	O
int	O
which	int
;	O
histdata_t	*(void)
*	O
old	*(*(void))
,	O
*	O
new	*(*(void))
;	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
entry	*(struct(*(char),*(char),*(void)))
;	O
register	O
int	O
i	int
,	O
last	int
;	O
if	O
(	O
which	int
<	O
-	O
2	int
||	O
which	int
>=	O
history_length	int
||	O
history_length	int
==	O
0	int
||	O
the_history	*(*(struct(*(char),*(char),*(void))))
==	O
0	int
)	O
return	O
;	O
if	O
(	O
which	int
>=	O
0	int
)	O
{	O
entry	*(struct(*(char),*(char),*(void)))
=	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
which	int
]	O
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(void)))
&&	O
entry	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
==	O
old	*(*(void))
)	O
entry	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
=	O
new	*(*(void))
;	O
return	O
;	O
}	O
last	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
history_length	int
;	O
i	int
++	O
)	O
{	O
entry	*(struct(*(char),*(char),*(void)))
=	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
i	int
]	O
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(void)))
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
==	O
old	*(*(void))
)	O
{	O
last	int
=	O
i	int
;	O
if	O
(	O
which	int
==	O
-	O
1	int
)	O
entry	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
=	O
new	*(*(void))
;	O
}	O
}	O
if	O
(	O
which	int
==	O
-	O
2	int
&&	O
last	int
>=	O
0	int
)	O
{	O
entry	*(struct(*(char),*(char),*(void)))
=	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
last	int
]	O
;	O
entry	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
=	O
new	*(*(void))
;	O
}	O
}	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
remove_history	(int)->(*(struct(*(char),*(char),*(void))))
(	O
which	int
)	O
int	O
which	int
;	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
return_value	*(struct(*(char),*(char),*(void)))
;	O
register	O
int	O
i	int
;	O
if	O
(	O
which	int
<	O
0	int
||	O
which	int
>=	O
history_length	int
||	O
history_length	int
==	O
0	int
||	O
the_history	*(*(struct(*(char),*(char),*(void))))
==	O
0	int
)	O
return	O
(	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
)	O
;	O
return_value	*(struct(*(char),*(char),*(void)))
=	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
which	int
]	O
;	O
for	O
(	O
i	int
=	O
which	int
;	O
i	int
<	O
history_length	int
;	O
i	int
++	O
)	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
i	int
]	O
=	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
i	int
+	O
1	int
]	O
;	O
history_length	int
--	O
;	O
return	O
(	O
return_value	*(struct(*(char),*(char),*(void)))
)	O
;	O
}	O
void	O
stifle_history	(int)->(void)
(	O
max	int
)	O
int	O
max	int
;	O
{	O
register	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
max	int
<	O
0	int
)	O
max	int
=	O
0	int
;	O
if	O
(	O
history_length	int
>	O
max	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
history_length	int
-	O
max	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
)	O
free_history_entry	(*(struct(*(char),*(char),*(void))))->(*(void))
(	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
i	int
]	O
)	O
;	O
history_base	int
=	O
i	int
;	O
for	O
(	O
j	int
=	O
0	int
,	O
i	int
=	O
history_length	int
-	O
max	int
;	O
j	int
<	O
max	int
;	O
i	int
++	O
,	O
j	int
++	O
)	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
j	int
]	O
=	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
i	int
]	O
;	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
j	int
]	O
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
;	O
history_length	int
=	O
j	int
;	O
}	O
history_stifled	int
=	O
1	int
;	O
max_input_history	int
=	O
history_max_entries	int
=	O
max	int
;	O
}	O
int	O
unstifle_history	()->(int)
(	O
)	O
{	O
if	O
(	O
history_stifled	int
)	O
{	O
history_stifled	int
=	O
0	int
;	O
return	O
(	O
history_max_entries	int
)	O
;	O
}	O
else	O
return	O
(	O
-	O
history_max_entries	int
)	O
;	O
}	O
int	O
history_is_stifled	()->(int)
(	O
)	O
{	O
return	O
(	O
history_stifled	int
)	O
;	O
}	O
void	O
clear_history	()->(void)
(	O
)	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
history_length	int
;	O
i	int
++	O
)	O
{	O
free_history_entry	(*(struct(*(char),*(char),*(void))))->(*(void))
(	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
i	int
]	O
)	O
;	O
the_history	*(*(struct(*(char),*(char),*(void))))
[	O
i	int
]	O
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
;	O
}	O
history_offset	int
=	O
history_length	int
=	O
0	int
;	O
}	O
