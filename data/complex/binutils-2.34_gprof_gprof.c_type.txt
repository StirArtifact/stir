static	O
void	O
usage	O
(	O
FILE	struct
*	O
,	O
int	O
)	O
ATTRIBUTE_NORETURN	O
;	O
const	O
char	O
*	O
whoami	O
;	O
const	O
char	O
*	O
function_mapping_file	O
;	O
static	O
const	O
char	O
*	O
external_symbol_table	O
;	O
const	O
char	O
*	O
a_out_name	O
=	O
A_OUTNAME	O
;	O
long	O
hz	O
=	O
HZ_WRONG	O
;	O
int	O
debug_level	O
=	O
0	int
;	O
int	O
output_style	O
=	O
0	int
;	O
int	O
output_width	O
=	O
80	int
;	O
bfd_boolean	int
bsd_style_output	O
=	O
FALSE	O
;	O
bfd_boolean	int
demangle	O
=	O
TRUE	int
;	O
bfd_boolean	int
ignore_direct_calls	O
=	O
FALSE	O
;	O
bfd_boolean	int
ignore_static_funcs	O
=	O
FALSE	O
;	O
bfd_boolean	int
ignore_zeros	O
=	O
TRUE	int
;	O
bfd_boolean	int
line_granularity	O
=	O
FALSE	O
;	O
bfd_boolean	int
print_descriptions	O
=	O
TRUE	int
;	O
bfd_boolean	int
print_path	O
=	O
FALSE	O
;	O
bfd_boolean	int
ignore_non_functions	O
=	O
FALSE	O
;	O
bfd_boolean	int
inline_file_names	O
=	O
FALSE	O
;	O
File_Format	O
file_format	O
=	O
FF_AUTO	O
;	O
bfd_boolean	int
first_output	O
=	O
TRUE	int
;	O
char	O
copyright	O
[	O
]	O
=	O
"@(#) Copyright (c) 1983 Regents of the University of California.\n All rights reserved.\n"	*(char)
;	O
static	O
char	O
*	O
gmon_name	O
=	O
GMONNAME	O
;	O
static	O
char	O
*	O
default_excluded_list	O
[	O
]	O
=	O
{	O
"_gprof_mcount"	*(char)
,	O
"mcount"	*(char)
,	O
"_mcount"	*(char)
,	O
"__mcount"	*(char)
,	O
"__mcount_internal"	*(char)
,	O
"__mcleanup"	*(char)
,	O
0	int
}	O
;	O
static	O
struct	O
option	O
long_options	O
[	O
]	O
=	O
{	O
{	O
"line"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"no-static"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"ignore-non-functions"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"external-symbol-table"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"annotated-source"	*(char)
,	O
optional_argument	O
,	O
0	int
,	O
'A'	O
}	O
,	O
{	O
"no-annotated-source"	*(char)
,	O
optional_argument	O
,	O
0	int
,	O
'J'	O
}	O
,	O
{	O
"flat-profile"	*(char)
,	O
optional_argument	O
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"no-flat-profile"	*(char)
,	O
optional_argument	O
,	O
0	int
,	O
'P'	O
}	O
,	O
{	O
"graph"	*(char)
,	O
optional_argument	O
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"no-graph"	*(char)
,	O
optional_argument	O
,	O
0	int
,	O
'Q'	O
}	O
,	O
{	O
"exec-counts"	*(char)
,	O
optional_argument	O
,	O
0	int
,	O
'C'	O
}	O
,	O
{	O
"no-exec-counts"	*(char)
,	O
optional_argument	O
,	O
0	int
,	O
'Z'	O
}	O
,	O
{	O
"function-ordering"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"file-ordering"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'R'	O
}	O
,	O
{	O
"file-info"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"sum"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"all-lines"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"demangle"	*(char)
,	O
optional_argument	O
,	O
0	int
,	O
OPTION_DEMANGLE	O
}	O
,	O
{	O
"no-demangle"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
OPTION_NO_DEMANGLE	O
}	O
,	O
{	O
"directory-path"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"display-unused-functions"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'z'	O
}	O
,	O
{	O
"inline-file-names"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
OPTION_INLINE_FILE_NAMES	O
}	O
,	O
{	O
"min-count"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'm'	O
}	O
,	O
{	O
"print-path"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"separate-files"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'y'	O
}	O
,	O
{	O
"static-call-graph"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"table-length"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"time"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"no-time"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'N'	O
}	O
,	O
{	O
"width"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'w'	O
}	O
,	O
{	O
""	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'e'	O
}	O
,	O
{	O
""	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'E'	O
}	O
,	O
{	O
""	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
""	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
""	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"brief"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"debug"	*(char)
,	O
optional_argument	O
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"file-format"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"traditional"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'T'	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
0	int
,	O
no_argument	O
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	O
(	O
FILE	struct
*	O
stream	*(void)
,	O
int	O
status	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
"Usage: %s [-[abcDhilLrsTvwxyz]] [-[ACeEfFJnNOpPqQRStZ][name]] [-I dirs]\n	[-d[num]] [-k from/to] [-m min-count] [-t table-length]\n	[--[no-]annotated-source[=name]] [--[no-]exec-counts[=name]]\n	[--[no-]flat-profile[=name]] [--[no-]graph[=name]]\n	[--[no-]time=name] [--all-lines] [--brief] [--debug[=level]]\n	[--function-ordering] [--file-ordering] [--inline-file-names]\n	[--directory-path=dirs] [--display-unused-functions]\n	[--file-format=name] [--file-info] [--help] [--line] [--min-count=n]\n	[--no-static] [--print-path] [--separate-files]\n	[--static-call-graph] [--sum] [--table-length=len] [--traditional]\n	[--version] [--width=n] [--ignore-non-functions]\n	[--demangle[=STYLE]] [--no-demangle] [--external-symbol-table=name] [@FILE]\n	[image-file] [profile-file...]\n"	*(char)
)	O
,	O
whoami	O
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	O
[	O
0	int
]	O
&&	O
status	int
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
"Report bugs to %s\n"	*(char)
)	O
,	O
REPORT_BUGS_TO	O
)	O
;	O
done	O
(	O
status	int
)	O
;	O
}	O
int	O
main	O
(	O
int	O
argc	O
,	O
char	O
*	O
*	O
argv	O
)	O
{	O
char	O
*	O
*	O
sp	O
,	O
*	O
str	O
;	O
Sym	O
*	O
*	O
cg	O
=	O
0	int
;	O
int	O
ch	O
,	O
user_specified	O
=	O
0	int
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	O
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	O
)	O
;	O
whoami	O
=	O
argv	O
[	O
0	int
]	O
;	O
xmalloc_set_program_name	O
(	O
whoami	O
)	O
;	O
expandargv	O
(	O
&	O
argc	O
,	O
&	O
argv	O
)	O
;	O
while	O
(	O
(	O
ch	O
=	O
getopt_long	O
(	O
argc	O
,	O
argv	O
,	O
"aA::bBcC::d::De:E:f:F:hiI:J::k:lLm:n:N:O:p::P::q::Q::rR:sS:t:Tvw:xyzZ::"	*(char)
,	O
long_options	O
,	O
0	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
ch	O
)	O
{	O
case	O
'a'	O
:	O
ignore_static_funcs	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'A'	O
:	O
if	O
(	O
optarg	*(char)
)	O
{	O
sym_id_add	O
(	O
optarg	*(char)
,	O
INCL_ANNO	O
)	O
;	O
}	O
output_style	O
|=	O
STYLE_ANNOTATED_SOURCE	O
;	O
user_specified	O
|=	O
STYLE_ANNOTATED_SOURCE	O
;	O
break	O
;	O
case	O
'b'	O
:	O
print_descriptions	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
'B'	O
:	O
output_style	O
|=	O
STYLE_CALL_GRAPH	O
;	O
user_specified	O
|=	O
STYLE_CALL_GRAPH	O
;	O
break	O
;	O
case	O
'c'	O
:	O
ignore_direct_calls	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'C'	O
:	O
if	O
(	O
optarg	*(char)
)	O
{	O
sym_id_add	O
(	O
optarg	*(char)
,	O
INCL_EXEC	O
)	O
;	O
}	O
output_style	O
|=	O
STYLE_EXEC_COUNTS	O
;	O
user_specified	O
|=	O
STYLE_EXEC_COUNTS	O
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
optarg	*(char)
)	O
{	O
debug_level	O
|=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
debug_level	O
|=	O
ANYDEBUG	O
;	O
}	O
else	O
{	O
debug_level	O
=	O
~	O
0	int
;	O
}	O
DBG	O
(	O
ANYDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[main] debug-level=0x%x\n"	*(char)
,	O
debug_level	O
)	O
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
ignore_non_functions	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'E'	O
:	O
sym_id_add	O
(	O
optarg	*(char)
,	O
EXCL_TIME	O
)	O
;	O
case	O
'e'	O
:	O
sym_id_add	O
(	O
optarg	*(char)
,	O
EXCL_GRAPH	O
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
sym_id_add	O
(	O
optarg	*(char)
,	O
INCL_TIME	O
)	O
;	O
case	O
'f'	O
:	O
sym_id_add	O
(	O
optarg	*(char)
,	O
INCL_GRAPH	O
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
sym_id_add	O
(	O
optarg	*(char)
,	O
EXCL_FLAT	O
)	O
;	O
break	O
;	O
case	O
'G'	O
:	O
sym_id_add	O
(	O
optarg	*(char)
,	O
INCL_FLAT	O
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	O
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
)	O
;	O
case	O
'i'	O
:	O
output_style	O
|=	O
STYLE_GMON_INFO	O
;	O
user_specified	O
|=	O
STYLE_GMON_INFO	O
;	O
break	O
;	O
case	O
'I'	O
:	O
search_list_append	O
(	O
&	O
src_search_list	O
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'J'	O
:	O
if	O
(	O
optarg	*(char)
)	O
{	O
sym_id_add	O
(	O
optarg	*(char)
,	O
EXCL_ANNO	O
)	O
;	O
output_style	O
|=	O
STYLE_ANNOTATED_SOURCE	O
;	O
}	O
else	O
{	O
output_style	O
&=	O
~	O
STYLE_ANNOTATED_SOURCE	O
;	O
}	O
user_specified	O
|=	O
STYLE_ANNOTATED_SOURCE	O
;	O
break	O
;	O
case	O
'k'	O
:	O
sym_id_add	O
(	O
optarg	*(char)
,	O
EXCL_ARCS	O
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
line_granularity	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'L'	O
:	O
print_path	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'm'	O
:	O
bb_min_calls	O
=	O
(	O
unsigned	O
long	O
)	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
sym_id_add	O
(	O
optarg	*(char)
,	O
INCL_TIME	O
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
sym_id_add	O
(	O
optarg	*(char)
,	O
EXCL_TIME	O
)	O
;	O
break	O
;	O
case	O
'O'	O
:	O
switch	O
(	O
optarg	*(char)
[	O
0	int
]	O
)	O
{	O
case	O
'a'	O
:	O
file_format	O
=	O
FF_AUTO	O
;	O
break	O
;	O
case	O
'm'	O
:	O
file_format	O
=	O
FF_MAGIC	O
;	O
break	O
;	O
case	O
'b'	O
:	O
file_format	O
=	O
FF_BSD	O
;	O
break	O
;	O
case	O
'4'	O
:	O
file_format	O
=	O
FF_BSD44	O
;	O
break	O
;	O
case	O
'p'	O
:	O
file_format	O
=	O
FF_PROF	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: unknown file format %s\n"	*(char)
)	O
,	O
optarg	*(char)
,	O
whoami	O
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
optarg	*(char)
)	O
{	O
sym_id_add	O
(	O
optarg	*(char)
,	O
INCL_FLAT	O
)	O
;	O
}	O
output_style	O
|=	O
STYLE_FLAT_PROFILE	O
;	O
user_specified	O
|=	O
STYLE_FLAT_PROFILE	O
;	O
break	O
;	O
case	O
'P'	O
:	O
if	O
(	O
optarg	*(char)
)	O
{	O
sym_id_add	O
(	O
optarg	*(char)
,	O
EXCL_FLAT	O
)	O
;	O
output_style	O
|=	O
STYLE_FLAT_PROFILE	O
;	O
}	O
else	O
{	O
output_style	O
&=	O
~	O
STYLE_FLAT_PROFILE	O
;	O
}	O
user_specified	O
|=	O
STYLE_FLAT_PROFILE	O
;	O
break	O
;	O
case	O
'q'	O
:	O
if	O
(	O
optarg	*(char)
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
optarg	*(char)
,	O
'/'	O
)	O
)	O
{	O
sym_id_add	O
(	O
optarg	*(char)
,	O
INCL_ARCS	O
)	O
;	O
}	O
else	O
{	O
sym_id_add	O
(	O
optarg	*(char)
,	O
INCL_GRAPH	O
)	O
;	O
}	O
}	O
output_style	O
|=	O
STYLE_CALL_GRAPH	O
;	O
user_specified	O
|=	O
STYLE_CALL_GRAPH	O
;	O
break	O
;	O
case	O
'r'	O
:	O
output_style	O
|=	O
STYLE_FUNCTION_ORDER	O
;	O
user_specified	O
|=	O
STYLE_FUNCTION_ORDER	O
;	O
break	O
;	O
case	O
'R'	O
:	O
output_style	O
|=	O
STYLE_FILE_ORDER	O
;	O
user_specified	O
|=	O
STYLE_FILE_ORDER	O
;	O
function_mapping_file	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'Q'	O
:	O
if	O
(	O
optarg	*(char)
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
optarg	*(char)
,	O
'/'	O
)	O
)	O
{	O
sym_id_add	O
(	O
optarg	*(char)
,	O
EXCL_ARCS	O
)	O
;	O
}	O
else	O
{	O
sym_id_add	O
(	O
optarg	*(char)
,	O
EXCL_GRAPH	O
)	O
;	O
}	O
output_style	O
|=	O
STYLE_CALL_GRAPH	O
;	O
}	O
else	O
{	O
output_style	O
&=	O
~	O
STYLE_CALL_GRAPH	O
;	O
}	O
user_specified	O
|=	O
STYLE_CALL_GRAPH	O
;	O
break	O
;	O
case	O
's'	O
:	O
output_style	O
|=	O
STYLE_SUMMARY_FILE	O
;	O
user_specified	O
|=	O
STYLE_SUMMARY_FILE	O
;	O
break	O
;	O
case	O
'S'	O
:	O
external_symbol_table	O
=	O
optarg	*(char)
;	O
DBG	O
(	O
AOUTDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"external-symbol-table: %s\n"	*(char)
,	O
optarg	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
bb_table_length	O
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
bb_table_length	O
<	O
0	int
)	O
{	O
bb_table_length	O
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'T'	O
:	O
bsd_style_output	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'v'	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"GNU gprof %s\n"	*(char)
)	O
,	O
BFD_VERSION_STRING	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Based on BSD gprof, copyright 1983 Regents of the University of California.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"This program is free software.  This program has absolutely no warranty.\n"	*(char)
)	O
)	O
;	O
done	O
(	O
0	int
)	O
;	O
case	O
'w'	O
:	O
output_width	O
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
output_width	O
<	O
1	int
)	O
{	O
output_width	O
=	O
1	int
;	O
}	O
break	O
;	O
case	O
'x'	O
:	O
bb_annotate_all_lines	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'y'	O
:	O
create_annotation_files	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'z'	O
:	O
ignore_zeros	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
if	O
(	O
optarg	*(char)
)	O
{	O
sym_id_add	O
(	O
optarg	*(char)
,	O
EXCL_EXEC	O
)	O
;	O
output_style	O
|=	O
STYLE_EXEC_COUNTS	O
;	O
}	O
else	O
{	O
output_style	O
&=	O
~	O
STYLE_EXEC_COUNTS	O
;	O
}	O
user_specified	O
|=	O
STYLE_EXEC_COUNTS	O
;	O
break	O
;	O
case	O
OPTION_DEMANGLE	O
:	O
demangle	O
=	O
TRUE	int
;	O
if	O
(	O
optarg	*(char)
!=	O
NULL	O
)	O
{	O
enum	O
demangling_styles	O
style	O
;	O
style	O
=	O
cplus_demangle_name_to_style	O
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
style	O
==	O
unknown_demangling	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: unknown demangling style `%s'\n"	*(char)
)	O
,	O
whoami	O
,	O
optarg	*(char)
)	O
;	O
xexit	O
(	O
1	int
)	O
;	O
}	O
cplus_demangle_set_style	O
(	O
style	O
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_NO_DEMANGLE	O
:	O
demangle	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_INLINE_FILE_NAMES	O
:	O
inline_file_names	O
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
usage	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
user_specified	O
&	O
STYLE_FUNCTION_ORDER	O
)	O
&&	O
(	O
user_specified	O
&	O
STYLE_FILE_ORDER	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: Only one of --function-ordering and --file-ordering may be specified.\n"	*(char)
)	O
,	O
whoami	O
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
output_style	O
&	O
STYLE_SUMMARY_FILE	O
)	O
line_granularity	O
=	O
1	int
;	O
str	O
=	O
(	O
char	O
*	O
)	O
getenv	(*(char))->(*(char))
(	O
"GPROF_PATH"	*(char)
)	O
;	O
if	O
(	O
str	O
)	O
search_list_append	O
(	O
&	O
src_search_list	O
,	O
str	O
)	O
;	O
if	O
(	O
optind	int
<	O
argc	O
)	O
a_out_name	O
=	O
argv	O
[	O
optind	int
++	O
]	O
;	O
if	O
(	O
optind	int
<	O
argc	O
)	O
gmon_name	O
=	O
argv	O
[	O
optind	int
++	O
]	O
;	O
for	O
(	O
sp	O
=	O
&	O
default_excluded_list	O
[	O
0	int
]	O
;	O
*	O
sp	O
;	O
sp	O
++	O
)	O
{	O
sym_id_add	O
(	O
*	O
sp	O
,	O
EXCL_TIME	O
)	O
;	O
sym_id_add	O
(	O
*	O
sp	O
,	O
EXCL_GRAPH	O
)	O
;	O
sym_id_add	O
(	O
*	O
sp	O
,	O
EXCL_FLAT	O
)	O
;	O
}	O
core_init	O
(	O
a_out_name	O
)	O
;	O
if	O
(	O
ignore_direct_calls	O
)	O
core_get_text_space	O
(	O
core_bfd	*(struct(*(char),*(struct),*(void),*(struct),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),long,long,struct(*(*(struct`)),*((*`,*`,*`)->(*`)),*(void),int,int,int,int),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,long,*(*(struct(*`,*`,long,int,*`,union`))),int,int,*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(void),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),union(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(struct)),union(*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(void)),*(void),*(void),*(struct(long,array(char)))))
)	O
;	O
if	O
(	O
external_symbol_table	O
)	O
core_create_syms_from	O
(	O
external_symbol_table	O
)	O
;	O
else	O
if	O
(	O
line_granularity	O
)	O
core_create_line_syms	O
(	O
)	O
;	O
else	O
core_create_function_syms	O
(	O
)	O
;	O
sym_id_parse	O
(	O
)	O
;	O
if	O
(	O
file_format	O
==	O
FF_PROF	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: sorry, file format `prof' is not yet supported\n"	*(char)
)	O
,	O
whoami	O
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
do	O
{	O
gmon_out_read	O
(	O
gmon_name	O
)	O
;	O
if	O
(	O
optind	int
<	O
argc	O
)	O
gmon_name	O
=	O
argv	O
[	O
optind	int
]	O
;	O
}	O
while	O
(	O
optind	int
++	O
<	O
argc	O
)	O
;	O
}	O
if	O
(	O
output_style	O
==	O
0	int
)	O
{	O
if	O
(	O
gmon_input	O
&	O
(	O
INPUT_HISTOGRAM	O
|	O
INPUT_CALL_GRAPH	O
)	O
)	O
{	O
if	O
(	O
gmon_input	O
&	O
INPUT_HISTOGRAM	O
)	O
output_style	O
|=	O
STYLE_FLAT_PROFILE	O
;	O
if	O
(	O
gmon_input	O
&	O
INPUT_CALL_GRAPH	O
)	O
output_style	O
|=	O
STYLE_CALL_GRAPH	O
;	O
}	O
else	O
output_style	O
=	O
STYLE_EXEC_COUNTS	O
;	O
output_style	O
&=	O
~	O
user_specified	O
;	O
}	O
if	O
(	O
output_style	O
&	O
STYLE_SUMMARY_FILE	O
)	O
{	O
gmon_out_write	O
(	O
GMONSUM	O
)	O
;	O
}	O
if	O
(	O
gmon_input	O
&	O
INPUT_HISTOGRAM	O
)	O
{	O
hist_assign_samples	O
(	O
)	O
;	O
}	O
if	O
(	O
gmon_input	O
&	O
INPUT_CALL_GRAPH	O
)	O
{	O
cg	O
=	O
cg_assemble	O
(	O
)	O
;	O
}	O
if	O
(	O
(	O
output_style	O
&	O
STYLE_FLAT_PROFILE	O
)	O
&&	O
!	O
(	O
gmon_input	O
&	O
INPUT_HISTOGRAM	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: gmon.out file is missing histogram\n"	*(char)
)	O
,	O
whoami	O
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
output_style	O
&	O
STYLE_CALL_GRAPH	O
)	O
&&	O
!	O
(	O
gmon_input	O
&	O
INPUT_CALL_GRAPH	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: gmon.out file is missing call-graph data\n"	*(char)
)	O
,	O
whoami	O
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
cg	O
&&	O
(	O
output_style	O
&	O
STYLE_CALL_GRAPH	O
)	O
&&	O
bsd_style_output	O
)	O
{	O
cg_print	O
(	O
cg	O
)	O
;	O
}	O
if	O
(	O
output_style	O
&	O
STYLE_FLAT_PROFILE	O
)	O
{	O
hist_print	O
(	O
)	O
;	O
}	O
if	O
(	O
cg	O
&&	O
(	O
output_style	O
&	O
STYLE_CALL_GRAPH	O
)	O
)	O
{	O
if	O
(	O
!	O
bsd_style_output	O
)	O
{	O
cg_print	O
(	O
cg	O
)	O
;	O
}	O
cg_print_index	O
(	O
)	O
;	O
}	O
if	O
(	O
output_style	O
&	O
STYLE_EXEC_COUNTS	O
)	O
print_exec_counts	O
(	O
)	O
;	O
if	O
(	O
output_style	O
&	O
STYLE_ANNOTATED_SOURCE	O
)	O
print_annotated_source	O
(	O
)	O
;	O
if	O
(	O
output_style	O
&	O
STYLE_FUNCTION_ORDER	O
)	O
cg_print_function_ordering	O
(	O
)	O
;	O
if	O
(	O
output_style	O
&	O
STYLE_FILE_ORDER	O
)	O
cg_print_file_ordering	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
done	O
(	O
int	O
status	int
)	O
{	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
