static	O
int	O
rl_change_case	(int,int)->(int)
PARAMS	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
_rl_char_search	(int,int,int)->(int)
PARAMS	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
_rl_insert_next_callback	(*(struct(int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
)	O
)	O
;	O
static	O
int	O
_rl_char_search_callback	(*(struct(int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
)	O
)	O
;	O
int	O
_rl_optimize_typeahead	int
=	O
1	int
;	O
int	O
rl_insert_text	(*(char))->(int)
(	O
string	*(char)
)	O
const	O
char	O
*	O
string	*(char)
;	O
{	O
register	O
int	O
i	int
,	O
l	int
;	O
l	int
=	O
(	O
string	*(char)
&&	O
*	O
string	*(char)
)	O
?	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
:	O
0	int
;	O
if	O
(	O
l	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
rl_end	int
+	O
l	int
>=	O
rl_line_buffer_len	int
)	O
rl_extend_line_buffer	(int)->(void)
(	O
rl_end	int
+	O
l	int
)	O
;	O
for	O
(	O
i	int
=	O
rl_end	int
;	O
i	int
>=	O
rl_point	int
;	O
i	int
--	O
)	O
rl_line_buffer	*(char)
[	O
i	int
+	O
l	int
]	O
=	O
rl_line_buffer	*(char)
[	O
i	int
]	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
rl_line_buffer	*(char)
+	O
rl_point	int
,	O
string	*(char)
,	O
l	int
)	O
;	O
if	O
(	O
_rl_doing_an_undo	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
l	int
==	O
1	int
)	O
&&	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
&&	O
(	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
->	O
what	enum(int,int,int,int)
==	O
UNDO_INSERT	int
)	O
&&	O
(	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
->	O
end	int
==	O
rl_point	int
)	O
&&	O
(	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
->	O
end	int
-	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
->	O
start	int
<	O
20	int
)	O
)	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
->	O
end	int
++	O
;	O
else	O
rl_add_undo	(enum(int,int,int,int),int,int,*(char))->(void)
(	O
UNDO_INSERT	int
,	O
rl_point	int
,	O
rl_point	int
+	O
l	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
rl_point	int
+=	O
l	int
;	O
rl_end	int
+=	O
l	int
;	O
rl_line_buffer	*(char)
[	O
rl_end	int
]	O
=	O
'\0'	O
;	O
return	O
l	int
;	O
}	O
int	O
rl_delete_text	(int,int)->(int)
(	O
from	int
,	O
to	int
)	O
int	O
from	int
,	O
to	int
;	O
{	O
register	O
char	O
*	O
text	*(char)
;	O
register	O
int	O
diff	int
,	O
i	int
;	O
if	O
(	O
from	int
>	O
to	int
)	O
SWAP	O
(	O
from	int
,	O
to	int
)	O
;	O
if	O
(	O
to	int
>	O
rl_end	int
)	O
{	O
to	int
=	O
rl_end	int
;	O
if	O
(	O
from	int
>	O
to	int
)	O
from	int
=	O
to	int
;	O
}	O
if	O
(	O
from	int
<	O
0	int
)	O
from	int
=	O
0	int
;	O
text	*(char)
=	O
rl_copy_text	(int,int)->(*(char))
(	O
from	int
,	O
to	int
)	O
;	O
diff	int
=	O
to	int
-	O
from	int
;	O
for	O
(	O
i	int
=	O
from	int
;	O
i	int
<	O
rl_end	int
-	O
diff	int
;	O
i	int
++	O
)	O
rl_line_buffer	*(char)
[	O
i	int
]	O
=	O
rl_line_buffer	*(char)
[	O
i	int
+	O
diff	int
]	O
;	O
if	O
(	O
_rl_doing_an_undo	int
==	O
0	int
)	O
rl_add_undo	(enum(int,int,int,int),int,int,*(char))->(void)
(	O
UNDO_DELETE	int
,	O
from	int
,	O
to	int
,	O
text	*(char)
)	O
;	O
else	O
xfree	(*(void))->(void)
(	O
text	*(char)
)	O
;	O
rl_end	int
-=	O
diff	int
;	O
rl_line_buffer	*(char)
[	O
rl_end	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
diff	int
)	O
;	O
}	O
void	O
_rl_fix_point	(int)->(void)
(	O
fix_mark_too	int
)	O
int	O
fix_mark_too	int
;	O
{	O
_RL_FIX_POINT	O
(	O
rl_point	int
)	O
;	O
if	O
(	O
fix_mark_too	int
)	O
_RL_FIX_POINT	O
(	O
rl_mark	int
)	O
;	O
}	O
int	O
_rl_replace_text	(*(char),int,int)->(int)
(	O
text	*(char)
,	O
start	int
,	O
end	int
)	O
const	O
char	O
*	O
text	*(char)
;	O
int	O
start	int
,	O
end	int
;	O
{	O
int	O
n	int
;	O
n	int
=	O
0	int
;	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
if	O
(	O
start	int
<=	O
end	int
)	O
rl_delete_text	(int,int)->(int)
(	O
start	int
,	O
end	int
+	O
1	int
)	O
;	O
rl_point	int
=	O
start	int
;	O
if	O
(	O
*	O
text	*(char)
)	O
n	int
=	O
rl_insert_text	(*(char))->(int)
(	O
text	*(char)
)	O
;	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
return	O
n	int
;	O
}	O
void	O
rl_replace_line	(*(char),int)->(void)
(	O
text	*(char)
,	O
clear_undo	int
)	O
const	O
char	O
*	O
text	*(char)
;	O
int	O
clear_undo	int
;	O
{	O
int	O
len	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
;	O
if	O
(	O
len	int
>=	O
rl_line_buffer_len	int
)	O
rl_extend_line_buffer	(int)->(void)
(	O
len	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rl_line_buffer	*(char)
,	O
text	*(char)
)	O
;	O
rl_end	int
=	O
len	int
;	O
if	O
(	O
clear_undo	int
)	O
rl_free_undo_list	()->(void)
(	O
)	O
;	O
_rl_fix_point	(int)->(void)
(	O
1	int
)	O
;	O
}	O
int	O
rl_forward_byte	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_backward_byte	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
int	O
end	int
,	O
lend	int
;	O
end	int
=	O
rl_point	int
+	O
count	int
;	O
lend	int
=	O
rl_end	int
>	O
0	int
?	O
rl_end	int
-	O
(	O
VI_COMMAND_MODE	O
(	O
)	O
)	O
:	O
rl_end	int
;	O
if	O
(	O
end	int
>	O
lend	int
)	O
{	O
rl_point	int
=	O
lend	int
;	O
rl_ding	()->(int)
(	O
)	O
;	O
}	O
else	O
rl_point	int
=	O
end	int
;	O
}	O
if	O
(	O
rl_end	int
<	O
0	int
)	O
rl_end	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
_rl_forward_char_internal	(int)->(int)
(	O
count	int
)	O
int	O
count	int
;	O
{	O
int	O
point	int
;	O
point	int
=	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
count	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
if	O
(	O
point	int
>=	O
rl_end	int
&&	O
VI_COMMAND_MODE	O
(	O
)	O
)	O
point	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_end	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
if	O
(	O
rl_end	int
<	O
0	int
)	O
rl_end	int
=	O
0	int
;	O
return	O
(	O
point	int
)	O
;	O
}	O
int	O
rl_forward_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
point	int
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
return	O
(	O
rl_forward_byte	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_backward_char	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
if	O
(	O
rl_point	int
==	O
rl_end	int
&&	O
EMACS_MODE	O
(	O
)	O
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
point	int
=	O
_rl_forward_char_internal	(int)->(int)
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
==	O
point	int
)	O
rl_ding	()->(int)
(	O
)	O
;	O
rl_point	int
=	O
point	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_forward	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_forward_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_backward_byte	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_forward_byte	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
if	O
(	O
rl_point	int
<	O
count	int
)	O
{	O
rl_point	int
=	O
0	int
;	O
rl_ding	()->(int)
(	O
)	O
;	O
}	O
else	O
rl_point	int
-=	O
count	int
;	O
}	O
if	O
(	O
rl_point	int
<	O
0	int
)	O
rl_point	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_backward_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
point	int
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
return	O
(	O
rl_backward_byte	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_forward_char	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
point	int
=	O
rl_point	int
;	O
while	O
(	O
count	int
>	O
0	int
&&	O
point	int
>	O
0	int
)	O
{	O
point	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
count	int
--	O
;	O
}	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
rl_point	int
=	O
0	int
;	O
rl_ding	()->(int)
(	O
)	O
;	O
}	O
else	O
rl_point	int
=	O
point	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_backward	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_backward_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_beg_of_line	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_point	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_end_of_line	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_point	int
=	O
rl_end	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_forward_word	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_backward_word	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
while	O
(	O
count	int
)	O
{	O
if	O
(	O
rl_point	int
==	O
rl_end	int
)	O
return	O
0	int
;	O
c	int
=	O
_rl_char_value	(*(char),int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
)	O
;	O
if	O
(	O
_rl_walphabetic	(int)->(int)
(	O
c	int
)	O
==	O
0	int
)	O
{	O
rl_point	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
)	O
{	O
c	int
=	O
_rl_char_value	(*(char),int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
)	O
;	O
if	O
(	O
_rl_walphabetic	(int)->(int)
(	O
c	int
)	O
)	O
break	O
;	O
rl_point	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
}	O
}	O
if	O
(	O
rl_point	int
==	O
rl_end	int
)	O
return	O
0	int
;	O
rl_point	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
)	O
{	O
c	int
=	O
_rl_char_value	(*(char),int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
)	O
;	O
if	O
(	O
_rl_walphabetic	(int)->(int)
(	O
c	int
)	O
==	O
0	int
)	O
break	O
;	O
rl_point	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
}	O
--	O
count	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_backward_word	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
,	O
p	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_forward_word	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
while	O
(	O
count	int
)	O
{	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
return	O
0	int
;	O
p	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
c	int
=	O
_rl_char_value	(*(char),int)->(int)
(	O
rl_line_buffer	*(char)
,	O
p	int
)	O
;	O
if	O
(	O
_rl_walphabetic	(int)->(int)
(	O
c	int
)	O
==	O
0	int
)	O
{	O
rl_point	int
=	O
p	int
;	O
while	O
(	O
rl_point	int
>	O
0	int
)	O
{	O
p	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
c	int
=	O
_rl_char_value	(*(char),int)->(int)
(	O
rl_line_buffer	*(char)
,	O
p	int
)	O
;	O
if	O
(	O
_rl_walphabetic	(int)->(int)
(	O
c	int
)	O
)	O
break	O
;	O
rl_point	int
=	O
p	int
;	O
}	O
}	O
while	O
(	O
rl_point	int
)	O
{	O
p	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
c	int
=	O
_rl_char_value	(*(char),int)->(int)
(	O
rl_line_buffer	*(char)
,	O
p	int
)	O
;	O
if	O
(	O
_rl_walphabetic	(int)->(int)
(	O
c	int
)	O
==	O
0	int
)	O
break	O
;	O
else	O
rl_point	int
=	O
p	int
;	O
}	O
--	O
count	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_refresh_line	(int,int)->(int)
(	O
ignore1	int
,	O
ignore2	int
)	O
int	O
ignore1	int
,	O
ignore2	int
;	O
{	O
int	O
curr_line	int
;	O
curr_line	int
=	O
_rl_current_display_line	()->(int)
(	O
)	O
;	O
_rl_move_vert	(int)->(void)
(	O
curr_line	int
)	O
;	O
_rl_move_cursor_relative	(int,*(char))->(void)
(	O
0	int
,	O
rl_line_buffer	*(char)
)	O
;	O
_rl_clear_to_eol	(int)->(void)
(	O
0	int
)	O
;	O
rl_redraw_prompt_last_line	()->(void)
(	O
)	O
;	O
rl_display_fixed	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_clear_screen	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_explicit_arg	int
)	O
{	O
rl_refresh_line	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
return	O
0	int
;	O
}	O
_rl_clear_screen	()->(void)
(	O
)	O
;	O
rl_forced_update_display	()->(int)
(	O
)	O
;	O
rl_display_fixed	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_skip_csi_sequence	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
ch	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
do	O
ch	int
=	O
rl_read_key	()->(int)
(	O
)	O
;	O
while	O
(	O
ch	int
>=	O
0x20	int
&&	O
ch	int
<	O
0x40	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
return	O
(	O
ch	int
<	O
0	int
)	O
;	O
}	O
int	O
rl_arrow_keys	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
int	O
ch	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
ch	int
=	O
rl_read_key	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
ch	int
<	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
switch	O
(	O
_rl_to_upper	(int)->(int)
(	O
ch	int
)	O
)	O
{	O
case	O
'A'	O
:	O
rl_get_previous_history	(int,int)->(int)
(	O
count	int
,	O
ch	int
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
rl_get_next_history	(int,int)->(int)
(	O
count	int
,	O
ch	int
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_forward_char	(int,int)->(int)
(	O
count	int
,	O
ch	int
)	O
;	O
else	O
rl_forward_byte	(int,int)->(int)
(	O
count	int
,	O
ch	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_backward_char	(int,int)->(int)
(	O
count	int
,	O
ch	int
)	O
;	O
else	O
rl_backward_byte	(int,int)->(int)
(	O
count	int
,	O
ch	int
)	O
;	O
break	O
;	O
default	O
:	O
rl_ding	()->(int)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
pending_bytes	array(char)
[	O
MB_LEN_MAX	int
]	O
;	O
static	O
int	O
pending_bytes_length	int
=	O
0	int
;	O
static	O
mbstate_t	struct(int,union(int,array(char)))
ps	struct(int,union(int,array(char)))
=	O
{	O
0	int
}	O
;	O
int	O
_rl_insert_char	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
register	O
int	O
i	int
;	O
char	O
*	O
string	*(char)
;	O
int	O
string_size	int
;	O
char	O
incoming	array(char)
[	O
MB_LEN_MAX	int
+	O
1	int
]	O
;	O
int	O
incoming_length	int
=	O
0	int
;	O
mbstate_t	struct(int,union(int,array(char)))
ps_back	struct(int,union(int,array(char)))
;	O
static	O
int	O
stored_count	int
=	O
0	int
;	O
if	O
(	O
count	int
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
{	O
incoming	array(char)
[	O
0	int
]	O
=	O
c	int
;	O
incoming	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
incoming_length	int
=	O
1	int
;	O
}	O
else	O
{	O
wchar_t	int
wc	int
;	O
size_t	long
ret	long
;	O
if	O
(	O
stored_count	int
<=	O
0	int
)	O
stored_count	int
=	O
count	int
;	O
else	O
count	int
=	O
stored_count	int
;	O
ps_back	struct(int,union(int,array(char)))
=	O
ps	struct(int,union(int,array(char)))
;	O
pending_bytes	array(char)
[	O
pending_bytes_length	int
++	O
]	O
=	O
c	int
;	O
ret	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc	int
,	O
pending_bytes	array(char)
,	O
pending_bytes_length	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
ret	long
==	O
(	O
size_t	long
)	O
-	O
2	int
)	O
{	O
ps	struct(int,union(int,array(char)))
=	O
ps_back	struct(int,union(int,array(char)))
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
ret	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
incoming	array(char)
[	O
0	int
]	O
=	O
pending_bytes	array(char)
[	O
0	int
]	O
;	O
incoming	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
incoming_length	int
=	O
1	int
;	O
pending_bytes_length	int
--	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
pending_bytes	array(char)
,	O
pending_bytes	array(char)
+	O
1	int
,	O
pending_bytes_length	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
}	O
else	O
if	O
(	O
ret	long
==	O
(	O
size_t	long
)	O
0	int
)	O
{	O
incoming	array(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
incoming_length	int
=	O
0	int
;	O
pending_bytes_length	int
--	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
}	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
incoming	array(char)
,	O
pending_bytes	array(char)
,	O
pending_bytes_length	int
)	O
;	O
incoming	array(char)
[	O
pending_bytes_length	int
]	O
=	O
'\0'	O
;	O
incoming_length	int
=	O
pending_bytes_length	int
;	O
pending_bytes_length	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
count	int
>	O
1	int
&&	O
count	int
<=	O
TEXT_COUNT_MAX	int
)	O
{	O
string_size	int
=	O
count	int
*	O
incoming_length	int
;	O
string	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
1	int
+	O
string_size	int
)	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
string_size	int
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
string	*(char)
+	O
i	int
,	O
incoming	array(char)
,	O
incoming_length	int
)	O
;	O
i	int
+=	O
incoming_length	int
;	O
}	O
incoming_length	int
=	O
0	int
;	O
stored_count	int
=	O
0	int
;	O
string	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
rl_insert_text	(*(char))->(int)
(	O
string	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
string	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
count	int
>	O
TEXT_COUNT_MAX	int
)	O
{	O
int	O
decreaser	int
;	O
string_size	int
=	O
incoming_length	int
*	O
TEXT_COUNT_MAX	int
;	O
string	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
1	int
+	O
string_size	int
)	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
string_size	int
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
string	*(char)
+	O
i	int
,	O
incoming	array(char)
,	O
incoming_length	int
)	O
;	O
i	int
+=	O
incoming_length	int
;	O
}	O
while	O
(	O
count	int
)	O
{	O
decreaser	int
=	O
(	O
count	int
>	O
TEXT_COUNT_MAX	int
)	O
?	O
TEXT_COUNT_MAX	int
:	O
count	int
;	O
string	*(char)
[	O
decreaser	int
*	O
incoming_length	int
]	O
=	O
'\0'	O
;	O
rl_insert_text	(*(char))->(int)
(	O
string	*(char)
)	O
;	O
count	int
-=	O
decreaser	int
;	O
}	O
xfree	(*(void))->(void)
(	O
string	*(char)
)	O
;	O
incoming_length	int
=	O
0	int
;	O
stored_count	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
{	O
if	O
(	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACROINPUT	int
)	O
==	O
0	int
)	O
&&	O
_rl_pushed_input_available	()->(int)
(	O
)	O
)	O
_rl_insert_typein	(int)->(void)
(	O
c	int
)	O
;	O
else	O
{	O
char	O
str	array(char)
[	O
2	int
]	O
;	O
str	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
str	array(char)
[	O
0	int
]	O
=	O
c	int
;	O
rl_insert_text	(*(char))->(int)
(	O
str	array(char)
)	O
;	O
}	O
}	O
else	O
{	O
rl_insert_text	(*(char))->(int)
(	O
incoming	array(char)
)	O
;	O
stored_count	int
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
_rl_overwrite_char	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
int	O
i	int
;	O
char	O
mbkey	array(char)
[	O
MB_LEN_MAX	int
]	O
;	O
int	O
k	int
;	O
if	O
(	O
count	int
>	O
0	int
&&	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
k	int
=	O
_rl_read_mbstring	(int,*(char),int)->(int)
(	O
c	int
,	O
mbkey	array(char)
,	O
MB_LEN_MAX	int
)	O
;	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_insert_text	(*(char))->(int)
(	O
mbkey	array(char)
)	O
;	O
else	O
_rl_insert_char	(int,int)->(int)
(	O
1	int
,	O
c	int
)	O
;	O
if	O
(	O
rl_point	int
<	O
rl_end	int
)	O
rl_delete	(int,int)->(int)
(	O
1	int
,	O
c	int
)	O
;	O
}	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_insert	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
int	O
r	int
,	O
n	int
,	O
x	int
;	O
r	int
=	O
(	O
rl_insert_mode	int
==	O
RL_IM_INSERT	int
)	O
?	O
_rl_insert_char	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
:	O
_rl_overwrite_char	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
;	O
x	int
=	O
0	int
;	O
n	int
=	O
(	O
unsigned	O
short	O
)	O
-	O
2	int
;	O
while	O
(	O
_rl_optimize_typeahead	int
&&	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_INPUTPENDING	int
|	O
RL_STATE_MACROINPUT	int
)	O
==	O
0	int
)	O
&&	O
_rl_pushed_input_available	()->(int)
(	O
)	O
==	O
0	int
&&	O
_rl_input_queued	(int)->(int)
(	O
0	int
)	O
&&	O
(	O
n	int
=	O
rl_read_key	()->(int)
(	O
)	O
)	O
>	O
0	int
&&	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
[	O
(	O
unsigned	O
char	O
)	O
n	int
]	O
.	O
type	char
==	O
ISFUNC	int
&&	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
[	O
(	O
unsigned	O
char	O
)	O
n	int
]	O
.	O
function	*((int,int)->(int))
==	O
rl_insert	(int,int)->(int)
)	O
{	O
r	int
=	O
(	O
rl_insert_mode	int
==	O
RL_IM_INSERT	int
)	O
?	O
_rl_insert_char	(int,int)->(int)
(	O
1	int
,	O
n	int
)	O
:	O
_rl_overwrite_char	(int,int)->(int)
(	O
1	int
,	O
n	int
)	O
;	O
n	int
=	O
(	O
unsigned	O
short	O
)	O
-	O
2	int
;	O
x	int
++	O
;	O
if	O
(	O
r	int
==	O
1	int
)	O
continue	O
;	O
if	O
(	O
rl_done	int
||	O
r	int
!=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
n	int
!=	O
(	O
unsigned	O
short	O
)	O
-	O
2	int
)	O
{	O
rl_last_func	*((int,int)->(int))
=	O
rl_insert	(int,int)->(int)
;	O
_rl_reset_argument	()->(void)
(	O
)	O
;	O
rl_executing_keyseq	*(char)
[	O
rl_key_sequence_length	int
=	O
0	int
]	O
=	O
'\0'	O
;	O
r	int
=	O
rl_execute_next	(int)->(int)
(	O
n	int
)	O
;	O
}	O
return	O
r	int
;	O
}	O
static	O
int	O
_rl_insert_next	(int)->(int)
(	O
count	int
)	O
int	O
count	int
;	O
{	O
int	O
c	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
c	int
=	O
rl_read_key	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACRODEF	int
)	O
)	O
_rl_add_macro_char	(int)->(void)
(	O
c	int
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
==	O
0	int
)	O
_rl_restore_tty_signals	()->(int)
(	O
)	O
;	O
return	O
(	O
_rl_insert_char	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
)	O
;	O
}	O
static	O
int	O
_rl_insert_next_callback	(*(struct(int,int,int)))->(int)
(	O
data	*(void)
)	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
data	*(void)
;	O
{	O
int	O
count	int
;	O
count	int
=	O
data	*(void)
->	O
count	int
;	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
return	O
_rl_insert_next	(int)->(int)
(	O
count	int
)	O
;	O
}	O
int	O
rl_quoted_insert	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
==	O
0	int
)	O
_rl_disable_tty_signals	()->(int)
(	O
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	*(struct(int,int,int))
=	O
_rl_callback_data_alloc	(int)->(*(struct(int,int,int)))
(	O
count	int
)	O
;	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
_rl_insert_next_callback	(*(struct(int,int,int)))->(int)
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
_rl_insert_next	(int)->(int)
(	O
count	int
)	O
;	O
}	O
int	O
rl_tab_insert	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
_rl_insert_char	(int,int)->(int)
(	O
count	int
,	O
'\t'	O
)	O
)	O
;	O
}	O
int	O
rl_newline	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_done	int
=	O
1	int
;	O
if	O
(	O
_rl_history_preserve_point	int
)	O
_rl_history_saved_point	int
=	O
(	O
rl_point	int
==	O
rl_end	int
)	O
?	O
-	O
1	int
:	O
rl_point	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_DONE	int
)	O
;	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
)	O
{	O
_rl_vi_done_inserting	()->(void)
(	O
)	O
;	O
if	O
(	O
_rl_vi_textmod_command	(int)->(int)
(	O
_rl_vi_last_command	int
)	O
==	O
0	int
)	O
_rl_vi_reset_last	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
rl_erase_empty_line	int
&&	O
rl_point	int
==	O
0	int
&&	O
rl_end	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
_rl_echoing_p	int
)	O
_rl_update_final	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_do_lowercase_version	(int,int)->(int)
(	O
ignore1	int
,	O
ignore2	int
)	O
int	O
ignore1	int
,	O
ignore2	int
;	O
{	O
return	O
0	int
;	O
}	O
int	O
_rl_overwrite_rubout	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
opoint	int
;	O
int	O
i	int
,	O
l	int
;	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
opoint	int
=	O
rl_point	int
;	O
for	O
(	O
i	int
=	O
l	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
rl_backward_char	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
l	int
+=	O
rl_character_len	(int,int)->(int)
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
,	O
rl_point	int
)	O
;	O
}	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
if	O
(	O
count	int
>	O
1	int
||	O
rl_explicit_arg	int
)	O
rl_kill_text	(int,int)->(int)
(	O
opoint	int
,	O
rl_point	int
)	O
;	O
else	O
rl_delete_text	(int,int)->(int)
(	O
opoint	int
,	O
rl_point	int
)	O
;	O
if	O
(	O
rl_point	int
<	O
rl_end	int
)	O
{	O
opoint	int
=	O
rl_point	int
;	O
_rl_insert_char	(int,int)->(int)
(	O
l	int
,	O
' '	O
)	O
;	O
rl_point	int
=	O
opoint	int
;	O
}	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_rubout	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_delete	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
!	O
rl_point	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
rl_insert_mode	int
==	O
RL_IM_OVERWRITE	int
)	O
return	O
(	O
_rl_overwrite_rubout	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
)	O
;	O
return	O
(	O
_rl_rubout_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
_rl_rubout_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
orig_point	int
;	O
unsigned	O
char	O
c	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_delete	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
orig_point	int
=	O
rl_point	int
;	O
if	O
(	O
count	int
>	O
1	int
||	O
rl_explicit_arg	int
)	O
{	O
rl_backward_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
rl_kill_text	(int,int)->(int)
(	O
orig_point	int
,	O
rl_point	int
)	O
;	O
}	O
else	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
{	O
c	int
=	O
rl_line_buffer	*(char)
[	O
--	O
rl_point	int
]	O
;	O
rl_delete_text	(int,int)->(int)
(	O
rl_point	int
,	O
orig_point	int
)	O
;	O
if	O
(	O
rl_point	int
==	O
rl_end	int
&&	O
ISPRINT	O
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
&&	O
_rl_last_c_pos	int
)	O
{	O
int	O
l	int
;	O
l	int
=	O
rl_character_len	(int,int)->(int)
(	O
c	int
,	O
rl_point	int
)	O
;	O
_rl_erase_at_end_of_line	(int)->(void)
(	O
l	int
)	O
;	O
}	O
}	O
else	O
{	O
rl_point	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
rl_delete_text	(int,int)->(int)
(	O
rl_point	int
,	O
orig_point	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_delete	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
xpoint	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
_rl_rubout_char	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_point	int
==	O
rl_end	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
count	int
>	O
1	int
||	O
rl_explicit_arg	int
)	O
{	O
xpoint	int
=	O
rl_point	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_forward_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
else	O
rl_forward_byte	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
rl_kill_text	(int,int)->(int)
(	O
xpoint	int
,	O
rl_point	int
)	O
;	O
rl_point	int
=	O
xpoint	int
;	O
}	O
else	O
{	O
xpoint	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
rl_delete_text	(int,int)->(int)
(	O
rl_point	int
,	O
xpoint	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_rubout_or_delete	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_end	int
!=	O
0	int
&&	O
rl_point	int
==	O
rl_end	int
)	O
return	O
(	O
_rl_rubout_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
)	O
;	O
else	O
return	O
(	O
rl_delete	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_delete_horizontal_space	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
int	O
start	int
;	O
while	O
(	O
rl_point	int
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
start	int
=	O
rl_point	int
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
if	O
(	O
start	int
!=	O
rl_point	int
)	O
{	O
rl_delete_text	(int,int)->(int)
(	O
start	int
,	O
rl_point	int
)	O
;	O
rl_point	int
=	O
start	int
;	O
}	O
if	O
(	O
rl_point	int
<	O
0	int
)	O
rl_point	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_delete_or_show_completions	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_end	int
!=	O
0	int
&&	O
rl_point	int
==	O
rl_end	int
)	O
return	O
(	O
rl_possible_completions	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
)	O
;	O
else	O
return	O
(	O
rl_delete	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_insert_comment	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
char	O
*	O
rl_comment_text	*(char)
;	O
int	O
rl_comment_len	int
;	O
rl_beg_of_line	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
rl_comment_text	*(char)
=	O
_rl_comment_begin	*(char)
?	O
_rl_comment_begin	*(char)
:	O
RL_COMMENT_BEGIN_DEFAULT	*(char)
;	O
if	O
(	O
rl_explicit_arg	int
==	O
0	int
)	O
rl_insert_text	(*(char))->(int)
(	O
rl_comment_text	*(char)
)	O
;	O
else	O
{	O
rl_comment_len	int
=	O
strlen	(*(char))->(long)
(	O
rl_comment_text	*(char)
)	O
;	O
if	O
(	O
STREQN	O
(	O
rl_comment_text	*(char)
,	O
rl_line_buffer	*(char)
,	O
rl_comment_len	int
)	O
)	O
rl_delete_text	(int,int)->(int)
(	O
rl_point	int
,	O
rl_point	int
+	O
rl_comment_len	int
)	O
;	O
else	O
rl_insert_text	(*(char))->(int)
(	O
rl_comment_text	*(char)
)	O
;	O
}	O
(	O
*	O
rl_redisplay_function	*(()->(void))
)	O
(	O
)	O
;	O
rl_newline	(int,int)->(int)
(	O
1	int
,	O
'\n'	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_upcase_word	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_change_case	(int,int)->(int)
(	O
count	int
,	O
UpCase	int
)	O
)	O
;	O
}	O
int	O
rl_downcase_word	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_change_case	(int,int)->(int)
(	O
count	int
,	O
DownCase	int
)	O
)	O
;	O
}	O
int	O
rl_capitalize_word	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_change_case	(int,int)->(int)
(	O
count	int
,	O
CapCase	int
)	O
)	O
;	O
}	O
static	O
int	O
rl_change_case	(int,int)->(int)
(	O
count	int
,	O
op	int
)	O
int	O
count	int
,	O
op	int
;	O
{	O
int	O
start	int
,	O
next	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
,	O
end	int
;	O
int	O
inword	int
,	O
c	int
,	O
nc	int
,	O
nop	int
;	O
wchar_t	int
wc	int
,	O
nwc	int
;	O
char	O
mb	array(char)
[	O
MB_LEN_MAX	int
+	O
1	int
]	O
;	O
int	O
mlen	int
;	O
size_t	long
m	long
;	O
mbstate_t	struct(int,union(int,array(char)))
mps	struct(int,union(int,array(char)))
;	O
start	int
=	O
rl_point	int
;	O
rl_forward_word	(int,int)->(int)
(	O
count	int
,	O
0	int
)	O
;	O
end	int
=	O
rl_point	int
;	O
if	O
(	O
op	int
!=	O
UpCase	int
&&	O
op	int
!=	O
DownCase	int
&&	O
op	int
!=	O
CapCase	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
count	int
<	O
0	int
)	O
SWAP	O
(	O
start	int
,	O
end	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
mps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
rl_modifying	(int,int)->(int)
(	O
start	int
,	O
end	int
)	O
;	O
inword	int
=	O
0	int
;	O
while	O
(	O
start	int
<	O
end	int
)	O
{	O
c	int
=	O
_rl_char_value	(*(char),int)->(int)
(	O
rl_line_buffer	*(char)
,	O
start	int
)	O
;	O
next	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	*(char)
,	O
start	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
if	O
(	O
_rl_walphabetic	(int)->(int)
(	O
c	int
)	O
==	O
0	int
)	O
{	O
inword	int
=	O
0	int
;	O
start	int
=	O
next	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
continue	O
;	O
}	O
if	O
(	O
op	int
==	O
CapCase	int
)	O
{	O
nop	int
=	O
inword	int
?	O
DownCase	int
:	O
UpCase	int
;	O
inword	int
=	O
1	int
;	O
}	O
else	O
nop	int
=	O
op	int
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
||	O
isascii	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
)	O
{	O
nc	int
=	O
(	O
nop	int
==	O
UpCase	int
)	O
?	O
_rl_to_upper	(int)->(int)
(	O
c	int
)	O
:	O
_rl_to_lower	(int)->(int)
(	O
c	int
)	O
;	O
rl_line_buffer	*(char)
[	O
start	int
]	O
=	O
nc	int
;	O
}	O
else	O
{	O
m	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc	int
,	O
rl_line_buffer	*(char)
+	O
start	int
,	O
end	int
-	O
start	int
,	O
&	O
mps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
m	long
)	O
)	O
wc	int
=	O
(	O
wchar_t	int
)	O
rl_line_buffer	*(char)
[	O
start	int
]	O
;	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
m	long
)	O
)	O
wc	int
=	O
L'\0'	O
;	O
nwc	int
=	O
(	O
nop	int
==	O
UpCase	int
)	O
?	O
_rl_to_wupper	O
(	O
wc	int
)	O
:	O
_rl_to_wlower	O
(	O
wc	int
)	O
;	O
if	O
(	O
nwc	int
!=	O
wc	int
)	O
{	O
mlen	int
=	O
wcrtomb	(*(char),int,*(struct(int,union(int,array(char)))))->(long)
(	O
mb	array(char)
,	O
nwc	int
,	O
&	O
mps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
mlen	int
>	O
0	int
)	O
mb	array(char)
[	O
mlen	int
]	O
=	O
'\0'	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
rl_line_buffer	*(char)
+	O
start	int
,	O
mb	array(char)
,	O
mlen	int
)	O
;	O
}	O
}	O
start	int
=	O
next	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
}	O
rl_point	int
=	O
end	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_transpose_words	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
char	O
*	O
word1	*(char)
,	O
*	O
word2	*(char)
;	O
int	O
w1_beg	int
,	O
w1_end	int
,	O
w2_beg	int
,	O
w2_end	int
;	O
int	O
orig_point	int
=	O
rl_point	int
;	O
if	O
(	O
!	O
count	int
)	O
return	O
0	int
;	O
rl_forward_word	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
w2_end	int
=	O
rl_point	int
;	O
rl_backward_word	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
w2_beg	int
=	O
rl_point	int
;	O
rl_backward_word	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
w1_beg	int
=	O
rl_point	int
;	O
rl_forward_word	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
w1_end	int
=	O
rl_point	int
;	O
if	O
(	O
(	O
w1_beg	int
==	O
w2_beg	int
)	O
||	O
(	O
w2_beg	int
<	O
w1_end	int
)	O
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
rl_point	int
=	O
orig_point	int
;	O
return	O
1	int
;	O
}	O
word1	*(char)
=	O
rl_copy_text	(int,int)->(*(char))
(	O
w1_beg	int
,	O
w1_end	int
)	O
;	O
word2	*(char)
=	O
rl_copy_text	(int,int)->(*(char))
(	O
w2_beg	int
,	O
w2_end	int
)	O
;	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
rl_point	int
=	O
w2_beg	int
;	O
rl_delete_text	(int,int)->(int)
(	O
w2_beg	int
,	O
w2_end	int
)	O
;	O
rl_insert_text	(*(char))->(int)
(	O
word1	*(char)
)	O
;	O
rl_point	int
=	O
w1_beg	int
;	O
rl_delete_text	(int,int)->(int)
(	O
w1_beg	int
,	O
w1_end	int
)	O
;	O
rl_insert_text	(*(char))->(int)
(	O
word2	*(char)
)	O
;	O
rl_point	int
=	O
w2_end	int
;	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
word1	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
word2	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_transpose_chars	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
char	O
*	O
dummy	*(char)
;	O
int	O
i	int
;	O
int	O
char_length	int
,	O
prev_point	int
;	O
if	O
(	O
count	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
rl_point	int
||	O
rl_end	int
<	O
2	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
if	O
(	O
rl_point	int
==	O
rl_end	int
)	O
{	O
rl_point	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
count	int
=	O
1	int
;	O
}	O
prev_point	int
=	O
rl_point	int
;	O
rl_point	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
char_length	int
=	O
prev_point	int
-	O
rl_point	int
;	O
dummy	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
char_length	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
char_length	int
;	O
i	int
++	O
)	O
dummy	*(char)
[	O
i	int
]	O
=	O
rl_line_buffer	*(char)
[	O
rl_point	int
+	O
i	int
]	O
;	O
dummy	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
rl_delete_text	(int,int)->(int)
(	O
rl_point	int
,	O
rl_point	int
+	O
char_length	int
)	O
;	O
rl_point	int
=	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
count	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
_rl_fix_point	(int)->(void)
(	O
0	int
)	O
;	O
rl_insert_text	(*(char))->(int)
(	O
dummy	*(char)
)	O
;	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
dummy	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
_rl_char_search_internal	(int,int,*(char),int)->(int)
(	O
count	int
,	O
dir	int
,	O
smbchar	*(char)
,	O
len	int
)	O
int	O
count	int
,	O
dir	int
;	O
char	O
*	O
smbchar	*(char)
;	O
int	O
len	int
;	O
{	O
int	O
pos	int
,	O
inc	int
;	O
int	O
prepos	int
;	O
if	O
(	O
dir	int
==	O
0	int
)	O
return	O
1	int
;	O
pos	int
=	O
rl_point	int
;	O
inc	int
=	O
(	O
dir	int
<	O
0	int
)	O
?	O
-	O
1	int
:	O
1	int
;	O
while	O
(	O
count	int
)	O
{	O
if	O
(	O
(	O
dir	int
<	O
0	int
&&	O
pos	int
<=	O
0	int
)	O
||	O
(	O
dir	int
>	O
0	int
&&	O
pos	int
>=	O
rl_end	int
)	O
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
pos	int
=	O
(	O
inc	int
>	O
0	int
)	O
?	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
pos	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
:	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
pos	int
,	O
MB_FIND_ANY	int
)	O
;	O
do	O
{	O
if	O
(	O
_rl_is_mbchar_matched	(*(char),int,int,*(char),int)->(int)
(	O
rl_line_buffer	*(char)
,	O
pos	int
,	O
rl_end	int
,	O
smbchar	*(char)
,	O
len	int
)	O
)	O
{	O
count	int
--	O
;	O
if	O
(	O
dir	int
<	O
0	int
)	O
rl_point	int
=	O
(	O
dir	int
==	O
BTO	O
)	O
?	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
pos	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
:	O
pos	int
;	O
else	O
rl_point	int
=	O
(	O
dir	int
==	O
FTO	int
)	O
?	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
pos	int
,	O
MB_FIND_ANY	int
)	O
:	O
pos	int
;	O
break	O
;	O
}	O
prepos	int
=	O
pos	int
;	O
}	O
while	O
(	O
(	O
dir	int
<	O
0	int
)	O
?	O
(	O
pos	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
pos	int
,	O
MB_FIND_ANY	int
)	O
)	O
!=	O
prepos	int
:	O
(	O
pos	int
=	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
pos	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
)	O
!=	O
prepos	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
_rl_char_search	(int,int,int)->(int)
(	O
count	int
,	O
fdir	int
,	O
bdir	int
)	O
int	O
count	int
,	O
fdir	int
,	O
bdir	int
;	O
{	O
char	O
mbchar	array(char)
[	O
MB_LEN_MAX	int
]	O
;	O
int	O
mb_len	int
;	O
mb_len	int
=	O
_rl_read_mbchar	(*(char),int)->(int)
(	O
mbchar	array(char)
,	O
MB_LEN_MAX	int
)	O
;	O
if	O
(	O
mb_len	int
<=	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
_rl_char_search_internal	(int,int,*(char),int)->(int)
(	O
-	O
count	int
,	O
bdir	int
,	O
mbchar	array(char)
,	O
mb_len	int
)	O
)	O
;	O
else	O
return	O
(	O
_rl_char_search_internal	(int,int,*(char),int)->(int)
(	O
count	int
,	O
fdir	int
,	O
mbchar	array(char)
,	O
mb_len	int
)	O
)	O
;	O
}	O
static	O
int	O
_rl_char_search_callback	(*(struct(int,int,int)))->(int)
(	O
data	*(void)
)	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
data	*(void)
;	O
{	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
return	O
(	O
_rl_char_search	(int,int,int)->(int)
(	O
data	*(void)
->	O
count	int
,	O
data	*(void)
->	O
i1	int
,	O
data	*(void)
->	O
i2	int
)	O
)	O
;	O
}	O
int	O
rl_char_search	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	*(struct(int,int,int))
=	O
_rl_callback_data_alloc	(int)->(*(struct(int,int,int)))
(	O
count	int
)	O
;	O
_rl_callback_data	*(struct(int,int,int))
->	O
i1	int
=	O
FFIND	int
;	O
_rl_callback_data	*(struct(int,int,int))
->	O
i2	int
=	O
BFIND	O
;	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
_rl_char_search_callback	(*(struct(int,int,int)))->(int)
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
_rl_char_search	(int,int,int)->(int)
(	O
count	int
,	O
FFIND	int
,	O
BFIND	O
)	O
)	O
;	O
}	O
int	O
rl_backward_char_search	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	*(struct(int,int,int))
=	O
_rl_callback_data_alloc	(int)->(*(struct(int,int,int)))
(	O
count	int
)	O
;	O
_rl_callback_data	*(struct(int,int,int))
->	O
i1	int
=	O
BFIND	O
;	O
_rl_callback_data	*(struct(int,int,int))
->	O
i2	int
=	O
FFIND	int
;	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
_rl_char_search_callback	(*(struct(int,int,int)))->(int)
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
_rl_char_search	(int,int,int)->(int)
(	O
count	int
,	O
BFIND	O
,	O
FFIND	int
)	O
)	O
;	O
}	O
int	O
_rl_set_mark_at_pos	(int)->(int)
(	O
position	int
)	O
int	O
position	int
;	O
{	O
if	O
(	O
position	int
>	O
rl_end	int
)	O
return	O
1	int
;	O
rl_mark	int
=	O
position	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_set_mark	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
_rl_set_mark_at_pos	(int)->(int)
(	O
rl_explicit_arg	int
?	O
count	int
:	O
rl_point	int
)	O
)	O
;	O
}	O
int	O
rl_exchange_point_and_mark	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_mark	int
>	O
rl_end	int
)	O
rl_mark	int
=	O
-	O
1	int
;	O
if	O
(	O
rl_mark	int
==	O
-	O
1	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
SWAP	O
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
return	O
0	int
;	O
}	O
