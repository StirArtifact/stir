static	O
const	O
char	O
app_text	array(char)
[	O
]	O
=	O
"Midnight-Commander"	*(char)
;	O
int	O
easy_patterns	int
=	O
1	int
;	O
extern	O
void	O
str_replace	(*(char),char,char)->(void)
(	O
char	O
*	O
s	*(char)
,	O
char	O
from	char
,	O
char	O
to	char
)	O
{	O
for	O
(	O
;	O
*	O
s	*(char)
!=	O
'\0'	O
;	O
s	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
s	*(char)
==	O
from	char
)	O
*	O
s	*(char)
=	O
to	char
;	O
}	O
}	O
static	O
inline	O
int	O
is_7bit_printable	(char)->(int)
(	O
unsigned	O
char	O
c	int
)	O
{	O
return	O
(	O
c	int
>	O
31	int
&&	O
c	int
<	O
127	int
)	O
;	O
}	O
static	O
inline	O
int	O
is_iso_printable	(char)->(int)
(	O
unsigned	O
char	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
>	O
31	int
&&	O
c	int
<	O
127	int
)	O
||	O
c	int
>=	O
160	int
)	O
;	O
}	O
static	O
inline	O
int	O
is_8bit_printable	(char)->(int)
(	O
unsigned	O
char	O
c	int
)	O
{	O
if	O
(	O
xterm_flag	int
)	O
return	O
is_iso_printable	(char)->(int)
(	O
c	int
)	O
;	O
return	O
(	O
c	int
>	O
31	int
&&	O
c	int
!=	O
127	int
&&	O
c	int
!=	O
155	int
)	O
;	O
}	O
int	O
is_printable	(int)->(int)
(	O
int	O
c	int
)	O
{	O
c	int
&=	O
0xff	int
;	O
if	O
(	O
!	O
eight_bit_clean	int
)	O
return	O
is_7bit_printable	(char)->(int)
(	O
c	int
)	O
;	O
if	O
(	O
full_eight_bits	int
)	O
{	O
return	O
is_8bit_printable	(char)->(int)
(	O
c	int
)	O
;	O
}	O
else	O
return	O
is_iso_printable	(char)->(int)
(	O
c	int
)	O
;	O
}	O
void	O
msglen	(*(char),*(int),*(int))->(void)
(	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
*	O
lines	*(int)
,	O
int	O
*	O
columns	*(int)
)	O
{	O
int	O
nlines	int
=	O
1	int
;	O
int	O
ncolumns	int
=	O
0	int
;	O
int	O
colindex	int
=	O
0	int
;	O
for	O
(	O
;	O
*	O
text	*(char)
!=	O
'\0'	O
;	O
text	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
text	*(char)
==	O
'\n'	O
)	O
{	O
nlines	int
++	O
;	O
colindex	int
=	O
0	int
;	O
}	O
else	O
{	O
colindex	int
++	O
;	O
if	O
(	O
colindex	int
>	O
ncolumns	int
)	O
ncolumns	int
=	O
colindex	int
;	O
}	O
}	O
*	O
lines	*(int)
=	O
nlines	int
;	O
*	O
columns	*(int)
=	O
ncolumns	int
;	O
}	O
char	O
*	O
trim	(*(char),*(char),int)->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
*	O
d	double
,	O
int	O
len	int
)	O
{	O
int	O
source_len	int
;	O
len	int
=	O
max	long
(	O
len	int
,	O
0	int
)	O
;	O
source_len	int
=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
;	O
if	O
(	O
source_len	int
>	O
len	int
)	O
{	O
if	O
(	O
len	int
<=	O
3	int
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
d	double
,	O
'.'	O
,	O
len	int
)	O
;	O
d	double
[	O
len	int
]	O
=	O
0	int
;	O
return	O
d	double
;	O
}	O
else	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
d	double
,	O
'.'	O
,	O
3	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
d	double
+	O
3	int
,	O
s	*(char)
+	O
3	int
+	O
source_len	int
-	O
len	int
)	O
;	O
}	O
}	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
d	double
,	O
s	*(char)
)	O
;	O
return	O
d	double
;	O
}	O
char	O
*	O
name_quote	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
int	O
quote_percent	int
)	O
{	O
char	O
*	O
ret	*(char)
,	O
*	O
d	double
;	O
d	double
=	O
ret	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
*	O
2	int
+	O
2	int
+	O
1	int
)	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
'-'	O
)	O
{	O
*	O
d	double
++	O
=	O
'.'	O
;	O
*	O
d	double
++	O
=	O
'/'	O
;	O
}	O
for	O
(	O
;	O
*	O
s	*(char)
;	O
s	*(char)
++	O
,	O
d	double
++	O
)	O
{	O
switch	O
(	O
*	O
s	*(char)
)	O
{	O
case	O
'%'	O
:	O
if	O
(	O
quote_percent	int
)	O
*	O
d	double
++	O
=	O
'%'	O
;	O
break	O
;	O
case	O
'\''	O
:	O
case	O
'\\'	O
:	O
case	O
'\r'	O
:	O
case	O
'\n'	O
:	O
case	O
'\t'	O
:	O
case	O
'"'	O
:	O
case	O
';'	O
:	O
case	O
' '	O
:	O
case	O
'?'	O
:	O
case	O
'|'	O
:	O
case	O
'['	O
:	O
case	O
']'	O
:	O
case	O
'{'	O
:	O
case	O
'}'	O
:	O
case	O
'<'	O
:	O
case	O
'>'	O
:	O
case	O
'`'	O
:	O
case	O
'!'	O
:	O
case	O
'$'	O
:	O
case	O
'&'	O
:	O
case	O
'*'	O
:	O
case	O
'('	O
:	O
case	O
')'	O
:	O
*	O
d	double
++	O
=	O
'\\'	O
;	O
break	O
;	O
case	O
'~'	O
:	O
case	O
'#'	O
:	O
if	O
(	O
d	double
==	O
ret	*(char)
)	O
*	O
d	double
++	O
=	O
'\\'	O
;	O
break	O
;	O
}	O
*	O
d	double
=	O
*	O
s	*(char)
;	O
}	O
*	O
d	double
=	O
'\0'	O
;	O
return	O
ret	*(char)
;	O
}	O
char	O
*	O
fake_name_quote	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
int	O
quote_percent	int
)	O
{	O
(	O
void	O
)	O
quote_percent	int
;	O
return	O
g_strdup	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
}	O
const	O
char	O
*	O
name_trunc	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
txt	*(char)
,	O
int	O
trunc_len	int
)	O
{	O
static	O
char	O
x	array(long)
[	O
MC_MAXPATHLEN	O
+	O
MC_MAXPATHLEN	O
]	O
;	O
int	O
txt_len	int
;	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
(	O
size_t	long
)	O
trunc_len	int
>	O
sizeof	O
(	O
x	array(long)
)	O
-	O
1	int
)	O
{	O
trunc_len	int
=	O
sizeof	O
(	O
x	array(long)
)	O
-	O
1	int
;	O
}	O
txt_len	int
=	O
strlen	(*(char))->(long)
(	O
txt	*(char)
)	O
;	O
if	O
(	O
txt_len	int
<=	O
trunc_len	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
x	array(long)
,	O
txt	*(char)
)	O
;	O
}	O
else	O
{	O
int	O
y	short
=	O
(	O
trunc_len	int
/	O
2	int
)	O
+	O
(	O
trunc_len	int
%	O
2	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
x	array(long)
,	O
txt	*(char)
,	O
y	short
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
x	array(long)
+	O
y	short
,	O
txt	*(char)
+	O
txt_len	int
-	O
(	O
trunc_len	int
/	O
2	int
)	O
,	O
trunc_len	int
/	O
2	int
)	O
;	O
x	array(long)
[	O
y	short
]	O
=	O
'~'	O
;	O
}	O
x	array(long)
[	O
trunc_len	int
]	O
=	O
0	int
;	O
for	O
(	O
p	*(void)
=	O
x	array(long)
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
if	O
(	O
!	O
is_printable	(int)->(int)
(	O
*	O
p	*(void)
)	O
)	O
*	O
p	*(void)
=	O
'?'	O
;	O
return	O
x	array(long)
;	O
}	O
const	O
char	O
*	O
path_trunc	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
path	*(char)
,	O
int	O
trunc_len	int
)	O
{	O
const	O
char	O
*	O
ret	*(char)
;	O
char	O
*	O
secure_path	*(char)
=	O
strip_password	(*(char),int)->(*(char))
(	O
g_strdup	(*(char))->(*(char))
(	O
path	*(char)
)	O
,	O
1	int
)	O
;	O
ret	*(char)
=	O
name_trunc	(*(char),int)->(*(char))
(	O
secure_path	*(char)
,	O
trunc_len	int
)	O
;	O
g_free	(*(void))->(void)
(	O
secure_path	*(char)
)	O
;	O
return	O
ret	*(char)
;	O
}	O
const	O
char	O
*	O
size_trunc	(double)->(*(char))
(	O
double	O
size	long
)	O
{	O
static	O
char	O
x	array(long)
[	O
BUF_TINY	int
]	O
;	O
long	O
int	O
divisor	long
=	O
1	int
;	O
const	O
char	O
*	O
xtra	*(char)
=	O
""	*(char)
;	O
if	O
(	O
size	long
>	O
999999999L	int
)	O
{	O
divisor	long
=	O
1024	int
;	O
xtra	*(char)
=	O
"K"	*(char)
;	O
if	O
(	O
size	long
/	O
divisor	long
>	O
999999999L	int
)	O
{	O
divisor	long
=	O
1024	int
*	O
1024	int
;	O
xtra	*(char)
=	O
"M"	*(char)
;	O
}	O
}	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
x	array(long)
,	O
sizeof	O
(	O
x	array(long)
)	O
,	O
"%.0f%s"	*(char)
,	O
(	O
size	long
/	O
divisor	long
)	O
,	O
xtra	*(char)
)	O
;	O
return	O
x	array(long)
;	O
}	O
const	O
char	O
*	O
size_trunc_sep	(double)->(*(char))
(	O
double	O
size	long
)	O
{	O
static	O
char	O
x	array(long)
[	O
60	int
]	O
;	O
int	O
count	int
;	O
const	O
char	O
*	O
p	*(void)
,	O
*	O
y	short
;	O
char	O
*	O
d	double
;	O
p	*(void)
=	O
y	short
=	O
size_trunc	(double)->(*(char))
(	O
size	long
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
-	O
1	int
;	O
d	double
=	O
x	array(long)
+	O
sizeof	O
(	O
x	array(long)
)	O
-	O
1	int
;	O
*	O
d	double
--	O
=	O
0	int
;	O
while	O
(	O
p	*(void)
>=	O
y	short
&&	O
isalpha	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(void)
)	O
)	O
*	O
d	double
--	O
=	O
*	O
p	*(void)
--	O
;	O
for	O
(	O
count	int
=	O
0	int
;	O
p	*(void)
>=	O
y	short
;	O
count	int
++	O
)	O
{	O
if	O
(	O
count	int
==	O
3	int
)	O
{	O
*	O
d	double
--	O
=	O
','	O
;	O
count	int
=	O
0	int
;	O
}	O
*	O
d	double
--	O
=	O
*	O
p	*(void)
--	O
;	O
}	O
d	double
++	O
;	O
if	O
(	O
*	O
d	double
==	O
','	O
)	O
d	double
++	O
;	O
return	O
d	double
;	O
}	O
void	O
size_trunc_len	(*(char),int,long,int)->(void)
(	O
char	O
*	O
buffer	*(char)
,	O
int	O
len	int
,	O
off_t	long
size	long
,	O
int	O
units	int
)	O
{	O
static	O
const	O
off_t	long
power10	array(long)
[	O
]	O
=	O
{	O
1	int
,	O
10	int
,	O
100	int
,	O
1000	int
,	O
10000	int
,	O
100000	int
,	O
1000000	int
,	O
10000000	int
,	O
100000000	int
,	O
1000000000	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
suffix	*(char)
[	O
]	O
=	O
{	O
""	*(char)
,	O
"K"	*(char)
,	O
"M"	*(char)
,	O
"G"	*(char)
,	O
"T"	*(char)
,	O
"P"	*(char)
,	O
"E"	*(char)
,	O
"Z"	*(char)
,	O
"Y"	*(char)
,	O
NULL	O
}	O
;	O
int	O
j	int
=	O
0	int
;	O
if	O
(	O
len	int
==	O
0	int
||	O
len	int
>	O
9	int
)	O
len	int
=	O
9	int
;	O
for	O
(	O
j	int
=	O
units	int
;	O
suffix	*(char)
[	O
j	int
]	O
!=	O
NULL	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
size	long
==	O
0	int
)	O
{	O
if	O
(	O
j	int
==	O
units	int
)	O
{	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
buffer	*(char)
,	O
len	int
+	O
1	int
,	O
"0"	*(char)
)	O
;	O
break	O
;	O
}	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
buffer	*(char)
,	O
len	int
+	O
1	int
,	O
(	O
len	int
>	O
1	int
)	O
?	O
"~%s"	*(char)
:	O
"%s"	*(char)
,	O
(	O
j	int
>	O
1	int
)	O
?	O
suffix	*(char)
[	O
j	int
-	O
1	int
]	O
:	O
"B"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
size	long
<	O
power10	array(long)
[	O
len	int
-	O
(	O
j	int
>	O
0	int
)	O
]	O
)	O
{	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
buffer	*(char)
,	O
len	int
+	O
1	int
,	O
"%lu%s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
size	long
,	O
suffix	*(char)
[	O
j	int
]	O
)	O
;	O
break	O
;	O
}	O
size	long
=	O
(	O
size	long
+	O
512	int
)	O
>>	O
10	int
;	O
}	O
}	O
int	O
is_exe	(int)->(int)
(	O
mode_t	int
mode	int
)	O
{	O
if	O
(	O
(	O
S_IXUSR	O
&	O
mode	int
)	O
||	O
(	O
S_IXGRP	O
&	O
mode	int
)	O
||	O
(	O
S_IXOTH	O
&	O
mode	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
string_perm	(int)->(*(char))
(	O
mode_t	int
mode_bits	int
)	O
{	O
static	O
char	O
mode	int
[	O
11	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
mode	int
,	O
"----------"	*(char)
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'd'	O
;	O
if	O
(	O
S_ISCHR	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'c'	O
;	O
if	O
(	O
S_ISBLK	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'b'	O
;	O
if	O
(	O
S_ISLNK	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'l'	O
;	O
if	O
(	O
S_ISFIFO	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'p'	O
;	O
if	O
(	O
S_ISNAM	int
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'n'	O
;	O
if	O
(	O
S_ISSOCK	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
's'	O
;	O
if	O
(	O
S_ISDOOR	int
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'D'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IXOTH	O
)	O
)	O
mode	int
[	O
9	int
]	O
=	O
'x'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IWOTH	O
)	O
)	O
mode	int
[	O
8	int
]	O
=	O
'w'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IROTH	O
)	O
)	O
mode	int
[	O
7	int
]	O
=	O
'r'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IXGRP	O
)	O
)	O
mode	int
[	O
6	int
]	O
=	O
'x'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IWGRP	O
)	O
)	O
mode	int
[	O
5	int
]	O
=	O
'w'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IRGRP	O
)	O
)	O
mode	int
[	O
4	int
]	O
=	O
'r'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IXUSR	O
)	O
)	O
mode	int
[	O
3	int
]	O
=	O
'x'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IWUSR	O
)	O
)	O
mode	int
[	O
2	int
]	O
=	O
'w'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IRUSR	O
)	O
)	O
mode	int
[	O
1	int
]	O
=	O
'r'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_ISUID	O
)	O
)	O
mode	int
[	O
3	int
]	O
=	O
(	O
mode	int
[	O
3	int
]	O
==	O
'x'	O
)	O
?	O
's'	O
:	O
'S'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_ISGID	O
)	O
)	O
mode	int
[	O
6	int
]	O
=	O
(	O
mode	int
[	O
6	int
]	O
==	O
'x'	O
)	O
?	O
's'	O
:	O
'S'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_ISVTX	O
)	O
)	O
mode	int
[	O
9	int
]	O
=	O
(	O
mode	int
[	O
9	int
]	O
==	O
'x'	O
)	O
?	O
't'	O
:	O
'T'	O
;	O
return	O
mode	int
;	O
}	O
char	O
*	O
strip_password	(*(char),int)->(*(char))
(	O
char	O
*	O
p	*(void)
,	O
int	O
has_prefix	int
)	O
{	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
size_t	long
len	int
;	O
}	O
prefixes	array(struct(*(char),long))
[	O
]	O
=	O
{	O
{	O
"/#ftp:"	*(char)
,	O
6	int
}	O
,	O
{	O
"ftp://"	*(char)
,	O
6	int
}	O
,	O
{	O
"/#mc:"	*(char)
,	O
5	int
}	O
,	O
{	O
"mc://"	*(char)
,	O
5	int
}	O
,	O
{	O
"/#smb:"	*(char)
,	O
6	int
}	O
,	O
{	O
"smb://"	*(char)
,	O
6	int
}	O
,	O
{	O
"/#sh:"	*(char)
,	O
5	int
}	O
,	O
{	O
"sh://"	*(char)
,	O
5	int
}	O
,	O
{	O
"ssh://"	*(char)
,	O
6	int
}	O
}	O
;	O
char	O
*	O
at	*(char)
,	O
*	O
inner_colon	*(char)
,	O
*	O
dir	*(struct)
;	O
size_t	long
i	array(int)
;	O
char	O
*	O
result	long
=	O
p	*(void)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
sizeof	O
(	O
prefixes	array(struct(*(char),long))
)	O
/	O
sizeof	O
(	O
prefixes	array(struct(*(char),long))
[	O
0	int
]	O
)	O
;	O
i	array(int)
++	O
)	O
{	O
char	O
*	O
q	*(char)
;	O
if	O
(	O
has_prefix	int
)	O
{	O
if	O
(	O
(	O
q	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
prefixes	array(struct(*(char),long))
[	O
i	array(int)
]	O
.	O
name	*(char)
)	O
)	O
==	O
0	int
)	O
continue	O
;	O
else	O
p	*(void)
=	O
q	*(char)
+	O
prefixes	array(struct(*(char),long))
[	O
i	array(int)
]	O
.	O
len	int
;	O
}	O
if	O
(	O
(	O
dir	*(struct)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
PATH_SEP	char
)	O
)	O
!=	O
NULL	O
)	O
*	O
dir	*(struct)
=	O
'\0'	O
;	O
at	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
'@'	O
)	O
;	O
if	O
(	O
dir	*(struct)
)	O
*	O
dir	*(struct)
=	O
PATH_SEP	char
;	O
if	O
(	O
at	*(char)
)	O
{	O
inner_colon	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
p	*(void)
,	O
':'	O
,	O
at	*(char)
-	O
p	*(void)
)	O
;	O
if	O
(	O
inner_colon	*(char)
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
inner_colon	*(char)
,	O
at	*(char)
,	O
strlen	(*(char))->(long)
(	O
at	*(char)
)	O
+	O
1	int
)	O
;	O
}	O
break	O
;	O
}	O
return	O
(	O
result	long
)	O
;	O
}	O
const	O
char	O
*	O
strip_home_and_password	(*(char))->(*(char))
(	O
const	O
char	O
*	O
dir	*(struct)
)	O
{	O
size_t	long
len	int
;	O
static	O
char	O
newdir	array(char)
[	O
MC_MAXPATHLEN	O
]	O
;	O
if	O
(	O
home_dir	*(char)
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
dir	*(struct)
,	O
home_dir	*(char)
,	O
len	int
=	O
strlen	(*(char))->(long)
(	O
home_dir	*(char)
)	O
)	O
&&	O
(	O
dir	*(struct)
[	O
len	int
]	O
==	O
PATH_SEP	char
||	O
dir	*(struct)
[	O
len	int
]	O
==	O
'\0'	O
)	O
)	O
{	O
newdir	array(char)
[	O
0	int
]	O
=	O
'~'	O
;	O
g_strlcpy	(*(char),*(char),long)->(long)
(	O
&	O
newdir	array(char)
[	O
1	int
]	O
,	O
&	O
dir	*(struct)
[	O
len	int
]	O
,	O
sizeof	O
(	O
newdir	array(char)
)	O
-	O
1	int
)	O
;	O
return	O
newdir	array(char)
;	O
}	O
g_strlcpy	(*(char),*(char),long)->(long)
(	O
newdir	array(char)
,	O
dir	*(struct)
,	O
sizeof	O
(	O
newdir	array(char)
)	O
)	O
;	O
strip_password	(*(char),int)->(*(char))
(	O
newdir	array(char)
,	O
1	int
)	O
;	O
return	O
newdir	array(char)
;	O
}	O
static	O
char	O
*	O
maybe_start_group	(*(char),int,*(int))->(*(char))
(	O
char	O
*	O
d	double
,	O
int	O
do_group	int
,	O
int	O
*	O
was_wildcard	*(int)
)	O
{	O
if	O
(	O
!	O
do_group	int
)	O
return	O
d	double
;	O
if	O
(	O
*	O
was_wildcard	*(int)
)	O
return	O
d	double
;	O
*	O
was_wildcard	*(int)
=	O
1	int
;	O
*	O
d	double
++	O
=	O
'\\'	O
;	O
*	O
d	double
++	O
=	O
'('	O
;	O
return	O
d	double
;	O
}	O
static	O
char	O
*	O
maybe_end_group	(*(char),int,*(int))->(*(char))
(	O
char	O
*	O
d	double
,	O
int	O
do_group	int
,	O
int	O
*	O
was_wildcard	*(int)
)	O
{	O
if	O
(	O
!	O
do_group	int
)	O
return	O
d	double
;	O
if	O
(	O
!	O
*	O
was_wildcard	*(int)
)	O
return	O
d	double
;	O
*	O
was_wildcard	*(int)
=	O
0	int
;	O
*	O
d	double
++	O
=	O
'\\'	O
;	O
*	O
d	double
++	O
=	O
')'	O
;	O
return	O
d	double
;	O
}	O
char	O
*	O
convert_pattern	(*(char),int,int)->(*(char))
(	O
const	O
char	O
*	O
pattern	*(char)
,	O
int	O
match_type	int
,	O
int	O
do_group	int
)	O
{	O
char	O
*	O
d	double
;	O
char	O
*	O
new_pattern	*(char)
;	O
int	O
was_wildcard	*(int)
=	O
0	int
;	O
const	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
(	O
match_type	int
!=	O
match_regex	int
)	O
&&	O
easy_patterns	int
)	O
{	O
new_pattern	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
MC_MAXPATHLEN	O
)	O
;	O
d	double
=	O
new_pattern	*(char)
;	O
if	O
(	O
match_type	int
==	O
match_file	int
)	O
*	O
d	double
++	O
=	O
'^'	O
;	O
for	O
(	O
s	*(char)
=	O
pattern	*(char)
;	O
*	O
s	*(char)
;	O
s	*(char)
++	O
,	O
d	double
++	O
)	O
{	O
switch	O
(	O
*	O
s	*(char)
)	O
{	O
case	O
'*'	O
:	O
d	double
=	O
maybe_start_group	(*(char),int,*(int))->(*(char))
(	O
d	double
,	O
do_group	int
,	O
&	O
was_wildcard	*(int)
)	O
;	O
*	O
d	double
++	O
=	O
'.'	O
;	O
*	O
d	double
=	O
'*'	O
;	O
break	O
;	O
case	O
'?'	O
:	O
d	double
=	O
maybe_start_group	(*(char),int,*(int))->(*(char))
(	O
d	double
,	O
do_group	int
,	O
&	O
was_wildcard	*(int)
)	O
;	O
*	O
d	double
=	O
'.'	O
;	O
break	O
;	O
case	O
'.'	O
:	O
d	double
=	O
maybe_end_group	(*(char),int,*(int))->(*(char))
(	O
d	double
,	O
do_group	int
,	O
&	O
was_wildcard	*(int)
)	O
;	O
*	O
d	double
++	O
=	O
'\\'	O
;	O
*	O
d	double
=	O
'.'	O
;	O
break	O
;	O
default	O
:	O
d	double
=	O
maybe_end_group	(*(char),int,*(int))->(*(char))
(	O
d	double
,	O
do_group	int
,	O
&	O
was_wildcard	*(int)
)	O
;	O
*	O
d	double
=	O
*	O
s	*(char)
;	O
break	O
;	O
}	O
}	O
d	double
=	O
maybe_end_group	(*(char),int,*(int))->(*(char))
(	O
d	double
,	O
do_group	int
,	O
&	O
was_wildcard	*(int)
)	O
;	O
if	O
(	O
match_type	int
==	O
match_file	int
)	O
*	O
d	double
++	O
=	O
'$'	O
;	O
*	O
d	double
=	O
0	int
;	O
return	O
new_pattern	*(char)
;	O
}	O
else	O
return	O
g_strdup	(*(char))->(*(char))
(	O
pattern	*(char)
)	O
;	O
}	O
int	O
regexp_match	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
pattern	*(char)
,	O
const	O
char	O
*	O
string	*(char)
,	O
int	O
match_type	int
)	O
{	O
static	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
static	O
char	O
*	O
old_pattern	*(char)
=	O
NULL	O
;	O
static	O
int	O
old_type	int
;	O
int	O
rval	*(char)
;	O
char	O
*	O
my_pattern	*(char)
;	O
if	O
(	O
!	O
old_pattern	*(char)
||	O
STRCOMP	O
(	O
old_pattern	*(char)
,	O
pattern	*(char)
)	O
||	O
old_type	int
!=	O
match_type	int
)	O
{	O
if	O
(	O
old_pattern	*(char)
)	O
{	O
regfree	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(void)
(	O
&	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
;	O
g_free	(*(void))->(void)
(	O
old_pattern	*(char)
)	O
;	O
old_pattern	*(char)
=	O
NULL	O
;	O
}	O
my_pattern	*(char)
=	O
convert_pattern	(*(char),int,int)->(*(char))
(	O
pattern	*(char)
,	O
match_type	int
,	O
0	int
)	O
;	O
if	O
(	O
regcomp	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int)->(int)
(	O
&	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
my_pattern	*(char)
,	O
REG_EXTENDED	int
|	O
REG_NOSUB	O
|	O
MC_ARCH_FLAGS	int
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
my_pattern	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
old_pattern	*(char)
=	O
my_pattern	*(char)
;	O
old_type	int
=	O
match_type	int
;	O
}	O
rval	*(char)
=	O
!	O
regexec	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),long,array(struct(int,int)),int)->(int)
(	O
&	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
string	*(char)
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
;	O
return	O
rval	*(char)
;	O
}	O
const	O
char	O
*	O
extension	(*(char))->(*(char))
(	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
const	O
char	O
*	O
d	double
=	O
strrchr	(*(char),int)->(*(char))
(	O
filename	*(char)
,	O
'.'	O
)	O
;	O
return	O
(	O
d	double
!=	O
NULL	O
)	O
?	O
d	double
+	O
1	int
:	O
""	*(char)
;	O
}	O
int	O
get_int	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
file	*(char)
,	O
const	O
char	O
*	O
key	*(void)
,	O
int	O
def	int
)	O
{	O
return	O
GetPrivateProfileInt	(*(char),*(char),int,*(char))->(int)
(	O
app_text	array(char)
,	O
key	*(void)
,	O
def	int
,	O
file	*(char)
)	O
;	O
}	O
int	O
set_int	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
file	*(char)
,	O
const	O
char	O
*	O
key	*(void)
,	O
int	O
value	*(void)
)	O
{	O
char	O
buffer	*(char)
[	O
BUF_TINY	int
]	O
;	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
buffer	*(char)
,	O
sizeof	O
(	O
buffer	*(char)
)	O
,	O
"%d"	*(char)
,	O
value	*(void)
)	O
;	O
return	O
WritePrivateProfileString	(*(char),*(char),*(char),*(char))->(int)
(	O
app_text	array(char)
,	O
key	*(void)
,	O
buffer	*(char)
,	O
file	*(char)
)	O
;	O
}	O
extern	O
char	O
*	O
get_config_string	(*(char),*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
file	*(char)
,	O
const	O
char	O
*	O
key	*(void)
,	O
const	O
char	O
*	O
defval	*(char)
)	O
{	O
char	O
buffer	*(char)
[	O
1024	int
]	O
;	O
(	O
void	O
)	O
GetPrivateProfileString	(*(char),*(char),*(char),*(char),short,*(char))->(short)
(	O
app_text	array(char)
,	O
key	*(void)
,	O
defval	*(char)
,	O
buffer	*(char)
,	O
sizeof	O
(	O
buffer	*(char)
)	O
,	O
file	*(char)
)	O
;	O
return	O
g_strdup	(*(char))->(*(char))
(	O
buffer	*(char)
)	O
;	O
}	O
extern	O
void	O
set_config_string	(*(char),*(char),*(char))->(void)
(	O
const	O
char	O
*	O
file	*(char)
,	O
const	O
char	O
*	O
key	*(void)
,	O
const	O
char	O
*	O
val	array(int)
)	O
{	O
(	O
void	O
)	O
WritePrivateProfileString	(*(char),*(char),*(char),*(char))->(int)
(	O
app_text	array(char)
,	O
key	*(void)
,	O
val	array(int)
,	O
file	*(char)
)	O
;	O
}	O
int	O
exist_file	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
access	(*(char),int)->(int)
(	O
name	*(char)
,	O
R_OK	int
)	O
==	O
0	int
;	O
}	O
char	O
*	O
load_file	(*(char))->(*(char))
(	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
FILE	struct
*	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
s	*(char)
;	O
char	O
*	O
data	*(void)
;	O
long	O
read_size	long
;	O
if	O
(	O
(	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
&	O
s	*(char)
)	O
!=	O
0	int
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
0	int
;	O
}	O
data	*(void)
=	O
g_malloc	(long)->(*(void))
(	O
s	*(char)
.	O
st_size	long
+	O
1	int
)	O
;	O
read_size	long
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
data	*(void)
,	O
1	int
,	O
s	*(char)
.	O
st_size	long
,	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
data	*(void)
[	O
read_size	long
]	O
=	O
0	int
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
read_size	long
>	O
0	int
)	O
return	O
data	*(void)
;	O
else	O
{	O
g_free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
char	O
*	O
load_mc_home_file	(*(char),*(*(char)))->(*(char))
(	O
const	O
char	O
*	O
filename	*(char)
,	O
char	O
*	O
*	O
allocated_filename	*(*(char))
)	O
{	O
char	O
*	O
hintfile_base	*(char)
,	O
*	O
hintfile	*(char)
;	O
char	O
*	O
lang	*(char)
;	O
char	O
*	O
data	*(void)
;	O
hintfile_base	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
mc_home	*(char)
,	O
filename	*(char)
)	O
;	O
lang	*(char)
=	O
guess_message_value	()->(*(char))
(	O
)	O
;	O
hintfile	*(char)
=	O
g_strconcat	(*(char))->(*(char))
(	O
hintfile_base	*(char)
,	O
"."	*(char)
,	O
lang	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
data	*(void)
=	O
load_file	(*(char))->(*(char))
(	O
hintfile	*(char)
)	O
;	O
if	O
(	O
!	O
data	*(void)
)	O
{	O
g_free	(*(void))->(void)
(	O
hintfile	*(char)
)	O
;	O
if	O
(	O
lang	*(char)
[	O
0	int
]	O
&&	O
lang	*(char)
[	O
1	int
]	O
)	O
lang	*(char)
[	O
2	int
]	O
=	O
0	int
;	O
hintfile	*(char)
=	O
g_strconcat	(*(char))->(*(char))
(	O
hintfile_base	*(char)
,	O
"."	*(char)
,	O
lang	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
data	*(void)
=	O
load_file	(*(char))->(*(char))
(	O
hintfile	*(char)
)	O
;	O
if	O
(	O
!	O
data	*(void)
)	O
{	O
g_free	(*(void))->(void)
(	O
hintfile	*(char)
)	O
;	O
hintfile	*(char)
=	O
hintfile_base	*(char)
;	O
data	*(void)
=	O
load_file	(*(char))->(*(char))
(	O
hintfile_base	*(char)
)	O
;	O
}	O
}	O
g_free	(*(void))->(void)
(	O
lang	*(char)
)	O
;	O
if	O
(	O
hintfile	*(char)
!=	O
hintfile_base	*(char)
)	O
g_free	(*(void))->(void)
(	O
hintfile_base	*(char)
)	O
;	O
if	O
(	O
allocated_filename	*(*(char))
)	O
*	O
allocated_filename	*(*(char))
=	O
hintfile	*(char)
;	O
else	O
g_free	(*(void))->(void)
(	O
hintfile	*(char)
)	O
;	O
return	O
data	*(void)
;	O
}	O
size_t	long
i18n_checktimelength	()->(long)
(	O
void	O
)	O
{	O
size_t	long
length	int
,	O
a	*(void)
,	O
b	*(void)
;	O
char	O
buf	*(char)
[	O
MAX_I18NTIMELENGTH	int
+	O
1	int
]	O
;	O
time_t	long
testtime	long
=	O
time	long
(	O
NULL	O
)	O
;	O
a	*(void)
=	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
-	O
1	int
,	O
_	O
(	O
"%b %e %H:%M"	*(char)
)	O
,	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
testtime	long
)	O
)	O
;	O
b	*(void)
=	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
-	O
1	int
,	O
_	O
(	O
"%b %e  %Y"	*(char)
)	O
,	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
testtime	long
)	O
)	O
;	O
length	int
=	O
max	long
(	O
a	*(void)
,	O
b	*(void)
)	O
;	O
if	O
(	O
length	int
>	O
MAX_I18NTIMELENGTH	int
||	O
length	int
<	O
MIN_I18NTIMELENGTH	int
)	O
length	int
=	O
STD_I18NTIMELENGTH	int
;	O
return	O
length	int
;	O
}	O
const	O
char	O
*	O
file_date	(long)->(*(char))
(	O
time_t	long
when	long
)	O
{	O
static	O
char	O
timebuf	array(char)
[	O
MAX_I18NTIMELENGTH	int
+	O
1	int
]	O
;	O
time_t	long
current_time	long
=	O
time	long
(	O
(	O
time_t	long
)	O
0	int
)	O
;	O
static	O
size_t	long
i18n_timelength	long
=	O
0	int
;	O
static	O
const	O
char	O
*	O
fmtyear	*(char)
,	O
*	O
fmttime	*(char)
;	O
const	O
char	O
*	O
fmt	*(char)
;	O
if	O
(	O
i18n_timelength	long
==	O
0	int
)	O
{	O
i18n_timelength	long
=	O
i18n_checktimelength	()->(long)
(	O
)	O
+	O
1	int
;	O
fmtyear	*(char)
=	O
_	O
(	O
"%b %e  %Y"	*(char)
)	O
;	O
fmttime	*(char)
=	O
_	O
(	O
"%b %e %H:%M"	*(char)
)	O
;	O
}	O
if	O
(	O
current_time	long
>	O
when	long
+	O
6L	int
*	O
30L	int
*	O
24L	int
*	O
60L	int
*	O
60L	int
||	O
current_time	long
<	O
when	long
-	O
60L	int
*	O
60L	int
)	O
fmt	*(char)
=	O
fmtyear	*(char)
;	O
else	O
fmt	*(char)
=	O
fmttime	*(char)
;	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
timebuf	array(char)
,	O
i18n_timelength	long
,	O
fmt	*(char)
,	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
when	long
)	O
)	O
;	O
return	O
timebuf	array(char)
;	O
}	O
const	O
char	O
*	O
extract_line	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
top	*(char)
)	O
{	O
static	O
char	O
tmp_line	array(char)
[	O
BUF_MEDIUM	int
]	O
;	O
char	O
*	O
t	long
=	O
tmp_line	array(char)
;	O
while	O
(	O
*	O
s	*(char)
&&	O
*	O
s	*(char)
!=	O
'\n'	O
&&	O
(	O
size_t	long
)	O
(	O
t	long
-	O
tmp_line	array(char)
)	O
<	O
sizeof	O
(	O
tmp_line	array(char)
)	O
-	O
1	int
&&	O
s	*(char)
<	O
top	*(char)
)	O
*	O
t	long
++	O
=	O
*	O
s	*(char)
++	O
;	O
*	O
t	long
=	O
0	int
;	O
return	O
tmp_line	array(char)
;	O
}	O
const	O
char	O
*	O
_icase_search	(*(char),*(char),*(int))->(*(char))
(	O
const	O
char	O
*	O
text	*(char)
,	O
const	O
char	O
*	O
data	*(void)
,	O
int	O
*	O
lng	*(int)
)	O
{	O
const	O
char	O
*	O
d	double
=	O
text	*(char)
;	O
const	O
char	O
*	O
e	*(char)
=	O
data	*(void)
;	O
int	O
dlng	int
=	O
0	int
;	O
if	O
(	O
lng	*(int)
)	O
*	O
lng	*(int)
=	O
0	int
;	O
for	O
(	O
;	O
*	O
e	*(char)
;	O
e	*(char)
++	O
)	O
{	O
while	O
(	O
*	O
(	O
e	*(char)
+	O
1	int
)	O
==	O
'\b'	O
&&	O
*	O
(	O
e	*(char)
+	O
2	int
)	O
)	O
{	O
e	*(char)
+=	O
2	int
;	O
dlng	int
+=	O
2	int
;	O
}	O
if	O
(	O
toupper	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
d	double
)	O
==	O
toupper	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
e	*(char)
)	O
)	O
d	double
++	O
;	O
else	O
{	O
e	*(char)
-=	O
d	double
-	O
text	*(char)
;	O
d	double
=	O
text	*(char)
;	O
dlng	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
*	O
d	double
)	O
{	O
if	O
(	O
lng	*(int)
)	O
*	O
lng	*(int)
=	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
+	O
dlng	int
;	O
return	O
e	*(char)
+	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
x_basename	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
const	O
char	O
*	O
where	*(char)
;	O
return	O
(	O
(	O
where	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
s	*(char)
,	O
PATH_SEP	char
)	O
)	O
)	O
?	O
where	*(char)
+	O
1	int
:	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
unix_error_string	(int)->(*(char))
(	O
int	O
error_num	int
)	O
{	O
static	O
char	O
buffer	*(char)
[	O
BUF_LARGE	O
]	O
;	O
gchar	char
*	O
strerror_currentlocale	*(char)
;	O
strerror_currentlocale	*(char)
=	O
g_locale_from_utf8	(*(char),long,*(long),*(long),*(*(struct(int,int,*(char)))))->(*(char))
(	O
g_strerror	(int)->(*(char))
(	O
error_num	int
)	O
,	O
-	O
1	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
buffer	*(char)
,	O
sizeof	O
(	O
buffer	*(char)
)	O
,	O
"%s (%d)"	*(char)
,	O
strerror_currentlocale	*(char)
,	O
error_num	int
)	O
;	O
g_free	(*(void))->(void)
(	O
strerror_currentlocale	*(char)
)	O
;	O
return	O
buffer	*(char)
;	O
}	O
const	O
char	O
*	O
skip_separators	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
for	O
(	O
;	O
*	O
s	*(char)
;	O
s	*(char)
++	O
)	O
if	O
(	O
*	O
s	*(char)
!=	O
' '	O
&&	O
*	O
s	*(char)
!=	O
'\t'	O
&&	O
*	O
s	*(char)
!=	O
','	O
)	O
break	O
;	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
skip_numbers	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
for	O
(	O
;	O
*	O
s	*(char)
;	O
s	*(char)
++	O
)	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	*(char)
)	O
)	O
break	O
;	O
return	O
s	*(char)
;	O
}	O
char	O
*	O
strip_ctrl_codes	(*(char))->(*(char))
(	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
*	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
char	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
if	O
(	O
!	O
s	*(char)
)	O
return	O
0	int
;	O
for	O
(	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
s	*(char)
,	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
s	*(char)
;	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
)	O
{	O
if	O
(	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
==	O
ESC_CHAR	char
)	O
{	O
;	O
if	O
(	O
*	O
(	O
++	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
==	O
'['	O
)	O
{	O
while	O
(	O
*	O
(	O
++	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
"0123456789;?"	*(char)
,	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
)	O
;	O
}	O
if	O
(	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
is_printable	(int)->(int)
(	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
)	O
*	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
++	O
=	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
++	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
}	O
*	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
0	int
;	O
return	O
s	*(char)
;	O
}	O
enum	O
compression_type	enum(int,int,int,int)
get_compression_type	(int)->(enum(int,int,int,int))
(	O
int	O
fd	int
)	O
{	O
unsigned	O
char	O
magic	array(char)
[	O
4	int
]	O
;	O
if	O
(	O
mc_read	(int,*(void),int)->(int)
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
magic	array(char)
,	O
4	int
)	O
!=	O
4	int
)	O
return	O
COMPRESSION_NONE	int
;	O
if	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
037	int
&&	O
(	O
magic	array(char)
[	O
1	int
]	O
==	O
0213	int
||	O
magic	array(char)
[	O
1	int
]	O
==	O
0236	int
)	O
)	O
{	O
return	O
COMPRESSION_GZIP	int
;	O
}	O
if	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
0120	int
&&	O
magic	array(char)
[	O
1	int
]	O
==	O
0113	int
&&	O
magic	array(char)
[	O
2	int
]	O
==	O
003	int
&&	O
magic	array(char)
[	O
3	int
]	O
==	O
004	int
)	O
{	O
mc_lseek	(int,long,int)->(long)
(	O
fd	int
,	O
8	int
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
mc_read	(int,*(void),int)->(int)
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
magic	array(char)
,	O
2	int
)	O
!=	O
2	int
)	O
return	O
COMPRESSION_NONE	int
;	O
if	O
(	O
(	O
magic	array(char)
[	O
0	int
]	O
!=	O
8	int
&&	O
magic	array(char)
[	O
0	int
]	O
!=	O
0	int
)	O
||	O
magic	array(char)
[	O
1	int
]	O
!=	O
0	int
)	O
return	O
COMPRESSION_NONE	int
;	O
return	O
COMPRESSION_GZIP	int
;	O
}	O
if	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
037	int
&&	O
(	O
magic	array(char)
[	O
1	int
]	O
==	O
036	int
||	O
magic	array(char)
[	O
1	int
]	O
==	O
0240	int
||	O
magic	array(char)
[	O
1	int
]	O
==	O
0235	int
)	O
)	O
{	O
return	O
COMPRESSION_GZIP	int
;	O
}	O
if	O
(	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
'B'	O
)	O
&&	O
(	O
magic	array(char)
[	O
1	int
]	O
==	O
'Z'	O
)	O
&&	O
(	O
magic	array(char)
[	O
3	int
]	O
>=	O
'1'	O
)	O
&&	O
(	O
magic	array(char)
[	O
3	int
]	O
<=	O
'9'	O
)	O
)	O
{	O
switch	O
(	O
magic	array(char)
[	O
2	int
]	O
)	O
{	O
case	O
'0'	O
:	O
return	O
COMPRESSION_BZIP	int
;	O
case	O
'h'	O
:	O
return	O
COMPRESSION_BZIP2	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
decompress_extension	(int)->(*(char))
(	O
int	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
COMPRESSION_GZIP	int
:	O
return	O
"#ugz"	*(char)
;	O
case	O
COMPRESSION_BZIP	int
:	O
return	O
"#ubz"	*(char)
;	O
case	O
COMPRESSION_BZIP2	int
:	O
return	O
"#ubz2"	*(char)
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Fatal: decompress_extension called with an unknown argument\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
add_hook	(*(*(struct(*((*`)->(void)),*(void),*(struct`)))),*((*(void))->(void)),*(void))->(void)
(	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
*	O
*	O
hook_list	*(struct)
,	O
void	O
(	O
*	O
hook_fn	*((*(void))->(void))
)	O
(	O
void	O
*	O
)	O
,	O
void	O
*	O
data	*(void)
)	O
{	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
*	O
new_hook	*(struct)
=	O
g_new	O
(	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
,	O
1	int
)	O
;	O
new_hook	*(struct)
->	O
hook_fn	*((*(void))->(void))
=	O
hook_fn	*((*(void))->(void))
;	O
new_hook	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
*	O
hook_list	*(struct)
;	O
new_hook	*(struct)
->	O
hook_data	*(void)
=	O
data	*(void)
;	O
*	O
hook_list	*(struct)
=	O
new_hook	*(struct)
;	O
}	O
void	O
execute_hooks	(*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))->(void)
(	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
*	O
hook_list	*(struct)
)	O
{	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
*	O
new_hook	*(struct)
=	O
0	int
;	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
*	O
p	*(void)
;	O
while	O
(	O
hook_list	*(struct)
)	O
{	O
add_hook	(*(*(struct(*((*`)->(void)),*(void),*(struct`)))),*((*(void))->(void)),*(void))->(void)
(	O
&	O
new_hook	*(struct)
,	O
hook_list	*(struct)
->	O
hook_fn	*((*(void))->(void))
,	O
hook_list	*(struct)
->	O
hook_data	*(void)
)	O
;	O
hook_list	*(struct)
=	O
hook_list	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
p	*(void)
=	O
new_hook	*(struct)
;	O
while	O
(	O
new_hook	*(struct)
)	O
{	O
(	O
*	O
new_hook	*(struct)
->	O
hook_fn	*((*(void))->(void))
)	O
(	O
new_hook	*(struct)
->	O
hook_data	*(void)
)	O
;	O
new_hook	*(struct)
=	O
new_hook	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
for	O
(	O
hook_list	*(struct)
=	O
p	*(void)
;	O
hook_list	*(struct)
;	O
)	O
{	O
p	*(void)
=	O
hook_list	*(struct)
;	O
hook_list	*(struct)
=	O
hook_list	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
}	O
void	O
delete_hook	(*(*(struct(*((*`)->(void)),*(void),*(struct`)))),*((*(void))->(void)))->(void)
(	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
*	O
*	O
hook_list	*(struct)
,	O
void	O
(	O
*	O
hook_fn	*((*(void))->(void))
)	O
(	O
void	O
*	O
)	O
)	O
{	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
*	O
current	*(struct)
,	O
*	O
new_list	*(struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct`)))))
,	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
new_list	*(struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct`)))))
=	O
0	int
;	O
for	O
(	O
current	*(struct)
=	O
*	O
hook_list	*(struct)
;	O
current	*(struct)
;	O
current	*(struct)
=	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
current	*(struct)
->	O
hook_fn	*((*(void))->(void))
==	O
hook_fn	*((*(void))->(void))
)	O
g_free	(*(void))->(void)
(	O
current	*(struct)
)	O
;	O
else	O
add_hook	(*(*(struct(*((*`)->(void)),*(void),*(struct`)))),*((*(void))->(void)),*(void))->(void)
(	O
&	O
new_list	*(struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct`)))))
,	O
current	*(struct)
->	O
hook_fn	*((*(void))->(void))
,	O
current	*(struct)
->	O
hook_data	*(void)
)	O
;	O
}	O
*	O
hook_list	*(struct)
=	O
new_list	*(struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct`)))))
;	O
}	O
int	O
hook_present	(*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))),*((*(void))->(void)))->(int)
(	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
*	O
hook_list	*(struct)
,	O
void	O
(	O
*	O
hook_fn	*((*(void))->(void))
)	O
(	O
void	O
*	O
)	O
)	O
{	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
hook_list	*(struct)
;	O
p	*(void)
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
if	O
(	O
p	*(void)
->	O
hook_fn	*((*(void))->(void))
==	O
hook_fn	*((*(void))->(void))
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
wipe_password	(*(char))->(void)
(	O
char	O
*	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
)	O
{	O
char	O
*	O
p	*(void)
=	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
;	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
;	O
for	O
(	O
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
*	O
p	*(void)
=	O
0	int
;	O
g_free	(*(void))->(void)
(	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
)	O
;	O
}	O
char	O
*	O
convert_controls	(*(char))->(*(char))
(	O
const	O
char	O
*	O
p	*(void)
)	O
{	O
char	O
*	O
valcopy	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
p	*(void)
)	O
;	O
char	O
*	O
q	*(char)
;	O
for	O
(	O
q	*(char)
=	O
valcopy	*(char)
;	O
*	O
p	*(void)
;	O
)	O
{	O
if	O
(	O
*	O
p	*(void)
==	O
'\\'	O
)	O
{	O
p	*(void)
++	O
;	O
if	O
(	O
(	O
*	O
p	*(void)
==	O
'e'	O
)	O
||	O
(	O
*	O
p	*(void)
==	O
'E'	O
)	O
)	O
{	O
p	*(void)
++	O
;	O
*	O
q	*(char)
++	O
=	O
ESC_CHAR	char
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
p	*(void)
==	O
'^'	O
)	O
{	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'^'	O
)	O
*	O
q	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
else	O
{	O
char	O
c	int
=	O
(	O
*	O
p	*(void)
|	O
0x20	int
)	O
;	O
if	O
(	O
c	int
>=	O
'a'	O
&&	O
c	int
<=	O
'z'	O
)	O
{	O
*	O
q	*(char)
++	O
=	O
c	int
-	O
'a'	O
+	O
1	int
;	O
p	*(void)
++	O
;	O
}	O
else	O
if	O
(	O
*	O
p	*(void)
)	O
p	*(void)
++	O
;	O
}	O
}	O
else	O
*	O
q	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
}	O
}	O
*	O
q	*(char)
=	O
0	int
;	O
return	O
valcopy	*(char)
;	O
}	O
static	O
char	O
*	O
resolve_symlinks	(*(char))->(*(char))
(	O
const	O
char	O
*	O
path	*(char)
)	O
{	O
char	O
*	O
buf	*(char)
,	O
*	O
buf2	*(char)
,	O
*	O
q	*(char)
,	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
c	int
;	O
int	O
len	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
mybuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
const	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
*	O
path	*(char)
!=	O
PATH_SEP	char
)	O
return	O
NULL	O
;	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
buf	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
MC_MAXPATHLEN	O
)	O
;	O
buf2	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
MC_MAXPATHLEN	O
)	O
;	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
++	O
=	O
PATH_SEP	char
;	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
0	int
;	O
p	*(void)
=	O
path	*(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
+	O
1	int
,	O
PATH_SEP	char
)	O
;	O
if	O
(	O
!	O
q	*(char)
)	O
{	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
+	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
q	*(char)
==	O
p	*(void)
+	O
1	int
)	O
break	O
;	O
}	O
c	int
=	O
*	O
q	*(char)
;	O
*	O
q	*(char)
=	O
0	int
;	O
if	O
(	O
mc_lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
path	*(char)
,	O
&	O
mybuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
{	O
g_free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
buf2	*(char)
)	O
;	O
*	O
q	*(char)
=	O
c	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
S_ISLNK	O
(	O
mybuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
p	*(void)
+	O
1	int
)	O
;	O
else	O
{	O
len	int
=	O
mc_readlink	(*(char),*(char),int)->(int)
(	O
path	*(char)
,	O
buf2	*(char)
,	O
MC_MAXPATHLEN	O
-	O
1	int
)	O
;	O
if	O
(	O
len	int
<	O
0	int
)	O
{	O
g_free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
buf2	*(char)
)	O
;	O
*	O
q	*(char)
=	O
c	int
;	O
return	O
NULL	O
;	O
}	O
buf2	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
if	O
(	O
*	O
buf2	*(char)
==	O
PATH_SEP	char
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
buf2	*(char)
)	O
;	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
buf2	*(char)
)	O
;	O
}	O
canonicalize_pathname	(*(char))->(void)
(	O
buf	*(char)
)	O
;	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
strchr	(*(char),int)->(*(char))
(	O
buf	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
||	O
*	O
(	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
-	O
1	int
)	O
!=	O
PATH_SEP	char
)	O
{	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
++	O
=	O
PATH_SEP	char
;	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
0	int
;	O
}	O
*	O
q	*(char)
=	O
c	int
;	O
p	*(void)
=	O
q	*(char)
;	O
if	O
(	O
!	O
c	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
*	O
buf	*(char)
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
PATH_SEP_STR	*(char)
)	O
;	O
else	O
if	O
(	O
*	O
(	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
-	O
1	int
)	O
==	O
PATH_SEP	char
&&	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
!=	O
buf	*(char)
+	O
1	int
)	O
*	O
(	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
-	O
1	int
)	O
=	O
0	int
;	O
g_free	(*(void))->(void)
(	O
buf2	*(char)
)	O
;	O
return	O
buf	*(char)
;	O
}	O
char	O
*	O
diff_two_paths	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
first	*(char)
,	O
const	O
char	O
*	O
second	*(char)
)	O
{	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(char)
,	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
*	O
s	*(char)
,	O
*	O
buf	*(char)
=	O
NULL	O
;	O
int	O
i	array(int)
,	O
j	int
,	O
prevlen	int
=	O
-	O
1	int
,	O
currlen	int
;	O
char	O
*	O
my_first	*(char)
=	O
NULL	O
,	O
*	O
my_second	*(char)
=	O
NULL	O
;	O
my_first	*(char)
=	O
resolve_symlinks	(*(char))->(*(char))
(	O
first	*(char)
)	O
;	O
if	O
(	O
my_first	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
my_second	*(char)
=	O
resolve_symlinks	(*(char))->(*(char))
(	O
second	*(char)
)	O
;	O
if	O
(	O
my_second	*(char)
==	O
NULL	O
)	O
{	O
g_free	(*(void))->(void)
(	O
my_first	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
2	int
;	O
j	int
++	O
)	O
{	O
p	*(void)
=	O
my_first	*(char)
;	O
q	*(char)
=	O
my_second	*(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
PATH_SEP	char
)	O
;	O
s	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
q	*(char)
,	O
PATH_SEP	char
)	O
;	O
if	O
(	O
!	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
||	O
!	O
s	*(char)
)	O
break	O
;	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
0	int
;	O
*	O
s	*(char)
=	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
q	*(char)
)	O
)	O
{	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
PATH_SEP	char
;	O
*	O
s	*(char)
=	O
PATH_SEP	char
;	O
break	O
;	O
}	O
else	O
{	O
*	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
PATH_SEP	char
;	O
*	O
s	*(char)
=	O
PATH_SEP	char
;	O
}	O
p	*(void)
=	O
r	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
+	O
1	int
;	O
q	*(char)
=	O
s	*(char)
+	O
1	int
;	O
}	O
p	*(void)
--	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
(	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
+	O
1	int
,	O
PATH_SEP	char
)	O
)	O
!=	O
NULL	O
;	O
i	array(int)
++	O
)	O
;	O
currlen	int
=	O
(	O
i	array(int)
+	O
1	int
)	O
*	O
3	int
+	O
strlen	(*(char))->(long)
(	O
q	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
j	int
)	O
{	O
if	O
(	O
currlen	int
<	O
prevlen	int
)	O
g_free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
else	O
{	O
g_free	(*(void))->(void)
(	O
my_first	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
my_second	*(char)
)	O
;	O
return	O
buf	*(char)
;	O
}	O
}	O
p	*(void)
=	O
buf	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
currlen	int
)	O
;	O
prevlen	int
=	O
currlen	int
;	O
for	O
(	O
;	O
i	array(int)
>=	O
0	int
;	O
i	array(int)
--	O
,	O
p	*(void)
+=	O
3	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
"../"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
q	*(char)
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
my_first	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
my_second	*(char)
)	O
;	O
return	O
buf	*(char)
;	O
}	O
char	O
*	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
dir	*(struct)
,	O
const	O
char	O
*	O
file	*(char)
)	O
{	O
int	O
i	array(int)
=	O
strlen	(*(char))->(long)
(	O
dir	*(struct)
)	O
;	O
if	O
(	O
dir	*(struct)
[	O
i	array(int)
-	O
1	int
]	O
==	O
PATH_SEP	char
)	O
return	O
g_strconcat	(*(char))->(*(char))
(	O
dir	*(struct)
,	O
file	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
else	O
return	O
g_strconcat	(*(char))->(*(char))
(	O
dir	*(struct)
,	O
PATH_SEP_STR	*(char)
,	O
file	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
GList	struct
*	O
list_append_unique	(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),*(char))->(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
GList	struct
*	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
char	O
*	O
text	*(char)
)	O
{	O
GList	struct
*	O
link	(*(char),*(char))->(int)
,	O
*	O
newlink	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
g_list_append	(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),*(void))->(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
text	*(char)
)	O
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
g_list_last	(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
;	O
link	(*(char),*(char))->(int)
=	O
g_list_previous	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
;	O
while	O
(	O
link	(*(char),*(char))->(int)
)	O
{	O
newlink	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
g_list_previous	O
(	O
link	(*(char),*(char))->(int)
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
link	(*(char),*(char))->(int)
->	O
data	*(void)
,	O
text	*(char)
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
link	(*(char),*(char))->(int)
->	O
data	*(void)
)	O
;	O
g_list_remove_link	(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
link	(*(char),*(char))->(int)
)	O
;	O
g_list_free_1	(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
link	(*(char),*(char))->(int)
)	O
;	O
}	O
link	(*(char),*(char))->(int)
=	O
newlink	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
}	O
return	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
}	O
int	O
mc_mkstemps	(*(*(char)),*(char),*(char))->(int)
(	O
char	O
*	O
*	O
pname	*(*(char))
,	O
const	O
char	O
*	O
prefix	*(char)
,	O
const	O
char	O
*	O
suffix	*(char)
)	O
{	O
static	O
const	O
char	O
letters	array(char)
[	O
]	O
=	O
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"	*(char)
;	O
static	O
unsigned	O
long	O
value	*(void)
;	O
struct	O
timeval	struct(long,long)
tv	*(struct(long,long))
;	O
char	O
*	O
tmpbase	*(char)
;	O
char	O
*	O
tmpname	*(char)
;	O
char	O
*	O
XXXXXX	*(char)
;	O
int	O
count	int
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
prefix	*(char)
,	O
PATH_SEP	char
)	O
==	O
NULL	O
)	O
{	O
tmpbase	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
mc_tmpdir	()->(*(char))
(	O
)	O
,	O
prefix	*(char)
)	O
;	O
}	O
else	O
{	O
tmpbase	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
prefix	*(char)
)	O
;	O
}	O
tmpname	*(char)
=	O
g_strconcat	(*(char))->(*(char))
(	O
tmpbase	*(char)
,	O
"XXXXXX"	*(char)
,	O
suffix	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
*	O
pname	*(*(char))
=	O
tmpname	*(char)
;	O
XXXXXX	*(char)
=	O
&	O
tmpname	*(char)
[	O
strlen	(*(char))->(long)
(	O
tmpbase	*(char)
)	O
]	O
;	O
g_free	(*(void))->(void)
(	O
tmpbase	*(char)
)	O
;	O
gettimeofday	(*(struct(long,long)),*(void))->(int)
(	O
&	O
tv	*(struct(long,long))
,	O
NULL	O
)	O
;	O
value	*(void)
+=	O
(	O
tv	*(struct(long,long))
.	O
tv_usec	long
<<	O
16	int
)	O
^	O
tv	*(struct(long,long))
.	O
tv_sec	long
^	O
getpid	()->(int)
(	O
)	O
;	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
TMP_MAX	int
;	O
++	O
count	int
)	O
{	O
unsigned	O
long	O
v	*(void)
=	O
value	*(void)
;	O
int	O
fd	int
;	O
XXXXXX	*(char)
[	O
0	int
]	O
=	O
letters	array(char)
[	O
v	*(void)
%	O
62	int
]	O
;	O
v	*(void)
/=	O
62	int
;	O
XXXXXX	*(char)
[	O
1	int
]	O
=	O
letters	array(char)
[	O
v	*(void)
%	O
62	int
]	O
;	O
v	*(void)
/=	O
62	int
;	O
XXXXXX	*(char)
[	O
2	int
]	O
=	O
letters	array(char)
[	O
v	*(void)
%	O
62	int
]	O
;	O
v	*(void)
/=	O
62	int
;	O
XXXXXX	*(char)
[	O
3	int
]	O
=	O
letters	array(char)
[	O
v	*(void)
%	O
62	int
]	O
;	O
v	*(void)
/=	O
62	int
;	O
XXXXXX	*(char)
[	O
4	int
]	O
=	O
letters	array(char)
[	O
v	*(void)
%	O
62	int
]	O
;	O
v	*(void)
/=	O
62	int
;	O
XXXXXX	*(char)
[	O
5	int
]	O
=	O
letters	array(char)
[	O
v	*(void)
%	O
62	int
]	O
;	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
tmpname	*(char)
,	O
O_RDWR	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
|	O
O_EXCL	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
return	O
fd	int
;	O
}	O
value	*(void)
+=	O
7777	int
;	O
}	O
g_free	(*(void))->(void)
(	O
tmpname	*(char)
)	O
;	O
*	O
pname	*(*(char))
=	O
NULL	O
;	O
return	O
-	O
1	int
;	O
}	O
void	O
load_file_position	(*(char),*(long),*(long))->(void)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
long	O
*	O
line	int
,	O
long	O
*	O
column	*(long)
)	O
{	O
char	O
*	O
fn	*(()->(void))
;	O
FILE	struct
*	O
f	struct(int,int,int,int)
;	O
char	O
buf	*(char)
[	O
MC_MAXPATHLEN	O
+	O
20	int
]	O
;	O
int	O
len	int
;	O
*	O
line	int
=	O
1	int
;	O
*	O
column	*(long)
=	O
0	int
;	O
fn	*(()->(void))
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
home_dir	*(char)
,	O
MC_FILEPOS	*(char)
)	O
;	O
f	struct(int,int,int,int)
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fn	*(()->(void))
,	O
"r"	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
fn	*(()->(void))
)	O
;	O
if	O
(	O
!	O
f	struct(int,int,int,int)
)	O
return	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
f	struct(int,int,int,int)
)	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
filename	*(char)
,	O
len	int
)	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
buf	*(char)
[	O
len	int
]	O
!=	O
' '	O
)	O
continue	O
;	O
p	*(void)
=	O
&	O
buf	*(char)
[	O
len	int
+	O
1	int
]	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
' '	O
)	O
)	O
continue	O
;	O
*	O
line	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
p	*(void)
,	O
const_cast	O
(	O
char	O
*	O
*	O
,	O
&	O
p	*(void)
)	O
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
';'	O
)	O
{	O
*	O
column	*(long)
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
p	*(void)
+	O
1	int
,	O
const_cast	O
(	O
char	O
*	O
*	O
,	O
&	O
p	*(void)
)	O
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
!=	O
'\n'	O
)	O
*	O
column	*(long)
=	O
0	int
;	O
}	O
else	O
*	O
line	int
=	O
1	int
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	struct(int,int,int,int)
)	O
;	O
}	O
void	O
save_file_position	(*(char),long,long)->(void)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
long	O
line	int
,	O
long	O
column	*(long)
)	O
{	O
char	O
*	O
tmp	*(char)
,	O
*	O
fn	*(()->(void))
;	O
FILE	struct
*	O
f	struct(int,int,int,int)
,	O
*	O
t	long
;	O
char	O
buf	*(char)
[	O
MC_MAXPATHLEN	O
+	O
20	int
]	O
;	O
int	O
i	array(int)
=	O
1	int
;	O
int	O
len	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
;	O
tmp	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
home_dir	*(char)
,	O
MC_FILEPOS_TMP	*(char)
)	O
;	O
fn	*(()->(void))
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
home_dir	*(char)
,	O
MC_FILEPOS	*(char)
)	O
;	O
t	long
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
tmp	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
t	long
)	O
{	O
g_free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
fn	*(()->(void))
)	O
;	O
return	O
;	O
}	O
if	O
(	O
line	int
!=	O
1	int
||	O
column	*(long)
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
t	long
,	O
"%s %ld;%ld\n"	*(char)
,	O
filename	*(char)
,	O
line	int
,	O
column	*(long)
)	O
;	O
}	O
f	struct(int,int,int,int)
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fn	*(()->(void))
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
f	struct(int,int,int,int)
)	O
{	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
f	struct(int,int,int,int)
)	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
filename	*(char)
,	O
len	int
)	O
==	O
0	int
&&	O
buf	*(char)
[	O
len	int
]	O
==	O
' '	O
&&	O
!	O
strchr	(*(char),int)->(*(char))
(	O
&	O
buf	*(char)
[	O
len	int
+	O
1	int
]	O
,	O
' '	O
)	O
)	O
continue	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
t	long
,	O
"%s"	*(char)
,	O
buf	*(char)
)	O
;	O
if	O
(	O
++	O
i	array(int)
>	O
MC_FILEPOS_ENTRIES	int
)	O
break	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	struct(int,int,int,int)
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
t	long
)	O
;	O
rename	(*(char),*(char))->(int)
(	O
tmp	*(char)
,	O
fn	*(()->(void))
)	O
;	O
g_free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
fn	*(()->(void))
)	O
;	O
}	O
extern	O
const	O
char	O
*	O
cstrcasestr	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
haystack	*(struct(*(*(void)),int))
,	O
const	O
char	O
*	O
needle	*(void)
)	O
{	O
const	O
char	O
*	O
hptr	*(char)
;	O
size_t	long
i	array(int)
,	O
needle_len	long
;	O
needle_len	long
=	O
strlen	(*(char))->(long)
(	O
needle	*(void)
)	O
;	O
for	O
(	O
hptr	*(char)
=	O
haystack	*(struct(*(*(void)),int))
;	O
*	O
hptr	*(char)
!=	O
'\0'	O
;	O
hptr	*(char)
++	O
)	O
{	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
needle_len	long
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
toupper	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
hptr	*(char)
[	O
i	array(int)
]	O
)	O
!=	O
toupper	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
needle	*(void)
[	O
i	array(int)
]	O
)	O
)	O
goto	O
next_try	O
;	O
}	O
return	O
hptr	*(char)
;	O
next_try	O
:	O
(	O
void	O
)	O
0	int
;	O
}	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
cstrstr	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
haystack	*(struct(*(*(void)),int))
,	O
const	O
char	O
*	O
needle	*(void)
)	O
{	O
return	O
strstr	(*(char),*(char))->(*(char))
(	O
haystack	*(struct(*(*(void)),int))
,	O
needle	*(void)
)	O
;	O
}	O
extern	O
char	O
*	O
str_unconst	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
return	O
(	O
char	O
*	O
)	O
s	*(char)
;	O
}	O
extern	O
int	O
ascii_alpha_to_cntrl	(int)->(int)
(	O
int	O
ch	int
)	O
{	O
if	O
(	O
(	O
ch	int
>=	O
ASCII_A	O
&&	O
ch	int
<=	O
ASCII_Z	O
)	O
||	O
(	O
ch	int
>=	O
ASCII_a	O
&&	O
ch	int
<=	O
ASCII_z	O
)	O
)	O
{	O
ch	int
&=	O
0x1f	int
;	O
}	O
return	O
ch	int
;	O
}	O
const	O
char	O
*	O
Q_	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
const	O
char	O
*	O
result	long
,	O
*	O
sep	*(char)
;	O
result	long
=	O
_	O
(	O
s	*(char)
)	O
;	O
sep	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
result	long
,	O
'|'	O
)	O
;	O
return	O
(	O
sep	*(char)
!=	O
NULL	O
)	O
?	O
sep	*(char)
+	O
1	int
:	O
result	long
;	O
}	O
