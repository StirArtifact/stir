void	O
mh_init	()->(void)
(	O
void	O
)	O
{	O
mu_stdstream_setup	(int)->(void)
(	O
MU_STDSTREAM_RESET_NONE	int
)	O
;	O
mu_register_all_formats	O
(	O
)	O
;	O
mh_read_profile	()->(void)
(	O
)	O
;	O
}	O
void	O
mh_init2	()->(void)
(	O
void	O
)	O
{	O
mh_current_folder	()->(*(char))
(	O
)	O
;	O
}	O
void	O
mh_err_memory	(int)->(void)
(	O
int	O
fatal	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"not enough memory"	*(char)
)	O
)	O
;	O
if	O
(	O
fatal	int
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
static	O
mu_address_t	*(struct)
mh_local_mailbox	()->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
(	O
void	O
)	O
{	O
static	O
mu_address_t	*(struct)
local_mailbox	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
if	O
(	O
!	O
local_mailbox	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
{	O
const	O
char	O
*	O
p	*(char)
=	O
mh_global_profile_get	O
(	O
"Local-Mailbox"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
p	*(char)
=	O
mu_get_user_email	(*(char))->(*(char))
(	O
NULL	O
)	O
;	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
local_mailbox	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
p	*(char)
)	O
;	O
}	O
return	O
local_mailbox	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
}	O
char	O
const	O
*	O
mh_get_my_user_name	()->(*(char))
(	O
void	O
)	O
{	O
mu_address_t	*(struct)
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
mh_local_mailbox	()->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
(	O
)	O
;	O
char	O
const	O
*	O
s	*(char)
;	O
MU_ASSERT	O
(	O
mu_address_sget_local_part	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),long,*(*(char)))->(int)
(	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
1	int
,	O
&	O
s	*(char)
)	O
)	O
;	O
return	O
s	*(char)
;	O
}	O
char	O
const	O
*	O
mh_get_my_real_name	()->(*(char))
(	O
void	O
)	O
{	O
mu_address_t	*(struct)
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
mh_local_mailbox	()->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
(	O
)	O
;	O
char	O
const	O
*	O
s	*(char)
;	O
if	O
(	O
mu_address_sget_personal	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),long,*(*(char)))->(int)
(	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
1	int
,	O
&	O
s	*(char)
)	O
)	O
return	O
NULL	O
;	O
return	O
s	*(char)
;	O
}	O
char	O
const	O
*	O
mh_my_email	()->(*(char))
(	O
void	O
)	O
{	O
mu_address_t	*(struct)
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
mh_local_mailbox	()->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
(	O
)	O
;	O
char	O
const	O
*	O
s	*(char)
;	O
MU_ASSERT	O
(	O
mu_address_sget_printable	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),*(*(char)))->(int)
(	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
&	O
s	*(char)
)	O
)	O
;	O
return	O
s	*(char)
;	O
}	O
char	O
const	O
*	O
mh_my_host	()->(*(char))
(	O
void	O
)	O
{	O
mu_address_t	*(struct)
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
mh_local_mailbox	()->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
(	O
)	O
;	O
char	O
const	O
*	O
s	*(char)
;	O
MU_ASSERT	O
(	O
mu_address_sget_domain	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),long,*(*(char)))->(int)
(	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
1	int
,	O
&	O
s	*(char)
)	O
)	O
;	O
return	O
s	*(char)
;	O
}	O
enum	O
part_match_mode	enum(int,int)
{	O
part_match_local	int
,	O
part_match_domain	int
}	O
;	O
enum	O
part_match_result	enum(int,int,int)
{	O
part_match_false	int
,	O
part_match_true	int
,	O
part_match_abort	int
}	O
;	O
static	O
int	O
match_char_class	(*(*(char)),char,int)->(int)
(	O
char	O
const	O
*	O
*	O
pexpr	*(*(char))
,	O
char	O
c	char
,	O
int	O
icase	int
)	O
;	O
static	O
enum	O
part_match_result	enum(int,int,int)
part_match	(*(char),*(char),enum(int,int))->(enum(int,int,int))
(	O
char	O
const	O
*	O
expr	*(char)
,	O
char	O
const	O
*	O
name	*(char)
,	O
enum	O
part_match_mode	enum(int,int)
mode	int
)	O
{	O
int	O
c	char
;	O
while	O
(	O
*	O
expr	*(char)
)	O
{	O
if	O
(	O
*	O
name	*(char)
==	O
0	int
&&	O
*	O
expr	*(char)
!=	O
'*'	O
)	O
return	O
part_match_abort	int
;	O
switch	O
(	O
*	O
expr	*(char)
)	O
{	O
case	O
'*'	O
:	O
while	O
(	O
*	O
++	O
expr	*(char)
==	O
'*'	O
)	O
;	O
if	O
(	O
*	O
expr	*(char)
==	O
0	int
)	O
return	O
part_match_true	int
;	O
while	O
(	O
*	O
name	*(char)
)	O
{	O
int	O
res	*(int)
=	O
part_match	(*(char),*(char),enum(int,int))->(enum(int,int,int))
(	O
expr	*(char)
,	O
name	*(char)
++	O
,	O
mode	int
)	O
;	O
if	O
(	O
res	*(int)
!=	O
part_match_false	int
)	O
return	O
res	*(int)
;	O
}	O
return	O
part_match_abort	int
;	O
case	O
'?'	O
:	O
expr	*(char)
++	O
;	O
if	O
(	O
*	O
name	*(char)
==	O
0	int
)	O
return	O
part_match_false	int
;	O
name	*(char)
++	O
;	O
break	O
;	O
case	O
'['	O
:	O
if	O
(	O
!	O
match_char_class	(*(*(char)),char,int)->(int)
(	O
&	O
expr	*(char)
,	O
*	O
name	*(char)
,	O
mode	int
==	O
part_match_domain	int
)	O
)	O
return	O
part_match_false	int
;	O
name	*(char)
++	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
expr	*(char)
[	O
1	int
]	O
)	O
{	O
c	char
=	O
*	O
++	O
expr	*(char)
;	O
expr	*(char)
++	O
;	O
if	O
(	O
*	O
name	*(char)
!=	O
mu_wordsplit_c_unquote_char	(int)->(int)
(	O
c	char
)	O
)	O
return	O
part_match_false	int
;	O
name	*(char)
++	O
;	O
break	O
;	O
}	O
default	O
:	O
if	O
(	O
mode	int
==	O
part_match_local	int
)	O
{	O
if	O
(	O
*	O
expr	*(char)
!=	O
*	O
name	*(char)
)	O
return	O
part_match_false	int
;	O
if	O
(	O
'@'	O
==	O
*	O
name	*(char)
)	O
mode	int
=	O
part_match_domain	int
;	O
}	O
else	O
{	O
if	O
(	O
mu_tolower	O
(	O
*	O
expr	*(char)
)	O
!=	O
mu_tolower	O
(	O
*	O
name	*(char)
)	O
)	O
return	O
part_match_false	int
;	O
}	O
expr	*(char)
++	O
;	O
name	*(char)
++	O
;	O
}	O
}	O
if	O
(	O
*	O
name	*(char)
==	O
0	int
)	O
return	O
part_match_true	int
;	O
if	O
(	O
mode	int
==	O
part_match_local	int
&&	O
*	O
name	*(char)
==	O
'@'	O
)	O
return	O
part_match_true	int
;	O
return	O
part_match_false	int
;	O
}	O
static	O
int	O
match_char_class	(*(*(char)),char,int)->(int)
(	O
char	O
const	O
*	O
*	O
pexpr	*(*(char))
,	O
char	O
c	char
,	O
int	O
icase	int
)	O
{	O
int	O
res	*(int)
;	O
int	O
rc	int
;	O
char	O
const	O
*	O
expr	*(char)
=	O
*	O
pexpr	*(*(char))
;	O
if	O
(	O
icase	int
)	O
c	char
=	O
mu_toupper	O
(	O
c	char
)	O
;	O
expr	*(char)
++	O
;	O
if	O
(	O
*	O
expr	*(char)
==	O
'^'	O
)	O
{	O
res	*(int)
=	O
0	int
;	O
expr	*(char)
++	O
;	O
}	O
else	O
res	*(int)
=	O
1	int
;	O
if	O
(	O
*	O
expr	*(char)
==	O
'-'	O
||	O
*	O
expr	*(char)
==	O
']'	O
)	O
rc	int
=	O
c	char
==	O
*	O
expr	*(char)
++	O
;	O
else	O
rc	int
=	O
!	O
res	*(int)
;	O
for	O
(	O
;	O
*	O
expr	*(char)
&&	O
*	O
expr	*(char)
!=	O
']'	O
;	O
expr	*(char)
++	O
)	O
{	O
if	O
(	O
rc	int
==	O
res	*(int)
)	O
{	O
if	O
(	O
*	O
expr	*(char)
==	O
'\\'	O
&&	O
expr	*(char)
[	O
1	int
]	O
==	O
']'	O
)	O
expr	*(char)
++	O
;	O
}	O
else	O
if	O
(	O
expr	*(char)
[	O
1	int
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
*	O
expr	*(char)
==	O
'\\'	O
)	O
rc	int
=	O
*	O
++	O
expr	*(char)
==	O
c	char
;	O
else	O
{	O
if	O
(	O
icase	int
)	O
rc	int
=	O
mu_toupper	O
(	O
*	O
expr	*(char)
)	O
<=	O
c	char
&&	O
c	char
<=	O
mu_toupper	O
(	O
expr	*(char)
[	O
2	int
]	O
)	O
;	O
else	O
rc	int
=	O
*	O
expr	*(char)
<=	O
c	char
&&	O
c	char
<=	O
expr	*(char)
[	O
2	int
]	O
;	O
expr	*(char)
+=	O
2	int
;	O
}	O
}	O
else	O
if	O
(	O
*	O
expr	*(char)
==	O
'\\'	O
&&	O
expr	*(char)
[	O
1	int
]	O
==	O
']'	O
)	O
rc	int
=	O
*	O
++	O
expr	*(char)
==	O
c	char
;	O
else	O
if	O
(	O
icase	int
)	O
rc	int
=	O
mu_toupper	O
(	O
*	O
expr	*(char)
)	O
==	O
c	char
;	O
else	O
rc	int
=	O
*	O
expr	*(char)
==	O
c	char
;	O
}	O
*	O
pexpr	*(*(char))
=	O
*	O
expr	*(char)
?	O
expr	*(char)
+	O
1	int
:	O
expr	*(char)
;	O
return	O
rc	int
==	O
res	*(int)
;	O
}	O
static	O
int	O
email_match	(*(char),*(char))->(int)
(	O
char	O
const	O
*	O
pattern	*(char)
,	O
char	O
const	O
*	O
name	*(char)
)	O
{	O
return	O
part_match	(*(char),*(char),enum(int,int))->(enum(int,int,int))
(	O
pattern	*(char)
,	O
name	*(char)
,	O
part_match_local	int
)	O
==	O
part_match_true	int
;	O
}	O
int	O
mh_is_my_name	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
static	O
mu_address_t	*(struct)
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
mu_address_t	*(struct)
p	*(char)
;	O
if	O
(	O
!	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
{	O
const	O
char	O
*	O
nlist	*(char)
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
mh_my_email	()->(*(char))
(	O
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_address_create"	*(char)
,	O
mh_my_email	()->(*(char))
(	O
)	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
nlist	*(char)
=	O
mh_global_profile_get	O
(	O
"Alternate-Mailboxes"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
nlist	*(char)
)	O
{	O
mu_address_t	*(struct)
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
struct	O
mu_address	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))))
hint	*(struct)
;	O
hint	*(struct)
.	O
domain	*(char)
=	O
NULL	O
;	O
rc	int
=	O
mu_address_create_hint	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(int)
(	O
&	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
nlist	*(char)
,	O
&	O
hint	*(struct)
,	O
MU_ADDR_HINT_DOMAIN	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
rc	int
=	O
mu_address_union	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(int)
(	O
&	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_address_union"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
}	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"bad Alternate-Mailboxes: %s; please fix"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
p	*(char)
=	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
p	*(char)
;	O
p	*(char)
=	O
p	*(char)
->	O
next	*((*(void))->(int))
)	O
{	O
if	O
(	O
email_match	(*(char),*(char))->(int)
(	O
p	*(char)
->	O
email	*(char)
,	O
name	*(char)
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
make_dir_hier	(*(char),int)->(int)
(	O
const	O
char	O
*	O
p	*(char)
,	O
mode_t	int
perm	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
char	O
*	O
dir	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
char	O
*	O
q	*(char)
=	O
dir	*(char)
;	O
while	O
(	O
!	O
rc	int
&&	O
(	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
q	*(char)
+	O
1	int
,	O
'/'	O
)	O
)	O
)	O
{	O
*	O
q	*(char)
=	O
0	int
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
dir	*(char)
,	O
X_OK	int
)	O
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create directory %s: error accessing name component %s: %s"	*(char)
)	O
,	O
p	*(char)
,	O
dir	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
rc	int
=	O
mkdir	(*(char),int)->(int)
(	O
dir	*(char)
,	O
perm	int
)	O
)	O
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create directory %s: error creating name component %s: %s"	*(char)
)	O
,	O
p	*(char)
,	O
dir	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
*	O
q	*(char)
=	O
'/'	O
;	O
}	O
free	(*(void))->(void)
(	O
dir	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mh_makedir	(*(char))->(int)
(	O
const	O
char	O
*	O
p	*(char)
)	O
{	O
int	O
rc	int
;	O
mode_t	int
save_umask	int
;	O
mode_t	int
perm	int
=	O
0711	int
;	O
const	O
char	O
*	O
pb	*(*(struct(*(struct),*(struct))))
=	O
mh_global_profile_get	O
(	O
"Folder-Protect"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
pb	*(*(struct(*(struct),*(struct))))
)	O
perm	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
pb	*(*(struct(*(struct),*(struct))))
,	O
NULL	O
,	O
8	int
)	O
;	O
save_umask	int
=	O
umask	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
make_dir_hier	(*(char),int)->(int)
(	O
p	*(char)
,	O
perm	int
)	O
)	O
==	O
0	int
)	O
{	O
rc	int
=	O
mkdir	(*(char),int)->(int)
(	O
p	*(char)
,	O
perm	int
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create directory %s: %s"	*(char)
)	O
,	O
p	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
umask	(int)->(int)
(	O
save_umask	int
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mh_check_folder	(*(char),int)->(int)
(	O
const	O
char	O
*	O
pathname	*(char)
,	O
int	O
confirm	int
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
struct	O
stat	*(int)
st	*(struct(long,long,long))
;	O
if	O
(	O
(	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
pathname	*(char)
,	O
':'	O
)	O
)	O
!=	O
NULL	O
)	O
p	*(char)
++	O
;	O
else	O
p	*(char)
=	O
pathname	*(char)
;	O
if	O
(	O
stat	*(int)
(	O
p	*(char)
,	O
&	O
st	*(struct(long,long,long))
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
if	O
(	O
!	O
confirm	int
||	O
mh_getyn	(*(char))->(int)
(	O
_	O
(	O
"Create folder \"%s\""	*(char)
)	O
,	O
p	*(char)
)	O
)	O
return	O
mh_makedir	(*(char))->(int)
(	O
p	*(char)
)	O
;	O
else	O
return	O
1	int
;	O
}	O
else	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"stat"	*(char)
,	O
p	*(char)
,	O
errno	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
mh_interactive_mode_p	()->(int)
(	O
void	O
)	O
{	O
static	O
int	O
interactive	int
=	O
-	O
1	int
;	O
if	O
(	O
interactive	int
<	O
0	int
)	O
interactive	int
=	O
isatty	(int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
?	O
1	int
:	O
0	int
;	O
return	O
interactive	int
;	O
}	O
int	O
mh_vgetyn	(*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
char	O
repl	array(char)
[	O
64	int
]	O
;	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
int	O
len	int
,	O
rc	int
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"? "	*(char)
)	O
;	O
p	*(char)
=	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
repl	array(char)
,	O
sizeof	O
repl	array(char)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
return	O
0	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
;	O
if	O
(	O
len	int
>	O
0	int
&&	O
p	*(char)
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
p	*(char)
[	O
len	int
--	O
]	O
=	O
0	int
;	O
rc	int
=	O
mu_true_answer_p	(*(char))->(int)
(	O
p	*(char)
)	O
;	O
if	O
(	O
rc	int
>=	O
0	int
)	O
return	O
rc	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Please answer yes or no: "	*(char)
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mh_getyn	(*(char))->(int)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
mh_interactive_mode_p	()->(int)
(	O
)	O
)	O
return	O
1	int
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
rc	int
=	O
mh_vgetyn	(*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mh_getyn_interactive	(*(char))->(int)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
int	O
rc	int
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
rc	int
=	O
mh_vgetyn	(*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
return	O
rc	int
;	O
}	O
mu_stream_t	*(struct)
mh_audit_open	(*(char),*(struct))->(*(struct))
(	O
char	O
*	O
name	*(char)
,	O
mu_mailbox_t	*(struct)
mbox	*(struct)
)	O
{	O
mu_stream_t	*(struct)
str	*(struct(int,*(char),*(char),*(char),*(char)))
;	O
char	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
[	O
64	int
]	O
;	O
time_t	long
t	long
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
mu_url_t	*(struct)
url	*(struct)
;	O
char	O
*	O
namep	*(*(char))
;	O
int	O
rc	int
;	O
namep	*(*(char))
=	O
mu_tilde_expansion	(*(char),int,*(char))->(*(char))
(	O
name	*(char)
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
namep	*(*(char))
,	O
MU_HIERARCHY_DELIMITER	char
)	O
==	O
NULL	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
mh_safe_make_file_name	(*(char),*(char))->(*(char))
(	O
mu_folder_directory	()->(*(char))
(	O
)	O
,	O
namep	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
namep	*(*(char))
)	O
;	O
namep	*(*(char))
=	O
p	*(char)
;	O
}	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
str	*(struct(int,*(char),*(char),*(char),*(char)))
,	O
namep	*(*(char))
,	O
MU_STREAM_CREAT	int
|	O
MU_STREAM_APPEND	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open audit file %s: %s"	*(char)
)	O
,	O
namep	*(*(char))
,	O
strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
namep	*(*(char))
)	O
;	O
return	O
NULL	O
;	O
}	O
free	(*(void))->(void)
(	O
namep	*(*(char))
)	O
;	O
time	struct(long,long)
(	O
&	O
t	long
)	O
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
)	O
;	O
mu_strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
sizeof	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
"%a, %d %b %Y %H:%M:%S %Z"	*(char)
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
mu_mailbox_get_url	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
url	*(struct)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct(int,*(char),*(char),*(char),*(char)))
,	O
"<<%s>> %s %s\n"	*(char)
,	O
mu_program_name	*(char)
,	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
mu_url_to_string	(*(struct))->(*(char))
(	O
url	*(struct)
)	O
)	O
;	O
return	O
str	*(struct(int,*(char),*(char),*(char),*(char)))
;	O
}	O
void	O
mh_audit_close	(*(struct))->(void)
(	O
mu_stream_t	*(struct)
str	*(struct(int,*(char),*(char),*(char),*(char)))
)	O
{	O
mu_stream_close	(*(struct))->(int)
(	O
str	*(struct(int,*(char),*(char),*(char),*(char)))
)	O
;	O
}	O
int	O
mh_message_number	(*(struct),*(long))->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
size_t	long
*	O
pnum	*(long)
)	O
{	O
return	O
mu_message_get_uid	(*(struct),*(long))->(int)
(	O
msg	*(struct)
,	O
pnum	*(long)
)	O
;	O
}	O
mu_mailbox_t	*(struct)
mh_open_folder	(*(char),int)->(*(struct))
(	O
const	O
char	O
*	O
folder	*(struct)
,	O
int	O
flags	int
)	O
{	O
mu_mailbox_t	*(struct)
mbox	*(struct)
=	O
NULL	O
;	O
char	O
*	O
name	*(char)
;	O
name	*(char)
=	O
mh_expand_name	(*(char),*(char),int)->(*(char))
(	O
NULL	O
,	O
folder	*(struct)
,	O
NAME_FOLDER	int
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
MU_STREAM_CREAT	int
)	O
&&	O
mh_check_folder	(*(char),int)->(int)
(	O
name	*(char)
,	O
1	int
)	O
)	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
if	O
(	O
mu_mailbox_create_default	(*(*(struct)),*(char))->(int)
(	O
&	O
mbox	*(struct)
,	O
name	*(char)
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create mailbox %s: %s"	*(char)
)	O
,	O
name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
mu_mailbox_open	(*(struct),int)->(int)
(	O
mbox	*(struct)
,	O
flags	int
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open mailbox %s: %s"	*(char)
)	O
,	O
name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
mbox	*(struct)
;	O
}	O
char	O
*	O
mh_get_dir	()->(*(char))
(	O
void	O
)	O
{	O
const	O
char	O
*	O
mhdir	*(char)
=	O
mh_global_profile_get	O
(	O
"Path"	*(char)
,	O
"Mail"	*(char)
)	O
;	O
char	O
*	O
mhcopy	*(char)
;	O
if	O
(	O
mhdir	*(char)
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
mu_get_homedir	()->(*(char))
(	O
)	O
;	O
mhcopy	*(char)
=	O
mh_safe_make_file_name	(*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
mhdir	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
}	O
else	O
mhcopy	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
mhdir	*(char)
)	O
;	O
if	O
(	O
!	O
mhcopy	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"not enough memory"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
return	O
mhcopy	*(char)
;	O
}	O
char	O
*	O
mh_expand_name	(*(char),*(char),int)->(*(char))
(	O
const	O
char	O
*	O
base	*(char)
,	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
what	int
)	O
{	O
char	O
*	O
p	*(char)
=	O
NULL	O
;	O
char	O
*	O
namep	*(*(char))
=	O
NULL	O
;	O
namep	*(*(char))
=	O
mu_tilde_expansion	(*(char),int,*(char))->(*(char))
(	O
name	*(char)
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
if	O
(	O
namep	*(*(char))
[	O
0	int
]	O
==	O
'+'	O
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
namep	*(*(char))
,	O
namep	*(*(char))
+	O
1	int
,	O
strlen	(*(char))->(long)
(	O
namep	*(*(char))
)	O
)	O
;	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
namep	*(*(char))
,	O
"../"	*(char)
,	O
3	int
)	O
==	O
0	int
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
namep	*(*(char))
,	O
"./"	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
cwd	short
=	O
mu_getcwd	()->(*(char))
(	O
)	O
;	O
char	O
*	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
mh_safe_make_file_name	(*(char),*(char))->(*(char))
(	O
cwd	short
,	O
namep	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
cwd	short
)	O
;	O
if	O
(	O
what	int
==	O
NAME_FILE	int
)	O
return	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
free	(*(void))->(void)
(	O
namep	*(*(char))
)	O
;	O
namep	*(*(char))
=	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
}	O
if	O
(	O
what	int
==	O
NAME_FOLDER	int
)	O
{	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
namep	*(*(char))
,	O
"mh:/"	*(char)
,	O
4	int
)	O
==	O
0	int
)	O
return	O
namep	*(*(char))
;	O
else	O
if	O
(	O
namep	*(*(char))
[	O
0	int
]	O
==	O
'/'	O
)	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
p	*(char)
,	O
"mh:%s"	*(char)
,	O
namep	*(*(char))
)	O
;	O
else	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
p	*(char)
,	O
"mh:%s/%s"	*(char)
,	O
base	*(char)
?	O
base	*(char)
:	O
mu_folder_directory	()->(*(char))
(	O
)	O
,	O
namep	*(*(char))
)	O
;	O
}	O
else	O
if	O
(	O
namep	*(*(char))
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
if	O
(	O
what	int
==	O
NAME_FILE	int
)	O
{	O
char	O
*	O
cwd	short
=	O
mu_getcwd	()->(*(char))
(	O
)	O
;	O
p	*(char)
=	O
mh_safe_make_file_name	(*(char),*(char))->(*(char))
(	O
cwd	short
,	O
namep	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
cwd	short
)	O
;	O
}	O
else	O
p	*(char)
=	O
mh_safe_make_file_name	(*(char),*(char))->(*(char))
(	O
base	*(char)
?	O
base	*(char)
:	O
mu_folder_directory	()->(*(char))
(	O
)	O
,	O
namep	*(*(char))
)	O
;	O
}	O
else	O
return	O
namep	*(*(char))
;	O
free	(*(void))->(void)
(	O
namep	*(*(char))
)	O
;	O
return	O
p	*(char)
;	O
}	O
int	O
mh_find_file	(*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
*	O
resolved_name	*(*(char))
)	O
{	O
char	O
*	O
s	*(char)
;	O
int	O
rc	int
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'/'	O
||	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
name	*(char)
[	O
1	int
]	O
==	O
'/'	O
)	O
||	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
name	*(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
name	*(char)
[	O
2	int
]	O
==	O
'/'	O
)	O
)	O
{	O
*	O
resolved_name	*(*(char))
=	O
mu_strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
name	*(char)
,	O
R_OK	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
errno	O
;	O
}	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
s	*(char)
=	O
mu_tilde_expansion	(*(char),int,*(char))->(*(char))
(	O
name	*(char)
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
*	O
resolved_name	*(*(char))
=	O
s	*(char)
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
s	*(char)
,	O
R_OK	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
errno	O
;	O
}	O
s	*(char)
=	O
mh_expand_name	(*(char),*(char),int)->(*(char))
(	O
NULL	O
,	O
name	*(char)
,	O
NAME_ANY	int
)	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
s	*(char)
,	O
R_OK	int
)	O
==	O
0	int
)	O
{	O
*	O
resolved_name	*(*(char))
=	O
s	*(char)
;	O
return	O
0	int
;	O
}	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"cannot access %s: %s"	*(char)
)	O
,	O
s	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
s	*(char)
=	O
mh_expand_name	(*(char),*(char),int)->(*(char))
(	O
mh_global_profile_get	O
(	O
"mhetcdir"	*(char)
,	O
MHLIBDIR	O
)	O
,	O
name	*(char)
,	O
NAME_ANY	int
)	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
s	*(char)
,	O
R_OK	int
)	O
==	O
0	int
)	O
{	O
*	O
resolved_name	*(*(char))
=	O
s	*(char)
;	O
return	O
0	int
;	O
}	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"cannot access %s: %s"	*(char)
)	O
,	O
s	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
*	O
resolved_name	*(*(char))
=	O
mu_strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
name	*(char)
,	O
R_OK	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
rc	int
=	O
errno	O
;	O
if	O
(	O
rc	int
!=	O
ENOENT	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"cannot access %s: %s"	*(char)
)	O
,	O
s	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mh_spawnp	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
prog	*(char)
,	O
const	O
char	O
*	O
file	*(char)
)	O
{	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
size_t	long
i	long
;	O
int	O
rc	int
,	O
status	int
;	O
char	O
*	O
*	O
xargv	*(*(char))
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_comment	*(char)
=	O
"#"	*(char)
;	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
prog	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_COMMENT	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot split line `%s': %s"	*(char)
)	O
,	O
prog	*(char)
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
return	O
1	int
;	O
}	O
xargv	*(*(char))
=	O
calloc	(long,long)->(*(void))
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
+	O
2	int
,	O
sizeof	O
(	O
*	O
xargv	*(*(char))
)	O
)	O
;	O
if	O
(	O
!	O
xargv	*(*(char))
)	O
{	O
mh_err_memory	(int)->(void)
(	O
0	int
)	O
;	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
xargv	*(*(char))
[	O
i	long
]	O
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	long
]	O
;	O
xargv	*(*(char))
[	O
i	long
++	O
]	O
=	O
(	O
char	O
*	O
)	O
file	*(char)
;	O
xargv	*(*(char))
[	O
i	long
++	O
]	O
=	O
NULL	O
;	O
rc	int
=	O
mu_spawnvp	(*(char),array(*(char)),*(int))->(int)
(	O
xargv	*(*(char))
[	O
0	int
]	O
,	O
xargv	*(*(char))
,	O
&	O
status	int
)	O
;	O
free	(*(void))->(void)
(	O
xargv	*(*(char))
)	O
;	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mh_file_copy	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
from	*(struct)
,	O
const	O
char	O
*	O
to	*(struct)
)	O
{	O
mu_stream_t	*(struct)
in	*(struct)
,	O
out	*(struct)
,	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
;	O
int	O
rc	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
in	*(struct)
,	O
from	*(struct)
,	O
MU_STREAM_READ	int
)	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open input file `%s': %s"	*(char)
)	O
,	O
from	*(struct)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
out	*(struct)
,	O
to	*(struct)
,	O
MU_STREAM_RDWR	O
|	O
MU_STREAM_CREAT	int
)	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open output file `%s': %s"	*(char)
)	O
,	O
to	*(struct)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
in	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_filter_create	(*(*(struct)),*(struct),*(char),int,int)->(int)
(	O
&	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
,	O
in	*(struct)
,	O
"INLINE-COMMENT"	*(char)
,	O
MU_FILTER_DECODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
in	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open filter stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
out	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
out	*(struct)
,	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
out	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"error copying file `%s' to `%s': %s"	*(char)
)	O
,	O
from	*(struct)
,	O
to	*(struct)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
mu_message_t	*(struct)
_file_to_message	(*(char))->(*(struct))
(	O
const	O
char	O
*	O
file_name	*(char)
)	O
{	O
struct	O
stat	*(int)
st	*(struct(long,long,long))
;	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
instream	*(struct)
;	O
if	O
(	O
stat	*(int)
(	O
file_name	*(char)
,	O
&	O
st	*(struct(long,long,long))
)	O
<	O
0	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"stat"	*(char)
,	O
file_name	*(char)
,	O
errno	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
instream	*(struct)
,	O
file_name	*(char)
,	O
MU_STREAM_READ	int
)	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create input stream (file %s): %s"	*(char)
)	O
,	O
file_name	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
mh_stream_to_message	(*(struct))->(*(struct))
(	O
instream	*(struct)
)	O
;	O
}	O
mu_message_t	*(struct)
mh_file_to_message	(*(char),*(char))->(*(struct))
(	O
const	O
char	O
*	O
folder	*(struct)
,	O
const	O
char	O
*	O
file_name	*(char)
)	O
{	O
mu_message_t	*(struct)
msg	*(struct)
;	O
char	O
*	O
tmp_name	*(char)
=	O
NULL	O
;	O
if	O
(	O
folder	*(struct)
)	O
{	O
tmp_name	*(char)
=	O
mh_expand_name	(*(char),*(char),int)->(*(char))
(	O
folder	*(struct)
,	O
file_name	*(char)
,	O
NAME_ANY	int
)	O
;	O
msg	*(struct)
=	O
_file_to_message	(*(char))->(*(struct))
(	O
tmp_name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tmp_name	*(char)
)	O
;	O
}	O
else	O
msg	*(struct)
=	O
_file_to_message	(*(char))->(*(struct))
(	O
file_name	*(char)
)	O
;	O
return	O
msg	*(struct)
;	O
}	O
void	O
mh_install_help	(*(char))->(void)
(	O
char	O
*	O
mhdir	*(char)
)	O
{	O
static	O
char	O
*	O
text	*(char)
=	O
N_	O
(	O
"Prior to using MH, it is necessary to have a file in your login\n"	*(char)
"directory (%s) named .mh_profile which contains information\n"	*(char)
"to direct certain MH operations.  The only item which is required\n"	*(char)
"is the path to use for all MH folder operations.  The suggested MH\n"	*(char)
"path for you is %s...\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
text	*(char)
)	O
,	O
mu_get_homedir	()->(*(char))
(	O
)	O
,	O
mhdir	*(char)
)	O
;	O
}	O
void	O
mh_real_install	(*(char),int)->(void)
(	O
char	O
*	O
name	*(char)
,	O
int	O
automode	int
)	O
{	O
char	O
*	O
home	*(char)
=	O
mu_get_homedir	()->(*(char))
(	O
)	O
;	O
char	O
*	O
mhdir	*(char)
;	O
char	O
*	O
ctx	*(char)
;	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
profile	*(struct)
;	O
mhdir	*(char)
=	O
mh_safe_make_file_name	(*(char),*(char))->(*(char))
(	O
home	*(char)
,	O
"Mail"	*(char)
)	O
;	O
if	O
(	O
!	O
automode	int
)	O
{	O
if	O
(	O
mh_getyn_interactive	(*(char))->(int)
(	O
_	O
(	O
"Do you need help"	*(char)
)	O
)	O
)	O
mh_install_help	(*(char))->(void)
(	O
mhdir	*(char)
)	O
;	O
if	O
(	O
!	O
mh_getyn_interactive	(*(char))->(int)
(	O
_	O
(	O
"Do you want the standard MH path \"%s\""	*(char)
)	O
,	O
mhdir	*(char)
)	O
)	O
{	O
int	O
local	int
;	O
char	O
*	O
p	*(char)
,	O
*	O
buf	*(char)
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
local	int
=	O
mh_getyn_interactive	(*(char))->(int)
(	O
_	O
(	O
"Do you want a path below your login directory"	*(char)
)	O
)	O
;	O
if	O
(	O
local	int
)	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"What is the path? "	*(char)
)	O
)	O
;	O
else	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"What is the full path? "	*(char)
)	O
)	O
;	O
mu_stream_flush	(*(struct))->(int)
(	O
mu_strin	*(struct)
)	O
;	O
if	O
(	O
mu_stream_getline	(*(struct),*(*(char)),*(long),*(long))->(int)
(	O
mu_strin	*(struct)
,	O
&	O
buf	*(char)
,	O
&	O
size	long
,	O
NULL	O
)	O
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
p	*(char)
=	O
mu_str_stripws	(*(char))->(*(char))
(	O
buf	*(char)
)	O
;	O
if	O
(	O
p	*(char)
>	O
buf	*(char)
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
buf	*(char)
,	O
p	*(char)
,	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
+	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
mhdir	*(char)
)	O
;	O
if	O
(	O
local	int
)	O
{	O
mhdir	*(char)
=	O
mh_safe_make_file_name	(*(char),*(char))->(*(char))
(	O
home	*(char)
,	O
p	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
}	O
else	O
mhdir	*(char)
=	O
p	*(char)
;	O
}	O
}	O
if	O
(	O
mh_check_folder	(*(char),int)->(int)
(	O
mhdir	*(char)
,	O
!	O
automode	int
)	O
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
profile	*(struct)
,	O
name	*(char)
,	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open file %s: %s"	*(char)
)	O
,	O
name	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
profile	*(struct)
,	O
"Path: %s\n"	*(char)
,	O
mhdir	*(char)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
profile	*(struct)
)	O
;	O
ctx	*(char)
=	O
mh_safe_make_file_name	(*(char),*(char))->(*(char))
(	O
mhdir	*(char)
,	O
MH_CONTEXT_FILE	*(char)
)	O
;	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
profile	*(struct)
,	O
ctx	*(char)
,	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
profile	*(struct)
,	O
"Current-Folder: inbox\n"	*(char)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
profile	*(struct)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
ctx	*(char)
)	O
;	O
ctx	*(char)
=	O
mh_safe_make_file_name	(*(char),*(char))->(*(char))
(	O
mhdir	*(char)
,	O
"inbox"	*(char)
)	O
;	O
if	O
(	O
mh_check_folder	(*(char),int)->(int)
(	O
ctx	*(char)
,	O
!	O
automode	int
)	O
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
ctx	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
mhdir	*(char)
)	O
;	O
}	O
void	O
mh_install	(*(char),int)->(void)
(	O
char	O
*	O
name	*(char)
,	O
int	O
automode	int
)	O
{	O
struct	O
stat	*(int)
st	*(struct(long,long,long))
;	O
if	O
(	O
stat	*(int)
(	O
name	*(char)
,	O
&	O
st	*(struct(long,long,long))
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
if	O
(	O
automode	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"I'm going to create the standard MH path for you.\n"	*(char)
)	O
)	O
;	O
mh_real_install	(*(char),int)->(void)
(	O
name	*(char)
,	O
automode	int
)	O
;	O
}	O
else	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"stat"	*(char)
,	O
name	*(char)
,	O
errno	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
&	O
S_IFREG	O
)	O
||	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
&	O
S_IFLNK	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"You already have an MH profile, use an editor to modify it"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"You already have file %s which is not a regular file or a symbolic link."	*(char)
)	O
,	O
name	*(char)
)	O
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Please remove it and try again"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
void	O
mh_annotate	(*(struct),*(char),*(char),int)->(void)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
const	O
char	O
*	O
field	*(char)
,	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
{	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
mu_attribute_t	*(struct)
attr	*(struct)
;	O
if	O
(	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
)	O
return	O
;	O
if	O
(	O
date	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
{	O
time_t	long
t	long
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
char	O
datebuf	array(char)
[	O
80	int
]	O
;	O
t	long
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
)	O
;	O
mu_strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
datebuf	array(char)
,	O
sizeof	O
datebuf	array(char)
,	O
"%a, %d %b %Y %H:%M:%S %Z"	*(char)
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
mu_header_prepend	(*(struct),*(char),*(char))->(int)
(	O
hdr	*(struct)
,	O
field	*(char)
,	O
datebuf	array(char)
)	O
;	O
}	O
if	O
(	O
text	*(char)
)	O
mu_header_prepend	(*(struct),*(char),*(char))->(int)
(	O
hdr	*(struct)
,	O
field	*(char)
,	O
text	*(char)
)	O
;	O
mu_message_get_attribute	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
attr	*(struct)
)	O
;	O
mu_attribute_set_modified	(*(struct))->(int)
(	O
attr	*(struct)
)	O
;	O
}	O
char	O
*	O
mh_create_message_id	(int)->(*(char))
(	O
int	O
subpart	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
mu_rfc2822_msg_id	(int,*(*(char)))->(int)
(	O
subpart	int
,	O
&	O
p	*(char)
)	O
;	O
return	O
p	*(char)
;	O
}	O
void	O
mh_set_reply_regex	(*(char))->(void)
(	O
const	O
char	O
*	O
str	*(struct(int,*(char),*(char),*(char),*(char)))
)	O
{	O
char	O
*	O
err	long
;	O
int	O
rc	int
=	O
mu_unre_set_regex	(*(char),int,*(*(char)))->(int)
(	O
str	*(struct(int,*(char),*(char),*(char),*(char)))
,	O
0	int
,	O
&	O
err	long
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
"reply_regex: %s%s%s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
,	O
err	long
?	O
": "	*(char)
:	O
""	*(char)
,	O
mu_prstr	(*(char))->(*(char))
(	O
err	long
)	O
)	O
;	O
}	O
const	O
char	O
*	O
mh_charset	(*(char))->(*(char))
(	O
const	O
char	O
*	O
dfl	*(char)
)	O
{	O
const	O
char	O
*	O
charset	*(char)
=	O
mh_global_profile_get	O
(	O
"Charset"	*(char)
,	O
dfl	*(char)
)	O
;	O
if	O
(	O
!	O
charset	*(char)
)	O
return	O
NULL	O
;	O
if	O
(	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
charset	*(char)
,	O
"auto"	*(char)
)	O
==	O
0	int
)	O
{	O
static	O
char	O
*	O
saved_charset	*(char)
;	O
if	O
(	O
!	O
saved_charset	*(char)
)	O
{	O
struct	O
mu_lc_all	struct(int,*(char),*(char),*(char),*(char))
lc_all	struct(int,*(char),*(char),*(char),*(char))
;	O
if	O
(	O
mu_parse_lc_all	(*(char),*(struct(int,*(char),*(char),*(char),*(char))),int)->(int)
(	O
getenv	(*(char))->(*(char))
(	O
"LC_ALL"	*(char)
)	O
,	O
&	O
lc_all	struct(int,*(char),*(char),*(char),*(char))
,	O
MU_LC_CSET	int
)	O
==	O
0	int
)	O
saved_charset	*(char)
=	O
lc_all	struct(int,*(char),*(char),*(char),*(char))
.	O
charset	*(char)
;	O
}	O
charset	*(char)
=	O
saved_charset	*(char)
;	O
}	O
return	O
charset	*(char)
;	O
}	O
int	O
mh_decode_2047	(*(char),*(*(char)))->(int)
(	O
char	O
const	O
*	O
text	*(char)
,	O
char	O
*	O
*	O
decoded_text	*(*(char))
)	O
{	O
const	O
char	O
*	O
charset	*(char)
=	O
mh_charset	(*(char))->(*(char))
(	O
NULL	O
)	O
;	O
if	O
(	O
!	O
charset	*(char)
)	O
return	O
1	int
;	O
return	O
mu_rfc2047_decode	(*(char),*(char),*(*(char)))->(int)
(	O
charset	*(char)
,	O
text	*(char)
,	O
decoded_text	*(*(char))
)	O
;	O
}	O
void	O
mh_quote	(*(char),*(*(char)))->(void)
(	O
const	O
char	O
*	O
in	*(struct)
,	O
char	O
*	O
*	O
out	*(struct)
)	O
{	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
in	*(struct)
)	O
;	O
if	O
(	O
len	int
&&	O
in	*(struct)
[	O
0	int
]	O
==	O
'"'	O
&&	O
in	*(struct)
[	O
len	int
-	O
1	int
]	O
==	O
'"'	O
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
char	O
*	O
q	*(char)
;	O
for	O
(	O
p	*(char)
=	O
in	*(struct)
+	O
1	int
;	O
p	*(char)
<	O
in	*(struct)
+	O
len	int
-	O
1	int
;	O
p	*(char)
++	O
)	O
if	O
(	O
*	O
p	*(char)
==	O
'\\'	O
||	O
*	O
p	*(char)
==	O
'"'	O
)	O
len	int
++	O
;	O
*	O
out	*(struct)
=	O
mu_alloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
q	*(char)
=	O
*	O
out	*(struct)
;	O
p	*(char)
=	O
in	*(struct)
;	O
*	O
q	*(char)
++	O
=	O
*	O
p	*(char)
++	O
;	O
while	O
(	O
p	*(char)
[	O
1	int
]	O
)	O
{	O
if	O
(	O
*	O
p	*(char)
==	O
'\\'	O
||	O
*	O
p	*(char)
==	O
'"'	O
)	O
*	O
q	*(char)
++	O
=	O
'\\'	O
;	O
*	O
q	*(char)
++	O
=	O
*	O
p	*(char)
++	O
;	O
}	O
*	O
q	*(char)
++	O
=	O
*	O
p	*(char)
++	O
;	O
*	O
q	*(char)
=	O
0	int
;	O
}	O
else	O
*	O
out	*(struct)
=	O
mu_strdup	(*(char))->(*(char))
(	O
in	*(struct)
)	O
;	O
}	O
void	O
mh_expand_aliases	(*(struct),*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
mu_address_t	*(struct)
*	O
addr_to	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
mu_address_t	*(struct)
*	O
addr_cc	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
mu_address_t	*(struct)
*	O
addr_bcc	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
{	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
size_t	long
i	long
,	O
num	long
;	O
const	O
char	O
*	O
buf	*(char)
;	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
;	O
mu_header_get_field_count	(*(struct),*(long))->(int)
(	O
hdr	*(struct)
,	O
&	O
num	long
)	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<=	O
num	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
mu_header_sget_field_name	(*(struct),long,*(*(char)))->(int)
(	O
hdr	*(struct)
,	O
i	long
,	O
&	O
buf	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
MU_HEADER_TO	*(char)
)	O
==	O
0	int
||	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
MU_HEADER_CC	*(char)
)	O
==	O
0	int
||	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
MU_HEADER_BCC	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
value	*(char)
;	O
mu_address_t	*(struct)
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
NULL	O
;	O
int	O
incl	*(int)
;	O
mu_header_aget_field_value_unfold	(*(struct),long,*(*(char)))->(int)
(	O
hdr	*(struct)
,	O
i	long
,	O
&	O
value	*(char)
)	O
;	O
mh_alias_expand	(*(char),*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(int))->(int)
(	O
value	*(char)
,	O
&	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
&	O
incl	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
value	*(char)
)	O
;	O
if	O
(	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
MU_HEADER_TO	*(char)
)	O
==	O
0	int
)	O
mu_address_union	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(int)
(	O
addr_to	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
else	O
if	O
(	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
MU_HEADER_CC	*(char)
)	O
==	O
0	int
)	O
mu_address_union	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(int)
(	O
addr_cc	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
?	O
addr_cc	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
:	O
addr_to	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
else	O
if	O
(	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
MU_HEADER_BCC	*(char)
)	O
==	O
0	int
)	O
mu_address_union	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(int)
(	O
addr_bcc	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
?	O
addr_bcc	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
:	O
addr_to	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
}	O
}	O
}	O
}	O
int	O
mh_draft_message	(*(char),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
msgspec	*(char)
,	O
char	O
*	O
*	O
pname	*(*(char))
)	O
{	O
mu_url_t	*(struct)
url	*(struct)
;	O
size_t	long
uid	int
;	O
int	O
rc	int
;	O
mu_mailbox_t	*(struct)
mbox	*(struct)
;	O
const	O
char	O
*	O
path	*(char)
;	O
mbox	*(struct)
=	O
mh_open_folder	(*(char),int)->(*(struct))
(	O
name	*(char)
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
!	O
mbox	*(struct)
)	O
return	O
1	int
;	O
mu_mailbox_get_url	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
url	*(struct)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
msgspec	*(char)
,	O
"new"	*(char)
)	O
==	O
0	int
)	O
{	O
mu_property_t	*(struct)
prop	*(struct)
;	O
rc	int
=	O
mu_mailbox_uidnext	(*(struct),*(long))->(int)
(	O
mbox	*(struct)
,	O
&	O
uid	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot obtain sequence number for the new message: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
mu_mailbox_get_property	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
prop	*(struct)
)	O
;	O
mu_property_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
prop	*(struct)
,	O
"cur"	*(char)
,	O
mu_umaxtostr	(int,long)->(*(char))
(	O
0	int
,	O
uid	int
)	O
,	O
1	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
argv	*(*(char))
[	O
2	int
]	O
;	O
mu_msgset_t	*(struct)
msgset	*(struct)
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
msgspec	*(char)
;	O
argv	*(*(char))
[	O
1	int
]	O
=	O
NULL	O
;	O
mh_msgset_parse	(*(*(struct)),*(struct),int,*(*(char)),*(char))->(void)
(	O
&	O
msgset	*(struct)
,	O
mbox	*(struct)
,	O
1	int
,	O
argv	*(*(char))
,	O
"cur"	*(char)
)	O
;	O
if	O
(	O
!	O
mh_msgset_single_message	(*(struct))->(int)
(	O
msgset	*(struct)
)	O
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"only one message at a time!"	*(char)
)	O
)	O
;	O
else	O
uid	int
=	O
mh_msgset_first	(*(struct),int)->(long)
(	O
msgset	*(struct)
,	O
RET_UID	int
)	O
;	O
mu_msgset_free	(*(struct))->(void)
(	O
msgset	*(struct)
)	O
;	O
}	O
mu_url_sget_path	(*(struct),*(*(char)))->(int)
(	O
url	*(struct)
,	O
&	O
path	*(char)
)	O
;	O
rc	int
=	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
pname	*(*(char))
,	O
"%s/%lu"	*(char)
,	O
path	*(char)
,	O
(	O
unsigned	O
long	O
)	O
uid	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_asprintf"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
mu_mailbox_close	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
;	O
mu_mailbox_destroy	(*(*(struct)))->(void)
(	O
&	O
mbox	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
char	O
*	O
mh_safe_make_file_name	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
dir	*(char)
,	O
const	O
char	O
*	O
file	*(char)
)	O
{	O
char	O
*	O
name	*(char)
=	O
mu_make_file_name	O
(	O
dir	*(char)
,	O
file	*(char)
)	O
;	O
if	O
(	O
!	O
name	*(char)
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_make_file_name"	*(char)
,	O
NULL	O
,	O
ENOMEM	int
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
return	O
name	*(char)
;	O
}	O
int	O
mh_width	()->(int)
(	O
void	O
)	O
{	O
struct	O
winsize	struct(short,short,short,short)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_col	short
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_row	short
=	O
0	int
;	O
if	O
(	O
(	O
ioctl	(int,long)->(int)
(	O
1	int
,	O
TIOCGWINSZ	int
,	O
(	O
char	O
*	O
)	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
<	O
0	int
)	O
||	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_col	short
==	O
0	int
)	O
return	O
80	int
;	O
return	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_col	short
;	O
}	O
