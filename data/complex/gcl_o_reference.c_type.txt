LFD	(int)->(int)
(	O
Lfboundp	int
)	O
(	O
void	O
)	O
{	O
object	O
sym	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
sym	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
}	O
object	O
symbol_function	(int)->(int)
(	O
object	O
sym	int
)	O
{	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
||	O
sym	int
->	O
s	O
.	O
s_mflag	O
)	O
FEinvalid_function	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEundefined_function	()->(int)
(	O
sym	int
)	O
;	O
return	O
(	O
sym	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lsymbol_function	int
)	O
(	O
void	O
)	O
{	O
object	O
sym	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
sym	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
{	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
(	O
long	O
)	O
(	O
sym	int
->	O
s	O
.	O
s_sfdef	O
)	O
)	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
sLspecial	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEundefined_function	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_mflag	O
)	O
{	O
vs_push	()->(int)
(	O
sym	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
sLmacro	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
return	O
;	O
}	O
vs_base	O
[	O
0	int
]	O
=	O
sym	int
->	O
s	O
.	O
s_gfdef	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fquote	int
)	O
(	O
object	O
form	int
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	()->(int)
(	O
form	int
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
MMcar	()->(int)
(	O
form	int
)	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Ffunction	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
fun	O
;	O
object	O
fd	O
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	()->(int)
(	O
form	int
)	O
;	O
fun	O
=	O
MMcar	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
fun	O
)	O
==	O
t_symbol	O
)	O
{	O
fd	O
=	O
lex_fd_sch	()->(int)
(	O
fun	O
)	O
;	O
if	O
(	O
MMnull	()->(int)
(	O
fd	O
)	O
||	O
MMcadr	()->(int)
(	O
fd	O
)	O
!=	O
sLfunction	O
)	O
if	O
(	O
fun	O
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
||	O
fun	O
->	O
s	O
.	O
s_mflag	O
)	O
FEundefined_function	()->(int)
(	O
fun	O
)	O
;	O
else	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
fun	O
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
}	O
else	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
MMcaddr	()->(int)
(	O
fd	O
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
type_of	()->(int)
(	O
fun	O
)	O
==	O
t_cons	O
&&	O
MMcar	()->(int)
(	O
fun	O
)	O
==	O
sLlambda	O
)	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
MMcdr	()->(int)
(	O
fun	O
)	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
lex_env	O
[	O
2	int
]	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
lex_env	O
[	O
1	int
]	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
lex_env	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
sLlambda_closure	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
else	O
FEinvalid_function	()->(int)
(	O
fun	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lsymbol_value	int
)	O
(	O
void	O
)	O
{	O
object	O
sym	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
sym	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_dbind	O
==	O
OBJNULL	O
)	O
FEunbound_variable	()->(int)
(	O
sym	int
)	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
sym	int
->	O
s	O
.	O
s_dbind	O
;	O
}	O
LFD	(int)->(int)
(	O
Lboundp	int
)	O
(	O
void	O
)	O
{	O
object	O
sym	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
sym	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_dbind	O
==	O
OBJNULL	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
}	O
LFD	(int)->(int)
(	O
Lmacro_function	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_gfdef	O
!=	O
OBJNULL	O
&&	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_mflag	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_gfdef	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
LFD	(int)->(int)
(	O
Lspecial_form_p	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
void	O
gcl_init_reference	()->(void)
(	O
void	O
)	O
{	O
make_function	()->(int)
(	O
"SYMBOL-FUNCTION"	*(char)
,	O
Lsymbol_function	int
)	O
;	O
make_function	()->(int)
(	O
"FBOUNDP"	*(char)
,	O
Lfboundp	int
)	O
;	O
sLquote	O
=	O
make_special_form	()->(int)
(	O
"QUOTE"	*(char)
,	O
Fquote	int
)	O
;	O
sLfunction	O
=	O
make_special_form	()->(int)
(	O
"FUNCTION"	*(char)
,	O
Ffunction	int
)	O
;	O
make_function	()->(int)
(	O
"SYMBOL-VALUE"	*(char)
,	O
Lsymbol_value	int
)	O
;	O
make_function	()->(int)
(	O
"BOUNDP"	*(char)
,	O
Lboundp	int
)	O
;	O
make_function	()->(int)
(	O
"MACRO-FUNCTION"	*(char)
,	O
Lmacro_function	int
)	O
;	O
make_function	()->(int)
(	O
"SPECIAL-FORM-P"	*(char)
,	O
Lspecial_form_p	int
)	O
;	O
make_function	()->(int)
(	O
"SPECIAL-OPERATOR-P"	*(char)
,	O
Lspecial_form_p	int
)	O
;	O
}	O
