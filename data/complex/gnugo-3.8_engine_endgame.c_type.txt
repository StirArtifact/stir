static	O
void	O
endgame_analyze_worm_liberties	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
;	O
static	O
void	O
endgame_find_backfilling_dame	(int,int)->(void)
(	O
int	O
str	int
,	O
int	O
color	int
)	O
;	O
static	O
int	O
endgame_find_liberties	(int,*(int),array(int),*(int),array(int),*(int),array(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
essential_liberties	*(int)
,	O
int	O
essential_libs	array(int)
[	O
MAXLIBS	O
]	O
,	O
int	O
*	O
inessential_liberties	*(int)
,	O
int	O
inessential_libs	array(int)
[	O
MAXLIBS	O
]	O
,	O
int	O
*	O
false_eye_liberties	*(int)
,	O
int	O
false_eye_libs	array(int)
[	O
MAXLIBS	O
]	O
)	O
;	O
void	O
endgame	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
TRACE	O
(	O
"\nEndgame move generator tries to look for additional moves...\n"	*(char)
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
&&	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
&&	O
!	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
invincible	int
&&	O
!	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
inessential	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
{	O
endgame_analyze_worm_liberties	(int,int)->(void)
(	O
pos	int
,	O
color	int
)	O
;	O
endgame_find_backfilling_dame	(int,int)->(void)
(	O
pos	int
,	O
color	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
endgame_analyze_worm_liberties	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
worm_color	int
=	O
board	*(char)
[	O
pos	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
worm_color	int
)	O
;	O
int	O
essential_liberties	*(int)
;	O
int	O
essential_libs	array(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
inessential_liberties	*(int)
;	O
int	O
inessential_libs	array(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
false_eye_liberties	*(int)
;	O
int	O
false_eye_libs	array(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
num_attacks	int
;	O
int	O
num_attacks2	int
;	O
int	O
attacks	array(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
defenses	array(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
apos	int
;	O
int	O
value	*(char)
;	O
if	O
(	O
!	O
endgame_find_liberties	(int,*(int),array(int),*(int),array(int),*(int),array(int))->(int)
(	O
pos	int
,	O
&	O
essential_liberties	*(int)
,	O
essential_libs	array(int)
,	O
&	O
inessential_liberties	*(int)
,	O
inessential_libs	array(int)
,	O
&	O
false_eye_liberties	*(int)
,	O
false_eye_libs	array(int)
)	O
)	O
return	O
;	O
apos	int
=	O
NO_MOVE	O
;	O
num_attacks	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
inessential_liberties	*(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
safe_move	(int,int)->(int)
(	O
inessential_libs	array(int)
[	O
k	int
]	O
,	O
other	int
)	O
||	O
!	O
trymove	(int,int,*(char),int)->(int)
(	O
inessential_libs	array(int)
[	O
k	int
]	O
,	O
other	int
,	O
"endgame"	*(char)
,	O
pos	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
inessential_liberties	*(int)
&&	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
{	O
if	O
(	O
countlib	(int)->(int)
(	O
pos	int
)	O
>	O
1	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
essential_liberties	*(int)
;	O
k	int
++	O
)	O
{	O
int	O
lib	int
=	O
essential_libs	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
lib	int
,	O
worm_color	int
)	O
&&	O
safe_move	(int,int)->(int)
(	O
lib	int
,	O
other	int
)	O
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
lib	int
,	O
other	int
,	O
"endgame"	*(char)
,	O
pos	int
)	O
)	O
{	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
int	O
dpos	int
;	O
if	O
(	O
find_defense	(int,*(int))->(int)
(	O
pos	int
,	O
&	O
dpos	int
)	O
&&	O
is_proper_eye_space	(int)->(int)
(	O
dpos	int
)	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
essential_liberties	*(int)
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
!=	O
k	int
&&	O
essential_libs	array(int)
[	O
i	int
]	O
!=	O
dpos	int
&&	O
does_defend	(int,int)->(int)
(	O
essential_libs	array(int)
[	O
i	int
]	O
,	O
pos	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
essential_liberties	*(int)
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
false_eye_liberties	*(int)
;	O
i	int
++	O
)	O
{	O
if	O
(	O
does_defend	(int,int)->(int)
(	O
false_eye_libs	array(int)
[	O
i	int
]	O
,	O
pos	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
false_eye_liberties	*(int)
)	O
{	O
int	O
adj	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adjs	int
;	O
adjs	int
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
pos	int
,	O
adj	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
adjs	int
;	O
i	int
++	O
)	O
{	O
int	O
lib2	int
;	O
findlib	(int,int,*(int))->(int)
(	O
adj	array(int)
[	O
i	int
]	O
,	O
1	int
,	O
&	O
lib2	int
)	O
;	O
if	O
(	O
lib2	int
!=	O
dpos	int
&&	O
!	O
is_proper_eye_space	(int)->(int)
(	O
lib2	int
)	O
&&	O
does_defend	(int,int)->(int)
(	O
lib2	int
,	O
pos	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
adjs	int
)	O
{	O
attacks	array(int)
[	O
num_attacks	int
]	O
=	O
lib	int
;	O
defenses	array(int)
[	O
num_attacks	int
]	O
=	O
dpos	int
;	O
num_attacks	int
++	O
;	O
}	O
}	O
}	O
}	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
essential_liberties	*(int)
>	O
0	int
)	O
{	O
attacks	array(int)
[	O
num_attacks	int
]	O
=	O
essential_libs	array(int)
[	O
0	int
]	O
;	O
defenses	array(int)
[	O
num_attacks	int
]	O
=	O
NO_MOVE	O
;	O
num_attacks	int
++	O
;	O
}	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
&	O
apos	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
is_proper_eye_space	(int)->(int)
(	O
apos	int
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
essential_liberties	*(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
does_defend	(int,int)->(int)
(	O
essential_libs	array(int)
[	O
k	int
]	O
,	O
pos	int
)	O
)	O
{	O
apos	int
=	O
NO_MOVE	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
apos	int
!=	O
NO_MOVE	O
&&	O
worm_color	int
==	O
color	int
&&	O
!	O
does_defend	(int,int)->(int)
(	O
apos	int
,	O
pos	int
)	O
)	O
apos	int
=	O
NO_MOVE	O
;	O
}	O
else	O
apos	int
=	O
NO_MOVE	O
;	O
}	O
}	O
else	O
{	O
inessential_liberties	*(int)
=	O
k	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
inessential_liberties	*(int)
;	O
k	int
++	O
)	O
popgo	()->(void)
(	O
)	O
;	O
ASSERT1	O
(	O
stackp	int
==	O
0	int
,	O
pos	int
)	O
;	O
num_attacks2	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_attacks	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
attacks	array(int)
[	O
k	int
]	O
,	O
other	int
)	O
)	O
{	O
if	O
(	O
defenses	array(int)
[	O
k	int
]	O
!=	O
NO_MOVE	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
int	O
pos2	int
=	O
defenses	array(int)
[	O
k	int
]	O
+	O
delta	array(int)
[	O
i	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
m	int
;	O
if	O
(	O
!	O
is_proper_eye_space	(int)->(int)
(	O
pos2	int
)	O
&&	O
safe_move	(int,int)->(int)
(	O
pos2	int
,	O
other	int
)	O
)	O
break	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
inessential_liberties	*(int)
;	O
m	int
++	O
)	O
{	O
if	O
(	O
inessential_libs	array(int)
[	O
m	int
]	O
==	O
pos2	int
)	O
break	O
;	O
}	O
if	O
(	O
m	int
<	O
inessential_liberties	*(int)
)	O
break	O
;	O
}	O
}	O
if	O
(	O
i	int
==	O
4	int
)	O
attacks	array(int)
[	O
num_attacks2	int
++	O
]	O
=	O
attacks	array(int)
[	O
k	int
]	O
;	O
}	O
else	O
{	O
ASSERT1	O
(	O
num_attacks	int
==	O
1	int
,	O
pos	int
)	O
;	O
attacks	array(int)
[	O
num_attacks2	int
++	O
]	O
=	O
attacks	array(int)
[	O
k	int
]	O
;	O
}	O
}	O
}	O
value	*(char)
=	O
0	int
;	O
if	O
(	O
apos	int
!=	O
NO_MOVE	O
)	O
{	O
value	*(char)
=	O
accuratelib	(int,int,int,*(int))->(int)
(	O
apos	int
,	O
other	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
-	O
2	int
;	O
}	O
if	O
(	O
value	*(char)
<=	O
0	int
&&	O
num_attacks2	int
==	O
0	int
)	O
return	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
inessential_liberties	*(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
trymove	(int,int,*(char),int)->(int)
(	O
inessential_libs	array(int)
[	O
k	int
]	O
,	O
worm_color	int
,	O
"endgame"	*(char)
,	O
pos	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
inessential_liberties	*(int)
&&	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
{	O
if	O
(	O
countlib	(int)->(int)
(	O
pos	int
)	O
>	O
1	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_attacks2	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
attacks	array(int)
[	O
k	int
]	O
,	O
other	int
,	O
"endgame"	*(char)
,	O
pos	int
)	O
)	O
{	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
TRACE	O
(	O
"  endgame move with territorial value %d.0 found at %1m\n"	*(char)
,	O
1	int
,	O
attacks	array(int)
[	O
k	int
]	O
)	O
;	O
add_expand_territory_move	(int)->(void)
(	O
attacks	array(int)
[	O
k	int
]	O
)	O
;	O
set_minimum_territorial_value	(int,float)->(void)
(	O
attacks	array(int)
[	O
k	int
]	O
,	O
1.0	int
)	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
essential_liberties	*(int)
>	O
0	int
&&	O
essential_libs	array(int)
[	O
0	int
]	O
==	O
attacks	array(int)
[	O
0	int
]	O
)	O
{	O
TRACE	O
(	O
"  endgame move with territorial value %d.0 found at %1m\n"	*(char)
,	O
1	int
,	O
attacks	array(int)
[	O
k	int
]	O
)	O
;	O
add_expand_territory_move	(int)->(void)
(	O
attacks	array(int)
[	O
0	int
]	O
)	O
;	O
set_minimum_territorial_value	(int,float)->(void)
(	O
attacks	array(int)
[	O
0	int
]	O
,	O
1.0	int
)	O
;	O
}	O
if	O
(	O
value	*(char)
>	O
0	int
&&	O
does_attack	(int,int)->(int)
(	O
apos	int
,	O
pos	int
)	O
)	O
{	O
TRACE	O
(	O
"  endgame move with territorial value %d.0 found at %1m\n"	*(char)
,	O
value	*(char)
,	O
apos	int
)	O
;	O
add_expand_territory_move	(int)->(void)
(	O
apos	int
)	O
;	O
set_minimum_territorial_value	(int,float)->(void)
(	O
apos	int
,	O
(	O
float	O
)	O
value	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
inessential_liberties	*(int)
=	O
k	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
inessential_liberties	*(int)
;	O
k	int
++	O
)	O
popgo	()->(void)
(	O
)	O
;	O
ASSERT1	O
(	O
stackp	int
==	O
0	int
,	O
pos	int
)	O
;	O
}	O
static	O
void	O
endgame_find_backfilling_dame	(int,int)->(void)
(	O
int	O
str	int
,	O
int	O
color_to_move	int
)	O
{	O
int	O
k	int
;	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
essential_liberties	*(int)
;	O
int	O
essential_libs	array(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
inessential_liberties	*(int)
;	O
int	O
inessential_libs	array(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
false_eye_liberties	*(int)
;	O
int	O
false_eye_libs	array(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
dpos	int
;	O
int	O
loop_again	int
=	O
1	int
;	O
int	O
potential_moves	array(float)
[	O
BOARDMAX	O
]	O
;	O
int	O
num_potential_moves	int
=	O
0	int
;	O
int	O
move	*(int)
=	O
NO_MOVE	O
;	O
while	O
(	O
loop_again	int
)	O
{	O
loop_again	int
=	O
0	int
;	O
if	O
(	O
!	O
endgame_find_liberties	(int,*(int),array(int),*(int),array(int),*(int),array(int))->(int)
(	O
str	int
,	O
&	O
essential_liberties	*(int)
,	O
essential_libs	array(int)
,	O
&	O
inessential_liberties	*(int)
,	O
inessential_libs	array(int)
,	O
&	O
false_eye_liberties	*(int)
,	O
false_eye_libs	array(int)
)	O
)	O
break	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
inessential_liberties	*(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
safe_move	(int,int)->(int)
(	O
inessential_libs	array(int)
[	O
k	int
]	O
,	O
other	int
)	O
||	O
!	O
trymove	(int,int,*(char),int)->(int)
(	O
inessential_libs	array(int)
[	O
k	int
]	O
,	O
other	int
,	O
"endgame"	*(char)
,	O
str	int
)	O
)	O
continue	O
;	O
increase_depth_values	()->(void)
(	O
)	O
;	O
if	O
(	O
board	*(char)
[	O
str	int
]	O
==	O
EMPTY	int
)	O
break	O
;	O
if	O
(	O
attack_and_defend	(int,*(int),*(int),*(int),*(int))->(int)
(	O
str	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
dpos	int
)	O
)	O
{	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
dpos	int
]	O
.	O
color	int
==	O
EMPTY	int
)	O
{	O
potential_moves	array(float)
[	O
num_potential_moves	int
]	O
=	O
dpos	int
;	O
num_potential_moves	int
++	O
;	O
}	O
forced_backfilling_moves	array(int)
[	O
dpos	int
]	O
=	O
1	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
dpos	int
,	O
color	int
,	O
"endgame"	*(char)
,	O
str	int
)	O
)	O
increase_depth_values	()->(void)
(	O
)	O
;	O
loop_again	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
while	O
(	O
stackp	int
>	O
0	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
}	O
for	O
(	O
k	int
=	O
num_potential_moves	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
potential_moves	array(float)
[	O
k	int
]	O
,	O
color	int
)	O
)	O
{	O
move	*(int)
=	O
potential_moves	array(float)
[	O
k	int
]	O
;	O
TRACE	O
(	O
"  backfilling dame found at %1m for string %1m\n"	*(char)
,	O
move	*(int)
,	O
str	int
)	O
;	O
if	O
(	O
color	int
==	O
color_to_move	int
)	O
{	O
add_expand_territory_move	(int)->(void)
(	O
move	*(int)
)	O
;	O
set_minimum_territorial_value	(int,float)->(void)
(	O
move	*(int)
,	O
0.1	int
)	O
;	O
}	O
break	O
;	O
}	O
}	O
static	O
int	O
endgame_find_liberties	(int,*(int),array(int),*(int),array(int),*(int),array(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
essential_liberties	*(int)
,	O
int	O
essential_libs	array(int)
[	O
MAXLIBS	O
]	O
,	O
int	O
*	O
inessential_liberties	*(int)
,	O
int	O
inessential_libs	array(int)
[	O
MAXLIBS	O
]	O
,	O
int	O
*	O
false_eye_liberties	*(int)
,	O
int	O
false_eye_libs	array(int)
[	O
MAXLIBS	O
]	O
)	O
{	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
k	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
*	O
essential_liberties	*(int)
=	O
0	int
;	O
*	O
inessential_liberties	*(int)
=	O
0	int
;	O
*	O
false_eye_liberties	*(int)
=	O
0	int
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
int	O
lib	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
if	O
(	O
!	O
is_proper_eye_space	(int)->(int)
(	O
lib	int
)	O
)	O
{	O
int	O
i	int
;	O
int	O
essential	int
=	O
0	int
;	O
int	O
found_other	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
int	O
pos	int
=	O
lib	int
+	O
delta	array(int)
[	O
i	int
]	O
;	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
||	O
!	O
IS_STONE	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
color	int
)	O
)	O
continue	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
||	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
ALIVE	int
)	O
return	O
0	int
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
board	*(char)
[	O
str	int
]	O
)	O
{	O
if	O
(	O
find_origin	(int)->(int)
(	O
pos	int
)	O
!=	O
find_origin	(int)->(int)
(	O
str	int
)	O
)	O
essential	int
=	O
1	int
;	O
}	O
else	O
found_other	int
=	O
1	int
;	O
}	O
if	O
(	O
i	int
<	O
4	int
)	O
break	O
;	O
if	O
(	O
found_other	int
)	O
{	O
if	O
(	O
essential	int
)	O
essential_libs	array(int)
[	O
(	O
*	O
essential_liberties	*(int)
)	O
++	O
]	O
=	O
lib	int
;	O
else	O
inessential_libs	array(int)
[	O
(	O
*	O
inessential_liberties	*(int)
)	O
++	O
]	O
=	O
lib	int
;	O
}	O
else	O
if	O
(	O
is_false_eye	(array(struct(float,char,int,array(int),int,array(int))),int)->(int)
(	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
,	O
lib	int
)	O
&&	O
!	O
false_eye_territory	array(int)
[	O
lib	int
]	O
)	O
false_eye_libs	array(int)
[	O
(	O
*	O
false_eye_liberties	*(int)
)	O
++	O
]	O
=	O
lib	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
