static	O
int	O
_debug	int
=	O
0	int
;	O
char	O
*	O
RPMVERSION	*(char)
=	O
VERSION	*(char)
;	O
char	O
*	O
rpm_stpcpy	(*(char),*(char))->(*(char))
(	O
dest	*(char)
,	O
src	*(char)
)	O
char	O
*	O
dest	*(char)
;	O
const	O
char	O
*	O
src	*(char)
;	O
{	O
register	O
char	O
*	O
d	*(char)
=	O
dest	*(char)
;	O
register	O
const	O
char	O
*	O
s	*(char)
=	O
src	*(char)
;	O
do	O
*	O
d	*(char)
++	O
=	O
*	O
s	*(char)
;	O
while	O
(	O
*	O
s	*(char)
++	O
!=	O
'\0'	O
)	O
;	O
return	O
d	*(char)
-	O
1	int
;	O
}	O
char	O
*	O
*	O
splitString	(*(char),int,char)->(*(*(char)))
(	O
const	O
char	O
*	O
str	*(char)
,	O
int	O
length	int
,	O
char	O
sep	char
)	O
{	O
const	O
char	O
*	O
source	enum(int,int,int,int,int,int,int,int,int,int)
;	O
char	O
*	O
s	*(char)
,	O
*	O
dest	*(char)
;	O
char	O
*	O
*	O
list	*(*(char))
;	O
int	O
i	int
;	O
int	O
fields	int
;	O
s	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
length	int
+	O
1	int
)	O
;	O
fields	int
=	O
1	int
;	O
for	O
(	O
source	enum(int,int,int,int,int,int,int,int,int,int)
=	O
str	*(char)
,	O
dest	*(char)
=	O
s	*(char)
,	O
i	int
=	O
0	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
,	O
source	enum(int,int,int,int,int,int,int,int,int,int)
++	O
,	O
dest	*(char)
++	O
)	O
{	O
*	O
dest	*(char)
=	O
*	O
source	enum(int,int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
*	O
dest	*(char)
==	O
sep	char
)	O
fields	int
++	O
;	O
}	O
*	O
dest	*(char)
=	O
'\0'	O
;	O
list	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
fields	int
+	O
1	int
)	O
)	O
;	O
dest	*(char)
=	O
s	*(char)
;	O
list	*(*(char))
[	O
0	int
]	O
=	O
dest	*(char)
;	O
i	int
=	O
1	int
;	O
while	O
(	O
i	int
<	O
fields	int
)	O
{	O
if	O
(	O
*	O
dest	*(char)
==	O
sep	char
)	O
{	O
list	*(*(char))
[	O
i	int
++	O
]	O
=	O
dest	*(char)
+	O
1	int
;	O
*	O
dest	*(char)
=	O
0	int
;	O
}	O
dest	*(char)
++	O
;	O
}	O
list	*(*(char))
[	O
i	int
]	O
=	O
NULL	O
;	O
return	O
list	*(*(char))
;	O
}	O
int	O
headerNVR	(*(struct),*(*(char)),*(*(char)),*(*(char)))->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
const	O
char	O
*	O
*	O
np	*(*(char))
,	O
const	O
char	O
*	O
*	O
vp	*(*(char))
,	O
const	O
char	O
*	O
*	O
rp	*(*(char))
)	O
{	O
int	O
type	enum(int,int,int,int)
,	O
count	long
;	O
if	O
(	O
np	*(*(char))
&&	O
!	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
RPMTAG_NAME	int
,	O
&	O
type	enum(int,int,int,int)
,	O
(	O
void	O
*	O
*	O
)	O
np	*(*(char))
,	O
&	O
count	long
)	O
)	O
*	O
np	*(*(char))
=	O
NULL	O
;	O
if	O
(	O
vp	*(*(char))
&&	O
!	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
RPMTAG_VERSION	int
,	O
&	O
type	enum(int,int,int,int)
,	O
(	O
void	O
*	O
*	O
)	O
vp	*(*(char))
,	O
&	O
count	long
)	O
)	O
*	O
vp	*(*(char))
=	O
NULL	O
;	O
if	O
(	O
rp	*(*(char))
&&	O
!	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
RPMTAG_RELEASE	int
,	O
&	O
type	enum(int,int,int,int)
,	O
(	O
void	O
*	O
*	O
)	O
rp	*(*(char))
,	O
&	O
count	long
)	O
)	O
*	O
rp	*(*(char))
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
void	O
freeSplitString	(*(*(char)))->(void)
(	O
char	O
*	O
*	O
list	*(*(char))
)	O
{	O
free	(*(void))->(void)
(	O
list	*(*(char))
[	O
0	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
list	*(*(char))
)	O
;	O
}	O
int	O
rpmfileexists	(*(char))->(int)
(	O
const	O
char	O
*	O
urlfn	*(char)
)	O
{	O
const	O
char	O
*	O
fn	*(char)
;	O
int	O
urltype	enum(int,int,int,int,int)
=	O
urlPath	(*(char),*(*(char)))->(int)
(	O
urlfn	*(char)
,	O
&	O
fn	*(char)
)	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
buf	*(char)
;	O
if	O
(	O
*	O
fn	*(char)
==	O
'\0'	O
)	O
fn	*(char)
=	O
"/"	*(char)
;	O
switch	O
(	O
urltype	enum(int,int,int,int,int)
)	O
{	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
case	O
URL_IS_UNKNOWN	int
:	O
if	O
(	O
Stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fn	*(char)
,	O
&	O
buf	*(char)
)	O
)	O
{	O
switch	O
(	O
errno	O
)	O
{	O
case	O
ENOENT	int
:	O
case	O
EINVAL	int
:	O
return	O
0	int
;	O
}	O
}	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
0	int
;	O
break	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
rpmvercmp	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
a	*(char)
,	O
const	O
char	O
*	O
b	*(char)
)	O
{	O
char	O
oldch1	char
,	O
oldch2	char
;	O
char	O
*	O
str1	*(char)
,	O
*	O
str2	*(char)
;	O
char	O
*	O
one	*(char)
,	O
*	O
two	*(char)
;	O
int	O
rc	int
;	O
int	O
isnum	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
a	*(char)
,	O
b	*(char)
)	O
)	O
return	O
0	int
;	O
str1	*(char)
=	O
alloca	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
a	*(char)
)	O
+	O
1	int
)	O
;	O
str2	*(char)
=	O
alloca	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
b	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
str1	*(char)
,	O
a	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
str2	*(char)
,	O
b	*(char)
)	O
;	O
one	*(char)
=	O
str1	*(char)
;	O
two	*(char)
=	O
str2	*(char)
;	O
while	O
(	O
*	O
one	*(char)
&&	O
*	O
two	*(char)
)	O
{	O
while	O
(	O
*	O
one	*(char)
&&	O
!	O
isalnum	(int)->(int)
(	O
*	O
one	*(char)
)	O
)	O
one	*(char)
++	O
;	O
while	O
(	O
*	O
two	*(char)
&&	O
!	O
isalnum	(int)->(int)
(	O
*	O
two	*(char)
)	O
)	O
two	*(char)
++	O
;	O
str1	*(char)
=	O
one	*(char)
;	O
str2	*(char)
=	O
two	*(char)
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
str1	*(char)
)	O
)	O
{	O
while	O
(	O
*	O
str1	*(char)
&&	O
isdigit	(int)->(int)
(	O
*	O
str1	*(char)
)	O
)	O
str1	*(char)
++	O
;	O
while	O
(	O
*	O
str2	*(char)
&&	O
isdigit	(int)->(int)
(	O
*	O
str2	*(char)
)	O
)	O
str2	*(char)
++	O
;	O
isnum	int
=	O
1	int
;	O
}	O
else	O
{	O
while	O
(	O
*	O
str1	*(char)
&&	O
isalpha	(int)->(int)
(	O
*	O
str1	*(char)
)	O
)	O
str1	*(char)
++	O
;	O
while	O
(	O
*	O
str2	*(char)
&&	O
isalpha	(int)->(int)
(	O
*	O
str2	*(char)
)	O
)	O
str2	*(char)
++	O
;	O
isnum	int
=	O
0	int
;	O
}	O
oldch1	char
=	O
*	O
str1	*(char)
;	O
*	O
str1	*(char)
=	O
'\0'	O
;	O
oldch2	char
=	O
*	O
str2	*(char)
;	O
*	O
str2	*(char)
=	O
'\0'	O
;	O
if	O
(	O
one	*(char)
==	O
str1	*(char)
)	O
return	O
-	O
1	int
;	O
if	O
(	O
two	*(char)
==	O
str2	*(char)
)	O
return	O
-	O
1	int
;	O
if	O
(	O
isnum	int
)	O
{	O
while	O
(	O
*	O
one	*(char)
==	O
'0'	O
)	O
one	*(char)
++	O
;	O
while	O
(	O
*	O
two	*(char)
==	O
'0'	O
)	O
two	*(char)
++	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
one	*(char)
)	O
>	O
strlen	(*(char))->(long)
(	O
two	*(char)
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
two	*(char)
)	O
>	O
strlen	(*(char))->(long)
(	O
one	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
one	*(char)
,	O
two	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
*	O
str1	*(char)
=	O
oldch1	char
;	O
one	*(char)
=	O
str1	*(char)
;	O
*	O
str2	*(char)
=	O
oldch2	char
;	O
two	*(char)
=	O
str2	*(char)
;	O
}	O
if	O
(	O
(	O
!	O
*	O
one	*(char)
)	O
&&	O
(	O
!	O
*	O
two	*(char)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
*	O
one	*(char)
)	O
return	O
-	O
1	int
;	O
else	O
return	O
1	int
;	O
}	O
void	O
stripTrailingSlashes	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
chptr	*(char)
;	O
chptr	*(char)
=	O
str	*(char)
+	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
-	O
1	int
;	O
while	O
(	O
*	O
chptr	*(char)
==	O
'/'	O
&&	O
chptr	*(char)
>=	O
str	*(char)
)	O
{	O
*	O
chptr	*(char)
=	O
'\0'	O
;	O
chptr	*(char)
--	O
;	O
}	O
}	O
int	O
doputenv	(*(char))->(int)
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
a	*(char)
;	O
a	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
a	*(char)
,	O
str	*(char)
)	O
;	O
return	O
putenv	(*(char))->(int)
(	O
a	*(char)
)	O
;	O
}	O
int	O
dosetenv	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
value	*(char)
,	O
int	O
overwrite	int
)	O
{	O
int	O
i	int
;	O
char	O
*	O
a	*(char)
;	O
if	O
(	O
!	O
overwrite	int
&&	O
getenv	(*(char))->(*(char))
(	O
name	*(char)
)	O
)	O
return	O
0	int
;	O
i	int
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
+	O
2	int
;	O
a	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
i	int
)	O
;	O
if	O
(	O
!	O
a	*(char)
)	O
return	O
1	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
a	*(char)
,	O
name	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
a	*(char)
,	O
"="	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
a	*(char)
,	O
value	*(char)
)	O
;	O
return	O
putenv	(*(char))->(int)
(	O
a	*(char)
)	O
;	O
}	O
int	O
unameToUid	(*(char),*(int))->(int)
(	O
const	O
char	O
*	O
thisUname	*(char)
,	O
uid_t	int
*	O
uid	int
)	O
{	O
static	O
char	O
*	O
lastUname	*(char)
=	O
NULL	O
;	O
static	O
int	O
lastUnameLen	int
=	O
0	int
;	O
static	O
int	O
lastUnameAlloced	int
;	O
static	O
uid_t	int
lastUid	int
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pwent	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
int	O
thisUnameLen	int
;	O
if	O
(	O
!	O
thisUname	*(char)
)	O
{	O
lastUnameLen	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
thisUname	*(char)
,	O
"root"	*(char)
)	O
)	O
{	O
*	O
uid	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
thisUnameLen	int
=	O
strlen	(*(char))->(long)
(	O
thisUname	*(char)
)	O
;	O
if	O
(	O
!	O
lastUname	*(char)
||	O
thisUnameLen	int
!=	O
lastUnameLen	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
thisUname	*(char)
,	O
lastUname	*(char)
)	O
)	O
{	O
if	O
(	O
lastUnameAlloced	int
<	O
thisUnameLen	int
+	O
1	int
)	O
{	O
lastUnameAlloced	int
=	O
thisUnameLen	int
+	O
10	int
;	O
lastUname	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
lastUname	*(char)
,	O
lastUnameAlloced	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
lastUname	*(char)
,	O
thisUname	*(char)
)	O
;	O
pwent	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
thisUname	*(char)
)	O
;	O
if	O
(	O
!	O
pwent	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
{	O
endpwent	()->(void)
(	O
)	O
;	O
pwent	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
thisUname	*(char)
)	O
;	O
if	O
(	O
!	O
pwent	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
return	O
-	O
1	int
;	O
}	O
lastUid	int
=	O
pwent	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
;	O
}	O
*	O
uid	int
=	O
lastUid	int
;	O
return	O
0	int
;	O
}	O
int	O
gnameToGid	(*(char),*(int))->(int)
(	O
const	O
char	O
*	O
thisGname	*(char)
,	O
gid_t	int
*	O
gid	int
)	O
{	O
static	O
char	O
*	O
lastGname	*(char)
=	O
NULL	O
;	O
static	O
int	O
lastGnameLen	int
=	O
0	int
;	O
static	O
int	O
lastGnameAlloced	int
;	O
static	O
uid_t	int
lastGid	int
;	O
int	O
thisGnameLen	int
;	O
struct	O
group	struct(*(char),*(char),int,*(*(char)))
*	O
grent	*(struct(*(char),*(char),int,*(*(char))))
;	O
if	O
(	O
!	O
thisGname	*(char)
)	O
{	O
lastGnameLen	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
thisGname	*(char)
,	O
"root"	*(char)
)	O
)	O
{	O
*	O
gid	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
thisGnameLen	int
=	O
strlen	(*(char))->(long)
(	O
thisGname	*(char)
)	O
;	O
if	O
(	O
!	O
lastGname	*(char)
||	O
thisGnameLen	int
!=	O
lastGnameLen	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
thisGname	*(char)
,	O
lastGname	*(char)
)	O
)	O
{	O
if	O
(	O
lastGnameAlloced	int
<	O
thisGnameLen	int
+	O
1	int
)	O
{	O
lastGnameAlloced	int
=	O
thisGnameLen	int
+	O
10	int
;	O
lastGname	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
lastGname	*(char)
,	O
lastGnameAlloced	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
lastGname	*(char)
,	O
thisGname	*(char)
)	O
;	O
grent	*(struct(*(char),*(char),int,*(*(char))))
=	O
getgrnam	(*(char))->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
thisGname	*(char)
)	O
;	O
if	O
(	O
!	O
grent	*(struct(*(char),*(char),int,*(*(char))))
)	O
{	O
endgrent	()->(void)
(	O
)	O
;	O
grent	*(struct(*(char),*(char),int,*(*(char))))
=	O
getgrnam	(*(char))->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
thisGname	*(char)
)	O
;	O
if	O
(	O
!	O
grent	*(struct(*(char),*(char),int,*(*(char))))
)	O
return	O
-	O
1	int
;	O
}	O
lastGid	int
=	O
grent	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_gid	int
;	O
}	O
*	O
gid	int
=	O
lastGid	int
;	O
return	O
0	int
;	O
}	O
char	O
*	O
uidToUname	(int)->(*(char))
(	O
uid_t	int
uid	int
)	O
{	O
static	O
int	O
lastUid	int
=	O
-	O
1	int
;	O
static	O
char	O
*	O
lastUname	*(char)
=	O
NULL	O
;	O
static	O
int	O
lastUnameLen	int
=	O
0	int
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pwent	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
int	O
len	int
;	O
if	O
(	O
uid	int
==	O
(	O
uid_t	int
)	O
-	O
1	int
)	O
{	O
lastUid	int
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
else	O
if	O
(	O
!	O
uid	int
)	O
{	O
return	O
"root"	*(char)
;	O
}	O
else	O
if	O
(	O
uid	int
==	O
lastUid	int
)	O
{	O
return	O
lastUname	*(char)
;	O
}	O
else	O
{	O
pwent	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
uid	int
)	O
;	O
if	O
(	O
!	O
pwent	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
return	O
NULL	O
;	O
lastUid	int
=	O
uid	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
pwent	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
)	O
;	O
if	O
(	O
lastUnameLen	int
<	O
len	int
+	O
1	int
)	O
{	O
lastUnameLen	int
=	O
len	int
+	O
20	int
;	O
lastUname	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
lastUname	*(char)
,	O
lastUnameLen	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
lastUname	*(char)
,	O
pwent	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
)	O
;	O
return	O
lastUname	*(char)
;	O
}	O
}	O
char	O
*	O
gidToGname	(int)->(*(char))
(	O
gid_t	int
gid	int
)	O
{	O
static	O
int	O
lastGid	int
=	O
-	O
1	int
;	O
static	O
char	O
*	O
lastGname	*(char)
=	O
NULL	O
;	O
static	O
int	O
lastGnameLen	int
=	O
0	int
;	O
struct	O
group	struct(*(char),*(char),int,*(*(char)))
*	O
grent	*(struct(*(char),*(char),int,*(*(char))))
;	O
int	O
len	int
;	O
if	O
(	O
gid	int
==	O
(	O
gid_t	int
)	O
-	O
1	int
)	O
{	O
lastGid	int
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
else	O
if	O
(	O
!	O
gid	int
)	O
{	O
return	O
"root"	*(char)
;	O
}	O
else	O
if	O
(	O
gid	int
==	O
lastGid	int
)	O
{	O
return	O
lastGname	*(char)
;	O
}	O
else	O
{	O
grent	*(struct(*(char),*(char),int,*(*(char))))
=	O
getgrgid	(int)->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
gid	int
)	O
;	O
if	O
(	O
!	O
grent	*(struct(*(char),*(char),int,*(*(char))))
)	O
return	O
NULL	O
;	O
lastGid	int
=	O
gid	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
grent	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_name	*(char)
)	O
;	O
if	O
(	O
lastGnameLen	int
<	O
len	int
+	O
1	int
)	O
{	O
lastGnameLen	int
=	O
len	int
+	O
20	int
;	O
lastGname	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
lastGname	*(char)
,	O
lastGnameLen	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
lastGname	*(char)
,	O
grent	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_name	*(char)
)	O
;	O
return	O
lastGname	*(char)
;	O
}	O
}	O
int	O
makeTempFile	(*(char),*(*(char)),*(*(struct)))->(int)
(	O
const	O
char	O
*	O
prefix	*(char)
,	O
const	O
char	O
*	O
*	O
fnptr	*(*(char))
,	O
FD_t	*(struct)
*	O
fdptr	*(*(struct))
)	O
{	O
const	O
char	O
*	O
tempfn	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
tfn	*(char)
=	O
NULL	O
;	O
int	O
temput	int
;	O
FD_t	*(struct)
fd	*(struct)
=	O
NULL	O
;	O
int	O
ran	int
;	O
if	O
(	O
!	O
prefix	*(char)
)	O
prefix	*(char)
=	O
""	*(char)
;	O
srand	(int)->(void)
(	O
time	struct(long,long)
(	O
NULL	O
)	O
)	O
;	O
ran	int
=	O
rand	()->(int)
(	O
)	O
%	O
100000	int
;	O
do	O
{	O
char	O
tfnbuf	array(char)
[	O
64	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
tfnbuf	array(char)
,	O
"rpm-tmp.%d"	*(char)
,	O
ran	int
++	O
)	O
;	O
if	O
(	O
tempfn	*(char)
)	O
xfree	O
(	O
tempfn	*(char)
)	O
;	O
tempfn	*(char)
=	O
rpmGenPath	(*(char),*(char),*(char))->(*(char))
(	O
prefix	*(char)
,	O
"%{_tmppath}/"	*(char)
,	O
tfnbuf	array(char)
)	O
;	O
temput	int
=	O
urlPath	(*(char),*(*(char)))->(int)
(	O
tempfn	*(char)
,	O
&	O
tfn	*(char)
)	O
;	O
if	O
(	O
*	O
tfn	*(char)
==	O
'\0'	O
)	O
goto	O
errxit	O
;	O
switch	O
(	O
temput	int
)	O
{	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_DASH	int
:	O
goto	O
errxit	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
fd	*(struct)
=	O
Fopen	(*(char),*(char))->(*(struct))
(	O
tempfn	*(char)
,	O
"w+x.ufdio"	*(char)
)	O
;	O
}	O
while	O
(	O
(	O
fd	*(struct)
==	O
NULL	O
||	O
Ferror	(*(struct))->(int)
(	O
fd	*(struct)
)	O
)	O
&&	O
errno	O
==	O
EEXIST	int
)	O
;	O
if	O
(	O
fd	*(struct)
==	O
NULL	O
||	O
Ferror	(*(struct))->(int)
(	O
fd	*(struct)
)	O
)	O
goto	O
errxit	O
;	O
switch	O
(	O
temput	int
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
sb2	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
case	O
URL_IS_PATH	int
:	O
case	O
URL_IS_UNKNOWN	int
:	O
if	O
(	O
!	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
tfn	*(char)
,	O
&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
&&	O
S_ISLNK	O
(	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SCRIPT	O
,	O
_	O
(	O
"error creating temporary file %s"	*(char)
)	O
,	O
tfn	*(char)
)	O
;	O
goto	O
errxit	O
;	O
}	O
if	O
(	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_nlink	long
!=	O
1	int
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SCRIPT	O
,	O
_	O
(	O
"error creating temporary file %s"	*(char)
)	O
,	O
tfn	*(char)
)	O
;	O
goto	O
errxit	O
;	O
}	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
Fileno	(*(struct))->(int)
(	O
fd	*(struct)
)	O
,	O
&	O
sb2	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
{	O
if	O
(	O
sb2	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
!=	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
||	O
sb2	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
!=	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SCRIPT	O
,	O
_	O
(	O
"error creating temporary file %s"	*(char)
)	O
,	O
tfn	*(char)
)	O
;	O
goto	O
errxit	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
fnptr	*(*(char))
)	O
*	O
fnptr	*(*(char))
=	O
tempfn	*(char)
;	O
else	O
if	O
(	O
tempfn	*(char)
)	O
{	O
xfree	O
(	O
tempfn	*(char)
)	O
;	O
tempfn	*(char)
=	O
NULL	O
;	O
}	O
*	O
fdptr	*(*(struct))
=	O
fd	*(struct)
;	O
return	O
0	int
;	O
errxit	O
:	O
if	O
(	O
tempfn	*(char)
)	O
xfree	O
(	O
tempfn	*(char)
)	O
;	O
if	O
(	O
fd	*(struct)
)	O
Fclose	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
char	O
*	O
currentDirectory	()->(*(char))
(	O
void	O
)	O
{	O
int	O
currDirLen	int
;	O
char	O
*	O
currDir	*(char)
;	O
currDirLen	int
=	O
50	int
;	O
currDir	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
currDirLen	int
)	O
;	O
while	O
(	O
!	O
getcwd	(*(char),long)->(*(char))
(	O
currDir	*(char)
,	O
currDirLen	int
)	O
&&	O
errno	O
==	O
ERANGE	int
)	O
{	O
currDirLen	int
+=	O
50	int
;	O
currDir	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
currDir	*(char)
,	O
currDirLen	int
)	O
;	O
}	O
return	O
currDir	*(char)
;	O
}	O
int	O
_noDirTokens	int
=	O
1	int
;	O
static	O
int	O
dncmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(char)
,	O
const	O
void	O
*	O
b	*(char)
)	O
{	O
const	O
char	O
*	O
const	O
*	O
first	*(struct)
=	O
a	*(char)
;	O
const	O
char	O
*	O
const	O
*	O
second	*(struct)
=	O
b	*(char)
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
first	*(struct)
,	O
*	O
second	*(struct)
)	O
;	O
}	O
void	O
compressFilelist	(*(struct))->(void)
(	O
Header	*(struct)
h	*(struct)
)	O
{	O
char	O
*	O
*	O
fileNames	*(*(char))
;	O
const	O
char	O
*	O
*	O
dirNames	*(*(char))
;	O
const	O
char	O
*	O
*	O
baseNames	*(*(char))
;	O
int_32	int
*	O
dirIndexes	*(int)
;	O
int	O
count	long
;	O
int	O
i	int
;	O
int	O
dirIndex	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
RPMTAG_OLDFILENAMES	int
,	O
NULL	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
fileNames	*(*(char))
,	O
&	O
count	long
)	O
)	O
return	O
;	O
dirNames	*(*(char))
=	O
alloca	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
dirNames	*(*(char))
)	O
*	O
count	long
)	O
;	O
baseNames	*(*(char))
=	O
alloca	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
dirNames	*(*(char))
)	O
*	O
count	long
)	O
;	O
dirIndexes	*(int)
=	O
alloca	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
dirIndexes	*(int)
)	O
*	O
count	long
)	O
;	O
if	O
(	O
fileNames	*(*(char))
[	O
0	int
]	O
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
dirIndex	int
=	O
0	int
;	O
dirNames	*(*(char))
[	O
dirIndex	int
]	O
=	O
""	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
dirIndexes	*(int)
[	O
i	int
]	O
=	O
dirIndex	int
;	O
baseNames	*(*(char))
[	O
i	int
]	O
=	O
fileNames	*(*(char))
[	O
i	int
]	O
;	O
}	O
goto	O
exit	(int)->(void)
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
const	O
char	O
*	O
*	O
needle	*(*(char))
;	O
char	O
*	O
baseName	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
fileNames	*(*(char))
[	O
i	int
]	O
,	O
'/'	O
)	O
+	O
1	int
;	O
char	O
savechar	char
;	O
int	O
len	int
=	O
baseName	*(char)
-	O
fileNames	*(*(char))
[	O
i	int
]	O
;	O
savechar	char
=	O
*	O
baseName	*(char)
;	O
*	O
baseName	*(char)
=	O
'\0'	O
;	O
if	O
(	O
dirIndex	int
<	O
0	int
||	O
(	O
needle	*(*(char))
=	O
bsearch	(*(void),*(void),long,long,*((*(void),*(void))->(int)))->(*(void))
(	O
&	O
fileNames	*(*(char))
[	O
i	int
]	O
,	O
dirNames	*(*(char))
,	O
dirIndex	int
+	O
1	int
,	O
sizeof	O
(	O
dirNames	*(*(char))
[	O
0	int
]	O
)	O
,	O
dncmp	(*(void),*(void))->(int)
)	O
)	O
==	O
NULL	O
)	O
{	O
char	O
*	O
s	*(char)
=	O
alloca	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
s	*(char)
,	O
fileNames	*(*(char))
[	O
i	int
]	O
,	O
len	int
+	O
1	int
)	O
;	O
s	*(char)
[	O
len	int
]	O
=	O
'\0'	O
;	O
dirIndexes	*(int)
[	O
i	int
]	O
=	O
++	O
dirIndex	int
;	O
dirNames	*(*(char))
[	O
dirIndex	int
]	O
=	O
s	*(char)
;	O
}	O
else	O
dirIndexes	*(int)
[	O
i	int
]	O
=	O
needle	*(*(char))
-	O
dirNames	*(*(char))
;	O
*	O
baseName	*(char)
=	O
savechar	char
;	O
baseNames	*(*(char))
[	O
i	int
]	O
=	O
baseName	*(char)
;	O
}	O
exit	(int)->(void)
:	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
h	*(struct)
,	O
RPMTAG_DIRNAMES	int
,	O
RPM_STRING_ARRAY_TYPE	int
,	O
dirNames	*(*(char))
,	O
dirIndex	int
+	O
1	int
)	O
;	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
h	*(struct)
,	O
RPMTAG_DIRINDEXES	int
,	O
RPM_INT32_TYPE	int
,	O
dirIndexes	*(int)
,	O
count	long
)	O
;	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
h	*(struct)
,	O
RPMTAG_BASENAMES	int
,	O
RPM_STRING_ARRAY_TYPE	int
,	O
baseNames	*(*(char))
,	O
count	long
)	O
;	O
xfree	O
(	O
fileNames	*(*(char))
)	O
;	O
headerRemoveEntry	(*(struct),int)->(int)
(	O
h	*(struct)
,	O
RPMTAG_OLDFILENAMES	int
)	O
;	O
}	O
static	O
void	O
doBuildFileList	(*(struct),*(*(*(char))),*(int),int,int,int)->(void)
(	O
Header	*(struct)
h	*(struct)
,	O
const	O
char	O
*	O
*	O
*	O
fileListPtr	*(*(*(char)))
,	O
int	O
*	O
fileCountPtr	*(int)
,	O
int	O
baseNameTag	int
,	O
int	O
dirNameTag	int
,	O
int	O
dirIndexesTag	int
)	O
{	O
const	O
char	O
*	O
*	O
baseNames	*(*(char))
;	O
const	O
char	O
*	O
*	O
dirNames	*(*(char))
;	O
int	O
*	O
dirIndexes	*(int)
;	O
int	O
count	long
;	O
const	O
char	O
*	O
*	O
fileNames	*(*(char))
;	O
int	O
size	long
;	O
char	O
*	O
data	*(void)
;	O
int	O
i	int
;	O
if	O
(	O
!	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
baseNameTag	int
,	O
NULL	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
baseNames	*(*(char))
,	O
&	O
count	long
)	O
)	O
{	O
*	O
fileListPtr	*(*(*(char)))
=	O
NULL	O
;	O
*	O
fileCountPtr	*(int)
=	O
0	int
;	O
return	O
;	O
}	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
dirNameTag	int
,	O
NULL	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
dirNames	*(*(char))
,	O
NULL	O
)	O
;	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
dirIndexesTag	int
,	O
NULL	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
dirIndexes	*(int)
,	O
&	O
count	long
)	O
;	O
size	long
=	O
sizeof	O
(	O
*	O
fileNames	*(*(char))
)	O
*	O
count	long
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
size	long
+=	O
strlen	(*(char))->(long)
(	O
baseNames	*(*(char))
[	O
i	int
]	O
)	O
+	O
strlen	(*(char))->(long)
(	O
dirNames	*(*(char))
[	O
dirIndexes	*(int)
[	O
i	int
]	O
]	O
)	O
+	O
1	int
;	O
fileNames	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
size	long
)	O
;	O
data	*(void)
=	O
(	O
(	O
char	O
*	O
)	O
fileNames	*(*(char))
)	O
+	O
(	O
sizeof	O
(	O
*	O
fileNames	*(*(char))
)	O
*	O
count	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
fileNames	*(*(char))
[	O
i	int
]	O
=	O
data	*(void)
;	O
data	*(void)
=	O
rpm_stpcpy	(*(char),*(char))->(*(char))
(	O
rpm_stpcpy	(*(char),*(char))->(*(char))
(	O
data	*(void)
,	O
dirNames	*(*(char))
[	O
dirIndexes	*(int)
[	O
i	int
]	O
]	O
)	O
,	O
baseNames	*(*(char))
[	O
i	int
]	O
)	O
;	O
*	O
data	*(void)
++	O
=	O
'\0'	O
;	O
}	O
xfree	O
(	O
baseNames	*(*(char))
)	O
;	O
xfree	O
(	O
dirNames	*(*(char))
)	O
;	O
*	O
fileListPtr	*(*(*(char)))
=	O
fileNames	*(*(char))
;	O
*	O
fileCountPtr	*(int)
=	O
count	long
;	O
}	O
void	O
expandFilelist	(*(struct))->(void)
(	O
Header	*(struct)
h	*(struct)
)	O
{	O
const	O
char	O
*	O
*	O
fileNames	*(*(char))
=	O
NULL	O
;	O
int	O
count	long
=	O
0	int
;	O
doBuildFileList	(*(struct),*(*(*(char))),*(int),int,int,int)->(void)
(	O
h	*(struct)
,	O
&	O
fileNames	*(*(char))
,	O
&	O
count	long
,	O
RPMTAG_BASENAMES	int
,	O
RPMTAG_DIRNAMES	int
,	O
RPMTAG_DIRINDEXES	int
)	O
;	O
if	O
(	O
fileNames	*(*(char))
==	O
NULL	O
||	O
count	long
<=	O
0	int
)	O
return	O
;	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
h	*(struct)
,	O
RPMTAG_OLDFILENAMES	int
,	O
RPM_STRING_ARRAY_TYPE	int
,	O
fileNames	*(*(char))
,	O
count	long
)	O
;	O
xfree	O
(	O
fileNames	*(*(char))
)	O
;	O
headerRemoveEntry	(*(struct),int)->(int)
(	O
h	*(struct)
,	O
RPMTAG_BASENAMES	int
)	O
;	O
headerRemoveEntry	(*(struct),int)->(int)
(	O
h	*(struct)
,	O
RPMTAG_DIRNAMES	int
)	O
;	O
headerRemoveEntry	(*(struct),int)->(int)
(	O
h	*(struct)
,	O
RPMTAG_DIRINDEXES	int
)	O
;	O
}	O
void	O
rpmBuildFileList	(*(struct),*(*(*(char))),*(int))->(void)
(	O
Header	*(struct)
h	*(struct)
,	O
const	O
char	O
*	O
*	O
*	O
fileListPtr	*(*(*(char)))
,	O
int	O
*	O
fileCountPtr	*(int)
)	O
{	O
doBuildFileList	(*(struct),*(*(*(char))),*(int),int,int,int)->(void)
(	O
h	*(struct)
,	O
fileListPtr	*(*(*(char)))
,	O
fileCountPtr	*(int)
,	O
RPMTAG_BASENAMES	int
,	O
RPMTAG_DIRNAMES	int
,	O
RPMTAG_DIRINDEXES	int
)	O
;	O
}	O
void	O
buildOrigFileList	(*(struct),*(*(*(char))),*(int))->(void)
(	O
Header	*(struct)
h	*(struct)
,	O
const	O
char	O
*	O
*	O
*	O
fileListPtr	*(*(*(char)))
,	O
int	O
*	O
fileCountPtr	*(int)
)	O
{	O
doBuildFileList	(*(struct),*(*(*(char))),*(int),int,int,int)->(void)
(	O
h	*(struct)
,	O
fileListPtr	*(*(*(char)))
,	O
fileCountPtr	*(int)
,	O
RPMTAG_ORIGBASENAMES	int
,	O
RPMTAG_ORIGDIRNAMES	int
,	O
RPMTAG_ORIGDIRINDEXES	int
)	O
;	O
}	O
int	O
myGlobPatternP	(*(char))->(int)
(	O
const	O
char	O
*	O
patternURL	*(char)
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
char	O
c	int
;	O
int	O
open	(*(char),int)->(int)
=	O
0	int
;	O
(	O
void	O
)	O
urlPath	(*(char),*(*(char)))->(int)
(	O
patternURL	*(char)
,	O
&	O
p	*(void)
)	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
p	*(void)
++	O
)	O
!=	O
'\0'	O
)	O
switch	O
(	O
c	int
)	O
{	O
case	O
'?'	O
:	O
case	O
'*'	O
:	O
return	O
(	O
1	int
)	O
;	O
case	O
'['	O
:	O
open	(*(char),int)->(int)
++	O
;	O
continue	O
;	O
case	O
']'	O
:	O
if	O
(	O
open	(*(char),int)->(int)
)	O
return	O
(	O
1	int
)	O
;	O
continue	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
*	O
p	*(void)
++	O
==	O
'\0'	O
)	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
glob_error	(*(char),int)->(int)
(	O
const	O
char	O
*	O
foo	*(char)
,	O
int	O
bar	int
)	O
{	O
return	O
1	int
;	O
}	O
int	O
rpmGlob	(*(char),*(int),*(*(*(char))))->(int)
(	O
const	O
char	O
*	O
patterns	*(char)
,	O
int	O
*	O
argcPtr	*(int)
,	O
const	O
char	O
*	O
*	O
*	O
argvPtr	*(*(*(char)))
)	O
{	O
int	O
ac	int
=	O
0	int
;	O
const	O
char	O
*	O
*	O
av	*(*(char))
=	O
NULL	O
;	O
int	O
argc	int
=	O
0	int
;	O
const	O
char	O
*	O
*	O
argv	*(*(char))
=	O
NULL	O
;	O
const	O
char	O
*	O
path	*(char)
;	O
const	O
char	O
*	O
globURL	*(char)
;	O
char	O
*	O
globRoot	*(char)
=	O
NULL	O
;	O
size_t	long
maxb	long
,	O
nb	long
;	O
glob_t	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
;	O
int	O
ut	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
rc	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"fatal error in (rpm)misc.c:%d\n"	*(char)
,	O
__LINE__	O
)	O
;	O
exit	(int)->(void)
(	O
223	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ac	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
!	O
myGlobPatternP	(*(char))->(int)
(	O
av	*(*(char))
[	O
j	int
]	O
)	O
)	O
{	O
if	O
(	O
argc	int
==	O
0	int
)	O
argv	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
(	O
argc	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
*	O
argv	*(*(char))
)	O
)	O
;	O
else	O
argv	*(*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
argv	*(*(char))
,	O
(	O
argc	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
*	O
argv	*(*(char))
)	O
)	O
;	O
if	O
(	O
_debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** rpmGlob argv[%d] \"%s\"\n"	*(char)
,	O
argc	int
,	O
av	*(*(char))
[	O
j	int
]	O
)	O
;	O
argv	*(*(char))
[	O
argc	int
++	O
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
av	*(*(char))
[	O
j	int
]	O
)	O
;	O
continue	O
;	O
}	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathc	long
=	O
0	int
;	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathv	*(*(char))
=	O
NULL	O
;	O
rc	int
=	O
Glob	(*(char),int,(*(char),int)->(int),*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
av	*(*(char))
[	O
j	int
]	O
,	O
0	int
,	O
glob_error	(*(char),int)->(int)
,	O
&	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
;	O
if	O
(	O
rc	int
)	O
goto	O
exit	(int)->(void)
;	O
maxb	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathc	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
nb	long
=	O
strlen	(*(char))->(long)
(	O
&	O
(	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathv	*(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
)	O
)	O
)	O
>	O
maxb	long
)	O
maxb	long
=	O
nb	long
;	O
}	O
ut	int
=	O
urlPath	(*(char),*(*(char)))->(int)
(	O
av	*(*(char))
[	O
j	int
]	O
,	O
&	O
path	*(char)
)	O
;	O
nb	long
=	O
(	O
(	O
ut	int
>	O
URL_IS_DASH	int
)	O
?	O
(	O
path	*(char)
-	O
av	*(*(char))
[	O
j	int
]	O
)	O
:	O
0	int
)	O
;	O
maxb	long
+=	O
nb	long
;	O
maxb	long
+=	O
1	int
;	O
globURL	*(char)
=	O
globRoot	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
maxb	long
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_PATH	int
:	O
case	O
URL_IS_DASH	int
:	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
globRoot	*(char)
,	O
av	*(*(char))
[	O
j	int
]	O
,	O
nb	long
)	O
;	O
break	O
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
}	O
globRoot	*(char)
+=	O
nb	long
;	O
*	O
globRoot	*(char)
=	O
'\0'	O
;	O
if	O
(	O
_debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** GLOB maxb %d diskURL %d %*s globURL %p %s\n"	*(char)
,	O
maxb	long
,	O
nb	long
,	O
nb	long
,	O
av	*(*(char))
[	O
j	int
]	O
,	O
globURL	*(char)
,	O
globURL	*(char)
)	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
argv	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
(	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathc	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
argv	*(*(char))
)	O
)	O
;	O
else	O
if	O
(	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathc	long
>	O
0	int
)	O
argv	*(*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
argv	*(*(char))
,	O
(	O
argc	int
+	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathc	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
argv	*(*(char))
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathc	long
;	O
i	int
++	O
)	O
{	O
const	O
char	O
*	O
globFile	*(char)
=	O
&	O
(	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathv	*(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
globRoot	*(char)
>	O
globURL	*(char)
&&	O
globRoot	*(char)
[	O
-	O
1	int
]	O
==	O
'/'	O
)	O
while	O
(	O
*	O
globFile	*(char)
==	O
'/'	O
)	O
globFile	*(char)
++	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
globRoot	*(char)
,	O
globFile	*(char)
)	O
;	O
if	O
(	O
_debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** rpmGlob argv[%d] \"%s\"\n"	*(char)
,	O
argc	int
,	O
globURL	*(char)
)	O
;	O
argv	*(*(char))
[	O
argc	int
++	O
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
globURL	*(char)
)	O
;	O
}	O
Globfree	(*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(void)
(	O
&	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
;	O
xfree	O
(	O
globURL	*(char)
)	O
;	O
}	O
argv	*(*(char))
[	O
argc	int
]	O
=	O
NULL	O
;	O
if	O
(	O
argvPtr	*(*(*(char)))
)	O
*	O
argvPtr	*(*(*(char)))
=	O
argv	*(*(char))
;	O
if	O
(	O
argcPtr	*(int)
)	O
*	O
argcPtr	*(int)
=	O
argc	int
;	O
rc	int
=	O
0	int
;	O
exit	(int)->(void)
:	O
if	O
(	O
av	*(*(char))
)	O
xfree	O
(	O
av	*(*(char))
)	O
;	O
if	O
(	O
(	O
rc	int
||	O
argvPtr	*(*(*(char)))
==	O
NULL	O
)	O
&&	O
argv	*(*(char))
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
xfree	O
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
xfree	O
(	O
argv	*(*(char))
)	O
;	O
argv	*(*(char))
=	O
NULL	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
rpmHeaderGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
,	O
int_32	int
*	O
type	enum(int,int,int,int)
,	O
void	O
*	O
*	O
p	*(void)
,	O
int_32	int
*	O
c	int
)	O
{	O
switch	O
(	O
tag	int
)	O
{	O
case	O
RPMTAG_OLDFILENAMES	int
:	O
{	O
const	O
char	O
*	O
*	O
fl	*(*(char))
=	O
NULL	O
;	O
int	O
count	long
;	O
rpmBuildFileList	(*(struct),*(*(*(char))),*(int))->(void)
(	O
h	*(struct)
,	O
&	O
fl	*(*(char))
,	O
&	O
count	long
)	O
;	O
if	O
(	O
count	long
>	O
0	int
)	O
{	O
*	O
p	*(void)
=	O
fl	*(*(char))
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
count	long
;	O
return	O
1	int
;	O
}	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
break	O
;	O
case	O
RPMTAG_GROUP	int
:	O
case	O
RPMTAG_DESCRIPTION	int
:	O
case	O
RPMTAG_SUMMARY	int
:	O
{	O
char	O
fmt	*(char)
[	O
128	int
]	O
;	O
const	O
char	O
*	O
msgstr	*(char)
;	O
const	O
char	O
*	O
errstr	*(char)
;	O
fmt	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
(	O
void	O
)	O
rpm_stpcpy	(*(char),*(char))->(*(char))
(	O
rpm_stpcpy	(*(char),*(char))->(*(char))
(	O
rpm_stpcpy	(*(char),*(char))->(*(char))
(	O
fmt	*(char)
,	O
"%{"	*(char)
)	O
,	O
tagName	(int)->(*(char))
(	O
tag	int
)	O
)	O
,	O
"}\n"	*(char)
)	O
;	O
msgstr	*(char)
=	O
headerSprintf	(*(struct),*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(char)))->(*(char))
(	O
h	*(struct)
,	O
fmt	*(char)
,	O
rpmTagTable	array(struct(*(char),int))
,	O
rpmHeaderFormats	array(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*`,*`,*`,*`))))))
,	O
&	O
errstr	*(char)
)	O
;	O
if	O
(	O
msgstr	*(char)
)	O
{	O
*	O
p	*(void)
=	O
(	O
void	O
*	O
)	O
msgstr	*(char)
;	O
if	O
(	O
type	enum(int,int,int,int)
)	O
*	O
type	enum(int,int,int,int)
=	O
RPM_STRING_TYPE	int
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
}	O
break	O
;	O
default	O
:	O
return	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
tag	int
,	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
)	O
;	O
break	O
;	O
}	O
}	O
