void	O
SetParms	O
(	O
long	O
cParms	O
,	O
HVAR	long
*	O
rghvar	O
,	O
double	O
*	O
rgdParm	O
)	O
{	O
long	O
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
cParms	O
;	O
i	O
++	O
)	O
SetVar	(long,double)->(int)
(	O
rghvar	O
[	O
i	O
]	O
,	O
rgdParm	O
[	O
i	O
]	O
)	O
;	O
}	O
void	O
SetParmsLog	O
(	O
long	O
cParms	O
,	O
HVAR	long
*	O
rghvar	O
,	O
double	O
*	O
rgdParm	O
)	O
{	O
long	O
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
cParms	O
;	O
i	O
++	O
)	O
SetVar	(long,double)->(int)
(	O
rghvar	O
[	O
i	O
]	O
,	O
log	(double)->(double)
(	O
rgdParm	O
[	O
i	O
]	O
)	O
)	O
;	O
}	O
void	O
SetParmsExp	O
(	O
long	O
cParms	O
,	O
HVAR	long
*	O
rghvar	O
,	O
double	O
*	O
rgdParm	O
)	O
{	O
long	O
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
cParms	O
;	O
i	O
++	O
)	O
SetVar	(long,double)->(int)
(	O
rghvar	O
[	O
i	O
]	O
,	O
exp	(double)->(double)
(	O
rgdParm	O
[	O
i	O
]	O
)	O
)	O
;	O
}	O
int	O
CalculateOneMCParm	O
(	O
PMCVAR	O
pMCVar	O
)	O
{	O
double	O
dParm1	O
,	O
dParm2	O
,	O
dMin	O
,	O
dMax	O
;	O
dParm1	O
=	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
0	int
]	O
)	O
;	O
dParm2	O
=	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
1	int
]	O
)	O
;	O
dMin	O
=	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
2	int
]	O
)	O
;	O
dMax	O
=	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
3	int
]	O
)	O
;	O
switch	O
(	O
pMCVar	O
->	O
iType	int
)	O
{	O
default	O
:	O
case	O
MCV_UNIFORM	O
:	O
pMCVar	O
->	O
dVal	double
=	O
UniformRandom	(double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
)	O
;	O
break	O
;	O
case	O
MCV_LOGUNIFORM	O
:	O
pMCVar	O
->	O
dVal	double
=	O
LogUniformRandom	(double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
)	O
;	O
break	O
;	O
case	O
MCV_BETA	O
:	O
pMCVar	O
->	O
dVal	double
=	O
BetaRandom	(double,double,double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
,	O
dMin	O
,	O
dMax	O
)	O
;	O
break	O
;	O
case	O
MCV_HALFNORMAL	O
:	O
pMCVar	O
->	O
dVal	double
=	O
fabs	(double)->(double)
(	O
NormalRandom	(double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
)	O
)	O
;	O
break	O
;	O
case	O
MCV_NORMAL	O
:	O
pMCVar	O
->	O
dVal	double
=	O
NormalRandom	(double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
)	O
;	O
break	O
;	O
case	O
MCV_NORMALCV	O
:	O
pMCVar	O
->	O
dVal	double
=	O
NormalRandom	(double,double)->(double)
(	O
dParm1	O
,	O
fabs	(double)->(double)
(	O
dParm1	O
*	O
dParm2	O
)	O
)	O
;	O
break	O
;	O
case	O
MCV_NORMALV	O
:	O
pMCVar	O
->	O
dVal	double
=	O
NormalRandom	(double,double)->(double)
(	O
dParm1	O
,	O
sqrt	(double)->(double)
(	O
dParm2	O
)	O
)	O
;	O
break	O
;	O
case	O
MCV_TRUNCNORMAL	O
:	O
pMCVar	O
->	O
dVal	double
=	O
TruncNormalRandom	(double,double,double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
,	O
dMin	O
,	O
dMax	O
)	O
;	O
break	O
;	O
case	O
MCV_TRUNCNORMALCV	O
:	O
pMCVar	O
->	O
dVal	double
=	O
TruncNormalRandom	(double,double,double,double)->(double)
(	O
dParm1	O
,	O
fabs	(double)->(double)
(	O
dParm1	O
*	O
dParm2	O
)	O
,	O
dMin	O
,	O
dMax	O
)	O
;	O
break	O
;	O
case	O
MCV_TRUNCNORMALV	O
:	O
pMCVar	O
->	O
dVal	double
=	O
TruncNormalRandom	(double,double,double,double)->(double)
(	O
dParm1	O
,	O
sqrt	(double)->(double)
(	O
dParm2	O
)	O
,	O
dMin	O
,	O
dMax	O
)	O
;	O
break	O
;	O
case	O
MCV_LOGNORMAL	O
:	O
pMCVar	O
->	O
dVal	double
=	O
LogNormalRandom	(double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
)	O
;	O
break	O
;	O
case	O
MCV_TRUNCLOGNORMAL	O
:	O
pMCVar	O
->	O
dVal	double
=	O
TruncLogNormalRandom	(double,double,double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
,	O
dMin	O
,	O
dMax	O
)	O
;	O
break	O
;	O
case	O
MCV_LOGNORMALV	O
:	O
pMCVar	O
->	O
dVal	double
=	O
LogNormalRandom	(double,double)->(double)
(	O
dParm1	O
,	O
exp	(double)->(double)
(	O
sqrt	(double)->(double)
(	O
dParm2	O
)	O
)	O
)	O
;	O
break	O
;	O
case	O
MCV_TRUNCLOGNORMALV	O
:	O
pMCVar	O
->	O
dVal	double
=	O
TruncLogNormalRandom	(double,double,double,double)->(double)
(	O
dParm1	O
,	O
exp	(double)->(double)
(	O
sqrt	(double)->(double)
(	O
dParm2	O
)	O
)	O
,	O
dMin	O
,	O
dMax	O
)	O
;	O
break	O
;	O
case	O
MCV_CHI2	O
:	O
pMCVar	O
->	O
dVal	double
=	O
Chi2Random	(double)->(double)
(	O
dParm1	O
)	O
;	O
break	O
;	O
case	O
MCV_BINOMIAL	O
:	O
pMCVar	O
->	O
dVal	double
=	O
BinomialRandom	(double,long)->(double)
(	O
dParm1	O
,	O
(	O
long	O
)	O
dParm2	O
)	O
;	O
break	O
;	O
case	O
MCV_PIECEWISE	O
:	O
pMCVar	O
->	O
dVal	double
=	O
PiecewiseRandom	(double,double,double,double)->(double)
(	O
dMin	O
,	O
dParm1	O
,	O
dParm2	O
,	O
dMax	O
)	O
;	O
break	O
;	O
case	O
MCV_EXPONENTIAL	O
:	O
pMCVar	O
->	O
dVal	double
=	O
ExpRandom	(double)->(double)
(	O
dParm1	O
)	O
;	O
break	O
;	O
case	O
MCV_GGAMMA	O
:	O
pMCVar	O
->	O
dVal	double
=	O
GGammaRandom	(double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
)	O
;	O
break	O
;	O
case	O
MCV_INVGGAMMA	O
:	O
pMCVar	O
->	O
dVal	double
=	O
InvGGammaRandom	(double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
)	O
;	O
break	O
;	O
case	O
MCV_TRUNCINVGGAMMA	O
:	O
pMCVar	O
->	O
dVal	double
=	O
TruncInvGGammaRandom	(double,double,double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
,	O
dMin	O
,	O
dMax	O
)	O
;	O
break	O
;	O
case	O
MCV_POISSON	O
:	O
pMCVar	O
->	O
dVal	double
=	O
PoissonRandom	(double)->(long)
(	O
dParm1	O
)	O
;	O
break	O
;	O
case	O
MCV_BINOMIALBETA	O
:	O
pMCVar	O
->	O
dVal	double
=	O
BinomialBetaRandom	(double,double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
,	O
dMin	O
)	O
;	O
break	O
;	O
case	O
MCV_GENLOGNORMAL	O
:	O
pMCVar	O
->	O
dVal	double
=	O
GenLogNormalRandom	(double,double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
,	O
dMin	O
)	O
;	O
break	O
;	O
case	O
MCV_STUDENTT	O
:	O
pMCVar	O
->	O
dVal	double
=	O
StudentTRandom	(double,double,double)->(double)
(	O
dParm1	O
,	O
dParm2	O
,	O
dMin	O
)	O
;	O
break	O
;	O
case	O
MCV_CAUCHY	O
:	O
pMCVar	O
->	O
dVal	double
=	O
CauchyRandom	(double)->(double)
(	O
dParm1	O
)	O
;	O
break	O
;	O
case	O
MCV_HALFCAUCHY	O
:	O
pMCVar	O
->	O
dVal	double
=	O
fabs	(double)->(double)
(	O
CauchyRandom	(double)->(double)
(	O
dParm1	O
)	O
)	O
;	O
break	O
;	O
case	O
MCV_USERLL	O
:	O
ReportError	O
(	O
NULL	O
,	O
RE_BADCONTEXT	O
|	O
RE_FATAL	O
,	O
"UserSpecifiedLL"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
CalcMCParms	O
(	O
PMONTECARLO	O
pMC	O
,	O
double	O
rgParms	O
[	O
]	O
,	O
long	O
iStart	O
)	O
{	O
long	O
i	O
;	O
if	O
(	O
!	O
rgParms	O
)	O
rgParms	O
=	O
pMC	O
->	O
rgdParms	O
;	O
for	O
(	O
i	O
=	O
iStart	O
;	O
i	O
<	O
pMC	O
->	O
nParms	O
;	O
i	O
++	O
)	O
{	O
CalculateOneMCParm	O
(	O
pMC	O
->	O
rgpMCVar	O
[	O
i	O
]	O
)	O
;	O
rgParms	O
[	O
i	O
]	O
=	O
pMC	O
->	O
rgpMCVar	O
[	O
i	O
]	O
->	O
dVal	double
;	O
}	O
}	O
BOOL	int
InitSetPoints	O
(	O
PMONTECARLO	O
pMC	O
)	O
{	O
register	O
char	O
c	O
;	O
PFILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
pfile	O
;	O
if	O
(	O
!	O
(	O
pfile	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pMC	O
->	O
szSetPointsFilename	O
,	O
"r"	*(char)
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_CANNOTOPEN	O
|	O
RE_FATAL	O
,	O
pMC	O
->	O
szSetPointsFilename	O
,	O
NULL	O
)	O
;	O
pMC	O
->	O
pfileSetPoints	O
=	O
pfile	O
;	O
do	O
{	O
c	O
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pMC	O
->	O
pfileSetPoints	O
)	O
;	O
}	O
while	O
(	O
c	O
!=	O
'\n'	O
)	O
;	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pMC	O
->	O
pfileSetPoints	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_INSUF_POINTS	O
|	O
RE_FATAL	O
,	O
pMC	O
->	O
szSetPointsFilename	O
,	O
NULL	O
)	O
;	O
return	O
(	O
!	O
pfile	O
)	O
;	O
}	O
BOOL	int
ReadSetPoints	O
(	O
PMONTECARLO	O
pMC	O
,	O
double	O
rgParms	O
[	O
]	O
)	O
{	O
BOOL	int
bReturn	O
=	O
FALSE	O
;	O
register	O
char	O
c	O
;	O
long	O
i	O
;	O
if	O
(	O
!	O
rgParms	O
)	O
rgParms	O
=	O
pMC	O
->	O
rgdParms	O
;	O
do	O
{	O
c	O
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pMC	O
->	O
pfileSetPoints	O
)	O
;	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pMC	O
->	O
pfileSetPoints	O
)	O
)	O
goto	O
Exit_ReadSetPoints	O
;	O
}	O
while	O
(	O
(	O
c	O
!=	O
'\t'	O
)	O
&&	O
(	O
c	O
!=	O
' '	O
)	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
pMC	O
->	O
nSetParms	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pMC	O
->	O
pfileSetPoints	O
)	O
||	O
(	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pMC	O
->	O
pfileSetPoints	O
,	O
"%lg"	*(char)
,	O
&	O
pMC	O
->	O
rgpMCVar	O
[	O
i	O
]	O
->	O
dVal	double
)	O
==	O
EOF	O
)	O
)	O
{	O
if	O
(	O
pMC	O
->	O
nRuns	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_INSUF_POINTS	O
|	O
RE_FATAL	O
,	O
pMC	O
->	O
szSetPointsFilename	O
,	O
NULL	O
)	O
;	O
goto	O
Exit_ReadSetPoints	O
;	O
}	O
rgParms	O
[	O
i	O
]	O
=	O
pMC	O
->	O
rgpMCVar	O
[	O
i	O
]	O
->	O
dVal	double
;	O
}	O
bReturn	O
=	O
TRUE	O
;	O
do	O
{	O
c	O
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pMC	O
->	O
pfileSetPoints	O
)	O
;	O
}	O
while	O
(	O
(	O
c	O
!=	O
'\n'	O
)	O
&&	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pMC	O
->	O
pfileSetPoints	O
)	O
)	O
;	O
Exit_ReadSetPoints	O
:	O
;	O
return	O
(	O
bReturn	O
)	O
;	O
}	O
BOOL	int
GetSPMods	O
(	O
PANALYSIS	O
panal	O
,	O
double	O
rgParms	O
[	O
]	O
)	O
{	O
BOOL	int
bOK	O
;	O
bOK	O
=	O
ReadSetPoints	O
(	O
&	O
panal	O
->	O
mc	O
,	O
rgParms	O
)	O
;	O
CalcMCParms	O
(	O
&	O
panal	O
->	O
mc	O
,	O
rgParms	O
,	O
panal	O
->	O
mc	O
.	O
nSetParms	O
)	O
;	O
return	O
bOK	O
;	O
}	O
void	O
SetParents	O
(	O
PMONTECARLO	O
pMC	O
,	O
long	O
iStart	O
)	O
{	O
long	O
i	O
,	O
j	O
,	O
k	O
;	O
PMCVAR	O
pMCVar1	O
,	O
pMCVar2	O
;	O
BOOL	int
bFound	O
;	O
for	O
(	O
i	O
=	O
iStart	O
;	O
i	O
<	O
pMC	O
->	O
nParms	O
;	O
i	O
++	O
)	O
{	O
pMCVar1	O
=	O
pMC	O
->	O
rgpMCVar	O
[	O
i	O
]	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
4	int
;	O
j	O
++	O
)	O
{	O
if	O
(	O
pMCVar1	O
->	O
iParmType	O
[	O
j	O
]	O
==	O
MCVP_PARM	O
)	O
{	O
bFound	O
=	O
FALSE	O
;	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
i	O
;	O
k	O
++	O
)	O
{	O
pMCVar2	O
=	O
pMC	O
->	O
rgpMCVar	O
[	O
k	O
]	O
;	O
if	O
(	O
pMCVar1	O
->	O
hParm	O
[	O
j	O
]	O
==	O
pMCVar2	O
->	O
hvar	long
)	O
{	O
pMCVar1	O
->	O
pdParm	O
[	O
j	O
]	O
=	O
&	O
(	O
pMCVar2	O
->	O
dVal	double
)	O
;	O
bFound	O
=	O
TRUE	O
;	O
}	O
}	O
if	O
(	O
!	O
bFound	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
"Error: parents must be declared before childrens when\n"	*(char)
"       creating sampling dependencies - Exiting.\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
