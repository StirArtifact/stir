static	O
error_t	O
op_null	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_getattr	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
struct	O
stat	O
st	struct
;	O
error_t	O
err	O
;	O
err	O
=	O
io_stat	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
!	O
err	O
)	O
*	O
reply	*(*(int))
=	O
encode_fattr	()->(int)
(	O
*	O
reply	*(*(int))
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
complete_setattr	(int,*(int))->(int)
(	O
mach_port_t	O
port	int
,	O
int	O
*	O
p	*(int)
)	O
{	O
uid_t	O
uid	O
,	O
gid	O
;	O
off_t	O
size	O
;	O
time_value_t	O
atime	O
,	O
mtime	O
;	O
struct	O
stat	O
st	struct
;	O
error_t	O
err	O
;	O
err	O
=	O
io_stat	()->(int)
(	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
uid	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
gid	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
uid	O
==	O
-	O
1	int
)	O
uid	O
=	O
st	struct
.	O
st_uid	O
;	O
if	O
(	O
gid	O
==	O
-	O
1	int
)	O
gid	O
=	O
st	struct
.	O
st_gid	O
;	O
if	O
(	O
uid	O
!=	O
st	struct
.	O
st_uid	O
||	O
gid	O
!=	O
st	struct
.	O
st_gid	O
)	O
err	O
=	O
file_chown	()->(int)
(	O
port	int
,	O
uid	O
,	O
gid	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
size	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
size	O
!=	O
-	O
1	int
&&	O
size	O
!=	O
st	struct
.	O
st_size	O
)	O
err	O
=	O
file_set_size	()->(int)
(	O
port	int
,	O
size	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
atime	O
.	O
seconds	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
atime	O
.	O
microseconds	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
mtime	O
.	O
seconds	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
mtime	O
.	O
microseconds	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
atime	O
.	O
seconds	O
!=	O
-	O
1	int
&&	O
atime	O
.	O
microseconds	O
==	O
-	O
1	int
)	O
atime	O
.	O
microseconds	O
=	O
0	int
;	O
if	O
(	O
mtime	O
.	O
seconds	O
!=	O
-	O
1	int
&&	O
mtime	O
.	O
microseconds	O
==	O
-	O
1	int
)	O
mtime	O
.	O
microseconds	O
=	O
0	int
;	O
if	O
(	O
atime	O
.	O
seconds	O
==	O
-	O
1	int
)	O
atime	O
.	O
seconds	O
=	O
st	struct
.	O
st_atim	O
.	O
tv_sec	O
;	O
if	O
(	O
atime	O
.	O
microseconds	O
==	O
-	O
1	int
)	O
atime	O
.	O
microseconds	O
=	O
st	struct
.	O
st_atim	O
.	O
tv_nsec	O
/	O
1000	int
;	O
if	O
(	O
mtime	O
.	O
seconds	O
==	O
-	O
1	int
)	O
mtime	O
.	O
seconds	O
=	O
st	struct
.	O
st_mtim	O
.	O
tv_sec	O
;	O
if	O
(	O
mtime	O
.	O
microseconds	O
==	O
-	O
1	int
)	O
mtime	O
.	O
microseconds	O
=	O
st	struct
.	O
st_mtim	O
.	O
tv_nsec	O
/	O
1000	int
;	O
if	O
(	O
atime	O
.	O
seconds	O
!=	O
st	struct
.	O
st_atim	O
.	O
tv_sec	O
||	O
atime	O
.	O
microseconds	O
!=	O
st	struct
.	O
st_atim	O
.	O
tv_nsec	O
/	O
1000	int
||	O
mtime	O
.	O
seconds	O
!=	O
st	struct
.	O
st_mtim	O
.	O
tv_sec	O
||	O
mtime	O
.	O
microseconds	O
!=	O
st	struct
.	O
st_mtim	O
.	O
tv_nsec	O
/	O
1000	int
)	O
err	O
=	O
file_utimes	()->(int)
(	O
port	int
,	O
atime	O
,	O
mtime	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_setattr	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
mode_t	O
mode	O
;	O
struct	O
stat	O
st	struct
;	O
mode	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
mode	O
!=	O
-	O
1	int
)	O
err	O
=	O
file_chmod	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
mode	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
complete_setattr	(int,*(int))->(int)
(	O
c	*(struct)
->	O
port	int
,	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
io_stat	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
*	O
reply	*(*(int))
=	O
encode_fattr	()->(int)
(	O
*	O
reply	*(*(int))
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_lookup	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
error_t	O
err	O
;	O
char	O
*	O
name	*(char)
;	O
retry_type	O
do_retry	O
;	O
char	O
retry_name	array(char)
[	O
1024	int
]	O
;	O
mach_port_t	O
newport	O
;	O
struct	O
cache_handle	O
*	O
newc	*(struct)
;	O
struct	O
stat	O
st	struct
;	O
decode_name	()->(int)
(	O
p	*(int)
,	O
&	O
name	*(char)
)	O
;	O
err	O
=	O
dir_lookup	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
name	*(char)
,	O
O_NOTRANS	O
,	O
0	int
,	O
&	O
do_retry	O
,	O
retry_name	array(char)
,	O
&	O
newport	O
)	O
;	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
err	O
&&	O
(	O
do_retry	O
!=	O
FS_RETRY_NORMAL	O
||	O
retry_name	array(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
)	O
err	O
=	O
EACCES	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
io_stat	()->(int)
(	O
newport	O
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
newc	*(struct)
=	O
create_cached_handle	()->(int)
(	O
c	*(struct)
->	O
handle	O
.	O
fs	O
,	O
c	*(struct)
,	O
newport	O
)	O
;	O
if	O
(	O
!	O
newc	*(struct)
)	O
return	O
ESTALE	O
;	O
*	O
reply	*(*(int))
=	O
encode_fhandle	()->(int)
(	O
*	O
reply	*(*(int))
,	O
newc	*(struct)
->	O
handle	O
.	O
array	O
)	O
;	O
*	O
reply	*(*(int))
=	O
encode_fattr	()->(int)
(	O
*	O
reply	*(*(int))
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_readlink	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
char	O
buf	array(char)
[	O
2048	int
]	O
,	O
*	O
transp	*(char)
=	O
buf	array(char)
;	O
mach_msg_type_number_t	O
len	O
=	O
sizeof	O
(	O
buf	array(char)
)	O
;	O
error_t	O
err	O
;	O
err	O
=	O
file_get_translator	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
&	O
transp	*(char)
,	O
&	O
len	O
)	O
;	O
if	O
(	O
err	O
)	O
{	O
if	O
(	O
transp	*(char)
!=	O
buf	array(char)
)	O
munmap	()->(int)
(	O
transp	*(char)
,	O
len	O
)	O
;	O
return	O
err	O
;	O
}	O
if	O
(	O
len	O
<	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
||	O
memcmp	O
(	O
transp	*(char)
,	O
_HURD_SYMLINK	O
,	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
)	O
)	O
return	O
EINVAL	O
;	O
transp	*(char)
+=	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
;	O
*	O
reply	*(*(int))
=	O
encode_string	()->(int)
(	O
*	O
reply	*(*(int))
,	O
transp	*(char)
)	O
;	O
if	O
(	O
transp	*(char)
!=	O
buf	array(char)
)	O
munmap	()->(int)
(	O
transp	*(char)
,	O
len	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
size_t	O
count_read_buffersize	(*(int),int)->(int)
(	O
int	O
*	O
p	*(int)
,	O
int	O
version	int
)	O
{	O
p	*(int)
++	O
;	O
return	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
}	O
static	O
error_t	O
op_read	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
off_t	O
offset	O
;	O
size_t	O
count	int
;	O
char	O
buf	array(char)
[	O
2048	int
]	O
,	O
*	O
bp	*(char)
=	O
buf	array(char)
;	O
mach_msg_type_number_t	O
buflen	O
=	O
sizeof	O
(	O
buf	array(char)
)	O
;	O
struct	O
stat	O
st	struct
;	O
error_t	O
err	O
;	O
offset	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
count	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
err	O
=	O
io_read	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
&	O
bp	*(char)
,	O
&	O
buflen	O
,	O
offset	O
,	O
count	int
)	O
;	O
if	O
(	O
err	O
)	O
{	O
if	O
(	O
bp	*(char)
!=	O
buf	array(char)
)	O
munmap	()->(int)
(	O
bp	*(char)
,	O
buflen	O
)	O
;	O
return	O
err	O
;	O
}	O
err	O
=	O
io_stat	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
*	O
reply	*(*(int))
=	O
encode_fattr	()->(int)
(	O
*	O
reply	*(*(int))
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
*	O
reply	*(*(int))
=	O
encode_data	()->(int)
(	O
*	O
reply	*(*(int))
,	O
bp	*(char)
,	O
buflen	O
)	O
;	O
if	O
(	O
bp	*(char)
!=	O
buf	array(char)
)	O
munmap	()->(int)
(	O
bp	*(char)
,	O
buflen	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_write	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
off_t	O
offset	O
;	O
size_t	O
count	int
;	O
error_t	O
err	O
;	O
mach_msg_type_number_t	O
amt	O
;	O
char	O
*	O
bp	*(char)
;	O
struct	O
stat	O
st	struct
;	O
p	*(int)
++	O
;	O
offset	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
p	*(int)
++	O
;	O
count	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
bp	*(char)
=	O
(	O
char	O
*	O
)	O
*	O
reply	*(*(int))
;	O
while	O
(	O
count	int
)	O
{	O
err	O
=	O
io_write	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
bp	*(char)
,	O
count	int
,	O
offset	O
,	O
&	O
amt	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
if	O
(	O
amt	O
==	O
0	int
)	O
return	O
EIO	O
;	O
count	int
-=	O
amt	O
;	O
bp	*(char)
+=	O
amt	O
;	O
offset	O
+=	O
amt	O
;	O
}	O
file_sync	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
1	int
,	O
0	int
)	O
;	O
err	O
=	O
io_stat	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
*	O
reply	*(*(int))
=	O
encode_fattr	()->(int)
(	O
*	O
reply	*(*(int))
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_create	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
error_t	O
err	O
;	O
char	O
*	O
name	*(char)
;	O
retry_type	O
do_retry	O
;	O
char	O
retry_name	array(char)
[	O
1024	int
]	O
;	O
mach_port_t	O
newport	O
;	O
struct	O
cache_handle	O
*	O
newc	*(struct)
;	O
struct	O
stat	O
st	struct
;	O
mode_t	O
mode	O
;	O
int	O
statchanged	int
=	O
0	int
;	O
off_t	O
size	O
;	O
p	*(int)
=	O
decode_name	()->(int)
(	O
p	*(int)
,	O
&	O
name	*(char)
)	O
;	O
mode	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
err	O
=	O
dir_lookup	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
name	*(char)
,	O
O_NOTRANS	O
|	O
O_CREAT	O
|	O
O_TRUNC	O
,	O
mode	O
,	O
&	O
do_retry	O
,	O
retry_name	array(char)
,	O
&	O
newport	O
)	O
;	O
if	O
(	O
!	O
err	O
&&	O
(	O
do_retry	O
!=	O
FS_RETRY_NORMAL	O
||	O
retry_name	array(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
)	O
err	O
=	O
EACCES	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
io_stat	()->(int)
(	O
newport	O
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
errout	O
;	O
p	*(int)
++	O
,	O
p	*(int)
++	O
;	O
size	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
size	O
!=	O
-	O
1	int
&&	O
size	O
!=	O
st	struct
.	O
st_size	O
)	O
{	O
err	O
=	O
file_set_size	()->(int)
(	O
newport	O
,	O
size	O
)	O
;	O
statchanged	int
=	O
1	int
;	O
}	O
if	O
(	O
err	O
)	O
goto	O
errout	O
;	O
if	O
(	O
statchanged	int
)	O
err	O
=	O
io_stat	()->(int)
(	O
newport	O
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
{	O
errout	O
:	O
dir_unlink	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
name	*(char)
)	O
;	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
return	O
err	O
;	O
}	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
newc	*(struct)
=	O
create_cached_handle	()->(int)
(	O
c	*(struct)
->	O
handle	O
.	O
fs	O
,	O
c	*(struct)
,	O
newport	O
)	O
;	O
if	O
(	O
!	O
newc	*(struct)
)	O
return	O
ESTALE	O
;	O
*	O
reply	*(*(int))
=	O
encode_fhandle	()->(int)
(	O
*	O
reply	*(*(int))
,	O
newc	*(struct)
->	O
handle	O
.	O
array	O
)	O
;	O
*	O
reply	*(*(int))
=	O
encode_fattr	()->(int)
(	O
*	O
reply	*(*(int))
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_remove	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
error_t	O
err	O
;	O
char	O
*	O
name	*(char)
;	O
decode_name	()->(int)
(	O
p	*(int)
,	O
&	O
name	*(char)
)	O
;	O
err	O
=	O
dir_unlink	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
name	*(char)
)	O
;	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_rename	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
fromc	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
struct	O
cache_handle	O
*	O
toc	*(struct)
;	O
char	O
*	O
fromname	*(char)
,	O
*	O
toname	*(char)
;	O
error_t	O
err	O
=	O
0	int
;	O
p	*(int)
=	O
decode_name	()->(int)
(	O
p	*(int)
,	O
&	O
fromname	*(char)
)	O
;	O
p	*(int)
=	O
lookup_cache_handle	()->(int)
(	O
p	*(int)
,	O
&	O
toc	*(struct)
,	O
fromc	*(struct)
->	O
ids	O
)	O
;	O
decode_name	()->(int)
(	O
p	*(int)
,	O
&	O
toname	*(char)
)	O
;	O
if	O
(	O
!	O
toc	*(struct)
)	O
err	O
=	O
ESTALE	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
dir_rename	()->(int)
(	O
fromc	*(struct)
->	O
port	int
,	O
fromname	*(char)
,	O
toc	*(struct)
->	O
port	int
,	O
toname	*(char)
,	O
0	int
)	O
;	O
free	()->(int)
(	O
fromname	*(char)
)	O
;	O
free	()->(int)
(	O
toname	*(char)
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_link	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
filec	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
struct	O
cache_handle	O
*	O
dirc	*(struct)
;	O
char	O
*	O
name	*(char)
;	O
error_t	O
err	O
=	O
0	int
;	O
p	*(int)
=	O
lookup_cache_handle	()->(int)
(	O
p	*(int)
,	O
&	O
dirc	*(struct)
,	O
filec	*(struct)
->	O
ids	O
)	O
;	O
decode_name	()->(int)
(	O
p	*(int)
,	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
dirc	*(struct)
)	O
err	O
=	O
ESTALE	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
dir_link	()->(int)
(	O
dirc	*(struct)
->	O
port	int
,	O
filec	*(struct)
->	O
port	int
,	O
name	*(char)
,	O
1	int
)	O
;	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_symlink	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
char	O
*	O
name	*(char)
,	O
*	O
target	*(char)
;	O
error_t	O
err	O
;	O
mode_t	O
mode	O
;	O
file_t	O
newport	O
=	O
MACH_PORT_NULL	O
;	O
size_t	O
len	O
;	O
char	O
*	O
buf	array(char)
;	O
p	*(int)
=	O
decode_name	()->(int)
(	O
p	*(int)
,	O
&	O
name	*(char)
)	O
;	O
p	*(int)
=	O
decode_name	()->(int)
(	O
p	*(int)
,	O
&	O
target	*(char)
)	O
;	O
mode	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
mode	O
==	O
-	O
1	int
)	O
mode	O
=	O
0777	int
;	O
len	O
=	O
strlen	O
(	O
target	*(char)
)	O
+	O
1	int
;	O
buf	array(char)
=	O
alloca	O
(	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
+	O
len	O
)	O
;	O
memcpy	O
(	O
buf	array(char)
,	O
_HURD_SYMLINK	O
,	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
)	O
;	O
memcpy	O
(	O
buf	array(char)
+	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
,	O
target	*(char)
,	O
len	O
)	O
;	O
err	O
=	O
dir_mkfile	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
O_WRITE	O
,	O
mode	O
,	O
&	O
newport	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
file_set_translator	()->(int)
(	O
newport	O
,	O
FS_TRANS_EXCL	O
|	O
FS_TRANS_SET	O
,	O
FS_TRANS_EXCL	O
|	O
FS_TRANS_SET	O
,	O
0	int
,	O
buf	array(char)
,	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
+	O
len	O
,	O
MACH_PORT_NULL	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
dir_link	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
newport	O
,	O
name	*(char)
,	O
1	int
)	O
;	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
free	()->(int)
(	O
target	*(char)
)	O
;	O
if	O
(	O
newport	O
!=	O
MACH_PORT_NULL	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
newport	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_mkdir	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
char	O
*	O
name	*(char)
;	O
mode_t	O
mode	O
;	O
retry_type	O
do_retry	O
;	O
char	O
retry_name	array(char)
[	O
1024	int
]	O
;	O
mach_port_t	O
newport	O
;	O
struct	O
stat	O
st	struct
;	O
struct	O
cache_handle	O
*	O
newc	*(struct)
;	O
error_t	O
err	O
;	O
p	*(int)
=	O
decode_name	()->(int)
(	O
p	*(int)
,	O
&	O
name	*(char)
)	O
;	O
mode	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
err	O
=	O
dir_mkdir	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
name	*(char)
,	O
mode	O
)	O
;	O
if	O
(	O
err	O
)	O
{	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
return	O
err	O
;	O
}	O
err	O
=	O
dir_lookup	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
name	*(char)
,	O
O_NOTRANS	O
,	O
0	int
,	O
&	O
do_retry	O
,	O
retry_name	array(char)
,	O
&	O
newport	O
)	O
;	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
err	O
&&	O
(	O
do_retry	O
!=	O
FS_RETRY_NORMAL	O
||	O
retry_name	array(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
)	O
err	O
=	O
EACCES	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
io_stat	()->(int)
(	O
newport	O
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
newc	*(struct)
=	O
create_cached_handle	()->(int)
(	O
c	*(struct)
->	O
handle	O
.	O
fs	O
,	O
c	*(struct)
,	O
newport	O
)	O
;	O
if	O
(	O
!	O
newc	*(struct)
)	O
return	O
ESTALE	O
;	O
*	O
reply	*(*(int))
=	O
encode_fhandle	()->(int)
(	O
*	O
reply	*(*(int))
,	O
newc	*(struct)
->	O
handle	O
.	O
array	O
)	O
;	O
*	O
reply	*(*(int))
=	O
encode_fattr	()->(int)
(	O
*	O
reply	*(*(int))
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_rmdir	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
char	O
*	O
name	*(char)
;	O
error_t	O
err	O
;	O
decode_name	()->(int)
(	O
p	*(int)
,	O
&	O
name	*(char)
)	O
;	O
err	O
=	O
dir_rmdir	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
name	*(char)
)	O
;	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_readdir	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
int	O
cookie	int
;	O
unsigned	O
count	int
;	O
error_t	O
err	O
;	O
char	O
*	O
buf	array(char)
;	O
struct	O
dirent	O
*	O
dp	*(struct)
;	O
size_t	O
bufsize	O
;	O
int	O
nentries	int
;	O
int	O
i	int
;	O
int	O
*	O
replystart	*(int)
;	O
int	O
*	O
r	*(int)
;	O
cookie	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
count	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
buf	array(char)
=	O
(	O
char	O
*	O
)	O
0	int
;	O
bufsize	O
=	O
0	int
;	O
err	O
=	O
dir_readdir	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
&	O
buf	array(char)
,	O
&	O
bufsize	O
,	O
cookie	int
,	O
-	O
1	int
,	O
count	int
,	O
&	O
nentries	int
)	O
;	O
if	O
(	O
err	O
)	O
{	O
if	O
(	O
buf	array(char)
)	O
munmap	()->(int)
(	O
buf	array(char)
,	O
bufsize	O
)	O
;	O
return	O
err	O
;	O
}	O
r	*(int)
=	O
*	O
reply	*(*(int))
;	O
if	O
(	O
nentries	int
==	O
0	int
)	O
{	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
0	int
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
1	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
,	O
dp	*(struct)
=	O
(	O
struct	O
dirent	O
*	O
)	O
buf	array(char)
,	O
replystart	*(int)
=	O
*	O
reply	*(*(int))
;	O
(	O
(	O
char	O
*	O
)	O
dp	*(struct)
<	O
buf	array(char)
+	O
bufsize	O
&&	O
i	int
<	O
nentries	int
&&	O
(	O
char	O
*	O
)	O
reply	*(*(int))
<	O
(	O
char	O
*	O
)	O
replystart	*(int)
+	O
count	int
)	O
;	O
i	int
++	O
,	O
dp	*(struct)
=	O
(	O
struct	O
dirent	O
*	O
)	O
(	O
(	O
char	O
*	O
)	O
dp	*(struct)
+	O
dp	*(struct)
->	O
d_reclen	O
)	O
)	O
{	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
1	int
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
dp	*(struct)
->	O
d_ino	O
)	O
;	O
r	*(int)
=	O
encode_string	()->(int)
(	O
r	*(int)
,	O
dp	*(struct)
->	O
d_name	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
i	int
+	O
cookie	int
+	O
1	int
)	O
;	O
}	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
0	int
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
0	int
)	O
;	O
}	O
*	O
reply	*(*(int))
=	O
r	*(int)
;	O
if	O
(	O
buf	array(char)
)	O
munmap	()->(int)
(	O
buf	array(char)
,	O
bufsize	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
size_t	O
count_readdir_buffersize	(*(int),int)->(int)
(	O
int	O
*	O
p	*(int)
,	O
int	O
version	int
)	O
{	O
p	*(int)
++	O
;	O
return	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
}	O
static	O
error_t	O
op_statfs	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
struct	O
statfs	O
st	struct
;	O
error_t	O
err	O
;	O
err	O
=	O
file_statfs	()->(int)
(	O
c	*(struct)
->	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
!	O
err	O
)	O
*	O
reply	*(*(int))
=	O
encode_statfs	()->(int)
(	O
*	O
reply	*(*(int))
,	O
&	O
st	struct
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_mnt	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
file_t	O
root	O
;	O
struct	O
cache_handle	O
*	O
newc	*(struct)
;	O
char	O
*	O
name	*(char)
;	O
decode_name	()->(int)
(	O
p	*(int)
,	O
&	O
name	*(char)
)	O
;	O
root	O
=	O
file_name_lookup	()->(int)
(	O
name	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
root	O
)	O
{	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
return	O
errno	O
;	O
}	O
newc	*(struct)
=	O
create_cached_handle	()->(int)
(	O
enter_filesystem	()->(int)
(	O
name	*(char)
,	O
root	O
)	O
,	O
c	*(struct)
,	O
root	O
)	O
;	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
newc	*(struct)
)	O
return	O
ESTALE	O
;	O
*	O
reply	*(*(int))
=	O
encode_fhandle	()->(int)
(	O
*	O
reply	*(*(int))
,	O
newc	*(struct)
->	O
handle	O
.	O
array	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_getport	(*(struct),*(int),*(*(int)),int)->(int)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
*	O
*	O
reply	*(*(int))
,	O
int	O
version	int
)	O
{	O
int	O
prog	int
,	O
vers	int
,	O
prot	int
;	O
prog	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
vers	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
prot	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
prot	int
!=	O
IPPROTO_UDP	O
)	O
*	O
(	O
*	O
reply	*(*(int))
)	O
++	O
=	O
htonl	()->(int)
(	O
0	int
)	O
;	O
else	O
if	O
(	O
(	O
prog	int
==	O
MOUNTPROG	O
&&	O
vers	int
==	O
MOUNTVERS	O
)	O
||	O
(	O
prog	int
==	O
NFS_PROGRAM	O
&&	O
vers	int
==	O
NFS_VERSION	O
)	O
)	O
*	O
(	O
*	O
reply	*(*(int))
)	O
++	O
=	O
htonl	()->(int)
(	O
NFS_PORT	O
)	O
;	O
else	O
if	O
(	O
prog	int
==	O
PMAPPROG	O
&&	O
vers	int
==	O
PMAPVERS	O
)	O
*	O
(	O
*	O
reply	*(*(int))
)	O
++	O
=	O
htonl	()->(int)
(	O
PMAPPORT	O
)	O
;	O
else	O
*	O
(	O
*	O
reply	*(*(int))
)	O
++	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
struct	O
proctable	O
nfs2table	struct
=	O
{	O
NFS2PROC_NULL	O
,	O
NFS2PROC_STATFS	O
,	O
{	O
{	O
op_null	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_getattr	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_setattr	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_lookup	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_readlink	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_read	(*(struct),*(int),*(*(int)),int)->(int)
,	O
count_read_buffersize	(*(int),int)->(int)
,	O
1	int
,	O
1	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_write	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_create	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_remove	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_rename	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_link	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_symlink	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_mkdir	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_rmdir	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_readdir	(*(struct),*(int),*(*(int)),int)->(int)
,	O
count_readdir_buffersize	(*(int),int)->(int)
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_statfs	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
}	O
}	O
;	O
struct	O
proctable	O
mounttable	struct
=	O
{	O
MOUNTPROC_NULL	O
,	O
MOUNTPROC_EXPORT	O
,	O
{	O
{	O
op_null	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_mnt	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
0	int
,	O
1	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_null	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_null	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
}	O
;	O
struct	O
proctable	O
pmaptable	struct
=	O
{	O
PMAPPROC_NULL	O
,	O
PMAPPROC_CALLIT	O
,	O
{	O
{	O
op_null	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_getport	(*(struct),*(int),*(*(int)),int)->(int)
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
}	O
;	O
