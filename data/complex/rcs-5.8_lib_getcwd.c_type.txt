char	O
*	O
__getcwd	O
(	O
char	O
*	O
buf	*(char)
,	O
size_t	long
size	long
)	O
{	O
enum	O
{	O
BIG_FILE_NAME_COMPONENT_LENGTH	int
=	O
255	int
,	O
BIG_FILE_NAME_LENGTH	int
=	O
MIN	O
(	O
4095	int
,	O
PATH_MAX	int
-	O
1	int
)	O
,	O
DEEP_NESTING	int
=	O
100	int
}	O
;	O
int	O
fd	int
=	O
AT_FDCWD	O
;	O
bool	bool
fd_needs_closing	bool
=	O
false	int
;	O
DIR	struct
*	O
dirstream	*(struct)
=	O
NULL	O
;	O
dev_t	long
rootdev	long
,	O
thisdev	long
;	O
ino_t	long
rootino	long
,	O
thisino	long
;	O
char	O
*	O
dir	*(char)
;	O
register	O
char	O
*	O
dirp	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
size_t	long
allocated	long
=	O
size	long
;	O
size_t	long
used	long
;	O
dir	*(char)
=	O
getcwd	(*(char),long)->(*(char))
(	O
buf	*(char)
,	O
size	long
)	O
;	O
if	O
(	O
dir	*(char)
||	O
(	O
size	long
&&	O
errno	O
==	O
ERANGE	int
)	O
)	O
return	O
dir	*(char)
;	O
if	O
(	O
errno	O
==	O
EINVAL	int
&&	O
buf	*(char)
==	O
NULL	O
&&	O
size	long
==	O
0	int
)	O
{	O
char	O
big_buffer	array(char)
[	O
BIG_FILE_NAME_LENGTH	int
+	O
1	int
]	O
;	O
dir	*(char)
=	O
getcwd	(*(char),long)->(*(char))
(	O
big_buffer	array(char)
,	O
sizeof	O
big_buffer	array(char)
)	O
;	O
if	O
(	O
dir	*(char)
)	O
return	O
strdup	(*(char))->(*(char))
(	O
dir	*(char)
)	O
;	O
}	O
if	O
(	O
size	long
==	O
0	int
)	O
{	O
if	O
(	O
buf	*(char)
!=	O
NULL	O
)	O
{	O
__set_errno	O
(	O
EINVAL	int
)	O
;	O
return	O
NULL	O
;	O
}	O
allocated	long
=	O
BIG_FILE_NAME_LENGTH	int
+	O
1	int
;	O
}	O
if	O
(	O
buf	*(char)
==	O
NULL	O
)	O
{	O
dir	*(char)
=	O
malloc	(long)->(*(void))
(	O
allocated	long
)	O
;	O
if	O
(	O
dir	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
}	O
else	O
dir	*(char)
=	O
buf	*(char)
;	O
dirp	*(char)
=	O
dir	*(char)
+	O
allocated	long
;	O
*	O
--	O
dirp	*(char)
=	O
'\0'	O
;	O
if	O
(	O
__lstat	O
(	O
"."	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
goto	O
lose	O
;	O
thisdev	long
=	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
;	O
thisino	long
=	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
;	O
if	O
(	O
__lstat	O
(	O
"/"	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
goto	O
lose	O
;	O
rootdev	long
=	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
;	O
rootino	long
=	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
;	O
while	O
(	O
!	O
(	O
thisdev	long
==	O
rootdev	long
&&	O
thisino	long
==	O
rootino	long
)	O
)	O
{	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
d	*(struct(long,long,short,char,array(char)))
;	O
dev_t	long
dotdev	long
;	O
ino_t	long
dotino	long
;	O
bool	bool
mount_point	bool
;	O
int	O
parent_status	int
;	O
size_t	long
dirroom	long
;	O
size_t	long
namlen	long
;	O
bool	bool
use_d_ino	bool
=	O
true	int
;	O
fd	int
=	O
openat	(int,*(char),int)->(int)
(	O
fd	int
,	O
".."	*(char)
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
goto	O
lose	O
;	O
fd_needs_closing	bool
=	O
true	int
;	O
parent_status	int
=	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
parent_status	int
!=	O
0	int
)	O
goto	O
lose	O
;	O
if	O
(	O
dirstream	*(struct)
&&	O
__closedir	O
(	O
dirstream	*(struct)
)	O
!=	O
0	int
)	O
{	O
dirstream	*(struct)
=	O
NULL	O
;	O
goto	O
lose	O
;	O
}	O
dotdev	long
=	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
;	O
dotino	long
=	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
;	O
mount_point	bool
=	O
dotdev	long
!=	O
thisdev	long
;	O
dirstream	*(struct)
=	O
fdopendir	(int)->(*(struct))
(	O
fd	int
)	O
;	O
if	O
(	O
dirstream	*(struct)
==	O
NULL	O
)	O
goto	O
lose	O
;	O
fd_needs_closing	bool
=	O
false	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
__set_errno	O
(	O
0	int
)	O
;	O
d	*(struct(long,long,short,char,array(char)))
=	O
__readdir	O
(	O
dirstream	*(struct)
)	O
;	O
if	O
(	O
d	*(struct(long,long,short,char,array(char)))
==	O
NULL	O
&&	O
errno	O
==	O
0	int
&&	O
use_d_ino	bool
)	O
{	O
use_d_ino	bool
=	O
false	int
;	O
rewinddir	(*(struct))->(void)
(	O
dirstream	*(struct)
)	O
;	O
d	*(struct(long,long,short,char,array(char)))
=	O
__readdir	O
(	O
dirstream	*(struct)
)	O
;	O
}	O
if	O
(	O
d	*(struct(long,long,short,char,array(char)))
==	O
NULL	O
)	O
{	O
if	O
(	O
errno	O
==	O
0	int
)	O
__set_errno	O
(	O
ENOENT	int
)	O
;	O
goto	O
lose	O
;	O
}	O
if	O
(	O
d	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
(	O
d	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
'\0'	O
||	O
(	O
d	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
d	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
2	int
]	O
==	O
'\0'	O
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
use_d_ino	bool
)	O
{	O
bool	bool
match	bool
=	O
(	O
MATCHING_INO	O
(	O
d	*(struct(long,long,short,char,array(char)))
,	O
thisino	long
)	O
||	O
mount_point	bool
)	O
;	O
if	O
(	O
!	O
match	bool
)	O
continue	O
;	O
}	O
{	O
int	O
entry_status	int
;	O
entry_status	int
=	O
fstatat	(int,*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int)->(int)
(	O
fd	int
,	O
d	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
AT_SYMLINK_NOFOLLOW	int
)	O
;	O
if	O
(	O
entry_status	int
==	O
0	int
&&	O
S_ISDIR	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
&&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
==	O
thisdev	long
&&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
==	O
thisino	long
)	O
break	O
;	O
}	O
}	O
dirroom	long
=	O
dirp	*(char)
-	O
dir	*(char)
;	O
namlen	long
=	O
_D_EXACT_NAMLEN	O
(	O
d	*(struct(long,long,short,char,array(char)))
)	O
;	O
if	O
(	O
dirroom	long
<=	O
namlen	long
)	O
{	O
if	O
(	O
size	long
!=	O
0	int
)	O
{	O
__set_errno	O
(	O
ERANGE	int
)	O
;	O
goto	O
lose	O
;	O
}	O
else	O
{	O
char	O
*	O
tmp	*(char)
;	O
size_t	long
oldsize	long
=	O
allocated	long
;	O
allocated	long
+=	O
MAX	O
(	O
allocated	long
,	O
namlen	long
)	O
;	O
if	O
(	O
allocated	long
<	O
oldsize	long
||	O
!	O
(	O
tmp	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
dir	*(char)
,	O
allocated	long
)	O
)	O
)	O
goto	O
memory_exhausted	O
;	O
dirp	*(char)
=	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tmp	*(char)
+	O
allocated	long
-	O
(	O
oldsize	long
-	O
dirroom	long
)	O
,	O
tmp	*(char)
+	O
dirroom	long
,	O
oldsize	long
-	O
dirroom	long
)	O
;	O
dir	*(char)
=	O
tmp	*(char)
;	O
}	O
}	O
dirp	*(char)
-=	O
namlen	long
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dirp	*(char)
,	O
d	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
,	O
namlen	long
)	O
;	O
*	O
--	O
dirp	*(char)
=	O
'/'	O
;	O
thisdev	long
=	O
dotdev	long
;	O
thisino	long
=	O
dotino	long
;	O
}	O
if	O
(	O
dirstream	*(struct)
&&	O
__closedir	O
(	O
dirstream	*(struct)
)	O
!=	O
0	int
)	O
{	O
dirstream	*(struct)
=	O
NULL	O
;	O
goto	O
lose	O
;	O
}	O
if	O
(	O
dirp	*(char)
==	O
&	O
dir	*(char)
[	O
allocated	long
-	O
1	int
]	O
)	O
*	O
--	O
dirp	*(char)
=	O
'/'	O
;	O
used	long
=	O
dir	*(char)
+	O
allocated	long
-	O
dirp	*(char)
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
dir	*(char)
,	O
dirp	*(char)
,	O
used	long
)	O
;	O
if	O
(	O
size	long
==	O
0	int
)	O
buf	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
dir	*(char)
,	O
used	long
)	O
;	O
if	O
(	O
buf	*(char)
==	O
NULL	O
)	O
buf	*(char)
=	O
dir	*(char)
;	O
return	O
buf	*(char)
;	O
memory_exhausted	O
:	O
__set_errno	O
(	O
ENOMEM	int
)	O
;	O
lose	O
:	O
{	O
int	O
save	int
=	O
errno	O
;	O
if	O
(	O
dirstream	*(struct)
)	O
__closedir	O
(	O
dirstream	*(struct)
)	O
;	O
if	O
(	O
fd_needs_closing	bool
)	O
close	(int)->(int)
(	O
fd	int
)	O
;	O
if	O
(	O
buf	*(char)
==	O
NULL	O
)	O
free	(*(void))->(void)
(	O
dir	*(char)
)	O
;	O
__set_errno	O
(	O
save	int
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
