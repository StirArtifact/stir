void	O
CalculateMeanAndVariance	O
(	O
long	O
n	int
,	O
double	O
x	*(*(double))
,	O
double	O
*	O
xi_bari	O
,	O
double	O
*	O
si_2i	O
)	O
{	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
*	O
xi_bari	O
=	O
x	*(*(double))
;	O
*	O
si_2i	O
=	O
0	int
;	O
return	O
;	O
}	O
double	O
mTmp	O
=	O
*	O
xi_bari	O
;	O
*	O
xi_bari	O
=	O
*	O
xi_bari	O
+	O
(	O
x	*(*(double))
-	O
*	O
xi_bari	O
)	O
/	O
n	int
;	O
*	O
si_2i	O
=	O
*	O
si_2i	O
+	O
(	O
x	*(*(double))
-	O
mTmp	O
)	O
*	O
(	O
x	*(*(double))
-	O
*	O
xi_bari	O
)	O
;	O
}	O
int	O
checkConvergence	O
(	O
int	O
nOut	O
,	O
int	O
variableCount	O
,	O
int	O
p_count	O
,	O
double	O
*	O
*	O
meansForAll	O
,	O
double	O
*	O
*	O
varsForAll	O
,	O
double	O
*	O
Rhat	O
)	O
{	O
int	O
vi	O
,	O
pi	O
;	O
int	O
converged	O
=	O
0	int
;	O
double	O
varsofvars	O
,	O
meansofmeans	O
,	O
varsofmeans	O
,	O
meansofvars	O
;	O
for	O
(	O
vi	O
=	O
0	int
;	O
vi	O
<	O
variableCount	O
;	O
vi	O
++	O
)	O
{	O
meansofmeans	O
=	O
0.0	int
;	O
for	O
(	O
pi	O
=	O
0	int
;	O
pi	O
<	O
p_count	O
;	O
pi	O
++	O
)	O
{	O
CalculateMeanAndVariance	O
(	O
(	O
pi	O
+	O
1	int
)	O
,	O
meansForAll	O
[	O
pi	O
]	O
[	O
vi	O
]	O
,	O
&	O
meansofmeans	O
,	O
&	O
varsofmeans	O
)	O
;	O
CalculateMeanAndVariance	O
(	O
(	O
pi	O
+	O
1	int
)	O
,	O
varsForAll	O
[	O
pi	O
]	O
[	O
vi	O
]	O
,	O
&	O
meansofvars	O
,	O
&	O
varsofvars	O
)	O
;	O
}	O
if	O
(	O
(	O
meansofvars	O
==	O
0	int
)	O
&&	O
(	O
varsofmeans	O
==	O
0	int
)	O
)	O
{	O
*	O
Rhat	O
=	O
1	int
;	O
converged	O
++	O
;	O
}	O
else	O
{	O
double	O
s2	O
=	O
(	O
(	O
nOut	O
-	O
1	int
)	O
*	O
meansofvars	O
+	O
varsofmeans	O
)	O
/	O
nOut	O
;	O
double	O
Vhat	O
=	O
s2	O
+	O
varsofmeans	O
/	O
(	O
nOut	O
*	O
p_count	O
)	O
;	O
*	O
Rhat	O
=	O
Vhat	O
/	O
meansofvars	O
;	O
if	O
(	O
*	O
Rhat	O
<	O
1.05	int
)	O
converged	O
++	O
;	O
}	O
}	O
return	O
converged	O
;	O
}	O
void	O
CollectConvInfo	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
double	O
*	O
*	O
mean_dest	O
=	O
(	O
double	O
*	O
*	O
)	O
args	O
[	O
0	int
]	O
;	O
double	O
*	O
*	O
var_dest	O
=	O
(	O
double	O
*	O
*	O
)	O
args	O
[	O
1	int
]	O
;	O
long	O
*	O
n	int
=	O
(	O
long	O
*	O
)	O
args	O
[	O
2	int
]	O
;	O
long	O
i	O
;	O
PMCVAR	O
pMCVar	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
plevel	O
->	O
nMCVars	O
;	O
i	O
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
i	O
]	O
;	O
*	O
*	O
mean_dest	O
=	O
pMCVar	O
->	O
dVal_mean	O
;	O
*	O
*	O
var_dest	O
=	O
pMCVar	O
->	O
dVal_var	O
/	O
(	O
*	O
n	int
-	O
1	int
)	O
;	O
(	O
*	O
mean_dest	O
)	O
++	O
;	O
(	O
*	O
var_dest	O
)	O
++	O
;	O
}	O
}	O
void	O
AnnounceMarkov	O
(	O
int	O
size	O
,	O
int	O
nSimTypeFlag	O
,	O
long	O
nIter	O
)	O
{	O
switch	O
(	O
nSimTypeFlag	O
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
"\nDoing %ld Metropolis within Gibbs simulation"	*(char)
,	O
nIter	O
)	O
;	O
printf	(*(char))->(int)
(	O
(	O
nIter	O
!=	O
1	int
?	O
"s"	*(char)
:	O
""	*(char)
)	O
)	O
;	O
if	O
(	O
size	O
>	O
1	int
)	O
printf	(*(char))->(int)
(	O
" on each of %d processors\n"	*(char)
,	O
size	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
"\nPrinting data and predictions for the last line of the "	*(char)
"restart file\n"	*(char)
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
"\nDoing %ld Metropolis-Hastings simulation"	*(char)
,	O
nIter	O
)	O
;	O
printf	(*(char))->(int)
(	O
(	O
nIter	O
!=	O
1	int
?	O
"s"	*(char)
:	O
""	*(char)
)	O
)	O
;	O
if	O
(	O
size	O
>	O
1	int
)	O
printf	(*(char))->(int)
(	O
" on each of %d processors\n"	*(char)
,	O
size	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	(*(char))->(int)
(	O
"\nDoing %ld Metropolis within Gibbs posterior "	*(char)
"tempered simulation"	*(char)
,	O
nIter	O
)	O
;	O
printf	(*(char))->(int)
(	O
(	O
nIter	O
!=	O
1	int
?	O
"s\n"	*(char)
:	O
"\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
printf	(*(char))->(int)
(	O
"\nDoing %ld Metropolis within Gibbs likelihood "	*(char)
"tempered simulation"	*(char)
,	O
nIter	O
)	O
;	O
printf	(*(char))->(int)
(	O
(	O
nIter	O
!=	O
1	int
?	O
"s\n"	*(char)
:	O
"\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
5	int
:	O
printf	(*(char))->(int)
(	O
"\nDoing Stochastic optimization\n"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
void	O
CalculateTotals	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
args	O
[	O
0	int
]	O
;	O
double	O
*	O
pdLnPrior	O
=	O
(	O
double	O
*	O
)	O
args	O
[	O
1	int
]	O
;	O
long	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
*	O
pdLnPrior	O
+=	O
LnDensity	O
(	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
,	O
panal	O
)	O
;	O
}	O
}	O
void	O
CheckForFixed	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
long	O
n	int
,	O
m	O
;	O
PMCVAR	O
pMCVar	O
;	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
pFVar	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
plevel	O
->	O
nFixedVars	O
;	O
m	O
++	O
)	O
{	O
pFVar	O
=	O
plevel	O
->	O
rgpFixedVars	O
[	O
m	O
]	O
;	O
if	O
(	O
pMCVar	O
->	O
hvar	long
==	O
pFVar	O
->	O
hvar	long
)	O
{	O
pMCVar	O
->	O
bIsFixed	O
=	O
TRUE	O
;	O
if	O
(	O
IsInput	(long)->(int)
(	O
pFVar	O
->	O
hvar	long
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: a sampled parameter cannot be assigned an input\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
else	O
pMCVar	O
->	O
dVal	double
=	O
pFVar	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
dVal	double
;	O
}	O
}	O
}	O
}	O
void	O
CheckPrintStatements	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
args	O
[	O
0	int
]	O
;	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
;	O
long	O
i	O
,	O
j	O
;	O
if	O
(	O
plevel	O
->	O
pexpt	O
==	O
NULL	O
)	O
return	O
;	O
pos	O
=	O
&	O
(	O
plevel	O
->	O
pexpt	O
->	O
os	O
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
pos	O
->	O
nOutputs	int
;	O
j	O
++	O
)	O
for	O
(	O
i	O
=	O
j	O
+	O
1	int
;	O
i	O
<	O
pos	O
->	O
nOutputs	int
;	O
i	O
++	O
)	O
if	O
(	O
pos	O
->	O
phvar_out	*(long)
[	O
j	O
]	O
==	O
pos	O
->	O
phvar_out	*(long)
[	O
i	O
]	O
)	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_DUPVARINEXPRT	O
|	O
RE_FATAL	O
,	O
pos	O
->	O
pszOutputNames	*(*(char))
[	O
i	O
]	O
,	O
"Print"	*(char)
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
pos	O
->	O
nData	int
;	O
j	O
++	O
)	O
for	O
(	O
i	O
=	O
j	O
+	O
1	int
;	O
i	O
<	O
pos	O
->	O
nData	int
;	O
i	O
++	O
)	O
if	O
(	O
pos	O
->	O
phvar_dat	*(long)
[	O
j	O
]	O
==	O
pos	O
->	O
phvar_dat	*(long)
[	O
i	O
]	O
)	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_DUPVARINEXPRT	O
|	O
RE_FATAL	O
,	O
pos	O
->	O
pszDataNames	*(*(char))
[	O
i	O
]	O
,	O
"Data"	*(char)
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
pos	O
->	O
nOutputs	int
;	O
j	O
++	O
)	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
pos	O
->	O
nData	int
;	O
i	O
++	O
)	O
if	O
(	O
(	O
pos	O
->	O
phvar_out	*(long)
[	O
j	O
]	O
==	O
pos	O
->	O
phvar_dat	*(long)
[	O
i	O
]	O
)	O
&&	O
(	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
j	O
]	O
!=	O
pos	O
->	O
pcData	*(int)
[	O
i	O
]	O
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\nError: unequal times in Print and Data statements for %s\n"	*(char)
"Exiting.\n\n"	*(char)
,	O
pos	O
->	O
pszOutputNames	*(*(char))
[	O
j	O
]	O
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
}	O
BOOL	int
CheckAllTransitions	O
(	O
PGIBBSDATA	O
pgd	O
)	O
{	O
BOOL	int
bOK	O
;	O
double	O
AcceptRate	O
;	O
int	O
i	O
;	O
i	O
=	O
pgd	O
->	O
startT	O
;	O
bOK	O
=	O
TRUE	O
;	O
while	O
(	O
(	O
i	O
<=	O
pgd	O
->	O
endT	O
-	O
1	int
)	O
&&	O
bOK	O
)	O
{	O
if	O
(	O
pgd	O
->	O
rglTransAttempts	O
[	O
i	O
]	O
<	O
10	int
)	O
{	O
bOK	O
=	O
FALSE	O
;	O
break	O
;	O
}	O
else	O
AcceptRate	O
=	O
pgd	O
->	O
rglTransAccepts	O
[	O
i	O
]	O
/	O
(	O
(	O
double	O
)	O
pgd	O
->	O
rglTransAttempts	O
[	O
i	O
]	O
)	O
;	O
bOK	O
=	O
(	O
AcceptRate	O
>	O
0.15	int
)	O
;	O
i	O
++	O
;	O
}	O
return	O
bOK	O
;	O
}	O
int	O
CheckTransitions	O
(	O
PGIBBSDATA	O
pgd	O
)	O
{	O
double	O
AcceptRate	O
;	O
int	O
i	O
;	O
i	O
=	O
pgd	O
->	O
startT	O
;	O
if	O
(	O
pgd	O
->	O
rglTransAttempts	O
[	O
i	O
]	O
<	O
10	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
AcceptRate	O
=	O
pgd	O
->	O
rglTransAccepts	O
[	O
i	O
]	O
/	O
(	O
(	O
double	O
)	O
pgd	O
->	O
rglTransAttempts	O
[	O
i	O
]	O
)	O
;	O
if	O
(	O
AcceptRate	O
<	O
0.30	int
)	O
{	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
AcceptRate	O
<	O
1	int
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
return	O
(	O
+	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
CloneLikes	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
long	O
nLikes	O
;	O
long	O
i	O
,	O
j	O
,	O
k	O
;	O
PLEVEL	O
pLower	O
;	O
PMCVAR	O
pClone	O
;	O
PMCVAR	O
pMCVar	O
;	O
BOOL	int
bFound	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
plevel	O
->	O
iInstances	O
;	O
i	O
++	O
)	O
{	O
pLower	O
=	O
plevel	O
->	O
pLevels	O
[	O
i	O
]	O
;	O
pLower	O
->	O
nLikes	O
=	O
nLikes	O
=	O
plevel	O
->	O
nLikes	O
+	O
ListLength	O
(	O
plevel	O
->	O
plistLikes	O
)	O
;	O
if	O
(	O
pLower	O
->	O
nLikes	O
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
(	O
pLower	O
->	O
rgpLikes	O
=	O
(	O
PMCVAR	O
*	O
)	O
malloc	O
(	O
pLower	O
->	O
nLikes	O
*	O
sizeof	O
(	O
PMCVAR	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"CloneLikes"	*(char)
,	O
NULL	O
)	O
;	O
}	O
}	O
nLikes	O
=	O
0	int
;	O
ForAllList3	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void),*(void),*(void))->(void)),*(void),*(void),*(void))->(void)
(	O
plevel	O
->	O
plistLikes	O
,	O
&	O
CloneLikesL	O
,	O
plevel	O
,	O
&	O
nLikes	O
,	O
NULL	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
plevel	O
->	O
iInstances	O
;	O
i	O
++	O
)	O
{	O
pLower	O
=	O
plevel	O
->	O
pLevels	O
[	O
i	O
]	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
plevel	O
->	O
nLikes	O
;	O
j	O
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpLikes	O
[	O
j	O
]	O
;	O
bFound	O
=	O
FALSE	O
;	O
k	O
=	O
0	int
;	O
while	O
(	O
(	O
k	O
<	O
nLikes	O
)	O
&&	O
(	O
!	O
bFound	O
)	O
)	O
{	O
bFound	O
=	O
(	O
pMCVar	O
->	O
hvar	long
==	O
pLower	O
->	O
rgpLikes	O
[	O
k	O
]	O
->	O
hvar	long
)	O
;	O
if	O
(	O
!	O
bFound	O
)	O
k	O
++	O
;	O
}	O
if	O
(	O
!	O
bFound	O
)	O
{	O
if	O
(	O
!	O
(	O
pClone	O
=	O
(	O
PMCVAR	O
)	O
malloc	O
(	O
sizeof	O
(	O
MCVAR	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"CloneLikes"	*(char)
,	O
NULL	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
pClone	O
,	O
pMCVar	O
,	O
sizeof	O
(	O
MCVAR	O
)	O
)	O
;	O
pLower	O
->	O
rgpLikes	O
[	O
nLikes	O
+	O
j	O
]	O
=	O
pClone	O
;	O
}	O
}	O
}	O
}	O
void	O
CloneLikesL	O
(	O
PVOID	*(void)
pData	*(void)
,	O
PVOID	*(void)
pUser1	O
,	O
PVOID	*(void)
pUser2	O
,	O
PVOID	*(void)
pUser3	O
)	O
{	O
PMCVAR	O
pMCVar	O
=	O
(	O
PMCVAR	O
)	O
pData	*(void)
;	O
PLEVEL	O
plevel	O
=	O
(	O
PLEVEL	O
)	O
pUser1	O
;	O
long	O
*	O
pnLikes	O
=	O
(	O
long	O
*	O
)	O
pUser2	O
;	O
long	O
i	O
;	O
PLEVEL	O
pLower	O
;	O
PMCVAR	O
pClone	O
;	O
++	O
pMCVar	O
->	O
iDepth	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
plevel	O
->	O
iInstances	O
;	O
i	O
++	O
)	O
{	O
pLower	O
=	O
plevel	O
->	O
pLevels	O
[	O
i	O
]	O
;	O
if	O
(	O
!	O
(	O
pClone	O
=	O
(	O
PMCVAR	O
)	O
malloc	O
(	O
sizeof	O
(	O
MCVAR	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"CloneLikeL"	*(char)
,	O
NULL	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
pClone	O
,	O
pMCVar	O
,	O
sizeof	O
(	O
MCVAR	O
)	O
)	O
;	O
pLower	O
->	O
rgpLikes	O
[	O
*	O
pnLikes	O
]	O
=	O
pClone	O
;	O
}	O
++	O
(	O
*	O
pnLikes	O
)	O
;	O
}	O
void	O
CloneMCVars	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
long	O
nMCVars	O
=	O
ListLength	O
(	O
plevel	O
->	O
plistMCVars	O
)	O
;	O
long	O
n	int
;	O
PLEVEL	O
pLower	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
iInstances	O
;	O
n	int
++	O
)	O
{	O
pLower	O
=	O
plevel	O
->	O
pLevels	O
[	O
n	int
]	O
;	O
pLower	O
->	O
nMCVars	O
=	O
nMCVars	O
;	O
if	O
(	O
nMCVars	O
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
(	O
pLower	O
->	O
rgpMCVars	O
=	O
(	O
PMCVAR	O
*	O
)	O
malloc	O
(	O
nMCVars	O
*	O
sizeof	O
(	O
PMCVAR	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"CloneMCVars"	*(char)
,	O
NULL	O
)	O
;	O
}	O
}	O
nMCVars	O
=	O
0	int
;	O
ForAllList3	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void),*(void),*(void))->(void)),*(void),*(void),*(void))->(void)
(	O
plevel	O
->	O
plistMCVars	O
,	O
&	O
CloneMCVarsL	O
,	O
plevel	O
,	O
&	O
nMCVars	O
,	O
NULL	O
)	O
;	O
}	O
void	O
CloneMCVarsL	O
(	O
PVOID	*(void)
pData	*(void)
,	O
PVOID	*(void)
pUser1	O
,	O
PVOID	*(void)
pUser2	O
,	O
PVOID	*(void)
pUser3	O
)	O
{	O
PMCVAR	O
pMCVar	O
=	O
(	O
PMCVAR	O
)	O
pData	*(void)
;	O
PLEVEL	O
plevel	O
=	O
(	O
PLEVEL	O
)	O
pUser1	O
;	O
long	O
*	O
pnMCVars	O
=	O
(	O
long	O
*	O
)	O
pUser2	O
;	O
long	O
i	O
;	O
PLEVEL	O
pLower	O
;	O
PMCVAR	O
pClone	O
;	O
++	O
pMCVar	O
->	O
iDepth	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
plevel	O
->	O
iInstances	O
;	O
i	O
++	O
)	O
{	O
pLower	O
=	O
plevel	O
->	O
pLevels	O
[	O
i	O
]	O
;	O
if	O
(	O
!	O
(	O
pClone	O
=	O
(	O
PMCVAR	O
)	O
malloc	O
(	O
sizeof	O
(	O
MCVAR	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"CloneMCVarsL"	*(char)
,	O
NULL	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
pClone	O
,	O
pMCVar	O
,	O
sizeof	O
(	O
MCVAR	O
)	O
)	O
;	O
pClone	O
->	O
plistDependents	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
pLower	O
->	O
rgpMCVars	O
[	O
*	O
pnMCVars	O
]	O
=	O
pClone	O
;	O
}	O
++	O
(	O
*	O
pnMCVars	O
)	O
;	O
}	O
void	O
CloseMarkovFiles	O
(	O
PGIBBSDATA	O
pgd	O
)	O
{	O
if	O
(	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
3	int
)	O
||	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
4	int
)	O
)	O
{	O
char	O
szFileName	O
[	O
MAX_FILENAMESIZE	O
+	O
6	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
szFileName	O
,	O
"%s%s"	*(char)
,	O
pgd	O
->	O
szGout	O
,	O
".perks"	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pgd	O
->	O
pfilePerks	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\nWrote perks to \"%s\"\n"	*(char)
,	O
szFileName	O
)	O
;	O
}	O
if	O
(	O
pgd	O
->	O
pfileOut	O
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pgd	O
->	O
pfileOut	O
)	O
;	O
printf	(*(char))->(int)
(	O
"Wrote MCMC sample to \"%s\"\n"	*(char)
,	O
pgd	O
->	O
szGout	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
void	O
ConvertLists	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
args	O
[	O
0	int
]	O
;	O
long	O
m	O
,	O
n	int
;	O
PMCVAR	O
pMCVar	O
;	O
if	O
(	O
plevel	O
->	O
pexpt	O
==	O
NULL	O
)	O
ListToPVArray	O
(	O
panal	O
,	O
plevel	O
->	O
plistVars	O
,	O
&	O
plevel	O
->	O
nFixedVars	O
,	O
&	O
plevel	O
->	O
rgpFixedVars	O
)	O
;	O
else	O
ListToPVArray	O
(	O
panal	O
,	O
plevel	O
->	O
pexpt	O
->	O
plistParmMods	O
,	O
&	O
plevel	O
->	O
nFixedVars	O
,	O
&	O
plevel	O
->	O
rgpFixedVars	O
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
;	O
ListToPMCArray	O
(	O
panal	O
,	O
pMCVar	O
->	O
plistDependents	O
,	O
&	O
pMCVar	O
->	O
nDependents	O
,	O
&	O
pMCVar	O
->	O
rgpDependents	O
)	O
;	O
if	O
(	O
pMCVar	O
->	O
nDependents	O
==	O
0	int
)	O
pMCVar	O
->	O
bExptIsDep	O
=	O
TRUE	O
;	O
else	O
{	O
m	O
=	O
0	int
;	O
while	O
(	O
(	O
m	O
<	O
pMCVar	O
->	O
nDependents	O
)	O
&&	O
!	O
(	O
pMCVar	O
->	O
bExptIsDep	O
=	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
pMCVar	O
->	O
rgpDependents	O
[	O
m	O
]	O
->	O
pszName	O
,	O
pMCVar	O
->	O
pszName	O
)	O
?	O
TRUE	O
:	O
FALSE	O
)	O
)	O
)	O
m	O
++	O
;	O
}	O
}	O
}	O
void	O
DoMarkov	O
(	O
PANALYSIS	O
panal	O
)	O
{	O
PGIBBSDATA	O
pgd	O
=	O
&	O
panal	O
->	O
gd	O
;	O
PLEVEL	O
pLevel0	O
=	O
panal	O
->	O
pLevels	O
[	O
0	int
]	O
;	O
long	O
nThetas	O
,	O
nUpdateAt	O
,	O
nTotal	O
;	O
long	O
i	O
,	O
iter	O
=	O
0	int
;	O
long	O
nIter	O
=	O
pgd	O
->	O
nMaxIter	O
;	O
double	O
*	O
pdMCVarVals	O
=	O
NULL	O
;	O
double	O
*	O
pdSum	O
=	O
NULL	O
;	O
double	O
*	O
*	O
prgdSumProd	O
=	O
NULL	O
;	O
double	O
dTmp	O
,	O
dLnPrior	O
=	O
0	int
,	O
dLnData	O
=	O
0	int
;	O
if	O
(	O
panal	O
->	O
rank	int
==	O
0	int
)	O
AnnounceMarkov	O
(	O
panal	O
->	O
size	O
,	O
pgd	O
->	O
nSimTypeFlag	O
,	O
nIter	O
)	O
;	O
OpenMarkovFiles	O
(	O
panal	O
)	O
;	O
ReadDataFile	O
(	O
panal	O
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
CloneMCVars	O
,	O
NULL	O
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
CloneLikes	O
,	O
NULL	O
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
FindMCParents	O
,	O
panal	O
,	O
NULL	O
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
FindMCDependents	O
,	O
panal	O
,	O
NULL	O
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
FindLikeParents	O
,	O
panal	O
,	O
NULL	O
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
ConvertLists	O
,	O
panal	O
,	O
NULL	O
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
CheckForFixed	O
,	O
NULL	O
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
CheckPrintStatements	O
,	O
panal	O
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
panal	O
->	O
rank	int
==	O
0	int
)	O
&&	O
(	O
panal	O
->	O
bDependents	O
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Hierarchical structure:\n\n"	*(char)
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
PrintDeps	O
,	O
NULL	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\nDone.\n\n"	*(char)
)	O
;	O
return	O
;	O
}	O
TraverseLevels	O
(	O
pLevel0	O
,	O
SetPointers	O
,	O
panal	O
,	O
NULL	O
)	O
;	O
if	O
(	O
pgd	O
->	O
szGrestart	O
)	O
{	O
nThetas	O
=	O
0	int
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
GetNumberOfMCVars	O
,	O
&	O
nThetas	O
)	O
;	O
if	O
(	O
(	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
3	int
)	O
||	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
4	int
)	O
)	O
&&	O
(	O
pgd	O
->	O
nPerks	O
!=	O
0	int
)	O
)	O
{	O
ReadRestartTemper	O
(	O
pgd	O
->	O
pfileRestart	O
,	O
nThetas	O
,	O
pgd	O
->	O
nPerks	O
,	O
&	O
pdMCVarVals	O
,	O
&	O
pdSum	O
,	O
&	O
prgdSumProd	O
,	O
&	O
iter	O
,	O
&	O
pgd	O
->	O
indexT	O
,	O
pgd	O
->	O
rgdlnPi	O
)	O
;	O
}	O
else	O
ReadRestart	O
(	O
pgd	O
->	O
pfileRestart	O
,	O
nThetas	O
,	O
&	O
pdMCVarVals	O
,	O
&	O
pdSum	O
,	O
&	O
prgdSumProd	O
,	O
&	O
iter	O
)	O
;	O
nThetas	O
=	O
0	int
;	O
if	O
(	O
!	O
TraverseLevels1	O
(	O
pLevel0	O
,	O
SetMCVars	O
,	O
pdMCVarVals	O
,	O
&	O
nThetas	O
,	O
NULL	O
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\nError: some read-in parameters are out of bounds - "	*(char)
"Exiting\n\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
1	int
)	O
{	O
if	O
(	O
panal	O
->	O
rank	int
==	O
0	int
)	O
{	O
PrintAllExpts	O
(	O
pLevel0	O
,	O
panal	O
,	O
pgd	O
->	O
pfileOut	O
)	O
;	O
CloseMarkovFiles	O
(	O
pgd	O
)	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
0	int
)	O
||	O
(	O
pgd	O
->	O
nSimTypeFlag	O
>=	O
3	int
)	O
)	O
{	O
char	O
szKernelFile	O
[	O
MAX_FILENAMESIZE	O
+	O
12	int
]	O
;	O
if	O
(	O
panal	O
->	O
size	O
>	O
1	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
szKernelFile	O
,	O
"%04d_%s%s"	*(char)
,	O
panal	O
->	O
rank	int
,	O
panal	O
->	O
gd	O
.	O
szGrestart	O
,	O
".kernel"	*(char)
)	O
;	O
}	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
szKernelFile	O
,	O
"%s%s"	*(char)
,	O
panal	O
->	O
gd	O
.	O
szGrestart	O
,	O
".kernel"	*(char)
)	O
;	O
}	O
FILE	struct
*	O
pfile	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
szKernelFile	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
pfile	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Reading kernel file %s\n"	*(char)
,	O
szKernelFile	O
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
ReadKernel	O
,	O
pfile	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
TraverseLevels	O
(	O
pLevel0	O
,	O
SetKernel	O
,	O
1	int
,	O
pdMCVarVals	O
,	O
NULL	O
)	O
;	O
free	O
(	O
pdMCVarVals	O
)	O
;	O
}	O
}	O
else	O
{	O
TraverseLevels	O
(	O
pLevel0	O
,	O
CalculateTotals	O
,	O
panal	O
,	O
&	O
dLnPrior	O
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
!	O
RunAllExpts	O
(	O
panal	O
,	O
&	O
dLnData	O
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\nError: cannot compute at the starting point - Exiting\n\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
TraverseLevels1	O
(	O
pLevel0	O
,	O
SaveLikelihoods	O
,	O
NULL	O
)	O
;	O
InitPerks	O
(	O
panal	O
)	O
;	O
WriteHeader	O
(	O
panal	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"\nError: a restart file must be given to print data and"	*(char)
"         predictions - Exiting.\n\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
TraverseLevels	O
(	O
pLevel0	O
,	O
SetKernel	O
,	O
2	int
,	O
pdMCVarVals	O
,	O
NULL	O
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
InitMCVars	O
,	O
NULL	O
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
CalculateTotals	O
,	O
panal	O
,	O
&	O
dLnPrior	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
RunAllExpts	O
(	O
panal	O
,	O
&	O
dLnData	O
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\nError: cannot compute at the starting point - Exiting\n\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
TraverseLevels1	O
(	O
pLevel0	O
,	O
SaveLikelihoods	O
,	O
NULL	O
)	O
;	O
InitPerks	O
(	O
panal	O
)	O
;	O
WriteHeader	O
(	O
panal	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"0\t"	*(char)
)	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
WriteMCVars	O
,	O
pgd	O
->	O
pfileOut	O
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
3	int
)	O
||	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
4	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%d\t"	*(char)
,	O
pgd	O
->	O
indexT	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
pgd	O
->	O
nPerks	O
;	O
i	O
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%e\t"	*(char)
,	O
pgd	O
->	O
rgdlnPi	O
[	O
i	O
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%e\t%e\t%e\n"	*(char)
,	O
dLnPrior	O
,	O
dLnData	O
,	O
dLnPrior	O
+	O
dLnData	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pgd	O
->	O
pfileOut	O
)	O
;	O
}	O
nTotal	O
=	O
UPDATE_BASE	O
;	O
nUpdateAt	O
=	O
iter	O
+	O
nTotal	O
;	O
while	O
(	O
iter	O
<	O
nIter	O
)	O
{	O
if	O
(	O
panal	O
->	O
bOutputIter	O
&&	O
(	O
(	O
iter	O
+	O
1	int
)	O
%	O
panal	O
->	O
nOutputFreq	O
==	O
0	int
)	O
)	O
{	O
if	O
(	O
panal	O
->	O
size	O
>	O
1	int
)	O
printf	(*(char))->(int)
(	O
"Processor %d, Iteration %ld\n"	*(char)
,	O
panal	O
->	O
rank	int
,	O
iter	O
+	O
1	int
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"Iteration %ld\n"	*(char)
,	O
iter	O
+	O
1	int
)	O
;	O
if	O
(	O
iter	O
==	O
nIter	O
-	O
1	int
)	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
(	O
iter	O
+	O
1	int
)	O
%	O
pgd	O
->	O
nPrintFreq	O
==	O
0	int
)	O
&&	O
(	O
iter	O
>=	O
pgd	O
->	O
nMaxIter	O
-	O
pgd	O
->	O
nPrintIter	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%ld\t"	*(char)
,	O
iter	O
+	O
1	int
)	O
;	O
if	O
(	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
0	int
)	O
||	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
5	int
)	O
)	O
{	O
TraverseLevels	O
(	O
pLevel0	O
,	O
SampleThetas	O
,	O
panal	O
,	O
pgd	O
,	O
&	O
iter	O
,	O
&	O
nUpdateAt	O
,	O
&	O
nTotal	O
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
(	O
iter	O
+	O
1	int
)	O
%	O
pgd	O
->	O
nPrintFreq	O
==	O
0	int
)	O
&&	O
(	O
iter	O
>=	O
pgd	O
->	O
nMaxIter	O
-	O
pgd	O
->	O
nPrintIter	O
)	O
)	O
{	O
dLnPrior	O
=	O
0.0	int
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
CalculateTotals	O
,	O
panal	O
,	O
&	O
dLnPrior	O
,	O
NULL	O
)	O
;	O
dLnData	O
=	O
0.0	int
;	O
TraverseLevels1	O
(	O
pLevel0	O
,	O
SumAllExpts	O
,	O
&	O
dLnData	O
,	O
NULL	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%e\t%e\t%e\n"	*(char)
,	O
dLnPrior	O
,	O
dLnData	O
,	O
dLnPrior	O
+	O
dLnData	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pgd	O
->	O
pfileOut	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
3	int
)	O
||	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
4	int
)	O
)	O
{	O
TraverseLevels	O
(	O
pLevel0	O
,	O
SampleThetasTempered	O
,	O
panal	O
,	O
pgd	O
,	O
&	O
iter	O
,	O
&	O
nUpdateAt	O
,	O
&	O
nTotal	O
,	O
&	O
pgd	O
->	O
indexT	O
,	O
NULL	O
)	O
;	O
dLnPrior	O
=	O
0.0	int
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
CalculateTotals	O
,	O
panal	O
,	O
&	O
dLnPrior	O
,	O
NULL	O
)	O
;	O
dLnData	O
=	O
0.0	int
;	O
TraverseLevels1	O
(	O
pLevel0	O
,	O
SumAllExpts	O
,	O
&	O
dLnData	O
,	O
NULL	O
)	O
;	O
dTmp	O
=	O
pgd	O
->	O
dCZero	O
/	O
(	O
iter	O
+	O
pgd	O
->	O
dNZero	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
pgd	O
->	O
nPerks	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
i	O
==	O
pgd	O
->	O
indexT	O
)	O
pgd	O
->	O
rgdlnPi	O
[	O
i	O
]	O
-=	O
dTmp	O
;	O
else	O
pgd	O
->	O
rgdlnPi	O
[	O
i	O
]	O
+=	O
dTmp	O
/	O
pgd	O
->	O
nPerks	O
;	O
}	O
if	O
(	O
(	O
(	O
iter	O
+	O
1	int
)	O
%	O
pgd	O
->	O
nPrintFreq	O
==	O
0	int
)	O
&&	O
(	O
iter	O
>=	O
pgd	O
->	O
nMaxIter	O
-	O
pgd	O
->	O
nPrintIter	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%d\t"	*(char)
,	O
pgd	O
->	O
indexT	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
pgd	O
->	O
nPerks	O
;	O
i	O
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%e\t"	*(char)
,	O
pgd	O
->	O
rgdlnPi	O
[	O
i	O
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%e\t%e\t%e\n"	*(char)
,	O
dLnPrior	O
,	O
dLnData	O
,	O
dLnPrior	O
+	O
dLnData	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pgd	O
->	O
pfileOut	O
)	O
;	O
}	O
pgd	O
->	O
rglCount	O
[	O
pgd	O
->	O
indexT	O
]	O
=	O
pgd	O
->	O
rglCount	O
[	O
pgd	O
->	O
indexT	O
]	O
+	O
1	int
;	O
pgd	O
->	O
indexT	O
=	O
SampleTemperature2	O
(	O
pgd	O
,	O
dLnPrior	O
,	O
dLnData	O
)	O
;	O
}	O
else	O
{	O
SampleThetaVector	O
(	O
pLevel0	O
,	O
panal	O
,	O
nThetas	O
,	O
pdMCVarVals	O
,	O
pdSum	O
,	O
prgdSumProd	O
,	O
iter	O
,	O
nUpdateAt	O
,	O
nTotal	O
,	O
&	O
dLnPrior	O
,	O
&	O
dLnData	O
)	O
;	O
if	O
(	O
(	O
(	O
iter	O
+	O
1	int
)	O
%	O
pgd	O
->	O
nPrintFreq	O
==	O
0	int
)	O
&&	O
(	O
iter	O
>=	O
pgd	O
->	O
nMaxIter	O
-	O
pgd	O
->	O
nPrintIter	O
)	O
)	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%5g\t"	*(char)
,	O
pdMCVarVals	O
[	O
i	O
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%e\t%e\t%e\n"	*(char)
,	O
dLnPrior	O
,	O
dLnData	O
,	O
dLnPrior	O
+	O
dLnData	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pgd	O
->	O
pfileOut	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
iter	O
==	O
nUpdateAt	O
)	O
{	O
nTotal	O
=	O
nTotal	O
*	O
3	int
/	O
2	int
;	O
nUpdateAt	O
=	O
iter	O
+	O
nTotal	O
;	O
}	O
iter	O
=	O
iter	O
+	O
1	int
;	O
}	O
if	O
(	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
3	int
)	O
||	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
4	int
)	O
)	O
{	O
PrintTemperatureDiagnostics	O
(	O
pgd	O
->	O
pfilePerks	O
,	O
pgd	O
)	O
;	O
}	O
if	O
(	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
0	int
)	O
||	O
(	O
pgd	O
->	O
nSimTypeFlag	O
>=	O
3	int
)	O
)	O
{	O
char	O
szKernelFile	O
[	O
MAX_FILENAMESIZE	O
+	O
7	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
szKernelFile	O
,	O
"%s%s"	*(char)
,	O
panal	O
->	O
gd	O
.	O
szGout	O
,	O
".kernel"	*(char)
)	O
;	O
FILE	struct
*	O
pfile	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
szKernelFile	O
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
pfile	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Cannot create kernel saving file '%s'\n"	*(char)
,	O
panal	O
->	O
gd	O
.	O
szGdata	O
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
TraverseLevels	O
(	O
pLevel0	O
,	O
WriteKernel	O
,	O
pfile	O
,	O
NULL	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfile	O
,	O
"\n"	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfile	O
)	O
;	O
printf	(*(char))->(int)
(	O
"Wrote kernel SDs to \"%s\"\n"	*(char)
,	O
szKernelFile	O
)	O
;	O
}	O
CloseMarkovFiles	O
(	O
pgd	O
)	O
;	O
}	O
BOOL	int
EqualSlopes	O
(	O
PDOUBLE	*(double)
x	*(*(double))
,	O
PDOUBLE	*(double)
y	O
,	O
int	O
i	O
)	O
{	O
double	O
s1	O
,	O
s2	O
;	O
s1	O
=	O
(	O
y	O
[	O
i	O
+	O
1	int
]	O
-	O
y	O
[	O
i	O
]	O
)	O
/	O
(	O
x	*(*(double))
[	O
i	O
+	O
1	int
]	O
-	O
x	*(*(double))
[	O
i	O
]	O
)	O
;	O
s2	O
=	O
(	O
y	O
[	O
i	O
+	O
2	int
]	O
-	O
y	O
[	O
i	O
]	O
)	O
/	O
(	O
x	*(*(double))
[	O
i	O
+	O
2	int
]	O
-	O
x	*(*(double))
[	O
i	O
]	O
)	O
;	O
return	O
(	O
fabs	(double)->(double)
(	O
s2	O
/	O
s1	O
-	O
1	int
)	O
<	O
SL_EPSILON	O
)	O
;	O
}	O
double	O
Extrapolate	O
(	O
PGIBBSDATA	O
pgd	O
,	O
double	O
dTargetX	O
,	O
int	O
i1	O
,	O
int	O
i2	O
)	O
{	O
return	O
(	O
pgd	O
->	O
rgdlnPi	O
[	O
i1	O
]	O
-	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
i1	O
]	O
-	O
dTargetX	O
)	O
*	O
(	O
pgd	O
->	O
rgdlnPi	O
[	O
i2	O
]	O
-	O
pgd	O
->	O
rgdlnPi	O
[	O
i1	O
]	O
)	O
/	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
i2	O
]	O
-	O
pgd	O
->	O
rgdPerks	O
[	O
i1	O
]	O
)	O
)	O
;	O
}	O
void	O
FindLikeParents	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
args	O
[	O
0	int
]	O
;	O
long	O
k	O
,	O
l	O
,	O
m	O
,	O
n	int
;	O
PLEVEL	O
pPrevLev	O
;	O
PMCVAR	O
pMCVar1	O
,	O
pMCVar2	O
;	O
BOOL	int
bFound	O
;	O
panal	O
->	O
pCurrentLevel	O
[	O
plevel	O
->	O
iDepth	O
]	O
=	O
plevel	O
;	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
plevel	O
->	O
nLikes	O
;	O
k	O
++	O
)	O
{	O
pMCVar1	O
=	O
plevel	O
->	O
rgpLikes	O
[	O
k	O
]	O
;	O
for	O
(	O
l	O
=	O
0	int
;	O
l	O
<	O
4	int
;	O
l	O
++	O
)	O
{	O
if	O
(	O
pMCVar1	O
->	O
iParmType	O
[	O
l	O
]	O
==	O
MCVP_PARM	O
)	O
{	O
bFound	O
=	O
FALSE	O
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
plevel	O
->	O
nMCVars	O
;	O
m	O
++	O
)	O
{	O
pMCVar2	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
m	O
]	O
;	O
if	O
(	O
pMCVar1	O
->	O
hParm	O
[	O
l	O
]	O
==	O
pMCVar2	O
->	O
hvar	long
)	O
{	O
pMCVar1	O
->	O
pMCVParent	O
[	O
l	O
]	O
=	O
pMCVar2	O
;	O
bFound	O
=	O
TRUE	O
;	O
}	O
}	O
if	O
(	O
!	O
bFound	O
)	O
{	O
for	O
(	O
n	int
=	O
plevel	O
->	O
iDepth	O
-	O
1	int
;	O
n	int
>=	O
0	int
;	O
n	int
--	O
)	O
{	O
pPrevLev	O
=	O
panal	O
->	O
pCurrentLevel	O
[	O
n	int
]	O
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
pPrevLev	O
->	O
nMCVars	O
;	O
m	O
++	O
)	O
{	O
pMCVar2	O
=	O
pPrevLev	O
->	O
rgpMCVars	O
[	O
m	O
]	O
;	O
if	O
(	O
pMCVar1	O
->	O
hParm	O
[	O
l	O
]	O
==	O
pMCVar2	O
->	O
hvar	long
)	O
{	O
pMCVar1	O
->	O
pMCVParent	O
[	O
l	O
]	O
=	O
pMCVar2	O
;	O
bFound	O
=	O
TRUE	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
bFound	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
"Error: parent in position %ld of %s must be\n"	*(char)
"       declared before it when creating\n"	*(char)
"       sampling dependencies - Exiting.\n\n"	*(char)
,	O
l	O
,	O
pMCVar1	O
->	O
pszName	O
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
void	O
FindMCDependents	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
long	O
i	O
,	O
j	O
;	O
PMCVAR	O
pMCVar	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
plevel	O
->	O
nMCVars	O
;	O
i	O
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
i	O
]	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
4	int
;	O
j	O
++	O
)	O
if	O
(	O
(	O
pMCVar	O
->	O
pMCVParent	O
[	O
j	O
]	O
!=	O
NULL	O
)	O
&&	O
(	O
pMCVar	O
->	O
pMCVParent	O
[	O
j	O
]	O
->	O
hvar	long
==	O
pMCVar	O
->	O
hParm	O
[	O
j	O
]	O
)	O
)	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
pMCVar	O
->	O
pMCVParent	O
[	O
j	O
]	O
->	O
plistDependents	O
,	O
pMCVar	O
)	O
;	O
}	O
}	O
void	O
FindMCParents	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
args	O
[	O
0	int
]	O
;	O
long	O
k	O
,	O
l	O
,	O
m	O
,	O
n	int
;	O
PLEVEL	O
pPrevLev	O
;	O
PMCVAR	O
pMCVar1	O
,	O
pMCVar2	O
;	O
BOOL	int
bFound	O
;	O
panal	O
->	O
pCurrentLevel	O
[	O
plevel	O
->	O
iDepth	O
]	O
=	O
plevel	O
;	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
plevel	O
->	O
nMCVars	O
;	O
k	O
++	O
)	O
{	O
pMCVar1	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
k	O
]	O
;	O
for	O
(	O
l	O
=	O
0	int
;	O
l	O
<	O
4	int
;	O
l	O
++	O
)	O
{	O
if	O
(	O
pMCVar1	O
->	O
iParmType	O
[	O
l	O
]	O
==	O
MCVP_PARM	O
)	O
{	O
bFound	O
=	O
FALSE	O
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
k	O
;	O
m	O
++	O
)	O
{	O
pMCVar2	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
m	O
]	O
;	O
if	O
(	O
pMCVar1	O
->	O
hParm	O
[	O
l	O
]	O
==	O
pMCVar2	O
->	O
hvar	long
)	O
{	O
pMCVar1	O
->	O
pMCVParent	O
[	O
l	O
]	O
=	O
pMCVar2	O
;	O
bFound	O
=	O
TRUE	O
;	O
}	O
}	O
if	O
(	O
!	O
bFound	O
)	O
{	O
for	O
(	O
n	int
=	O
plevel	O
->	O
iDepth	O
-	O
1	int
;	O
n	int
>=	O
0	int
;	O
n	int
--	O
)	O
{	O
pPrevLev	O
=	O
panal	O
->	O
pCurrentLevel	O
[	O
n	int
]	O
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
pPrevLev	O
->	O
nMCVars	O
;	O
m	O
++	O
)	O
{	O
pMCVar2	O
=	O
pPrevLev	O
->	O
rgpMCVars	O
[	O
m	O
]	O
;	O
if	O
(	O
pMCVar1	O
->	O
hParm	O
[	O
l	O
]	O
==	O
pMCVar2	O
->	O
hvar	long
)	O
{	O
pMCVar1	O
->	O
pMCVParent	O
[	O
l	O
]	O
=	O
pMCVar2	O
;	O
bFound	O
=	O
TRUE	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
bFound	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
"Error: parent in position %ld of %s must be\n"	*(char)
"       declared before it when creating\n"	*(char)
"       sampling dependencies - Exiting.\n\n"	*(char)
,	O
l	O
,	O
pMCVar1	O
->	O
pszName	O
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
void	O
GetNumberOfMCVars	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
long	O
*	O
pnThetas	O
=	O
(	O
long	O
*	O
)	O
args	O
[	O
0	int
]	O
;	O
*	O
pnThetas	O
+=	O
plevel	O
->	O
nMCVars	O
;	O
}	O
void	O
InitMCVars	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
long	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
if	O
(	O
!	O
(	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
->	O
bIsFixed	O
)	O
)	O
CalculateOneMCParm	O
(	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
)	O
;	O
}	O
void	O
ListToPMCArray	O
(	O
PANALYSIS	O
panal	O
,	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
long	O
*	O
pnMCVars	O
,	O
PMCVAR	O
*	O
*	O
rgpMCVars	O
)	O
{	O
if	O
(	O
(	O
*	O
pnMCVars	O
=	O
ListLength	O
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
)	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
(	O
*	O
rgpMCVars	O
=	O
(	O
PMCVAR	O
*	O
)	O
malloc	O
(	O
*	O
pnMCVars	O
*	O
sizeof	O
(	O
PMCVAR	O
)	O
)	O
)	O
)	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"ListToPMCArray"	*(char)
)	O
;	O
*	O
pnMCVars	O
=	O
0	int
;	O
ForAllList3	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void),*(void),*(void))->(void)),*(void),*(void),*(void))->(void)
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
&	O
ListToPMCArrayL	O
,	O
pnMCVars	O
,	O
*	O
rgpMCVars	O
,	O
NULL	O
)	O
;	O
}	O
void	O
ListToPMCArrayL	O
(	O
PVOID	*(void)
pData	*(void)
,	O
PVOID	*(void)
pUser1	O
,	O
PVOID	*(void)
pUser2	O
,	O
PVOID	*(void)
pUser3	O
)	O
{	O
PMCVAR	O
pMCVar	O
=	O
(	O
PMCVAR	O
)	O
pData	*(void)
;	O
long	O
*	O
pnMCVars	O
=	O
(	O
long	O
*	O
)	O
pUser1	O
;	O
PMCVAR	O
*	O
rgpMCVars	O
=	O
(	O
PMCVAR	O
*	O
)	O
pUser2	O
;	O
rgpMCVars	O
[	O
(	O
*	O
pnMCVars	O
)	O
++	O
]	O
=	O
pMCVar	O
;	O
}	O
void	O
ListToPVArray	O
(	O
PANALYSIS	O
panal	O
,	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
long	O
*	O
pnFixedVars	O
,	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
*	O
*	O
rgpFixedVars	O
)	O
{	O
if	O
(	O
(	O
*	O
pnFixedVars	O
=	O
ListLength	O
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
)	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
(	O
*	O
rgpFixedVars	O
=	O
(	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
*	O
)	O
malloc	O
(	O
*	O
pnFixedVars	O
*	O
sizeof	O
(	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
)	O
)	O
)	O
)	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"ListToPVArray"	*(char)
)	O
;	O
*	O
pnFixedVars	O
=	O
0	int
;	O
ForAllList3	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void),*(void),*(void))->(void)),*(void),*(void),*(void))->(void)
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
&	O
ListToPVArrayL	O
,	O
pnFixedVars	O
,	O
*	O
rgpFixedVars	O
,	O
NULL	O
)	O
;	O
}	O
void	O
ListToPVArrayL	O
(	O
PVOID	*(void)
pData	*(void)
,	O
PVOID	*(void)
pUser1	O
,	O
PVOID	*(void)
pUser2	O
,	O
PVOID	*(void)
pUser3	O
)	O
{	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
pVar	O
=	O
(	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
)	O
pData	*(void)
;	O
long	O
*	O
pnFixedVars	O
=	O
(	O
long	O
*	O
)	O
pUser1	O
;	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
*	O
rgpFixedVars	O
=	O
(	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
*	O
)	O
pUser2	O
;	O
rgpFixedVars	O
[	O
(	O
*	O
pnFixedVars	O
)	O
++	O
]	O
=	O
pVar	O
;	O
}	O
double	O
LnDensity	O
(	O
PMCVAR	O
pMCVar	O
,	O
PANALYSIS	O
panal	O
)	O
{	O
double	O
dTmp	O
=	O
0	int
,	O
density	O
;	O
double	O
dTmp2	O
,	O
dTmp3	O
,	O
dTmp4	O
;	O
double	O
dParm1	O
=	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
0	int
]	O
)	O
;	O
double	O
dParm2	O
=	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
1	int
]	O
)	O
;	O
double	O
dMin	O
=	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
2	int
]	O
)	O
;	O
double	O
dMax	O
=	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
3	int
]	O
)	O
;	O
double	O
dTheta	O
=	O
pMCVar	O
->	O
dVal	double
;	O
char	O
str	O
[	O
10	int
]	O
;	O
if	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_BINOMIALBETA	O
)	O
{	O
if	O
(	O
dTheta	O
<	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: variate out of bounds in LnDensity\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_GENLOGNORMAL	O
||	O
pMCVar	O
->	O
iType	int
==	O
MCV_STUDENTT	O
)	O
{	O
if	O
(	O
dParm1	O
<	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: parameter %g out of bounds in LnDensity\n"	*(char)
,	O
dParm1	O
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
dTheta	O
>	O
dMax	O
||	O
dTheta	O
<	O
dMin	O
)	O
{	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
}	O
}	O
switch	O
(	O
pMCVar	O
->	O
iType	int
)	O
{	O
case	O
MCV_UNIFORM	O
:	O
if	O
(	O
dTheta	O
>	O
dParm2	O
||	O
dTheta	O
<	O
dParm1	O
)	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
if	O
(	O
dParm2	O
<=	O
dParm1	O
)	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_BADUNIFORMDIST	O
|	O
RE_FATAL	O
,	O
pMCVar	O
->	O
pszName	O
,	O
"LnDensity"	*(char)
)	O
;	O
return	O
-	O
log	(double)->(double)
(	O
dParm2	O
-	O
dParm1	O
)	O
;	O
case	O
MCV_LOGUNIFORM	O
:	O
if	O
(	O
dTheta	O
>	O
dParm2	O
||	O
dTheta	O
<	O
dParm1	O
)	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
if	O
(	O
dParm2	O
<=	O
dParm1	O
)	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_BADUNIFORMDIST	O
|	O
RE_FATAL	O
,	O
pMCVar	O
->	O
pszName	O
,	O
"LnDensity"	*(char)
)	O
;	O
return	O
-	O
log	(double)->(double)
(	O
dTheta	O
*	O
(	O
dParm2	O
-	O
dParm1	O
)	O
)	O
;	O
case	O
MCV_NORMALV	O
:	O
dParm2	O
=	O
sqrt	(double)->(double)
(	O
dParm2	O
)	O
;	O
return	O
lnDFNormal	(double,double,double)->(double)
(	O
dTheta	O
,	O
dParm1	O
,	O
dParm2	O
)	O
;	O
case	O
MCV_NORMALCV	O
:	O
dParm2	O
=	O
fabs	(double)->(double)
(	O
dParm1	O
*	O
dParm2	O
)	O
;	O
return	O
lnDFNormal	(double,double,double)->(double)
(	O
dTheta	O
,	O
dParm1	O
,	O
dParm2	O
)	O
;	O
case	O
MCV_NORMAL	O
:	O
case	O
MCV_HALFNORMAL	O
:	O
return	O
lnDFNormal	(double,double,double)->(double)
(	O
dTheta	O
,	O
dParm1	O
,	O
dParm2	O
)	O
;	O
case	O
MCV_LOGNORMALV	O
:	O
dParm2	O
=	O
exp	(double)->(double)
(	O
sqrt	(double)->(double)
(	O
dParm2	O
)	O
)	O
;	O
case	O
MCV_LOGNORMAL	O
:	O
if	O
(	O
dParm1	O
<=	O
0.0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
str	O
,	O
"%5.2e"	*(char)
,	O
dParm1	O
)	O
;	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_BADLOGNORMALMEAN	O
|	O
RE_FATAL	O
,	O
pMCVar	O
->	O
pszName	O
,	O
str	O
,	O
"LnDensity"	*(char)
)	O
;	O
}	O
return	O
(	O
lnDFNormal	(double,double,double)->(double)
(	O
log	(double)->(double)
(	O
dTheta	O
)	O
,	O
log	(double)->(double)
(	O
dParm1	O
)	O
,	O
log	(double)->(double)
(	O
dParm2	O
)	O
)	O
-	O
log	(double)->(double)
(	O
dTheta	O
)	O
)	O
;	O
case	O
MCV_TRUNCNORMALV	O
:	O
dParm2	O
=	O
sqrt	(double)->(double)
(	O
dParm2	O
)	O
;	O
return	O
lnDFNormal	(double,double,double)->(double)
(	O
dTheta	O
,	O
dParm1	O
,	O
dParm2	O
)	O
-	O
log	(double)->(double)
(	O
CDFNormal	(double)->(double)
(	O
(	O
dMax	O
-	O
dParm1	O
)	O
/	O
dParm2	O
)	O
-	O
CDFNormal	(double)->(double)
(	O
(	O
dMin	O
-	O
dParm1	O
)	O
/	O
dParm2	O
)	O
)	O
;	O
case	O
MCV_TRUNCNORMALCV	O
:	O
dParm2	O
=	O
fabs	(double)->(double)
(	O
dParm1	O
*	O
dParm2	O
)	O
;	O
return	O
lnDFNormal	(double,double,double)->(double)
(	O
dTheta	O
,	O
dParm1	O
,	O
dParm2	O
)	O
-	O
log	(double)->(double)
(	O
CDFNormal	(double)->(double)
(	O
(	O
dMax	O
-	O
dParm1	O
)	O
/	O
dParm2	O
)	O
-	O
CDFNormal	(double)->(double)
(	O
(	O
dMin	O
-	O
dParm1	O
)	O
/	O
dParm2	O
)	O
)	O
;	O
case	O
MCV_TRUNCNORMAL	O
:	O
if	O
(	O
dParm2	O
<=	O
0.0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
str	O
,	O
"%5.2e"	*(char)
,	O
dParm2	O
)	O
;	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_BADNORMALSD	O
|	O
RE_FATAL	O
,	O
pMCVar	O
->	O
pszName	O
,	O
str	O
,	O
"LnDensity"	*(char)
)	O
;	O
}	O
return	O
lnDFNormal	(double,double,double)->(double)
(	O
dTheta	O
,	O
dParm1	O
,	O
dParm2	O
)	O
-	O
log	(double)->(double)
(	O
CDFNormal	(double)->(double)
(	O
(	O
dMax	O
-	O
dParm1	O
)	O
/	O
dParm2	O
)	O
-	O
CDFNormal	(double)->(double)
(	O
(	O
dMin	O
-	O
dParm1	O
)	O
/	O
dParm2	O
)	O
)	O
;	O
case	O
MCV_TRUNCLOGNORMALV	O
:	O
dParm2	O
=	O
exp	(double)->(double)
(	O
sqrt	(double)->(double)
(	O
dParm2	O
)	O
)	O
;	O
case	O
MCV_TRUNCLOGNORMAL	O
:	O
if	O
(	O
dParm1	O
<=	O
0.0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
str	O
,	O
"%5.2e"	*(char)
,	O
dParm1	O
)	O
;	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_BADLOGNORMALMEAN	O
|	O
RE_FATAL	O
,	O
pMCVar	O
->	O
pszName	O
,	O
str	O
,	O
"LnDensity"	*(char)
)	O
;	O
}	O
if	O
(	O
dParm2	O
<=	O
1.0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
str	O
,	O
"%5.2e"	*(char)
,	O
dParm2	O
)	O
;	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_BADLOGNORMALSD	O
|	O
RE_FATAL	O
,	O
pMCVar	O
->	O
pszName	O
,	O
str	O
,	O
"LnDensity"	*(char)
)	O
;	O
}	O
dTmp	O
=	O
log	(double)->(double)
(	O
dParm2	O
)	O
;	O
return	O
lnDFNormal	(double,double,double)->(double)
(	O
log	(double)->(double)
(	O
dTheta	O
)	O
,	O
log	(double)->(double)
(	O
dParm1	O
)	O
,	O
dTmp	O
)	O
-	O
log	(double)->(double)
(	O
dTheta	O
)	O
-	O
log	(double)->(double)
(	O
CDFNormal	(double)->(double)
(	O
log	(double)->(double)
(	O
dMax	O
/	O
dParm1	O
)	O
/	O
dTmp	O
)	O
-	O
CDFNormal	(double)->(double)
(	O
log	(double)->(double)
(	O
dMin	O
/	O
dParm1	O
)	O
/	O
dTmp	O
)	O
)	O
;	O
case	O
MCV_BETA	O
:	O
return	O
lnDFBeta	(double,double,double,double,double)->(double)
(	O
dTheta	O
,	O
dParm1	O
,	O
dParm2	O
,	O
dMin	O
,	O
dMax	O
)	O
;	O
case	O
MCV_CHI2	O
:	O
dTmp	O
=	O
0.5	int
*	O
dParm1	O
;	O
return	O
(	O
dTmp	O
-	O
1	int
)	O
*	O
log	(double)->(double)
(	O
dTheta	O
)	O
-	O
0.5	int
*	O
dTheta	O
+	O
dTmp	O
*	O
(	O
-	O
6.9314718056E-01	int
)	O
-	O
lnGamma	(double)->(double)
(	O
dTmp	O
)	O
;	O
case	O
MCV_BINOMIAL	O
:	O
if	O
(	O
(	O
dParm1	O
<	O
0	int
)	O
||	O
(	O
dParm1	O
>	O
1	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad p for binomial variate in LnDensity\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
dTheta	O
>	O
dParm2	O
)	O
{	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
}	O
dTmp	O
=	O
lnGamma	(double)->(double)
(	O
dParm2	O
+	O
1	int
)	O
-	O
lnGamma	(double)->(double)
(	O
dTheta	O
+	O
1	int
)	O
-	O
lnGamma	(double)->(double)
(	O
dParm2	O
-	O
dTheta	O
+	O
1	int
)	O
;	O
if	O
(	O
dParm1	O
==	O
0	int
)	O
{	O
if	O
(	O
dTheta	O
!=	O
0	int
)	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
}	O
else	O
dTmp	O
=	O
dTmp	O
+	O
dTheta	O
*	O
log	(double)->(double)
(	O
dParm1	O
)	O
;	O
if	O
(	O
dParm1	O
==	O
1	int
)	O
{	O
if	O
(	O
(	O
dParm2	O
-	O
dTheta	O
)	O
==	O
0	int
)	O
return	O
dTmp	O
;	O
else	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
}	O
else	O
return	O
dTmp	O
+	O
(	O
dParm2	O
-	O
dTheta	O
)	O
*	O
log	(double)->(double)
(	O
1	int
-	O
dParm1	O
)	O
;	O
case	O
MCV_PIECEWISE	O
:	O
density	O
=	O
2	int
/	O
(	O
dMax	O
+	O
dParm2	O
-	O
dParm1	O
-	O
dMin	O
)	O
;	O
if	O
(	O
dTheta	O
<=	O
dParm1	O
)	O
return	O
log	(double)->(double)
(	O
density	O
*	O
(	O
dTheta	O
-	O
dMin	O
)	O
/	O
(	O
dParm1	O
-	O
dMin	O
)	O
)	O
;	O
else	O
if	O
(	O
dTheta	O
<=	O
dParm2	O
)	O
return	O
log	(double)->(double)
(	O
density	O
)	O
;	O
else	O
return	O
log	(double)->(double)
(	O
density	O
*	O
(	O
dMax	O
-	O
dTheta	O
)	O
/	O
(	O
dMax	O
-	O
dParm2	O
)	O
)	O
;	O
case	O
MCV_EXPONENTIAL	O
:	O
if	O
(	O
dParm1	O
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: negative or null inverse scale (%g) for exponential "	*(char)
"variate in LnDensity\n"	*(char)
,	O
dParm1	O
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
return	O
-	O
dTheta	O
*	O
dParm1	O
+	O
log	(double)->(double)
(	O
dParm1	O
)	O
;	O
case	O
MCV_GGAMMA	O
:	O
if	O
(	O
dParm2	O
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad inv. scale for gamma variate in LnDensity\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
dParm1	O
-	O
1	int
)	O
*	O
log	(double)->(double)
(	O
dTheta	O
)	O
-	O
dParm2	O
*	O
dTheta	O
+	O
dParm1	O
*	O
log	(double)->(double)
(	O
dParm2	O
)	O
-	O
lnGamma	(double)->(double)
(	O
dParm1	O
)	O
;	O
case	O
MCV_TRUNCINVGGAMMA	O
:	O
printf	(*(char))->(int)
(	O
"Error: Truncated inverse gamma density cannot be evaluated\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"       if the GNU Scientific Library is not installed\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
case	O
MCV_INVGGAMMA	O
:	O
if	O
(	O
dParm2	O
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad scale for inv. gamma variate in LnDensity\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
-	O
dParm1	O
-	O
1	int
)	O
*	O
log	(double)->(double)
(	O
dTheta	O
)	O
-	O
dParm2	O
/	O
dTheta	O
+	O
dParm1	O
*	O
log	(double)->(double)
(	O
dParm2	O
)	O
-	O
lnGamma	(double)->(double)
(	O
dParm1	O
)	O
-	O
dTmp	O
;	O
case	O
MCV_POISSON	O
:	O
if	O
(	O
dParm1	O
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad rate for Poisson variate in LnDensity\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
return	O
dTheta	O
*	O
log	(double)->(double)
(	O
dParm1	O
)	O
-	O
dParm1	O
-	O
lnGamma	(double)->(double)
(	O
dTheta	O
+	O
1	int
)	O
;	O
case	O
MCV_BINOMIALBETA	O
:	O
if	O
(	O
dParm1	O
<	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad expectation for BinomialBeta variate "	*(char)
"in LnDensity\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
dParm2	O
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad alpha for BinomialBeta variate in LnDensity\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
dMin	O
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad beta for BinomialBeta variate in LnDensity\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
dTmp	O
=	O
floor	(double)->(double)
(	O
0.5	int
+	O
dParm1	O
+	O
dParm1	O
*	O
dMin	O
/	O
dParm2	O
)	O
;	O
if	O
(	O
dTheta	O
>	O
dTmp	O
)	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
else	O
{	O
if	O
(	O
(	O
dParm2	O
==	O
0.5	int
)	O
&&	O
(	O
dMin	O
==	O
0.5	int
)	O
)	O
dTmp	O
=	O
lnGamma	(double)->(double)
(	O
0.5	int
+	O
dTheta	O
)	O
+	O
lnGamma	(double)->(double)
(	O
0.5	int
+	O
dTmp	O
-	O
dTheta	O
)	O
-	O
lnGamma	(double)->(double)
(	O
dTheta	O
+	O
1	int
)	O
-	O
lnGamma	(double)->(double)
(	O
dTmp	O
-	O
dTheta	O
+	O
1	int
)	O
;	O
else	O
dTmp	O
=	O
lnGamma	(double)->(double)
(	O
dParm2	O
+	O
dMin	O
)	O
+	O
lnGamma	(double)->(double)
(	O
dTmp	O
+	O
1	int
)	O
+	O
lnGamma	(double)->(double)
(	O
dParm2	O
+	O
dTheta	O
)	O
+	O
lnGamma	(double)->(double)
(	O
dMin	O
+	O
dTmp	O
-	O
dTheta	O
)	O
-	O
lnGamma	(double)->(double)
(	O
dTheta	O
+	O
1	int
)	O
-	O
lnGamma	(double)->(double)
(	O
dTmp	O
-	O
dTheta	O
+	O
1	int
)	O
-	O
lnGamma	(double)->(double)
(	O
dParm2	O
)	O
-	O
lnGamma	(double)->(double)
(	O
dMin	O
)	O
-	O
lnGamma	(double)->(double)
(	O
dParm2	O
+	O
dMin	O
+	O
dTmp	O
)	O
;	O
return	O
dTmp	O
;	O
}	O
case	O
MCV_GENLOGNORMAL	O
:	O
if	O
(	O
dParm1	O
<	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad expectation for GenLogNormal variate "	*(char)
"in LnDensity\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
dTmp	O
=	O
sqrt	(double)->(double)
(	O
exp	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
dMin	O
,	O
2	int
)	O
)	O
*	O
(	O
exp	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
dMin	O
,	O
2	int
)	O
)	O
-	O
1	int
)	O
)	O
;	O
dTmp2	O
=	O
pow	(double,double)->(double)
(	O
dParm2	O
/	O
dTmp	O
,	O
2	int
)	O
;	O
dTmp3	O
=	O
log	(double)->(double)
(	O
dParm1	O
+	O
sqrt	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
dParm1	O
,	O
2	int
)	O
+	O
dTmp2	O
)	O
)	O
;	O
if	O
(	O
(	O
dTheta	O
<	O
0	int
)	O
&&	O
(	O
dTmp2	O
<	O
(	O
0.01	int
*	O
dTheta	O
*	O
dTheta	O
)	O
)	O
)	O
dTmp4	O
=	O
log	(double)->(double)
(	O
dTmp2	O
/	O
(	O
-	O
2	int
*	O
dTheta	O
)	O
*	O
(	O
1	int
+	O
0.25	int
*	O
dTmp2	O
/	O
pow	(double,double)->(double)
(	O
dTheta	O
,	O
2	int
)	O
)	O
)	O
;	O
else	O
dTmp4	O
=	O
log	(double)->(double)
(	O
dTheta	O
+	O
sqrt	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
dTheta	O
,	O
2	int
)	O
+	O
dTmp2	O
)	O
)	O
;	O
return	O
lnDFNormal	(double,double,double)->(double)
(	O
dTmp4	O
,	O
dTmp3	O
,	O
dTmp	O
)	O
-	O
0.5	int
*	O
log	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
dTmp4	O
,	O
2	int
)	O
+	O
dTmp2	O
)	O
;	O
case	O
MCV_STUDENTT	O
:	O
if	O
(	O
dParm1	O
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad dof for Student-T variate"	*(char)
"in LnDensity\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
dTmp	O
=	O
(	O
dParm1	O
+	O
1	int
)	O
/	O
2	int
;	O
return	O
(	O
lnGamma	(double)->(double)
(	O
dTmp	O
)	O
-	O
lnGamma	(double)->(double)
(	O
dParm1	O
/	O
2	int
)	O
-	O
0.5	int
*	O
log	(double)->(double)
(	O
dParm1	O
*	O
PI	O
*	O
dMin	O
*	O
dMin	O
)	O
-	O
dTmp	O
*	O
log	(double)->(double)
(	O
1	int
+	O
pow	(double,double)->(double)
(	O
(	O
dTheta	O
-	O
dParm2	O
)	O
/	O
dMin	O
,	O
2	int
)	O
/	O
dParm1	O
)	O
)	O
;	O
case	O
MCV_CAUCHY	O
:	O
return	O
(	O
LNINVERPI	O
-	O
log	(double)->(double)
(	O
dParm1	O
+	O
dTheta	O
*	O
dTheta	O
/	O
dParm1	O
)	O
)	O
;	O
case	O
MCV_HALFCAUCHY	O
:	O
return	O
(	O
LN2OVERPI	O
-	O
log	(double)->(double)
(	O
dParm1	O
+	O
dTheta	O
*	O
dTheta	O
/	O
dParm1	O
)	O
)	O
;	O
case	O
MCV_USERLL	O
:	O
return	O
(	O
dParm1	O
)	O
;	O
default	O
:	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_UNKNOWNDIST	O
|	O
RE_FATAL	O
,	O
"LnDensity"	*(char)
)	O
;	O
}	O
return	O
0.0	int
;	O
}	O
double	O
LnLike	O
(	O
PMCVAR	O
pMCVar	O
,	O
PANALYSIS	O
panal	O
)	O
{	O
long	O
n	int
;	O
double	O
dDensity	O
,	O
dLnLike	O
=	O
0.0	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
pMCVar	O
->	O
nDependents	O
;	O
n	int
++	O
)	O
{	O
dDensity	O
=	O
LnDensity	O
(	O
pMCVar	O
->	O
rgpDependents	O
[	O
n	int
]	O
,	O
panal	O
)	O
;	O
if	O
(	O
dDensity	O
==	O
NULL_SUPPORT	O
)	O
return	O
NULL_SUPPORT	O
;	O
else	O
dLnLike	O
+=	O
dDensity	O
;	O
}	O
return	O
dLnLike	O
;	O
}	O
double	O
LnLikeData	O
(	O
PLEVEL	O
plevel	O
,	O
PANALYSIS	O
panal	O
)	O
{	O
PMCVAR	O
pMCVar	O
;	O
long	O
i	O
,	O
j	O
,	O
k	O
;	O
double	O
dLnLike	O
=	O
0.0	int
;	O
double	O
dTmp	O
;	O
BOOL	int
bMissData	O
,	O
bMissOutp	O
;	O
static	O
PDOUBLE	*(double)
pdBase	O
[	O
4	int
]	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
plevel	O
->	O
nLikes	O
;	O
i	O
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpLikes	O
[	O
i	O
]	O
;	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
4	int
;	O
k	O
++	O
)	O
pdBase	O
[	O
k	O
]	O
=	O
pMCVar	O
->	O
pdParm	O
[	O
k	O
]	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
pMCVar	O
->	O
lCount	O
;	O
j	O
++	O
)	O
{	O
pMCVar	O
->	O
dVal	double
=	O
pMCVar	O
->	O
pdVal	O
[	O
j	O
]	O
;	O
if	O
(	O
pMCVar	O
->	O
dVal	double
!=	O
INPUT_MISSING_VALUE	O
)	O
{	O
bMissData	O
=	O
FALSE	O
;	O
bMissOutp	O
=	O
FALSE	O
;	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
4	int
;	O
k	O
++	O
)	O
{	O
if	O
(	O
pMCVar	O
->	O
iParmType	O
[	O
k	O
]	O
==	O
MCVP_PRED	O
)	O
{	O
pMCVar	O
->	O
pdParm	O
[	O
k	O
]	O
=	O
pdBase	O
[	O
k	O
]	O
+	O
j	O
;	O
bMissOutp	O
=	O
bMissOutp	O
+	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
k	O
]	O
)	O
==	O
MISSING_VALUE	O
)	O
;	O
}	O
else	O
if	O
(	O
pMCVar	O
->	O
iParmType	O
[	O
k	O
]	O
==	O
MCVP_DATA	O
)	O
{	O
pMCVar	O
->	O
pdParm	O
[	O
k	O
]	O
=	O
pdBase	O
[	O
k	O
]	O
+	O
j	O
;	O
bMissData	O
=	O
bMissData	O
+	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
k	O
]	O
)	O
==	O
INPUT_MISSING_VALUE	O
)	O
;	O
}	O
}	O
if	O
(	O
bMissData	O
==	O
FALSE	O
)	O
{	O
if	O
(	O
bMissOutp	O
==	O
FALSE	O
)	O
{	O
dTmp	O
=	O
LnDensity	O
(	O
pMCVar	O
,	O
panal	O
)	O
;	O
if	O
(	O
dTmp	O
==	O
NULL_SUPPORT	O
)	O
{	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
4	int
;	O
k	O
++	O
)	O
pMCVar	O
->	O
pdParm	O
[	O
k	O
]	O
=	O
pdBase	O
[	O
k	O
]	O
;	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
}	O
else	O
dLnLike	O
=	O
dLnLike	O
+	O
dTmp	O
;	O
}	O
else	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_BADMODEL	O
|	O
RE_FATAL	O
,	O
"LnLikeData"	*(char)
)	O
;	O
}	O
}	O
}	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
4	int
;	O
k	O
++	O
)	O
pMCVar	O
->	O
pdParm	O
[	O
k	O
]	O
=	O
pdBase	O
[	O
k	O
]	O
;	O
}	O
return	O
(	O
dLnLike	O
)	O
;	O
}	O
double	O
MaxMCVar	O
(	O
PMCVAR	O
pMCVar	O
)	O
{	O
if	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_BINOMIAL	O
||	O
pMCVar	O
->	O
iType	int
==	O
MCV_POISSON	O
)	O
{	O
return	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
3	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_UNIFORM	O
||	O
pMCVar	O
->	O
iType	int
==	O
MCV_LOGUNIFORM	O
)	O
{	O
return	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
1	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
return	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
3	int
]	O
)	O
)	O
;	O
}	O
}	O
}	O
double	O
MinMCVar	O
(	O
PMCVAR	O
pMCVar	O
)	O
{	O
if	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_BINOMIAL	O
||	O
pMCVar	O
->	O
iType	int
==	O
MCV_POISSON	O
)	O
{	O
return	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
2	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_UNIFORM	O
||	O
pMCVar	O
->	O
iType	int
==	O
MCV_LOGUNIFORM	O
)	O
{	O
return	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
0	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
return	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
2	int
]	O
)	O
)	O
;	O
}	O
}	O
}	O
void	O
RunTemperingBlock	O
(	O
PANALYSIS	O
panal	O
,	O
long	O
lRunLength	O
,	O
PLONG	*(long)
iter	O
)	O
{	O
PGIBBSDATA	O
pgd	O
=	O
&	O
panal	O
->	O
gd	O
;	O
PLEVEL	O
pLevel0	O
=	O
panal	O
->	O
pLevels	O
[	O
0	int
]	O
;	O
double	O
dTmp	O
,	O
dLnPrior	O
=	O
0	int
,	O
dLnData	O
=	O
0	int
;	O
long	O
i	O
,	O
j	O
;	O
long	O
nUpdateAt	O
,	O
nTotal	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
lRunLength	O
;	O
i	O
++	O
)	O
{	O
nTotal	O
=	O
UPDATE_BASE	O
;	O
nUpdateAt	O
=	O
*	O
iter	O
+	O
nTotal	O
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
SampleThetasTempered	O
,	O
panal	O
,	O
pgd	O
,	O
&	O
i	O
,	O
&	O
nUpdateAt	O
,	O
&	O
nTotal	O
,	O
&	O
pgd	O
->	O
indexT	O
,	O
NULL	O
)	O
;	O
dLnPrior	O
=	O
0.0	int
;	O
TraverseLevels	O
(	O
pLevel0	O
,	O
CalculateTotals	O
,	O
panal	O
,	O
&	O
dLnPrior	O
,	O
NULL	O
)	O
;	O
dLnData	O
=	O
0.0	int
;	O
TraverseLevels1	O
(	O
pLevel0	O
,	O
SumAllExpts	O
,	O
&	O
dLnData	O
,	O
NULL	O
)	O
;	O
dTmp	O
=	O
pgd	O
->	O
dCZero	O
/	O
(	O
double	O
)	O
(	O
i	O
+	O
pgd	O
->	O
dNZero	O
)	O
;	O
for	O
(	O
j	O
=	O
pgd	O
->	O
startT	O
;	O
j	O
<=	O
pgd	O
->	O
endT	O
;	O
j	O
++	O
)	O
{	O
if	O
(	O
j	O
==	O
pgd	O
->	O
indexT	O
)	O
pgd	O
->	O
rgdlnPi	O
[	O
j	O
]	O
-=	O
dTmp	O
;	O
else	O
pgd	O
->	O
rgdlnPi	O
[	O
j	O
]	O
+=	O
dTmp	O
/	O
(	O
double	O
)	O
pgd	O
->	O
nPerks	O
;	O
}	O
pgd	O
->	O
rglCount	O
[	O
pgd	O
->	O
indexT	O
]	O
=	O
pgd	O
->	O
rglCount	O
[	O
pgd	O
->	O
indexT	O
]	O
+	O
1	int
;	O
pgd	O
->	O
indexT	O
=	O
SampleTemperature2	O
(	O
pgd	O
,	O
dLnPrior	O
,	O
dLnData	O
)	O
;	O
if	O
(	O
i	O
==	O
nUpdateAt	O
)	O
{	O
nTotal	O
=	O
nTotal	O
*	O
3	int
/	O
2	int
;	O
nUpdateAt	O
=	O
i	O
+	O
nTotal	O
;	O
}	O
(	O
*	O
iter	O
)	O
++	O
;	O
}	O
}	O
double	O
NextDown	O
(	O
double	O
Perk	O
)	O
{	O
int	O
i	O
;	O
static	O
double	O
PTable	O
[	O
21	int
]	O
=	O
{	O
0	int
,	O
1E-6	int
,	O
1E-5	int
,	O
1E-4	int
,	O
1E-3	int
,	O
1E-2	int
,	O
0.1	int
,	O
0.2	int
,	O
0.3	int
,	O
0.5	int
,	O
0.6	int
,	O
0.7	int
,	O
0.8	int
,	O
0.9	int
,	O
0.95	int
,	O
0.97	int
,	O
0.99	int
,	O
0.999	int
,	O
0.9999	int
,	O
0.99999	int
,	O
1	int
}	O
;	O
i	O
=	O
0	int
;	O
while	O
(	O
Perk	O
>	O
PTable	O
[	O
i	O
]	O
)	O
{	O
i	O
++	O
;	O
}	O
return	O
(	O
i	O
==	O
0	int
?	O
PTable	O
[	O
i	O
]	O
:	O
PTable	O
[	O
i	O
-	O
1	int
]	O
)	O
;	O
}	O
void	O
InitPerks	O
(	O
PANALYSIS	O
panal	O
)	O
{	O
PGIBBSDATA	O
pgd	O
=	O
&	O
panal	O
->	O
gd	O
;	O
long	O
i	O
,	O
j	O
,	O
k	O
,	O
iter	O
=	O
0	int
;	O
double	O
dTmp	O
;	O
int	O
bTrans	O
;	O
BOOL	int
bHappy	O
,	O
bTooManyTrials	O
;	O
if	O
(	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
3	int
)	O
||	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
4	int
)	O
)	O
{	O
if	O
(	O
!	O
(	O
pgd	O
->	O
rglTransAttempts	O
=	O
InitlVector	(long)->(*(long))
(	O
NTEMP	O
)	O
)	O
||	O
!	O
(	O
pgd	O
->	O
rglTransAccepts	O
=	O
InitlVector	(long)->(*(long))
(	O
NTEMP	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"InitPerks"	*(char)
,	O
NULL	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
NTEMP	O
;	O
i	O
++	O
)	O
pgd	O
->	O
rglTransAttempts	O
[	O
i	O
]	O
=	O
pgd	O
->	O
rglTransAccepts	O
[	O
i	O
]	O
=	O
0	int
;	O
if	O
(	O
pgd	O
->	O
nPerks	O
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Setting perks (inverse temperatures).\n"	*(char)
)	O
;	O
pgd	O
->	O
nPerks	O
=	O
NTEMP	O
;	O
if	O
(	O
!	O
(	O
pgd	O
->	O
rgdPerks	O
=	O
InitdVector	(long)->(*(double))
(	O
NTEMP	O
)	O
)	O
||	O
!	O
(	O
pgd	O
->	O
rgdlnPi	O
=	O
InitdVector	(long)->(*(double))
(	O
NTEMP	O
)	O
)	O
||	O
!	O
(	O
pgd	O
->	O
rglCount	O
=	O
InitlVector	(long)->(*(long))
(	O
NTEMP	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"InitPerks"	*(char)
,	O
NULL	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
NTEMP	O
;	O
i	O
++	O
)	O
{	O
pgd	O
->	O
rgdPerks	O
[	O
i	O
]	O
=	O
pgd	O
->	O
rgdlnPi	O
[	O
i	O
]	O
=	O
pgd	O
->	O
rglCount	O
[	O
i	O
]	O
=	O
0	int
;	O
}	O
pgd	O
->	O
endT	O
=	O
NTEMP	O
-	O
1	int
;	O
pgd	O
->	O
startT	O
=	O
NTEMP	O
-	O
2	int
;	O
pgd	O
->	O
indexT	O
=	O
pgd	O
->	O
startT	O
;	O
double	O
dEPSILON	O
=	O
0.99	int
;	O
double	O
dUP	O
=	O
2.0	int
;	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
startT	O
]	O
=	O
dEPSILON	O
;	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
endT	O
]	O
=	O
1.00	int
;	O
long	O
nOldPrintIter	O
=	O
pgd	O
->	O
nPrintIter	O
;	O
pgd	O
->	O
nPrintIter	O
=	O
-	O
pgd	O
->	O
nMaxPerkSetIter	O
;	O
int	O
lRunLength	O
=	O
100	int
;	O
double	O
dBoundary	O
=	O
0.0	int
;	O
do	O
{	O
pgd	O
->	O
indexT	O
=	O
pgd	O
->	O
startT	O
;	O
RunTemperingBlock	O
(	O
panal	O
,	O
lRunLength	O
,	O
&	O
iter	O
)	O
;	O
PrintTemperatureDiagnostics	O
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
pgd	O
)	O
;	O
PrintTemperatureDiagnostics	O
(	O
pgd	O
->	O
pfilePerks	O
,	O
pgd	O
)	O
;	O
bTrans	O
=	O
CheckTransitions	O
(	O
pgd	O
)	O
;	O
if	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
startT	O
]	O
==	O
dBoundary	O
)	O
{	O
bHappy	O
=	O
(	O
bTrans	O
>	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
bHappy	O
=	O
FALSE	O
;	O
}	O
bTooManyTrials	O
=	O
(	O
iter	O
>	O
pgd	O
->	O
nMaxPerkSetIter	O
)	O
;	O
if	O
(	O
!	O
bHappy	O
)	O
{	O
if	O
(	O
bTrans	O
==	O
-	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"acceptance rate 1<->2 too low, stepping back up\n"	*(char)
)	O
;	O
dTmp	O
=	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
startT	O
]	O
+	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
startT	O
+	O
1	int
]	O
)	O
/	O
dUP	O
;	O
pgd	O
->	O
rgdlnPi	O
[	O
pgd	O
->	O
startT	O
]	O
=	O
(	O
pgd	O
->	O
rgdlnPi	O
[	O
pgd	O
->	O
startT	O
]	O
+	O
Extrapolate	O
(	O
pgd	O
,	O
dTmp	O
,	O
pgd	O
->	O
startT	O
,	O
pgd	O
->	O
startT	O
+	O
1	int
)	O
)	O
/	O
2	int
;	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
startT	O
]	O
=	O
dTmp	O
;	O
}	O
if	O
(	O
bTrans	O
==	O
+	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"acceptance rate 1<->2 too high, moving down\n"	*(char)
)	O
;	O
dTmp	O
=	O
NextDown	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
startT	O
]	O
)	O
;	O
pgd	O
->	O
rgdlnPi	O
[	O
pgd	O
->	O
startT	O
]	O
=	O
(	O
pgd	O
->	O
rgdlnPi	O
[	O
pgd	O
->	O
startT	O
]	O
+	O
Extrapolate	O
(	O
pgd	O
,	O
dTmp	O
,	O
pgd	O
->	O
startT	O
,	O
pgd	O
->	O
startT	O
+	O
1	int
)	O
)	O
/	O
2	int
;	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
startT	O
]	O
=	O
dTmp	O
;	O
}	O
if	O
(	O
bTrans	O
==	O
0	int
)	O
{	O
if	O
(	O
pgd	O
->	O
startT	O
>	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"acceptance rate 1<->2 ok, adding a new point\n"	*(char)
)	O
;	O
if	O
(	O
CheckAllTransitions	O
(	O
pgd	O
)	O
)	O
{	O
int	O
i	O
=	O
pgd	O
->	O
endT	O
;	O
int	O
j	O
=	O
i	O
-	O
2	int
;	O
while	O
(	O
j	O
>=	O
pgd	O
->	O
startT	O
)	O
{	O
if	O
(	O
EqualSlopes	O
(	O
pgd	O
->	O
rgdPerks	O
,	O
pgd	O
->	O
rgdlnPi	O
,	O
j	O
)	O
)	O
{	O
for	O
(	O
k	O
=	O
j	O
;	O
k	O
>=	O
pgd	O
->	O
startT	O
;	O
k	O
--	O
)	O
{	O
pgd	O
->	O
rgdPerks	O
[	O
k	O
+	O
1	int
]	O
=	O
pgd	O
->	O
rgdPerks	O
[	O
k	O
]	O
;	O
pgd	O
->	O
rgdlnPi	O
[	O
k	O
+	O
1	int
]	O
=	O
pgd	O
->	O
rgdlnPi	O
[	O
k	O
]	O
;	O
pgd	O
->	O
rglCount	O
[	O
k	O
+	O
1	int
]	O
=	O
pgd	O
->	O
rglCount	O
[	O
k	O
]	O
;	O
}	O
pgd	O
->	O
startT	O
++	O
;	O
if	O
(	O
pgd	O
->	O
indexT	O
<=	O
j	O
)	O
pgd	O
->	O
indexT	O
++	O
;	O
lRunLength	O
=	O
lRunLength	O
-	O
100	int
;	O
printf	(*(char))->(int)
(	O
"Scale has been reduced.\n"	*(char)
)	O
;	O
}	O
else	O
{	O
i	O
--	O
;	O
j	O
--	O
;	O
}	O
}	O
}	O
pgd	O
->	O
startT	O
=	O
pgd	O
->	O
startT	O
-	O
1	int
;	O
pgd	O
->	O
indexT	O
=	O
pgd	O
->	O
startT	O
;	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
startT	O
]	O
=	O
NextDown	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
startT	O
+	O
1	int
]	O
)	O
;	O
pgd	O
->	O
rgdlnPi	O
[	O
pgd	O
->	O
startT	O
]	O
=	O
(	O
pgd	O
->	O
rgdlnPi	O
[	O
pgd	O
->	O
startT	O
+	O
1	int
]	O
+	O
Extrapolate	O
(	O
pgd	O
,	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
startT	O
]	O
,	O
pgd	O
->	O
startT	O
+	O
1	int
,	O
pgd	O
->	O
startT	O
+	O
2	int
)	O
)	O
/	O
2	int
;	O
lRunLength	O
=	O
lRunLength	O
+	O
100	int
;	O
}	O
else	O
bTooManyTrials	O
=	O
TRUE	O
;	O
}	O
for	O
(	O
i	O
=	O
pgd	O
->	O
startT	O
;	O
i	O
<=	O
pgd	O
->	O
endT	O
;	O
i	O
++	O
)	O
{	O
pgd	O
->	O
rglCount	O
[	O
i	O
]	O
=	O
0	int
;	O
pgd	O
->	O
rglTransAttempts	O
[	O
i	O
]	O
=	O
pgd	O
->	O
rglTransAccepts	O
[	O
i	O
]	O
=	O
0	int
;	O
}	O
}	O
}	O
while	O
(	O
(	O
!	O
bHappy	O
)	O
&&	O
(	O
!	O
bTooManyTrials	O
)	O
)	O
;	O
if	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
pgd	O
->	O
startT	O
]	O
==	O
dBoundary	O
)	O
printf	(*(char))->(int)
(	O
"Perk %lg reached in %ld iterations.\n"	*(char)
,	O
dBoundary	O
,	O
iter	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"Perk %lg not reached in %ld iterations...\n"	*(char)
,	O
dBoundary	O
,	O
iter	O
)	O
;	O
pgd	O
->	O
nPrintIter	O
=	O
nOldPrintIter	O
;	O
int	O
iCount	O
=	O
pgd	O
->	O
endT	O
-	O
pgd	O
->	O
startT	O
+	O
1	int
;	O
if	O
(	O
iCount	O
!=	O
NTEMP	O
)	O
{	O
pgd	O
->	O
nPerks	O
=	O
iCount	O
;	O
pgd	O
->	O
indexT	O
=	O
pgd	O
->	O
indexT	O
-	O
pgd	O
->	O
startT	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
iCount	O
;	O
i	O
++	O
)	O
{	O
j	O
=	O
pgd	O
->	O
startT	O
+	O
i	O
;	O
pgd	O
->	O
rgdPerks	O
[	O
i	O
]	O
=	O
pgd	O
->	O
rgdPerks	O
[	O
j	O
]	O
;	O
pgd	O
->	O
rgdlnPi	O
[	O
i	O
]	O
=	O
pgd	O
->	O
rgdlnPi	O
[	O
j	O
]	O
;	O
pgd	O
->	O
rglCount	O
[	O
i	O
]	O
=	O
0	int
;	O
}	O
pgd	O
->	O
startT	O
=	O
0	int
;	O
pgd	O
->	O
endT	O
=	O
iCount	O
-	O
1	int
;	O
}	O
printf	(*(char))->(int)
(	O
"Done with InitPerks - Continuing.\n\n"	*(char)
)	O
;	O
}	O
}	O
}	O
void	O
OpenMarkovFiles	O
(	O
PANALYSIS	O
panal	O
)	O
{	O
PGIBBSDATA	O
pgd	O
=	O
&	O
panal	O
->	O
gd	O
;	O
char	O
*	O
with_rank	O
;	O
if	O
(	O
panal	O
->	O
bDependents	O
)	O
return	O
;	O
if	O
(	O
panal	O
->	O
bCommandLineSpec	O
)	O
{	O
free	O
(	O
pgd	O
->	O
szGout	O
)	O
;	O
panal	O
->	O
bAllocatedFileName	O
=	O
FALSE	O
;	O
pgd	O
->	O
szGout	O
=	O
panal	O
->	O
szOutfilename	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
pgd	O
->	O
szGout	O
)	O
)	O
pgd	O
->	O
szGout	O
=	O
"MCMC.default.out"	*(char)
;	O
if	O
(	O
panal	O
->	O
size	O
>	O
1	int
)	O
{	O
with_rank	O
=	O
malloc	O
(	O
sizeof	O
(	O
char	O
)	O
*	O
(	O
6	int
+	O
strlen	(*(char))->(long)
(	O
pgd	O
->	O
szGout	O
)	O
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
with_rank	O
,	O
"%04d_%s"	*(char)
,	O
panal	O
->	O
rank	int
,	O
pgd	O
->	O
szGout	O
)	O
;	O
pgd	O
->	O
szGout	O
=	O
with_rank	O
;	O
}	O
if	O
(	O
pgd	O
->	O
szGrestart	O
)	O
if	O
(	O
!	O
(	O
pgd	O
->	O
pfileRestart	O
)	O
&&	O
!	O
(	O
pgd	O
->	O
pfileRestart	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pgd	O
->	O
szGrestart	O
,	O
"r"	*(char)
)	O
)	O
)	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_FATAL	O
|	O
RE_CANNOTOPEN	O
,	O
pgd	O
->	O
szGrestart	O
,	O
"OpenMarkovFiles"	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
pgd	O
->	O
pfileOut	O
)	O
&&	O
!	O
(	O
pgd	O
->	O
pfileOut	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pgd	O
->	O
szGout	O
,	O
"w"	*(char)
)	O
)	O
)	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_FATAL	O
|	O
RE_CANNOTOPEN	O
,	O
pgd	O
->	O
szGout	O
,	O
"OpenMarkovFiles"	*(char)
)	O
;	O
if	O
(	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
3	int
)	O
||	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
4	int
)	O
)	O
{	O
char	O
szFileName	O
[	O
MAX_FILENAMESIZE	O
+	O
6	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
szFileName	O
,	O
"%s%s"	*(char)
,	O
pgd	O
->	O
szGout	O
,	O
".perks"	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
pgd	O
->	O
pfilePerks	O
)	O
&&	O
!	O
(	O
pgd	O
->	O
pfilePerks	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
szFileName	O
,	O
"w"	*(char)
)	O
)	O
)	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_FATAL	O
|	O
RE_CANNOTOPEN	O
,	O
szFileName	O
,	O
"OpenMarkovFiles"	*(char)
)	O
;	O
}	O
}	O
void	O
PrintAllExpts	O
(	O
PLEVEL	O
plevel	O
,	O
PANALYSIS	O
panal	O
,	O
PFILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
pOutFile	O
)	O
{	O
long	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
iInstances	O
;	O
n	int
++	O
)	O
TraverseLevels1	O
(	O
plevel	O
->	O
pLevels	O
[	O
n	int
]	O
,	O
PrintExpt	O
,	O
panal	O
,	O
pOutFile	O
,	O
NULL	O
)	O
;	O
}	O
void	O
PrintDeps	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
long	O
n	int
,	O
m	O
;	O
PMCVAR	O
pMCVar	O
;	O
printf	(*(char))->(int)
(	O
"Depth %d; Instance %d\n"	*(char)
,	O
plevel	O
->	O
iDepth	O
,	O
plevel	O
->	O
iSequence	O
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
;	O
printf	(*(char))->(int)
(	O
"Variable %s (%d) [%"	*(char)
PRIxPTR	O
"]\n"	*(char)
,	O
pMCVar	O
->	O
pszName	O
,	O
pMCVar	O
->	O
iDepth	O
,	O
(	O
intptr_t	long
)	O
pMCVar	O
)	O
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
4	int
;	O
m	O
++	O
)	O
if	O
(	O
pMCVar	O
->	O
pMCVParent	O
[	O
m	O
]	O
!=	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
"  Parent %ld: %s (%d) [%"	*(char)
PRIxPTR	O
"]\n"	*(char)
,	O
m	O
,	O
pMCVar	O
->	O
pMCVParent	O
[	O
m	O
]	O
->	O
pszName	O
,	O
pMCVar	O
->	O
pMCVParent	O
[	O
m	O
]	O
->	O
iDepth	O
,	O
(	O
intptr_t	long
)	O
pMCVar	O
->	O
pMCVParent	O
[	O
m	O
]	O
)	O
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
pMCVar	O
->	O
nDependents	O
;	O
m	O
++	O
)	O
printf	(*(char))->(int)
(	O
"  Dependent: %s (%d) [%"	*(char)
PRIxPTR	O
"]\n"	*(char)
,	O
pMCVar	O
->	O
rgpDependents	O
[	O
m	O
]	O
->	O
pszName	O
,	O
pMCVar	O
->	O
rgpDependents	O
[	O
m	O
]	O
->	O
iDepth	O
,	O
(	O
intptr_t	long
)	O
pMCVar	O
->	O
rgpDependents	O
[	O
m	O
]	O
)	O
;	O
if	O
(	O
pMCVar	O
->	O
bExptIsDep	O
)	O
printf	(*(char))->(int)
(	O
"  This variable influences experiments directly\n"	*(char)
)	O
;	O
}	O
}	O
int	O
PrintExpt	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
args	O
[	O
0	int
]	O
;	O
PFILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
pOutFile	O
=	O
(	O
PFILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
args	O
[	O
1	int
]	O
;	O
long	O
k	O
,	O
l	O
,	O
m	O
,	O
n	int
;	O
PEXPERIMENT	O
pExpt	O
=	O
plevel	O
->	O
pexpt	O
;	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
;	O
static	O
long	O
printed_head	O
=	O
0	int
;	O
if	O
(	O
!	O
printed_head	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pOutFile	O
,	O
"Level\tSimulation\tOutput_Var\tTime\tData\tPrediction\n"	*(char)
)	O
;	O
printed_head	O
=	O
1	int
;	O
}	O
panal	O
->	O
pCurrentLevel	O
[	O
plevel	O
->	O
iDepth	O
]	O
=	O
plevel	O
;	O
panal	O
->	O
iInstance	O
[	O
plevel	O
->	O
iDepth	O
]	O
=	O
plevel	O
->	O
iSequence	O
;	O
if	O
(	O
pExpt	O
!=	O
NULL	O
)	O
{	O
InitModel	()->(void)
(	O
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<=	O
plevel	O
->	O
iDepth	O
;	O
n	int
++	O
)	O
{	O
SetModelVars	O
(	O
panal	O
->	O
pCurrentLevel	O
[	O
n	int
]	O
)	O
;	O
SetFixedVars	O
(	O
panal	O
->	O
pCurrentLevel	O
[	O
n	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
DoOneExperiment	O
(	O
pExpt	O
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Warning: DoOneExperiment failed\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
pos	O
=	O
&	O
pExpt	O
->	O
os	O
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
pos	O
->	O
nOutputs	int
;	O
m	O
++	O
)	O
{	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
pos	O
->	O
nData	int
;	O
k	O
++	O
)	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
pos	O
->	O
pszDataNames	*(*(char))
[	O
k	O
]	O
,	O
pos	O
->	O
pszOutputNames	*(*(char))
[	O
m	O
]	O
)	O
)	O
break	O
;	O
for	O
(	O
l	O
=	O
0	int
;	O
l	O
<	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
m	O
]	O
;	O
l	O
++	O
)	O
{	O
for	O
(	O
n	int
=	O
1	int
;	O
n	int
<	O
plevel	O
->	O
iDepth	O
;	O
n	int
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pOutFile	O
,	O
"%d_"	*(char)
,	O
panal	O
->	O
iInstance	O
[	O
n	int
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pOutFile	O
,	O
"%d\t"	*(char)
,	O
panal	O
->	O
iInstance	O
[	O
plevel	O
->	O
iDepth	O
]	O
)	O
;	O
if	O
(	O
k	O
!=	O
pos	O
->	O
nData	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pOutFile	O
,	O
"%d\t%s\t%g\t%g\t%g\n"	*(char)
,	O
pExpt	O
->	O
iExp	O
,	O
pos	O
->	O
pszOutputNames	*(*(char))
[	O
m	O
]	O
,	O
pos	O
->	O
prgdOutputTimes	*(*(double))
[	O
m	O
]	O
[	O
l	O
]	O
,	O
pos	O
->	O
prgdDataVals	*(*(double))
[	O
k	O
]	O
[	O
l	O
]	O
,	O
pos	O
->	O
prgdOutputVals	*(*(double))
[	O
m	O
]	O
[	O
l	O
]	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pOutFile	O
,	O
"%d\t%s\t%g\t\t%g\n"	*(char)
,	O
pExpt	O
->	O
iExp	O
,	O
pos	O
->	O
pszOutputNames	*(*(char))
[	O
m	O
]	O
,	O
pos	O
->	O
prgdOutputTimes	*(*(double))
[	O
m	O
]	O
[	O
l	O
]	O
,	O
pos	O
->	O
prgdOutputVals	*(*(double))
[	O
m	O
]	O
[	O
l	O
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pOutFile	O
,	O
"\n"	*(char)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pOutFile	O
,	O
"\n"	*(char)
)	O
;	O
}	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
PrintTemperatureDiagnostics	O
(	O
PFILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
fOut	O
,	O
PGIBBSDATA	O
pgd	O
)	O
{	O
register	O
int	O
i	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fOut	O
,	O
"\nPerks:"	*(char)
)	O
;	O
for	O
(	O
i	O
=	O
pgd	O
->	O
startT	O
;	O
i	O
<=	O
pgd	O
->	O
endT	O
;	O
i	O
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fOut	O
,	O
"\t%g"	*(char)
,	O
pgd	O
->	O
rgdPerks	O
[	O
i	O
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fOut	O
,	O
"\nCounts:"	*(char)
)	O
;	O
for	O
(	O
i	O
=	O
pgd	O
->	O
startT	O
;	O
i	O
<=	O
pgd	O
->	O
endT	O
;	O
i	O
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fOut	O
,	O
"\t%ld"	*(char)
,	O
pgd	O
->	O
rglCount	O
[	O
i	O
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fOut	O
,	O
"\nLnPi(i):"	*(char)
)	O
;	O
for	O
(	O
i	O
=	O
pgd	O
->	O
startT	O
;	O
i	O
<=	O
pgd	O
->	O
endT	O
;	O
i	O
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fOut	O
,	O
"\t%g"	*(char)
,	O
pgd	O
->	O
rgdlnPi	O
[	O
i	O
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fOut	O
,	O
"\nTried Jumps:\t"	*(char)
)	O
;	O
for	O
(	O
i	O
=	O
pgd	O
->	O
startT	O
;	O
i	O
<=	O
pgd	O
->	O
endT	O
-	O
1	int
;	O
i	O
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fOut	O
,	O
"\t%ld"	*(char)
,	O
pgd	O
->	O
rglTransAttempts	O
[	O
i	O
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fOut	O
,	O
"\nAccepted Jumps:\t"	*(char)
)	O
;	O
for	O
(	O
i	O
=	O
pgd	O
->	O
startT	O
;	O
i	O
<=	O
pgd	O
->	O
endT	O
-	O
1	int
;	O
i	O
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fOut	O
,	O
"\t%ld"	*(char)
,	O
pgd	O
->	O
rglTransAccepts	O
[	O
i	O
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fOut	O
,	O
"\n\n"	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fOut	O
)	O
;	O
}	O
void	O
ReadData	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
FILE	struct
*	O
pfileData	O
=	O
(	O
FILE	struct
*	O
)	O
args	O
[	O
0	int
]	O
;	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
;	O
int	O
cDat	O
,	O
i	O
,	O
j	O
;	O
if	O
(	O
plevel	O
->	O
pexpt	O
==	O
NULL	O
)	O
return	O
;	O
pos	O
=	O
&	O
(	O
plevel	O
->	O
pexpt	O
->	O
os	O
)	O
;	O
cDat	O
=	O
pos	O
->	O
nOutputs	int
;	O
pos	O
->	O
prgdDataVals	*(*(double))
=	O
InitpdVector	(long)->(*(*(double)))
(	O
cDat	O
)	O
;	O
pos	O
->	O
pcData	*(int)
=	O
InitiVector	(long)->(*(int))
(	O
cDat	O
)	O
;	O
pos	O
->	O
pszDataNames	*(*(char))
=	O
(	O
PSTR	*(char)
*	O
)	O
malloc	O
(	O
cDat	O
*	O
sizeof	O
(	O
PSTR	*(char)
)	O
)	O
;	O
pos	O
->	O
phvar_dat	*(long)
=	O
(	O
HVAR	long
*	O
)	O
malloc	O
(	O
cDat	O
*	O
sizeof	O
(	O
HVAR	long
)	O
)	O
;	O
if	O
(	O
pos	O
->	O
prgdDataVals	*(*(double))
==	O
NULL	O
||	O
pos	O
->	O
phvar_dat	*(long)
==	O
NULL	O
||	O
pos	O
->	O
pszDataNames	*(*(char))
==	O
NULL	O
||	O
pos	O
->	O
pcData	*(int)
==	O
NULL	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"ReadData()"	*(char)
,	O
NULL	O
)	O
;	O
else	O
{	O
pos	O
->	O
nData	int
=	O
cDat	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
cDat	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
!	O
(	O
pos	O
->	O
prgdDataVals	*(*(double))
[	O
i	O
]	O
=	O
InitdVector	(long)->(*(double))
(	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
i	O
]	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"ReadData()"	*(char)
,	O
NULL	O
)	O
;	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
i	O
]	O
;	O
j	O
++	O
)	O
if	O
(	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfileData	O
,	O
"%lg"	*(char)
,	O
&	O
(	O
pos	O
->	O
prgdDataVals	*(*(double))
[	O
i	O
]	O
[	O
j	O
]	O
)	O
)	O
==	O
EOF	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: incorrect length for data file - Exiting\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
pos	O
->	O
pcData	*(int)
[	O
i	O
]	O
=	O
j	O
;	O
pos	O
->	O
phvar_dat	*(long)
[	O
i	O
]	O
=	O
pos	O
->	O
phvar_out	*(long)
[	O
i	O
]	O
;	O
pos	O
->	O
pszDataNames	*(*(char))
[	O
i	O
]	O
=	O
pos	O
->	O
pszOutputNames	*(*(char))
[	O
i	O
]	O
;	O
}	O
}	O
}	O
void	O
ReadDataFile	O
(	O
PANALYSIS	O
panal	O
)	O
{	O
if	O
(	O
panal	O
->	O
gd	O
.	O
szGdata	O
)	O
{	O
char	O
c	O
;	O
FILE	struct
*	O
pfile	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
panal	O
->	O
gd	O
.	O
szGdata	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
pfile	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Cannot open data file '%s'\n"	*(char)
,	O
panal	O
->	O
gd	O
.	O
szGdata	O
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
do	O
{	O
c	O
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfile	O
)	O
;	O
}	O
while	O
(	O
c	O
!=	O
'\n'	O
)	O
;	O
TraverseLevels	O
(	O
panal	O
->	O
pLevels	O
[	O
0	int
]	O
,	O
ReadData	O
,	O
pfile	O
,	O
NULL	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfile	O
)	O
;	O
}	O
}	O
void	O
ReadRestart	O
(	O
FILE	struct
*	O
pfileRestart	O
,	O
long	O
nThetas	O
,	O
PDOUBLE	*(double)
*	O
pdTheta	O
,	O
PDOUBLE	*(double)
*	O
pdSum	O
,	O
PDOUBLE	*(double)
*	O
*	O
prgdSumProd	O
,	O
long	O
*	O
pIter	O
)	O
{	O
register	O
char	O
c	O
;	O
register	O
long	O
i	O
,	O
j	O
;	O
if	O
(	O
*	O
pdTheta	O
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
pdTheta	O
=	O
InitdVector	(long)->(*(double))
(	O
nThetas	O
)	O
)	O
)	O
ReportRunTimeError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"ReadRestart"	*(char)
)	O
;	O
if	O
(	O
*	O
pdSum	O
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
pdSum	O
=	O
InitdVector	(long)->(*(double))
(	O
nThetas	O
)	O
)	O
)	O
ReportRunTimeError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"ReadRestart"	*(char)
)	O
;	O
if	O
(	O
*	O
prgdSumProd	O
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
prgdSumProd	O
=	O
InitdMatrix	(long,long)->(*(*(double)))
(	O
nThetas	O
,	O
nThetas	O
)	O
)	O
)	O
ReportRunTimeError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"ReadRestart"	*(char)
)	O
;	O
*	O
pIter	O
=	O
-	O
1	int
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
{	O
(	O
*	O
pdSum	O
)	O
[	O
i	O
]	O
=	O
0.0	int
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nThetas	O
;	O
j	O
++	O
)	O
(	O
*	O
prgdSumProd	O
)	O
[	O
i	O
]	O
[	O
j	O
]	O
=	O
0.0	int
;	O
}	O
do	O
{	O
c	O
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfileRestart	O
)	O
;	O
}	O
while	O
(	O
c	O
!=	O
'\n'	O
)	O
;	O
while	O
(	O
!	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfileRestart	O
)	O
||	O
(	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfileRestart	O
,	O
"%*s"	*(char)
)	O
==	O
EOF	O
)	O
)	O
)	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfileRestart	O
,	O
"%lg"	*(char)
,	O
&	O
(	O
(	O
*	O
pdTheta	O
)	O
[	O
i	O
]	O
)	O
)	O
==	O
EOF	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: incorrect length for restart file - Exiting\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
(	O
*	O
pdSum	O
)	O
[	O
i	O
]	O
+=	O
(	O
*	O
pdTheta	O
)	O
[	O
i	O
]	O
;	O
}	O
}	O
do	O
{	O
c	O
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfileRestart	O
)	O
;	O
}	O
while	O
(	O
c	O
!=	O
'\n'	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nThetas	O
;	O
j	O
++	O
)	O
(	O
*	O
prgdSumProd	O
)	O
[	O
i	O
]	O
[	O
j	O
]	O
+=	O
(	O
*	O
pdTheta	O
)	O
[	O
i	O
]	O
*	O
(	O
*	O
pdTheta	O
)	O
[	O
j	O
]	O
;	O
*	O
pIter	O
=	O
*	O
pIter	O
+	O
1	int
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfileRestart	O
)	O
;	O
}	O
void	O
ReadRestartTemper	O
(	O
FILE	struct
*	O
pfileRestart	O
,	O
long	O
nThetas	O
,	O
int	O
nPerks	O
,	O
PDOUBLE	*(double)
*	O
pdTheta	O
,	O
PDOUBLE	*(double)
*	O
pdSum	O
,	O
PDOUBLE	*(double)
*	O
*	O
prgdSumProd	O
,	O
long	O
*	O
pIter	O
,	O
int	O
*	O
pindexT	O
,	O
double	O
*	O
pdlnPi	O
)	O
{	O
register	O
char	O
c	O
;	O
register	O
long	O
i	O
,	O
j	O
;	O
if	O
(	O
*	O
pdTheta	O
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
pdTheta	O
=	O
InitdVector	(long)->(*(double))
(	O
nThetas	O
)	O
)	O
)	O
ReportRunTimeError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"ReadRestart"	*(char)
)	O
;	O
if	O
(	O
*	O
pdSum	O
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
pdSum	O
=	O
InitdVector	(long)->(*(double))
(	O
nThetas	O
)	O
)	O
)	O
ReportRunTimeError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"ReadRestart"	*(char)
)	O
;	O
if	O
(	O
*	O
prgdSumProd	O
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
prgdSumProd	O
=	O
InitdMatrix	(long,long)->(*(*(double)))
(	O
nThetas	O
,	O
nThetas	O
)	O
)	O
)	O
ReportRunTimeError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"ReadRestart"	*(char)
)	O
;	O
*	O
pIter	O
=	O
-	O
1	int
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
{	O
(	O
*	O
pdSum	O
)	O
[	O
i	O
]	O
=	O
0.0	int
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nThetas	O
;	O
j	O
++	O
)	O
(	O
*	O
prgdSumProd	O
)	O
[	O
i	O
]	O
[	O
j	O
]	O
=	O
0.0	int
;	O
}	O
do	O
{	O
c	O
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfileRestart	O
)	O
;	O
}	O
while	O
(	O
c	O
!=	O
'\n'	O
)	O
;	O
while	O
(	O
!	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfileRestart	O
)	O
||	O
(	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfileRestart	O
,	O
"%*s"	*(char)
)	O
==	O
EOF	O
)	O
)	O
)	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfileRestart	O
,	O
"%lg"	*(char)
,	O
&	O
(	O
(	O
*	O
pdTheta	O
)	O
[	O
i	O
]	O
)	O
)	O
==	O
EOF	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: incorrect length for restart file - Exiting\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
(	O
*	O
pdSum	O
)	O
[	O
i	O
]	O
+=	O
(	O
*	O
pdTheta	O
)	O
[	O
i	O
]	O
;	O
}	O
}	O
if	O
(	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfileRestart	O
,	O
"%d"	*(char)
,	O
pindexT	O
)	O
==	O
EOF	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: incorrect length for restart file - Exiting\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nPerks	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfileRestart	O
,	O
"%lg"	*(char)
,	O
&	O
(	O
pdlnPi	O
[	O
i	O
]	O
)	O
)	O
==	O
EOF	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: incorrect length for restart file - Exiting\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
}	O
do	O
{	O
c	O
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfileRestart	O
)	O
;	O
}	O
while	O
(	O
c	O
!=	O
'\n'	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nThetas	O
;	O
j	O
++	O
)	O
(	O
*	O
prgdSumProd	O
)	O
[	O
i	O
]	O
[	O
j	O
]	O
+=	O
(	O
*	O
pdTheta	O
)	O
[	O
i	O
]	O
*	O
(	O
*	O
pdTheta	O
)	O
[	O
j	O
]	O
;	O
*	O
pIter	O
=	O
*	O
pIter	O
+	O
1	int
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfileRestart	O
)	O
;	O
}	O
int	O
RestoreLikelihoods	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PEXPERIMENT	O
pExpt	O
=	O
plevel	O
->	O
pexpt	O
;	O
if	O
(	O
pExpt	O
!=	O
NULL	O
)	O
{	O
pExpt	O
->	O
dLnLike	O
=	O
pExpt	O
->	O
dLnLikeSave	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
RunAllExpts	O
(	O
PANALYSIS	O
panal	O
,	O
PDOUBLE	*(double)
pdLnData	O
)	O
{	O
PLEVEL	O
plevel0	O
=	O
panal	O
->	O
pLevels	O
[	O
0	int
]	O
;	O
long	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel0	O
->	O
iInstances	O
;	O
n	int
++	O
)	O
{	O
if	O
(	O
!	O
TraverseLevels1	O
(	O
plevel0	O
->	O
pLevels	O
[	O
n	int
]	O
,	O
RunExpt	O
,	O
panal	O
,	O
pdLnData	O
,	O
NULL	O
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
RunExpt	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
args	O
[	O
0	int
]	O
;	O
double	O
*	O
pdLnData	O
=	O
(	O
double	O
*	O
)	O
args	O
[	O
1	int
]	O
;	O
long	O
i	O
;	O
PEXPERIMENT	O
pExpt	O
=	O
plevel	O
->	O
pexpt	O
;	O
panal	O
->	O
pCurrentLevel	O
[	O
plevel	O
->	O
iDepth	O
]	O
=	O
plevel	O
;	O
if	O
(	O
pExpt	O
!=	O
NULL	O
)	O
{	O
InitModel	()->(void)
(	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<=	O
plevel	O
->	O
iDepth	O
;	O
i	O
++	O
)	O
{	O
SetModelVars	O
(	O
panal	O
->	O
pCurrentLevel	O
[	O
i	O
]	O
)	O
;	O
SetFixedVars	O
(	O
panal	O
->	O
pCurrentLevel	O
[	O
i	O
]	O
)	O
;	O
}	O
if	O
(	O
!	O
DoOneExperiment	O
(	O
pExpt	O
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Warning: DoOneExperiment failed\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
pExpt	O
->	O
dLnLike	O
=	O
LnLikeData	O
(	O
plevel	O
,	O
panal	O
)	O
;	O
*	O
pdLnData	O
=	O
(	O
*	O
pdLnData	O
)	O
+	O
pExpt	O
->	O
dLnLike	O
;	O
}	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
long	O
SampleTemperature	O
(	O
PGIBBSDATA	O
pgd	O
,	O
double	O
dLnPrior	O
,	O
double	O
dLnData	O
)	O
{	O
int	O
indexT	O
=	O
pgd	O
->	O
indexT	O
;	O
int	O
indexT_new	O
;	O
if	O
(	O
indexT	O
==	O
0	int
)	O
indexT_new	O
=	O
1	int
;	O
else	O
{	O
if	O
(	O
indexT	O
==	O
pgd	O
->	O
nPerks	O
-	O
1	int
)	O
indexT_new	O
=	O
indexT	O
-	O
1	int
;	O
else	O
{	O
if	O
(	O
Randoms	()->(double)
(	O
)	O
>	O
0.5	int
)	O
indexT_new	O
=	O
indexT	O
+	O
1	int
;	O
else	O
indexT_new	O
=	O
indexT	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
TestTemper	O
(	O
pgd	O
,	O
indexT	O
,	O
indexT_new	O
,	O
dLnPrior	O
,	O
dLnData	O
,	O
pgd	O
->	O
rgdlnPi	O
[	O
indexT	O
]	O
,	O
pgd	O
->	O
rgdlnPi	O
[	O
indexT_new	O
]	O
)	O
)	O
{	O
return	O
(	O
indexT_new	O
)	O
;	O
}	O
else	O
return	O
(	O
indexT	O
)	O
;	O
}	O
long	O
SampleTemperature2	O
(	O
PGIBBSDATA	O
pgd	O
,	O
double	O
dLnPrior	O
,	O
double	O
dLnData	O
)	O
{	O
int	O
indexT	O
=	O
pgd	O
->	O
indexT	O
;	O
int	O
indexT_new	O
;	O
if	O
(	O
indexT	O
==	O
pgd	O
->	O
startT	O
)	O
indexT_new	O
=	O
indexT	O
+	O
1	int
;	O
else	O
{	O
if	O
(	O
indexT	O
==	O
pgd	O
->	O
endT	O
)	O
indexT_new	O
=	O
indexT	O
-	O
1	int
;	O
else	O
{	O
if	O
(	O
Randoms	()->(double)
(	O
)	O
>	O
0.5	int
)	O
indexT_new	O
=	O
indexT	O
+	O
1	int
;	O
else	O
indexT_new	O
=	O
indexT	O
-	O
1	int
;	O
}	O
}	O
int	O
minI	O
=	O
(	O
indexT	O
<	O
indexT_new	O
?	O
indexT	O
:	O
indexT_new	O
)	O
;	O
pgd	O
->	O
rglTransAttempts	O
[	O
minI	O
]	O
++	O
;	O
if	O
(	O
TestTemper	O
(	O
pgd	O
,	O
indexT	O
,	O
indexT_new	O
,	O
dLnPrior	O
,	O
dLnData	O
,	O
pgd	O
->	O
rgdlnPi	O
[	O
indexT	O
]	O
,	O
pgd	O
->	O
rgdlnPi	O
[	O
indexT_new	O
]	O
)	O
)	O
{	O
pgd	O
->	O
rglTransAccepts	O
[	O
minI	O
]	O
++	O
;	O
return	O
(	O
indexT_new	O
)	O
;	O
}	O
else	O
return	O
(	O
indexT	O
)	O
;	O
}	O
double	O
SampleTheta	O
(	O
PMCVAR	O
pMCVar	O
)	O
{	O
if	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_BINOMIAL	O
||	O
pMCVar	O
->	O
iType	int
==	O
MCV_POISSON	O
)	O
{	O
return	O
floor	(double)->(double)
(	O
0.5	int
+	O
TruncNormalRandom	(double,double,double,double)->(double)
(	O
pMCVar	O
->	O
dVal	double
,	O
pMCVar	O
->	O
dKernelSD	O
,	O
MinMCVar	O
(	O
pMCVar	O
)	O
,	O
MaxMCVar	O
(	O
pMCVar	O
)	O
)	O
)	O
;	O
}	O
else	O
{	O
return	O
TruncNormalRandom	(double,double,double,double)->(double)
(	O
pMCVar	O
->	O
dVal	double
,	O
pMCVar	O
->	O
dKernelSD	O
,	O
MinMCVar	O
(	O
pMCVar	O
)	O
,	O
MaxMCVar	O
(	O
pMCVar	O
)	O
)	O
;	O
}	O
}	O
double	O
SampleThetaUnif	O
(	O
PMCVAR	O
pMCVar	O
)	O
{	O
if	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_BINOMIAL	O
||	O
pMCVar	O
->	O
iType	int
==	O
MCV_POISSON	O
)	O
return	O
floor	(double)->(double)
(	O
0.5	int
+	O
UniformRandom	(double,double)->(double)
(	O
MinMCVar	O
(	O
pMCVar	O
)	O
,	O
MaxMCVar	O
(	O
pMCVar	O
)	O
)	O
)	O
;	O
else	O
return	O
UniformRandom	(double,double)->(double)
(	O
MinMCVar	O
(	O
pMCVar	O
)	O
,	O
MaxMCVar	O
(	O
pMCVar	O
)	O
)	O
;	O
}	O
void	O
SampleThetas	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
args	O
[	O
0	int
]	O
;	O
PGIBBSDATA	O
pgd	O
=	O
(	O
PGIBBSDATA	O
)	O
args	O
[	O
1	int
]	O
;	O
long	O
*	O
pnIter	O
=	O
(	O
long	O
*	O
)	O
args	O
[	O
2	int
]	O
;	O
long	O
*	O
pnUpdateAt	O
=	O
(	O
long	O
*	O
)	O
args	O
[	O
3	int
]	O
;	O
long	O
*	O
pnTotal	O
=	O
(	O
long	O
*	O
)	O
args	O
[	O
4	int
]	O
;	O
double	O
dLnPrior	O
,	O
dLnLike	O
,	O
dLnData	O
,	O
dLnKern	O
;	O
double	O
dLnPriorNew	O
,	O
dLnLikeNew	O
,	O
dLnDataNew	O
,	O
dLnKernNew	O
;	O
double	O
dTheta	O
,	O
dJumps	O
;	O
PMCVAR	O
pMCVar	O
;	O
long	O
n	int
;	O
panal	O
->	O
pCurrentLevel	O
[	O
plevel	O
->	O
iDepth	O
]	O
=	O
plevel	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
;	O
if	O
(	O
pMCVar	O
->	O
bIsFixed	O
)	O
goto	O
WriteIt	O
;	O
dLnPrior	O
=	O
LnDensity	O
(	O
pMCVar	O
,	O
panal	O
)	O
;	O
dLnLike	O
=	O
LnLike	O
(	O
pMCVar	O
,	O
panal	O
)	O
;	O
dLnData	O
=	O
0.0	int
;	O
if	O
(	O
pMCVar	O
->	O
bExptIsDep	O
)	O
{	O
TraverseLevels1	O
(	O
plevel	O
,	O
SumAllExpts	O
,	O
&	O
dLnData	O
,	O
NULL	O
)	O
;	O
}	O
dTheta	O
=	O
pMCVar	O
->	O
dVal	double
;	O
if	O
(	O
*	O
pnIter	O
==	O
*	O
pnUpdateAt	O
)	O
{	O
dJumps	O
=	O
(	O
double	O
)	O
pMCVar	O
->	O
lJumps	O
/	O
(	O
double	O
)	O
(	O
*	O
pnTotal	O
)	O
;	O
if	O
(	O
dJumps	O
>	O
0.3	int
)	O
{	O
if	O
(	O
dJumps	O
==	O
1	int
)	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
<	O
sqrt	(double)->(double)
(	O
DBL_MAX	O
)	O
)	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
>	O
2	int
)	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
*	O
pMCVar	O
->	O
dKernelSD	O
;	O
else	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
*	O
20	int
;	O
}	O
else	O
pMCVar	O
->	O
dKernelSD	O
=	O
DBL_MAX	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
<	O
DBL_MAX	O
/	O
2	int
)	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
*	O
2	int
;	O
else	O
pMCVar	O
->	O
dKernelSD	O
=	O
DBL_MAX	O
;	O
}	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
>	O
pMCVar	O
->	O
dMaxKernelSD	O
)	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dMaxKernelSD	O
;	O
}	O
else	O
{	O
if	O
(	O
dJumps	O
==	O
0	int
)	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
>	O
pow	(double,double)->(double)
(	O
DBL_MIN	O
,	O
0.45	int
)	O
)	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
>	O
2	int
)	O
{	O
pMCVar	O
->	O
dKernelSD	O
=	O
pow	(double,double)->(double)
(	O
pMCVar	O
->	O
dKernelSD	O
,	O
0.45	int
)	O
;	O
}	O
else	O
{	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
*	O
0.04	int
;	O
}	O
}	O
else	O
pMCVar	O
->	O
dKernelSD	O
=	O
DBL_MIN	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
>	O
DBL_MIN	O
/	O
0.4	int
)	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
*	O
0.4	int
;	O
else	O
pMCVar	O
->	O
dKernelSD	O
=	O
DBL_MIN	O
;	O
}	O
}	O
pMCVar	O
->	O
lJumps	O
=	O
0	int
;	O
}	O
dLnKern	O
=	O
log	(double)->(double)
(	O
CDFNormal	(double)->(double)
(	O
(	O
MaxMCVar	O
(	O
pMCVar	O
)	O
-	O
pMCVar	O
->	O
dVal	double
)	O
/	O
pMCVar	O
->	O
dKernelSD	O
)	O
-	O
CDFNormal	(double)->(double)
(	O
(	O
MinMCVar	O
(	O
pMCVar	O
)	O
-	O
pMCVar	O
->	O
dVal	double
)	O
/	O
pMCVar	O
->	O
dKernelSD	O
)	O
)	O
;	O
pMCVar	O
->	O
dVal	double
=	O
SampleTheta	O
(	O
pMCVar	O
)	O
;	O
dLnKernNew	O
=	O
log	(double)->(double)
(	O
CDFNormal	(double)->(double)
(	O
(	O
MaxMCVar	O
(	O
pMCVar	O
)	O
-	O
pMCVar	O
->	O
dVal	double
)	O
/	O
pMCVar	O
->	O
dKernelSD	O
)	O
-	O
CDFNormal	(double)->(double)
(	O
(	O
MinMCVar	O
(	O
pMCVar	O
)	O
-	O
pMCVar	O
->	O
dVal	double
)	O
/	O
pMCVar	O
->	O
dKernelSD	O
)	O
)	O
;	O
dLnPriorNew	O
=	O
LnDensity	O
(	O
pMCVar	O
,	O
panal	O
)	O
;	O
dLnLikeNew	O
=	O
LnLike	O
(	O
pMCVar	O
,	O
panal	O
)	O
;	O
dLnDataNew	O
=	O
0.0	int
;	O
if	O
(	O
pMCVar	O
->	O
bExptIsDep	O
)	O
{	O
if	O
(	O
!	O
TraverseLevels1	O
(	O
plevel	O
,	O
RunExpt	O
,	O
panal	O
,	O
&	O
dLnDataNew	O
,	O
NULL	O
)	O
)	O
{	O
pMCVar	O
->	O
dVal	double
=	O
dTheta	O
;	O
TraverseLevels1	O
(	O
plevel	O
,	O
RestoreLikelihoods	O
,	O
NULL	O
)	O
;	O
goto	O
WriteIt	O
;	O
}	O
}	O
if	O
(	O
!	O
TestImpRatio	O
(	O
pgd	O
,	O
pMCVar	O
->	O
bExptIsDep	O
,	O
dLnKern	O
,	O
dLnKernNew	O
,	O
dLnPrior	O
,	O
dLnPriorNew	O
,	O
dLnLike	O
,	O
dLnLikeNew	O
,	O
dLnData	O
,	O
dLnDataNew	O
)	O
)	O
{	O
pMCVar	O
->	O
dVal	double
=	O
dTheta	O
;	O
if	O
(	O
pMCVar	O
->	O
bExptIsDep	O
)	O
TraverseLevels1	O
(	O
plevel	O
,	O
RestoreLikelihoods	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
pMCVar	O
->	O
lJumps	O
=	O
pMCVar	O
->	O
lJumps	O
+	O
1	int
;	O
if	O
(	O
pMCVar	O
->	O
bExptIsDep	O
)	O
TraverseLevels1	O
(	O
plevel	O
,	O
SaveLikelihoods	O
,	O
NULL	O
)	O
;	O
}	O
CalculateMeanAndVariance	O
(	O
(	O
*	O
pnIter	O
+	O
1	int
)	O
,	O
pMCVar	O
->	O
dVal	double
,	O
&	O
pMCVar	O
->	O
dVal_mean	O
,	O
&	O
pMCVar	O
->	O
dVal_var	O
)	O
;	O
WriteIt	O
:	O
if	O
(	O
(	O
(	O
*	O
pnIter	O
+	O
1	int
)	O
%	O
pgd	O
->	O
nPrintFreq	O
==	O
0	int
)	O
&&	O
(	O
*	O
pnIter	O
>=	O
pgd	O
->	O
nMaxIter	O
-	O
pgd	O
->	O
nPrintIter	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%5g\t"	*(char)
,	O
pMCVar	O
->	O
dVal	double
)	O
;	O
}	O
}	O
}	O
void	O
SampleThetasTempered	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
args	O
[	O
0	int
]	O
;	O
PGIBBSDATA	O
pgd	O
=	O
(	O
PGIBBSDATA	O
)	O
args	O
[	O
1	int
]	O
;	O
long	O
*	O
pnIter	O
=	O
(	O
long	O
*	O
)	O
args	O
[	O
2	int
]	O
;	O
long	O
*	O
pnUpdateAt	O
=	O
(	O
long	O
*	O
)	O
args	O
[	O
3	int
]	O
;	O
long	O
*	O
pnTotal	O
=	O
(	O
long	O
*	O
)	O
args	O
[	O
4	int
]	O
;	O
long	O
*	O
pindexT	O
=	O
(	O
long	O
*	O
)	O
args	O
[	O
5	int
]	O
;	O
double	O
dLnPrior	O
,	O
dLnLike	O
,	O
dLnData	O
,	O
dLnKern	O
;	O
double	O
dLnPriorNew	O
,	O
dLnLikeNew	O
,	O
dLnDataNew	O
,	O
dLnKernNew	O
;	O
double	O
dTheta	O
,	O
dJumps	O
,	O
old_dKernelSD	O
;	O
PMCVAR	O
pMCVar	O
;	O
long	O
n	int
;	O
panal	O
->	O
pCurrentLevel	O
[	O
plevel	O
->	O
iDepth	O
]	O
=	O
plevel	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
;	O
if	O
(	O
pMCVar	O
->	O
bIsFixed	O
)	O
goto	O
WriteIt	O
;	O
dLnPrior	O
=	O
LnDensity	O
(	O
pMCVar	O
,	O
panal	O
)	O
;	O
dLnLike	O
=	O
LnLike	O
(	O
pMCVar	O
,	O
panal	O
)	O
;	O
dLnData	O
=	O
0.0	int
;	O
if	O
(	O
pMCVar	O
->	O
bExptIsDep	O
)	O
{	O
TraverseLevels1	O
(	O
plevel	O
,	O
SumAllExpts	O
,	O
&	O
dLnData	O
,	O
NULL	O
)	O
;	O
}	O
dTheta	O
=	O
pMCVar	O
->	O
dVal	double
;	O
if	O
(	O
*	O
pnIter	O
==	O
*	O
pnUpdateAt	O
)	O
{	O
dJumps	O
=	O
(	O
double	O
)	O
pMCVar	O
->	O
lJumps	O
/	O
(	O
double	O
)	O
(	O
*	O
pnTotal	O
)	O
;	O
if	O
(	O
dJumps	O
>	O
0.3	int
)	O
{	O
if	O
(	O
dJumps	O
==	O
1	int
)	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
<	O
sqrt	(double)->(double)
(	O
DBL_MAX	O
)	O
)	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
>	O
2	int
)	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
*	O
pMCVar	O
->	O
dKernelSD	O
;	O
else	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
*	O
20	int
;	O
}	O
else	O
pMCVar	O
->	O
dKernelSD	O
=	O
DBL_MAX	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
<	O
DBL_MAX	O
/	O
2	int
)	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
*	O
2	int
;	O
else	O
pMCVar	O
->	O
dKernelSD	O
=	O
DBL_MAX	O
;	O
}	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
>	O
pMCVar	O
->	O
dMaxKernelSD	O
)	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dMaxKernelSD	O
;	O
}	O
else	O
{	O
if	O
(	O
dJumps	O
==	O
0	int
)	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
>	O
pow	(double,double)->(double)
(	O
DBL_MIN	O
,	O
0.45	int
)	O
)	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
>	O
2	int
)	O
{	O
pMCVar	O
->	O
dKernelSD	O
=	O
pow	(double,double)->(double)
(	O
pMCVar	O
->	O
dKernelSD	O
,	O
0.45	int
)	O
;	O
}	O
else	O
{	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
*	O
0.04	int
;	O
}	O
}	O
else	O
pMCVar	O
->	O
dKernelSD	O
=	O
DBL_MIN	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
>	O
DBL_MIN	O
/	O
0.4	int
)	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
*	O
0.4	int
;	O
else	O
pMCVar	O
->	O
dKernelSD	O
=	O
DBL_MIN	O
;	O
}	O
}	O
pMCVar	O
->	O
lJumps	O
=	O
0	int
;	O
}	O
if	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
*	O
pindexT	O
]	O
>	O
0	int
)	O
{	O
old_dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
;	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dKernelSD	O
*	O
exp	(double)->(double)
(	O
(	O
1	int
-	O
pgd	O
->	O
rgdPerks	O
[	O
*	O
pindexT	O
]	O
)	O
*	O
LN2PI	O
*	O
0.25	int
-	O
0.75	int
*	O
log	(double)->(double)
(	O
pgd	O
->	O
rgdPerks	O
[	O
*	O
pindexT	O
]	O
)	O
)	O
;	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
>	O
pMCVar	O
->	O
dMaxKernelSD	O
)	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dMaxKernelSD	O
;	O
dLnKern	O
=	O
log	(double)->(double)
(	O
CDFNormal	(double)->(double)
(	O
(	O
MaxMCVar	O
(	O
pMCVar	O
)	O
-	O
pMCVar	O
->	O
dVal	double
)	O
/	O
pMCVar	O
->	O
dKernelSD	O
)	O
-	O
CDFNormal	(double)->(double)
(	O
(	O
MinMCVar	O
(	O
pMCVar	O
)	O
-	O
pMCVar	O
->	O
dVal	double
)	O
/	O
pMCVar	O
->	O
dKernelSD	O
)	O
)	O
;	O
pMCVar	O
->	O
dVal	double
=	O
SampleTheta	O
(	O
pMCVar	O
)	O
;	O
dLnKernNew	O
=	O
log	(double)->(double)
(	O
CDFNormal	(double)->(double)
(	O
(	O
MaxMCVar	O
(	O
pMCVar	O
)	O
-	O
pMCVar	O
->	O
dVal	double
)	O
/	O
pMCVar	O
->	O
dKernelSD	O
)	O
-	O
CDFNormal	(double)->(double)
(	O
(	O
MinMCVar	O
(	O
pMCVar	O
)	O
-	O
pMCVar	O
->	O
dVal	double
)	O
/	O
pMCVar	O
->	O
dKernelSD	O
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
3	int
)	O
{	O
pMCVar	O
->	O
dVal	double
=	O
SampleThetaUnif	O
(	O
pMCVar	O
)	O
;	O
}	O
else	O
{	O
CalculateOneMCParm	O
(	O
pMCVar	O
)	O
;	O
}	O
}	O
dLnPriorNew	O
=	O
LnDensity	O
(	O
pMCVar	O
,	O
panal	O
)	O
;	O
dLnLikeNew	O
=	O
LnLike	O
(	O
pMCVar	O
,	O
panal	O
)	O
;	O
dLnDataNew	O
=	O
0.0	int
;	O
if	O
(	O
pMCVar	O
->	O
bExptIsDep	O
)	O
{	O
if	O
(	O
!	O
TraverseLevels1	O
(	O
plevel	O
,	O
RunExpt	O
,	O
panal	O
,	O
&	O
dLnDataNew	O
,	O
NULL	O
)	O
)	O
{	O
pMCVar	O
->	O
dVal	double
=	O
dTheta	O
;	O
TraverseLevels1	O
(	O
plevel	O
,	O
RestoreLikelihoods	O
,	O
NULL	O
)	O
;	O
goto	O
WriteIt	O
;	O
}	O
}	O
if	O
(	O
!	O
TestImpRatioTemper	O
(	O
pgd	O
,	O
pMCVar	O
->	O
bExptIsDep	O
,	O
dLnKern	O
,	O
dLnKernNew	O
,	O
dLnPrior	O
,	O
dLnPriorNew	O
,	O
dLnLike	O
,	O
dLnLikeNew	O
,	O
dLnData	O
,	O
dLnDataNew	O
,	O
*	O
pindexT	O
)	O
)	O
{	O
pMCVar	O
->	O
dVal	double
=	O
dTheta	O
;	O
if	O
(	O
pMCVar	O
->	O
bExptIsDep	O
)	O
TraverseLevels1	O
(	O
plevel	O
,	O
RestoreLikelihoods	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
pMCVar	O
->	O
lJumps	O
=	O
pMCVar	O
->	O
lJumps	O
+	O
1	int
;	O
if	O
(	O
pMCVar	O
->	O
bExptIsDep	O
)	O
TraverseLevels1	O
(	O
plevel	O
,	O
SaveLikelihoods	O
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
*	O
pindexT	O
]	O
>	O
0	int
)	O
pMCVar	O
->	O
dKernelSD	O
=	O
old_dKernelSD	O
;	O
WriteIt	O
:	O
if	O
(	O
(	O
(	O
*	O
pnIter	O
+	O
1	int
)	O
%	O
pgd	O
->	O
nPrintFreq	O
==	O
0	int
)	O
&&	O
(	O
*	O
pnIter	O
>=	O
pgd	O
->	O
nMaxIter	O
-	O
pgd	O
->	O
nPrintIter	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"%5g\t"	*(char)
,	O
pMCVar	O
->	O
dVal	double
)	O
;	O
}	O
}	O
}	O
void	O
SampleThetaVector	O
(	O
PLEVEL	O
pLevel	O
,	O
PANALYSIS	O
panal	O
,	O
long	O
nThetas	O
,	O
double	O
*	O
pdTheta	O
,	O
double	O
*	O
pdSum	O
,	O
double	O
*	O
*	O
prgdSumProd	O
,	O
long	O
iter	O
,	O
long	O
nUpdateAt	O
,	O
long	O
nTotal	O
,	O
PDOUBLE	*(double)
pdLnPrior	O
,	O
PDOUBLE	*(double)
pdLnData	O
)	O
{	O
register	O
long	O
i	O
,	O
j	O
;	O
double	O
dTmp	O
,	O
dAccept	O
,	O
dLnPrior_old	O
,	O
dLnData_old	O
;	O
BOOL	int
bInBounds	O
;	O
static	O
long	O
lAccepted	O
=	O
0	int
;	O
static	O
double	O
dJumpSpread	O
;	O
static	O
PDOUBLE	*(double)
pdTheta_old	O
=	O
NULL	O
;	O
static	O
PDOUBLE	*(double)
*	O
prgdComponent	*(*(double))
;	O
static	O
PDOUBLE	*(double)
*	O
prgdVariance	*(*(double))
;	O
static	O
PDOUBLE	*(double)
dNormVar	O
;	O
if	O
(	O
(	O
pdTheta_old	O
==	O
NULL	O
)	O
||	O
(	O
iter	O
==	O
nUpdateAt	O
)	O
)	O
{	O
if	O
(	O
pdTheta_old	O
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
pdTheta_old	O
=	O
InitdVector	(long)->(*(double))
(	O
nThetas	O
)	O
)	O
||	O
!	O
(	O
dNormVar	O
=	O
InitdVector	(long)->(*(double))
(	O
nThetas	O
)	O
)	O
||	O
!	O
(	O
prgdVariance	*(*(double))
=	O
InitdMatrix	(long,long)->(*(*(double)))
(	O
nThetas	O
,	O
nThetas	O
)	O
)	O
||	O
!	O
(	O
prgdComponent	*(*(double))
=	O
InitdMatrix	(long,long)->(*(*(double)))
(	O
nThetas	O
,	O
nThetas	O
)	O
)	O
)	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"SampleThetaVector"	*(char)
)	O
;	O
dJumpSpread	O
=	O
2.4	int
/	O
sqrt	(double)->(double)
(	O
nThetas	O
)	O
;	O
}	O
else	O
{	O
dAccept	O
=	O
(	O
(	O
double	O
)	O
lAccepted	O
)	O
/	O
(	O
double	O
)	O
(	O
nTotal	O
)	O
;	O
if	O
(	O
dAccept	O
>	O
0.3	int
)	O
dJumpSpread	O
=	O
dJumpSpread	O
*	O
1.5	int
;	O
else	O
if	O
(	O
dAccept	O
<	O
0.15	int
)	O
dJumpSpread	O
=	O
dJumpSpread	O
*	O
0.7	int
;	O
printf	(*(char))->(int)
(	O
"Monitoring: iter\t%ld\t"	*(char)
,	O
iter	O
)	O
;	O
printf	(*(char))->(int)
(	O
"success rate\t%g\tspread\t%g\n"	*(char)
,	O
dAccept	O
,	O
dJumpSpread	O
)	O
;	O
lAccepted	O
=	O
0	int
;	O
}	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nThetas	O
;	O
j	O
++	O
)	O
prgdVariance	*(*(double))
[	O
i	O
]	O
[	O
j	O
]	O
=	O
(	O
prgdSumProd	O
[	O
i	O
]	O
[	O
j	O
]	O
-	O
pdSum	O
[	O
i	O
]	O
*	O
pdSum	O
[	O
j	O
]	O
/	O
(	O
double	O
)	O
(	O
iter	O
+	O
1	int
)	O
)	O
/	O
(	O
double	O
)	O
iter	O
;	O
if	O
(	O
!	O
Cholesky	(*(*(double)),*(*(double)),long)->(int)
(	O
prgdVariance	*(*(double))
,	O
prgdComponent	*(*(double))
,	O
nThetas	O
)	O
)	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nThetas	O
;	O
j	O
++	O
)	O
{	O
if	O
(	O
i	O
==	O
j	O
)	O
prgdVariance	*(*(double))
[	O
i	O
]	O
[	O
j	O
]	O
=	O
prgdSumProd	O
[	O
i	O
]	O
[	O
j	O
]	O
/	O
(	O
double	O
)	O
(	O
iter	O
)	O
;	O
else	O
prgdVariance	*(*(double))
[	O
i	O
]	O
[	O
j	O
]	O
=	O
0.0	int
;	O
}	O
if	O
(	O
!	O
Cholesky	(*(*(double)),*(*(double)),long)->(int)
(	O
prgdVariance	*(*(double))
,	O
prgdComponent	*(*(double))
,	O
nThetas	O
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: impossible to compute a jumping kernel - Exiting."	*(char)
"(You should check or change the restart file).\n\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
pdTheta_old	O
[	O
i	O
]	O
=	O
pdTheta	O
[	O
i	O
]	O
;	O
dLnPrior_old	O
=	O
*	O
pdLnPrior	O
;	O
dLnData_old	O
=	O
*	O
pdLnData	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
dNormVar	O
[	O
i	O
]	O
=	O
NormalRandom	(double,double)->(double)
(	O
0.0	int
,	O
1.0	int
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
{	O
dTmp	O
=	O
0	int
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<=	O
i	O
;	O
j	O
++	O
)	O
dTmp	O
=	O
dTmp	O
+	O
dNormVar	O
[	O
j	O
]	O
*	O
prgdComponent	*(*(double))
[	O
i	O
]	O
[	O
j	O
]	O
;	O
pdTheta	O
[	O
i	O
]	O
=	O
pdTheta_old	O
[	O
i	O
]	O
+	O
dJumpSpread	O
*	O
dTmp	O
;	O
}	O
long	O
iTmp	O
=	O
0	int
;	O
bInBounds	O
=	O
TraverseLevels1	O
(	O
pLevel	O
,	O
SetMCVars	O
,	O
pdTheta	O
,	O
&	O
iTmp	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
bInBounds	O
)	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
pdTheta	O
[	O
i	O
]	O
=	O
pdTheta_old	O
[	O
i	O
]	O
;	O
goto	O
DontJump	O
;	O
}	O
*	O
pdLnPrior	O
=	O
0.0	int
;	O
TraverseLevels	O
(	O
pLevel	O
,	O
CalculateTotals	O
,	O
panal	O
,	O
pdLnPrior	O
,	O
NULL	O
)	O
;	O
*	O
pdLnData	O
=	O
0.0	int
;	O
if	O
(	O
!	O
RunAllExpts	O
(	O
panal	O
,	O
pdLnData	O
)	O
)	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
pdTheta	O
[	O
i	O
]	O
=	O
pdTheta_old	O
[	O
i	O
]	O
;	O
*	O
pdLnPrior	O
=	O
dLnPrior_old	O
;	O
*	O
pdLnData	O
=	O
dLnData_old	O
;	O
}	O
else	O
{	O
if	O
(	O
log	(double)->(double)
(	O
Randoms	()->(double)
(	O
)	O
)	O
>	O
(	O
(	O
*	O
pdLnPrior	O
)	O
+	O
(	O
*	O
pdLnData	O
)	O
-	O
dLnPrior_old	O
-	O
dLnData_old	O
)	O
)	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
pdTheta	O
[	O
i	O
]	O
=	O
pdTheta_old	O
[	O
i	O
]	O
;	O
*	O
pdLnPrior	O
=	O
dLnPrior_old	O
;	O
*	O
pdLnData	O
=	O
dLnData_old	O
;	O
}	O
else	O
{	O
lAccepted	O
++	O
;	O
}	O
}	O
DontJump	O
:	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nThetas	O
;	O
i	O
++	O
)	O
{	O
pdSum	O
[	O
i	O
]	O
+=	O
pdTheta	O
[	O
i	O
]	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nThetas	O
;	O
j	O
++	O
)	O
prgdSumProd	O
[	O
i	O
]	O
[	O
j	O
]	O
+=	O
pdTheta	O
[	O
i	O
]	O
*	O
pdTheta	O
[	O
j	O
]	O
;	O
}	O
}	O
int	O
SaveLikelihoods	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PEXPERIMENT	O
pExpt	O
=	O
plevel	O
->	O
pexpt	O
;	O
if	O
(	O
pExpt	O
!=	O
NULL	O
)	O
{	O
pExpt	O
->	O
dLnLikeSave	O
=	O
pExpt	O
->	O
dLnLike	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
SetFixedVars	O
(	O
PLEVEL	O
plevel	O
)	O
{	O
long	O
n	int
;	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
pFVar	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nFixedVars	O
;	O
n	int
++	O
)	O
{	O
pFVar	O
=	O
plevel	O
->	O
rgpFixedVars	O
[	O
n	int
]	O
;	O
if	O
(	O
IsInput	(long)->(int)
(	O
pFVar	O
->	O
hvar	long
)	O
)	O
SetInput	(long,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))->(int)
(	O
pFVar	O
->	O
hvar	long
,	O
pFVar	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
)	O
;	O
else	O
SetVar	(long,double)->(int)
(	O
pFVar	O
->	O
hvar	long
,	O
pFVar	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
dVal	double
)	O
;	O
}	O
}	O
void	O
SetKernel	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
intptr_t	long
useMCVarVals	O
=	O
(	O
intptr_t	long
)	O
args	O
[	O
0	int
]	O
;	O
double	O
*	O
pdMCVarVals	O
=	O
(	O
double	O
*	O
)	O
args	O
[	O
1	int
]	O
;	O
double	O
dMin	O
,	O
dMax	O
,	O
dTmp	O
;	O
long	O
n	int
,	O
m	O
;	O
static	O
long	O
nThetas	O
;	O
PMCVAR	O
pMCVar	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
->	O
bIsFixed	O
)	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
;	O
CalculateOneMCParm	O
(	O
pMCVar	O
)	O
;	O
if	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_UNIFORM	O
||	O
pMCVar	O
->	O
iType	int
==	O
MCV_LOGUNIFORM	O
)	O
pMCVar	O
->	O
dMaxKernelSD	O
=	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
1	int
]	O
)	O
-	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
0	int
]	O
)	O
)	O
/	O
6.0	int
;	O
else	O
pMCVar	O
->	O
dMaxKernelSD	O
=	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
3	int
]	O
)	O
-	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
2	int
]	O
)	O
)	O
/	O
6.0	int
;	O
dMin	O
=	O
dMax	O
=	O
pMCVar	O
->	O
dVal	double
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
3	int
;	O
m	O
++	O
)	O
{	O
CalculateOneMCParm	O
(	O
pMCVar	O
)	O
;	O
dTmp	O
=	O
pMCVar	O
->	O
dVal	double
;	O
if	O
(	O
dMin	O
>=	O
dTmp	O
)	O
dMin	O
=	O
dTmp	O
;	O
else	O
if	O
(	O
dMax	O
<	O
dTmp	O
)	O
dMax	O
=	O
dTmp	O
;	O
}	O
if	O
(	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
2	int
]	O
)	O
==	O
-	O
DBL_MAX	O
)	O
||	O
(	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
3	int
]	O
)	O
==	O
DBL_MAX	O
)	O
)	O
pMCVar	O
->	O
dKernelSD	O
=	O
(	O
0.5	int
*	O
dMax	O
)	O
-	O
(	O
0.5	int
*	O
dMin	O
)	O
;	O
else	O
pMCVar	O
->	O
dKernelSD	O
=	O
dMax	O
-	O
dMin	O
;	O
if	O
(	O
pMCVar	O
->	O
dKernelSD	O
==	O
0	int
)	O
{	O
pMCVar	O
->	O
dKernelSD	O
=	O
pMCVar	O
->	O
dMaxKernelSD	O
;	O
}	O
}	O
if	O
(	O
useMCVarVals	O
==	O
1	int
)	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
->	O
dVal	double
=	O
pdMCVarVals	O
[	O
nThetas	O
++	O
]	O
;	O
}	O
}	O
void	O
WriteKernel	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
FILE	struct
*	O
pfile	O
=	O
(	O
FILE	struct
*	O
)	O
args	O
[	O
0	int
]	O
;	O
long	O
n	int
;	O
PMCVAR	O
pMCVar	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
->	O
bIsFixed	O
)	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfile	O
,	O
"%lg\t"	*(char)
,	O
pMCVar	O
->	O
dKernelSD	O
)	O
;	O
}	O
}	O
}	O
void	O
ReadKernel	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
FILE	struct
*	O
pfile	O
=	O
(	O
FILE	struct
*	O
)	O
args	O
[	O
0	int
]	O
;	O
long	O
n	int
;	O
PMCVAR	O
pMCVar	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
->	O
bIsFixed	O
)	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
;	O
pMCVar	O
->	O
dMaxKernelSD	O
=	O
(	O
MaxMCVar	O
(	O
pMCVar	O
)	O
-	O
MinMCVar	O
(	O
pMCVar	O
)	O
)	O
/	O
6.0	int
;	O
if	O
(	O
!	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfile	O
,	O
"%lg"	*(char)
,	O
&	O
(	O
pMCVar	O
->	O
dKernelSD	O
)	O
)	O
)	O
{	O
ReportError	O
(	O
NULL	O
,	O
RE_READERROR	O
|	O
RE_FATAL	O
,	O
"kernel file"	*(char)
,	O
NULL	O
)	O
;	O
}	O
}	O
}	O
}	O
void	O
SetModelVars	O
(	O
PLEVEL	O
plevel	O
)	O
{	O
long	O
n	int
;	O
PMCVAR	O
pMCVar	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
;	O
if	O
(	O
!	O
(	O
pMCVar	O
->	O
bIsFixed	O
)	O
&&	O
(	O
IsParm	(long)->(int)
(	O
pMCVar	O
->	O
hvar	long
)	O
)	O
)	O
SetVar	(long,double)->(int)
(	O
pMCVar	O
->	O
hvar	long
,	O
pMCVar	O
->	O
dVal	double
)	O
;	O
}	O
}	O
int	O
SetMCVars	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
double	O
*	O
pdMCVarVals	O
=	O
(	O
double	O
*	O
)	O
args	O
[	O
0	int
]	O
;	O
long	O
*	O
nThetas	O
=	O
(	O
long	O
*	O
)	O
args	O
[	O
1	int
]	O
;	O
PMCVAR	O
pMCVar	O
;	O
double	O
dVar	O
;	O
long	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
dVar	O
=	O
pdMCVarVals	O
[	O
(	O
*	O
nThetas	O
)	O
++	O
]	O
;	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
;	O
if	O
(	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_UNIFORM	O
)	O
||	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_LOGUNIFORM	O
)	O
)	O
{	O
if	O
(	O
(	O
dVar	O
<	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
0	int
]	O
)	O
)	O
||	O
(	O
dVar	O
>	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
1	int
]	O
)	O
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
dVar	O
<	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
2	int
]	O
)	O
)	O
||	O
(	O
dVar	O
>	O
*	O
(	O
pMCVar	O
->	O
pdParm	O
[	O
3	int
]	O
)	O
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
pMCVar	O
->	O
dVal	double
=	O
dVar	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
SetPointers	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
long	O
i	O
,	O
j	O
,	O
k	O
;	O
PMCVAR	O
pMCVar	O
;	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
;	O
BOOL	int
bFound	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
plevel	O
->	O
nMCVars	O
;	O
i	O
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
i	O
]	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
4	int
;	O
j	O
++	O
)	O
{	O
if	O
(	O
pMCVar	O
->	O
pMCVParent	O
[	O
j	O
]	O
==	O
NULL	O
)	O
pMCVar	O
->	O
pdParm	O
[	O
j	O
]	O
=	O
&	O
(	O
pMCVar	O
->	O
dParm	O
[	O
j	O
]	O
)	O
;	O
else	O
pMCVar	O
->	O
pdParm	O
[	O
j	O
]	O
=	O
&	O
(	O
pMCVar	O
->	O
pMCVParent	O
[	O
j	O
]	O
->	O
dVal	double
)	O
;	O
}	O
}	O
if	O
(	O
plevel	O
->	O
pexpt	O
!=	O
NULL	O
)	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
plevel	O
->	O
nLikes	O
;	O
i	O
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpLikes	O
[	O
i	O
]	O
;	O
pos	O
=	O
&	O
(	O
plevel	O
->	O
pexpt	O
->	O
os	O
)	O
;	O
bFound	O
=	O
FALSE	O
;	O
j	O
=	O
0	int
;	O
while	O
(	O
(	O
j	O
<	O
pos	O
->	O
nData	int
)	O
&&	O
(	O
!	O
bFound	O
)	O
)	O
{	O
bFound	O
=	O
(	O
pMCVar	O
->	O
hvar	long
==	O
pos	O
->	O
phvar_dat	*(long)
[	O
j	O
]	O
)	O
;	O
if	O
(	O
!	O
bFound	O
)	O
j	O
++	O
;	O
}	O
if	O
(	O
bFound	O
)	O
{	O
pMCVar	O
->	O
pdVal	O
=	O
pos	O
->	O
prgdDataVals	*(*(double))
[	O
j	O
]	O
;	O
pMCVar	O
->	O
lCount	O
=	O
pos	O
->	O
pcData	*(int)
[	O
j	O
]	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Error: no Data for %s in Simulation %d - Exiting.\n\n"	*(char)
,	O
pMCVar	O
->	O
pszName	O
,	O
plevel	O
->	O
pexpt	O
->	O
iExp	O
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
4	int
;	O
j	O
++	O
)	O
{	O
if	O
(	O
pMCVar	O
->	O
iParmType	O
[	O
j	O
]	O
==	O
MCVP_PRED	O
)	O
{	O
bFound	O
=	O
FALSE	O
;	O
k	O
=	O
0	int
;	O
while	O
(	O
(	O
k	O
<	O
pos	O
->	O
nOutputs	int
)	O
&&	O
(	O
!	O
bFound	O
)	O
)	O
{	O
bFound	O
=	O
(	O
pMCVar	O
->	O
hParm	O
[	O
j	O
]	O
==	O
pos	O
->	O
phvar_out	*(long)
[	O
k	O
]	O
)	O
;	O
if	O
(	O
!	O
bFound	O
)	O
k	O
++	O
;	O
}	O
if	O
(	O
bFound	O
)	O
{	O
pMCVar	O
->	O
pdParm	O
[	O
j	O
]	O
=	O
&	O
(	O
pos	O
->	O
prgdOutputVals	*(*(double))
[	O
k	O
]	O
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Error: missing Print statement for parameter number %ld\n"	*(char)
"of %s distribution - Exiting.\n\n"	*(char)
,	O
j	O
,	O
pMCVar	O
->	O
pszName	O
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pMCVar	O
->	O
iParmType	O
[	O
j	O
]	O
==	O
MCVP_DATA	O
)	O
{	O
bFound	O
=	O
FALSE	O
;	O
k	O
=	O
0	int
;	O
while	O
(	O
(	O
k	O
<	O
pos	O
->	O
nData	int
)	O
&&	O
(	O
!	O
bFound	O
)	O
)	O
{	O
bFound	O
=	O
(	O
pMCVar	O
->	O
hParm	O
[	O
j	O
]	O
==	O
pos	O
->	O
phvar_dat	*(long)
[	O
k	O
]	O
)	O
;	O
if	O
(	O
!	O
bFound	O
)	O
k	O
++	O
;	O
}	O
if	O
(	O
bFound	O
)	O
{	O
pMCVar	O
->	O
pdParm	O
[	O
j	O
]	O
=	O
&	O
(	O
pos	O
->	O
prgdDataVals	*(*(double))
[	O
k	O
]	O
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Error: no Data for %s in Simulation %d - Exiting.\n\n"	*(char)
,	O
pMCVar	O
->	O
pszName	O
,	O
plevel	O
->	O
pexpt	O
->	O
iExp	O
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
pMCVar	O
->	O
pMCVParent	O
[	O
j	O
]	O
==	O
NULL	O
)	O
pMCVar	O
->	O
pdParm	O
[	O
j	O
]	O
=	O
&	O
(	O
pMCVar	O
->	O
dParm	O
[	O
j	O
]	O
)	O
;	O
else	O
pMCVar	O
->	O
pdParm	O
[	O
j	O
]	O
=	O
&	O
(	O
pMCVar	O
->	O
pMCVParent	O
[	O
j	O
]	O
->	O
dVal	double
)	O
;	O
}	O
}	O
}	O
}	O
int	O
SumAllExpts	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
double	O
*	O
pdLnData	O
=	O
(	O
double	O
*	O
)	O
args	O
[	O
0	int
]	O
;	O
PEXPERIMENT	O
pExpt	O
=	O
plevel	O
->	O
pexpt	O
;	O
if	O
(	O
pExpt	O
!=	O
NULL	O
)	O
{	O
*	O
pdLnData	O
+=	O
pExpt	O
->	O
dLnLike	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
BOOL	int
TestImpRatio	O
(	O
PGIBBSDATA	O
pgd	O
,	O
BOOL	int
bExptIsDep	O
,	O
double	O
dLnKern	O
,	O
double	O
dLnKernNew	O
,	O
double	O
dLnPrior	O
,	O
double	O
dLnPriorNew	O
,	O
double	O
dLnLike	O
,	O
double	O
dLnLikeNew	O
,	O
double	O
dLnData	O
,	O
double	O
dLnDataNew	O
)	O
{	O
double	O
dPjump	O
;	O
if	O
(	O
dLnKernNew	O
==	O
NULL_SUPPORT	O
||	O
dLnPriorNew	O
==	O
NULL_SUPPORT	O
||	O
dLnLikeNew	O
==	O
NULL_SUPPORT	O
||	O
dLnDataNew	O
==	O
NULL_SUPPORT	O
)	O
return	O
FALSE	O
;	O
dPjump	O
=	O
dLnPriorNew	O
-	O
dLnPrior	O
+	O
dLnLikeNew	O
-	O
dLnLike	O
+	O
dLnKern	O
-	O
dLnKernNew	O
;	O
if	O
(	O
bExptIsDep	O
)	O
dPjump	O
+=	O
dLnDataNew	O
-	O
dLnData	O
;	O
if	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
0	int
)	O
return	O
(	O
(	O
BOOL	int
)	O
(	O
log	(double)->(double)
(	O
Randoms	()->(double)
(	O
)	O
)	O
<=	O
dPjump	O
)	O
)	O
;	O
else	O
{	O
if	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
5	int
)	O
return	O
(	O
(	O
BOOL	int
)	O
(	O
0	int
<=	O
dPjump	O
)	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Error: simTypeFlag should be 0 or 5 in TestImpRatio "	*(char)
"- Exiting.\n\n"	*(char)
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
BOOL	int
TestImpRatioTemper	O
(	O
PGIBBSDATA	O
pgd	O
,	O
BOOL	int
bExptIsDep	O
,	O
double	O
dLnKern	O
,	O
double	O
dLnKernNew	O
,	O
double	O
dLnPrior	O
,	O
double	O
dLnPriorNew	O
,	O
double	O
dLnLike	O
,	O
double	O
dLnLikeNew	O
,	O
double	O
dLnData	O
,	O
double	O
dLnDataNew	O
,	O
long	O
indexT	O
)	O
{	O
double	O
dPjump	O
;	O
if	O
(	O
dLnPriorNew	O
==	O
NULL_SUPPORT	O
||	O
dLnLikeNew	O
==	O
NULL_SUPPORT	O
||	O
dLnDataNew	O
==	O
NULL_SUPPORT	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
indexT	O
]	O
==	O
0	int
)	O
return	O
TRUE	O
;	O
if	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
3	int
)	O
{	O
dPjump	O
=	O
pgd	O
->	O
rgdPerks	O
[	O
indexT	O
]	O
*	O
(	O
dLnPriorNew	O
-	O
dLnPrior	O
+	O
dLnLikeNew	O
-	O
dLnLike	O
)	O
+	O
dLnKern	O
-	O
dLnKernNew	O
;	O
}	O
else	O
{	O
dPjump	O
=	O
dLnPriorNew	O
-	O
dLnPrior	O
+	O
pgd	O
->	O
rgdPerks	O
[	O
indexT	O
]	O
*	O
(	O
dLnLikeNew	O
-	O
dLnLike	O
)	O
+	O
dLnKern	O
-	O
dLnKernNew	O
;	O
}	O
if	O
(	O
bExptIsDep	O
)	O
dPjump	O
+=	O
pgd	O
->	O
rgdPerks	O
[	O
indexT	O
]	O
*	O
(	O
dLnDataNew	O
-	O
dLnData	O
)	O
;	O
return	O
(	O
(	O
BOOL	int
)	O
(	O
log	(double)->(double)
(	O
Randoms	()->(double)
(	O
)	O
)	O
<=	O
dPjump	O
)	O
)	O
;	O
}	O
BOOL	int
TestTemper	O
(	O
PGIBBSDATA	O
pgd	O
,	O
long	O
indexT	O
,	O
long	O
indexT_new	O
,	O
double	O
dLnPrior	O
,	O
double	O
dLnData	O
,	O
double	O
pseudo	O
,	O
double	O
pseudonew	O
)	O
{	O
double	O
dPjump	O
=	O
0	int
;	O
if	O
(	O
dLnPrior	O
+	O
dLnData	O
==	O
NULL_SUPPORT	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
3	int
)	O
{	O
dPjump	O
=	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
indexT_new	O
]	O
-	O
pgd	O
->	O
rgdPerks	O
[	O
indexT	O
]	O
)	O
*	O
(	O
dLnPrior	O
+	O
dLnData	O
)	O
+	O
pseudonew	O
-	O
pseudo	O
+	O
(	O
(	O
indexT_new	O
==	O
0	int
)	O
||	O
(	O
indexT_new	O
==	O
pgd	O
->	O
nPerks	O
-	O
1	int
)	O
?	O
0	int
:	O
MINUSLN2	O
)	O
-	O
(	O
(	O
indexT	O
==	O
0	int
)	O
||	O
(	O
indexT	O
==	O
pgd	O
->	O
nPerks	O
-	O
1	int
)	O
?	O
0	int
:	O
MINUSLN2	O
)	O
;	O
}	O
else	O
{	O
dPjump	O
=	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
indexT_new	O
]	O
-	O
pgd	O
->	O
rgdPerks	O
[	O
indexT	O
]	O
)	O
*	O
dLnData	O
+	O
pseudonew	O
-	O
pseudo	O
+	O
(	O
(	O
indexT_new	O
==	O
0	int
)	O
||	O
(	O
indexT_new	O
==	O
pgd	O
->	O
nPerks	O
-	O
1	int
)	O
?	O
0	int
:	O
MINUSLN2	O
)	O
-	O
(	O
(	O
indexT	O
==	O
0	int
)	O
||	O
(	O
indexT	O
==	O
pgd	O
->	O
nPerks	O
-	O
1	int
)	O
?	O
0	int
:	O
MINUSLN2	O
)	O
;	O
}	O
return	O
(	O
(	O
BOOL	int
)	O
(	O
log	(double)->(double)
(	O
Randoms	()->(double)
(	O
)	O
)	O
<=	O
dPjump	O
)	O
)	O
;	O
}	O
void	O
TraverseLevels	O
(	O
PLEVEL	O
plevel	O
,	O
void	O
(	O
*	O
routinePtr	O
)	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	O
;	O
static	O
char	O
*	O
arg	O
[	O
MAX_ARGS	O
]	O
,	O
*	O
*	O
args	O
=	O
arg	O
;	O
char	O
*	O
arg1	O
;	O
long	O
n	int
,	O
nargs	O
=	O
0	int
;	O
va_start	O
(	O
ap	O
,	O
routinePtr	O
)	O
;	O
if	O
(	O
(	O
arg1	O
=	O
va_arg	O
(	O
ap	O
,	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
arg	O
[	O
0	int
]	O
=	O
arg1	O
;	O
while	O
(	O
(	O
arg	O
[	O
++	O
nargs	O
]	O
=	O
va_arg	O
(	O
ap	O
,	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
}	O
;	O
}	O
va_end	O
(	O
ap	O
)	O
;	O
routinePtr	O
(	O
plevel	O
,	O
args	O
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
iInstances	O
;	O
n	int
++	O
)	O
TraverseLevels	O
(	O
plevel	O
->	O
pLevels	O
[	O
n	int
]	O
,	O
routinePtr	O
,	O
NULL	O
)	O
;	O
}	O
int	O
TraverseLevels1	O
(	O
PLEVEL	O
plevel	O
,	O
int	O
(	O
*	O
routinePtr	O
)	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	O
;	O
static	O
char	O
*	O
arg	O
[	O
MAX_ARGS	O
]	O
,	O
*	O
*	O
args	O
=	O
arg	O
;	O
char	O
*	O
arg1	O
;	O
long	O
n	int
,	O
nargs	O
=	O
0	int
;	O
va_start	O
(	O
ap	O
,	O
routinePtr	O
)	O
;	O
if	O
(	O
(	O
arg1	O
=	O
va_arg	O
(	O
ap	O
,	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
arg	O
[	O
0	int
]	O
=	O
arg1	O
;	O
while	O
(	O
(	O
arg	O
[	O
++	O
nargs	O
]	O
=	O
va_arg	O
(	O
ap	O
,	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
}	O
;	O
}	O
va_end	O
(	O
ap	O
)	O
;	O
if	O
(	O
routinePtr	O
(	O
plevel	O
,	O
args	O
)	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
iInstances	O
;	O
n	int
++	O
)	O
{	O
if	O
(	O
!	O
TraverseLevels1	O
(	O
plevel	O
->	O
pLevels	O
[	O
n	int
]	O
,	O
routinePtr	O
,	O
NULL	O
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
else	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
WriteHeader	O
(	O
PANALYSIS	O
panal	O
)	O
{	O
PGIBBSDATA	O
pgd	O
=	O
&	O
panal	O
->	O
gd	O
;	O
long	O
i	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"iter\t"	*(char)
)	O
;	O
TraverseLevels	O
(	O
panal	O
->	O
pLevels	O
[	O
0	int
]	O
,	O
WriteParameterNames	O
,	O
panal	O
,	O
pgd	O
->	O
pfileOut	O
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
3	int
)	O
||	O
(	O
pgd	O
->	O
nSimTypeFlag	O
==	O
4	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"IndexT\t"	*(char)
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
pgd	O
->	O
nPerks	O
;	O
i	O
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"LnPseudoPrior(%ld)\t"	*(char)
,	O
i	O
+	O
1	int
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pgd	O
->	O
pfileOut	O
,	O
"LnPrior\tLnData\tLnPosterior\n"	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pgd	O
->	O
pfileOut	O
)	O
;	O
}	O
void	O
WriteParameterNames	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
args	O
[	O
0	int
]	O
;	O
PFILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
outFile	O
=	O
(	O
FILE	struct
*	O
)	O
args	O
[	O
1	int
]	O
;	O
long	O
n	int
,	O
m	O
;	O
panal	O
->	O
iInstance	O
[	O
plevel	O
->	O
iDepth	O
]	O
=	O
plevel	O
->	O
iSequence	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outFile	O
,	O
"%s("	*(char)
,	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
->	O
pszName	O
)	O
;	O
for	O
(	O
m	O
=	O
1	int
;	O
m	O
<	O
plevel	O
->	O
iDepth	O
;	O
m	O
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outFile	O
,	O
"%d."	*(char)
,	O
panal	O
->	O
iInstance	O
[	O
m	O
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outFile	O
,	O
"%d)\t"	*(char)
,	O
panal	O
->	O
iInstance	O
[	O
plevel	O
->	O
iDepth	O
]	O
)	O
;	O
}	O
}	O
void	O
WriteMCVars	O
(	O
PLEVEL	O
plevel	O
,	O
char	O
*	O
*	O
args	O
)	O
{	O
PFILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
pOutFile	O
=	O
(	O
PFILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
args	O
[	O
0	int
]	O
;	O
long	O
n	int
;	O
PMCVAR	O
pMCVar	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
nMCVars	O
;	O
n	int
++	O
)	O
{	O
pMCVar	O
=	O
plevel	O
->	O
rgpMCVars	O
[	O
n	int
]	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pOutFile	O
,	O
"%5g\t"	*(char)
,	O
pMCVar	O
->	O
dVal	double
)	O
;	O
}	O
}	O
