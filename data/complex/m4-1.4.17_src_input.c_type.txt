enum	O
input_type	enum(int,int,int)
{	O
INPUT_STRING	int
,	O
INPUT_FILE	int
,	O
INPUT_MACRO	int
}	O
;	O
typedef	O
enum	O
input_type	enum(int,int,int)
input_type	enum(int,int,int)
;	O
struct	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
{	O
struct	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
input_type	enum(int,int,int)
type	enum(int,int,int,int)
;	O
const	O
char	O
*	O
file	*(char)
;	O
int	O
line	int
;	O
union	O
{	O
struct	O
{	O
char	O
*	O
string	struct(*(char),long)
;	O
char	O
*	O
end	*(char)
;	O
}	O
u_s	struct(*(char),*(char))
;	O
struct	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
bool_bitfield	bool
end	*(char)
:	O
1	int
;	O
bool_bitfield	bool
close	*((*(void))->(int))
:	O
1	int
;	O
bool_bitfield	bool
advance	bool
:	O
1	int
;	O
}	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
;	O
builtin_func	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct)))->(void)
*	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
;	O
}	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
;	O
}	O
;	O
typedef	O
struct	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
;	O
const	O
char	O
*	O
current_file	*(char)
;	O
int	O
current_line	int
;	O
static	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
static	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
file_names	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
static	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
wrapup_stack	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
static	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
static	O
void	O
*	O
token_bottom	*(void)
;	O
static	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
static	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
wsp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
static	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
static	O
bool	bool
start_of_input_line	bool
;	O
static	O
bool	bool
input_change	bool
;	O
STRING	struct(*(char),long)
rquote	struct(*(char),long)
;	O
STRING	struct(*(char),long)
lquote	struct(*(char),long)
;	O
STRING	struct(*(char),long)
bcomm	struct(*(char),long)
;	O
STRING	struct(*(char),long)
ecomm	struct(*(char),long)
;	O
void	O
push_file	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),bool)->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
const	O
char	O
*	O
title	*(char)
,	O
bool	bool
close_when_done	bool
)	O
{	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
if	O
(	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
!=	O
NULL	O
)	O
{	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
NULL	O
;	O
}	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_INPUT	int
)	O
DEBUG_MESSAGE1	O
(	O
"input read from %s"	*(char)
,	O
title	*(char)
)	O
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
(	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
)	O
obstack_alloc	O
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
sizeof	O
(	O
struct	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
)	O
)	O
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
type	enum(int,int,int,int)
=	O
INPUT_FILE	int
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
file	*(char)
=	O
(	O
char	O
*	O
)	O
obstack_copy0	O
(	O
&	O
file_names	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
title	*(char)
,	O
strlen	(*(char))->(long)
(	O
title	*(char)
)	O
)	O
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
line	int
=	O
1	int
;	O
input_change	bool
=	O
true	int
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
end	*(char)
=	O
false	int
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
close	*((*(void))->(int))
=	O
close_when_done	bool
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
advance	bool
=	O
start_of_input_line	bool
;	O
output_current_line	int
=	O
-	O
1	int
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
}	O
void	O
push_macro	(*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))->(void)
(	O
builtin_func	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct)))->(void)
*	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
)	O
{	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
if	O
(	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
!=	O
NULL	O
)	O
{	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
NULL	O
;	O
}	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
(	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
)	O
obstack_alloc	O
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
sizeof	O
(	O
struct	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
)	O
)	O
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
type	enum(int,int,int,int)
=	O
INPUT_MACRO	int
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
file	*(char)
=	O
current_file	*(char)
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
line	int
=	O
current_line	int
;	O
input_change	bool
=	O
true	int
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
=	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
}	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
push_string_init	()->(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
(	O
void	O
)	O
{	O
if	O
(	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
!=	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: recursive push_string!"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
(	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
)	O
obstack_alloc	O
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
sizeof	O
(	O
struct	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
)	O
)	O
;	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
->	O
type	enum(int,int,int,int)
=	O
INPUT_STRING	int
;	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
->	O
file	*(char)
=	O
current_file	*(char)
;	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
->	O
line	int
=	O
current_line	int
;	O
return	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
}	O
const	O
char	O
*	O
push_string_finish	()->(*(char))
(	O
void	O
)	O
{	O
const	O
char	O
*	O
ret	*(char)
=	O
NULL	O
;	O
if	O
(	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
obstack_object_size	O
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
>	O
0	int
)	O
{	O
size_t	long
len	long
=	O
obstack_object_size	O
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
obstack_1grow	O
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'\0'	O
)	O
;	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
string	struct(*(char),long)
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
end	*(char)
=	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
string	struct(*(char),long)
+	O
len	long
;	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
ret	*(char)
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
string	struct(*(char),long)
;	O
input_change	bool
=	O
true	int
;	O
}	O
else	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
NULL	O
;	O
return	O
ret	*(char)
;	O
}	O
void	O
push_wrapup	(*(char))->(void)
(	O
const	O
char	O
*	O
s	long
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
s	long
)	O
;	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
(	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
)	O
obstack_alloc	O
(	O
wrapup_stack	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
sizeof	O
(	O
struct	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
)	O
)	O
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
wsp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
type	enum(int,int,int,int)
=	O
INPUT_STRING	int
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
file	*(char)
=	O
current_file	*(char)
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
line	int
=	O
current_line	int
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
string	struct(*(char),long)
=	O
(	O
char	O
*	O
)	O
obstack_copy0	O
(	O
wrapup_stack	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
s	long
,	O
len	long
)	O
;	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
end	*(char)
=	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
string	struct(*(char),long)
+	O
len	long
;	O
wsp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
i	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
}	O
static	O
void	O
pop_input	()->(void)
(	O
void	O
)	O
{	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
tmp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
switch	O
(	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
INPUT_STRING	int
:	O
case	O
INPUT_MACRO	int
:	O
break	O
;	O
case	O
INPUT_FILE	int
:	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_INPUT	int
)	O
{	O
if	O
(	O
tmp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
)	O
DEBUG_MESSAGE2	O
(	O
"input reverted to %s, line %d"	*(char)
,	O
tmp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
file	*(char)
,	O
tmp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
line	int
)	O
;	O
else	O
DEBUG_MESSAGE	O
(	O
"input exhausted"	*(char)
)	O
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"read error"	*(char)
)	O
)	O
;	O
if	O
(	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
close	*((*(void))->(int))
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
retcode	int
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
close	*((*(void))->(int))
&&	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"error reading file"	*(char)
)	O
)	O
;	O
retcode	int
=	O
EXIT_FAILURE	int
;	O
}	O
start_of_input_line	bool
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
advance	bool
;	O
output_current_line	int
=	O
-	O
1	int
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: input stack botch in pop_input ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
)	O
;	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
NULL	O
;	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
tmp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
input_change	bool
=	O
true	int
;	O
}	O
bool	bool
pop_wrapup	()->(bool)
(	O
void	O
)	O
{	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
NULL	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
if	O
(	O
wsp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
==	O
NULL	O
)	O
{	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
NULL	O
)	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
file_names	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
NULL	O
)	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
wrapup_stack	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
wrapup_stack	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
return	O
false	int
;	O
}	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
wrapup_stack	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
wrapup_stack	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
)	O
)	O
;	O
obstack_init	O
(	O
wrapup_stack	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
wsp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
wsp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
NULL	O
;	O
input_change	bool
=	O
true	int
;	O
return	O
true	int
;	O
}	O
static	O
void	O
init_macro_token	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))->(void)
(	O
token_data	struct
*	O
td	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
{	O
if	O
(	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
type	enum(int,int,int,int)
!=	O
INPUT_MACRO	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad call to init_macro_token ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
TOKEN_DATA_TYPE	O
(	O
td	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
=	O
TOKEN_FUNC	int
;	O
TOKEN_DATA_FUNC	O
(	O
td	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
;	O
}	O
static	O
int	O
peek_input	()->(int)
(	O
void	O
)	O
{	O
int	O
ch	int
;	O
input_block	struct(*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void))))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),bool,bool,bool),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
*	O
block	*(void)
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
block	*(void)
==	O
NULL	O
)	O
return	O
CHAR_EOF	int
;	O
switch	O
(	O
block	*(void)
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
INPUT_STRING	int
:	O
ch	int
=	O
to_uchar	O
(	O
block	*(void)
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
string	struct(*(char),long)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
ch	int
!=	O
'\0'	O
)	O
return	O
ch	int
;	O
break	O
;	O
case	O
INPUT_FILE	int
:	O
ch	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
block	*(void)
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ch	int
!=	O
EOF	O
)	O
{	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ch	int
,	O
block	*(void)
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
ch	int
;	O
}	O
block	*(void)
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
end	*(char)
=	O
true	int
;	O
break	O
;	O
case	O
INPUT_MACRO	int
:	O
return	O
CHAR_MACRO	int
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: input stack botch in peek_input ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
block	*(void)
=	O
block	*(void)
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
}	O
}	O
static	O
int	O
next_char_1	()->(int)
(	O
void	O
)	O
{	O
int	O
ch	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
==	O
NULL	O
)	O
{	O
current_file	*(char)
=	O
""	*(char)
;	O
current_line	int
=	O
0	int
;	O
return	O
CHAR_EOF	int
;	O
}	O
if	O
(	O
input_change	bool
)	O
{	O
current_file	*(char)
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
file	*(char)
;	O
current_line	int
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
line	int
;	O
input_change	bool
=	O
false	int
;	O
}	O
switch	O
(	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
INPUT_STRING	int
:	O
ch	int
=	O
to_uchar	O
(	O
*	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
string	struct(*(char),long)
++	O
)	O
;	O
if	O
(	O
ch	int
!=	O
'\0'	O
)	O
return	O
ch	int
;	O
break	O
;	O
case	O
INPUT_FILE	int
:	O
if	O
(	O
start_of_input_line	bool
)	O
{	O
start_of_input_line	bool
=	O
false	int
;	O
current_line	int
=	O
++	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
line	int
;	O
}	O
ch	int
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
end	*(char)
?	O
EOF	O
:	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_f	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,bool,bool)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ch	int
!=	O
EOF	O
)	O
{	O
if	O
(	O
ch	int
==	O
'\n'	O
)	O
start_of_input_line	bool
=	O
true	int
;	O
return	O
ch	int
;	O
}	O
break	O
;	O
case	O
INPUT_MACRO	int
:	O
pop_input	()->(void)
(	O
)	O
;	O
return	O
CHAR_MACRO	int
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: input stack botch in next_char ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
pop_input	()->(void)
(	O
)	O
;	O
}	O
}	O
void	O
skip_line	()->(void)
(	O
void	O
)	O
{	O
int	O
ch	int
;	O
const	O
char	O
*	O
file	*(char)
=	O
current_file	*(char)
;	O
int	O
line	int
=	O
current_line	int
;	O
while	O
(	O
(	O
ch	int
=	O
next_char	O
(	O
)	O
)	O
!=	O
CHAR_EOF	int
&&	O
ch	int
!=	O
'\n'	O
)	O
;	O
if	O
(	O
ch	int
==	O
CHAR_EOF	int
)	O
M4ERROR_AT_LINE	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
file	*(char)
,	O
line	int
,	O
"Warning: end of file treated as newline"	*(char)
)	O
)	O
;	O
if	O
(	O
file	*(char)
!=	O
current_file	*(char)
||	O
line	int
!=	O
current_line	int
)	O
input_change	bool
=	O
true	int
;	O
}	O
static	O
bool	bool
match_input	(*(char),bool)->(bool)
(	O
const	O
char	O
*	O
s	long
,	O
bool	bool
consume	bool
)	O
{	O
int	O
n	long
;	O
int	O
ch	int
;	O
const	O
char	O
*	O
t	*(char)
;	O
bool	bool
result	*(*(char))
=	O
false	int
;	O
ch	int
=	O
peek_input	()->(int)
(	O
)	O
;	O
if	O
(	O
ch	int
!=	O
to_uchar	O
(	O
*	O
s	long
)	O
)	O
return	O
false	int
;	O
if	O
(	O
s	long
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
consume	bool
)	O
next_char	O
(	O
)	O
;	O
return	O
true	int
;	O
}	O
next_char	O
(	O
)	O
;	O
for	O
(	O
n	long
=	O
1	int
,	O
t	*(char)
=	O
s	long
++	O
;	O
peek_input	()->(int)
(	O
)	O
==	O
to_uchar	O
(	O
*	O
s	long
++	O
)	O
;	O
)	O
{	O
next_char	O
(	O
)	O
;	O
n	long
++	O
;	O
if	O
(	O
*	O
s	long
==	O
'\0'	O
)	O
{	O
if	O
(	O
consume	bool
)	O
return	O
true	int
;	O
result	*(*(char))
=	O
true	int
;	O
break	O
;	O
}	O
}	O
{	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
push_string_init	()->(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
(	O
)	O
;	O
obstack_grow	O
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
t	*(char)
,	O
n	long
)	O
;	O
}	O
push_string_finish	()->(*(char))
(	O
)	O
;	O
return	O
result	*(*(char))
;	O
}	O
void	O
input_init	()->(void)
(	O
void	O
)	O
{	O
current_file	*(char)
=	O
""	*(char)
;	O
current_line	int
=	O
0	int
;	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
)	O
)	O
;	O
obstack_init	O
(	O
current_input	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
wrapup_stack	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
)	O
)	O
;	O
obstack_init	O
(	O
wrapup_stack	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
obstack_init	O
(	O
&	O
file_names	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
obstack_init	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
obstack_alloc	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
1	int
)	O
;	O
token_bottom	*(void)
=	O
obstack_base	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
NULL	O
;	O
wsp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
=	O
NULL	O
;	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
NULL	O
;	O
start_of_input_line	bool
=	O
false	int
;	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
=	O
xstrdup	(*(char))->(*(char))
(	O
DEF_LQUOTE	*(char)
)	O
;	O
lquote	struct(*(char),long)
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
=	O
xstrdup	(*(char))->(*(char))
(	O
DEF_RQUOTE	*(char)
)	O
;	O
rquote	struct(*(char),long)
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
bcomm	struct(*(char),long)
.	O
string	struct(*(char),long)
=	O
xstrdup	(*(char))->(*(char))
(	O
DEF_BCOMM	*(char)
)	O
;	O
bcomm	struct(*(char),long)
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
bcomm	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
ecomm	struct(*(char),long)
.	O
string	struct(*(char),long)
=	O
xstrdup	(*(char))->(*(char))
(	O
DEF_ECOMM	*(char)
)	O
;	O
ecomm	struct(*(char),long)
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
ecomm	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
}	O
void	O
set_quotes	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
lq	*(char)
,	O
const	O
char	O
*	O
rq	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
free	(*(void))->(void)
(	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
if	O
(	O
!	O
lq	*(char)
)	O
{	O
lq	*(char)
=	O
DEF_LQUOTE	*(char)
;	O
rq	*(char)
=	O
DEF_RQUOTE	*(char)
;	O
}	O
else	O
if	O
(	O
!	O
rq	*(char)
||	O
(	O
*	O
lq	*(char)
&&	O
!	O
*	O
rq	*(char)
)	O
)	O
rq	*(char)
=	O
DEF_RQUOTE	*(char)
;	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
=	O
xstrdup	(*(char))->(*(char))
(	O
lq	*(char)
)	O
;	O
lquote	struct(*(char),long)
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
=	O
xstrdup	(*(char))->(*(char))
(	O
rq	*(char)
)	O
;	O
rquote	struct(*(char),long)
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
}	O
void	O
set_comment	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
bc	*(char)
,	O
const	O
char	O
*	O
ec	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
bcomm	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
free	(*(void))->(void)
(	O
ecomm	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
if	O
(	O
!	O
bc	*(char)
)	O
bc	*(char)
=	O
ec	*(char)
=	O
""	*(char)
;	O
else	O
if	O
(	O
!	O
ec	*(char)
||	O
(	O
*	O
bc	*(char)
&&	O
!	O
*	O
ec	*(char)
)	O
)	O
ec	*(char)
=	O
DEF_ECOMM	*(char)
;	O
bcomm	struct(*(char),long)
.	O
string	struct(*(char),long)
=	O
xstrdup	(*(char))->(*(char))
(	O
bc	*(char)
)	O
;	O
bcomm	struct(*(char),long)
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
bcomm	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
ecomm	struct(*(char),long)
.	O
string	struct(*(char),long)
=	O
xstrdup	(*(char))->(*(char))
(	O
ec	*(char)
)	O
;	O
ecomm	struct(*(char),long)
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
ecomm	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
}	O
token_type	enum(int,int,int,int,int,int,int,int)
next_token	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(int))->(enum(int,int,int,int,int,int,int,int))
(	O
token_data	struct
*	O
td	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
,	O
int	O
*	O
line	int
)	O
{	O
int	O
ch	int
;	O
int	O
quote_level	int
;	O
token_type	enum(int,int,int,int,int,int,int,int)
type	enum(int,int,int,int)
;	O
const	O
char	O
*	O
file	*(char)
;	O
int	O
dummy	int
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
token_bottom	*(void)
)	O
;	O
if	O
(	O
!	O
line	int
)	O
line	int
=	O
&	O
dummy	int
;	O
ch	int
=	O
peek_input	()->(int)
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
CHAR_EOF	int
)	O
{	O
next_char	O
(	O
)	O
;	O
return	O
TOKEN_EOF	int
;	O
}	O
if	O
(	O
ch	int
==	O
CHAR_MACRO	int
)	O
{	O
init_macro_token	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))->(void)
(	O
td	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
;	O
next_char	O
(	O
)	O
;	O
return	O
TOKEN_MACDEF	int
;	O
}	O
next_char	O
(	O
)	O
;	O
file	*(char)
=	O
current_file	*(char)
;	O
*	O
line	int
=	O
current_line	int
;	O
if	O
(	O
MATCH	O
(	O
ch	int
,	O
bcomm	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
true	int
)	O
)	O
{	O
obstack_grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
bcomm	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
bcomm	struct(*(char),long)
.	O
length	long
)	O
;	O
while	O
(	O
(	O
ch	int
=	O
next_char	O
(	O
)	O
)	O
!=	O
CHAR_EOF	int
&&	O
!	O
MATCH	O
(	O
ch	int
,	O
ecomm	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
true	int
)	O
)	O
obstack_1grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
ch	int
)	O
;	O
if	O
(	O
ch	int
!=	O
CHAR_EOF	int
)	O
obstack_grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
ecomm	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
ecomm	struct(*(char),long)
.	O
length	long
)	O
;	O
else	O
M4ERROR_AT_LINE	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
file	*(char)
,	O
*	O
line	int
,	O
"ERROR: end of file in comment"	*(char)
)	O
)	O
;	O
type	enum(int,int,int,int)
=	O
TOKEN_STRING	int
;	O
}	O
else	O
if	O
(	O
default_word_regexp	int
&&	O
(	O
isalpha	(int)->(int)
(	O
ch	int
)	O
||	O
ch	int
==	O
'_'	O
)	O
)	O
{	O
obstack_1grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
ch	int
)	O
;	O
while	O
(	O
(	O
ch	int
=	O
peek_input	()->(int)
(	O
)	O
)	O
!=	O
CHAR_EOF	int
&&	O
(	O
isalnum	(int)->(int)
(	O
ch	int
)	O
||	O
ch	int
==	O
'_'	O
)	O
)	O
{	O
obstack_1grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
ch	int
)	O
;	O
next_char	O
(	O
)	O
;	O
}	O
type	enum(int,int,int,int)
=	O
TOKEN_WORD	int
;	O
}	O
else	O
if	O
(	O
!	O
MATCH	O
(	O
ch	int
,	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
true	int
)	O
)	O
{	O
switch	O
(	O
ch	int
)	O
{	O
case	O
'('	O
:	O
type	enum(int,int,int,int)
=	O
TOKEN_OPEN	int
;	O
break	O
;	O
case	O
','	O
:	O
type	enum(int,int,int,int)
=	O
TOKEN_COMMA	int
;	O
break	O
;	O
case	O
')'	O
:	O
type	enum(int,int,int,int)
=	O
TOKEN_CLOSE	int
;	O
break	O
;	O
default	O
:	O
type	enum(int,int,int,int)
=	O
TOKEN_SIMPLE	int
;	O
break	O
;	O
}	O
obstack_1grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
ch	int
)	O
;	O
}	O
else	O
{	O
bool	bool
fast	bool
=	O
lquote	struct(*(char),long)
.	O
length	long
==	O
1	int
&&	O
rquote	struct(*(char),long)
.	O
length	long
==	O
1	int
;	O
quote_level	int
=	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
const	O
char	O
*	O
buffer	*(char)
=	O
(	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
&&	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
type	enum(int,int,int,int)
==	O
INPUT_STRING	int
?	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
string	struct(*(char),long)
:	O
NULL	O
)	O
;	O
if	O
(	O
buffer	*(char)
&&	O
*	O
buffer	*(char)
)	O
{	O
size_t	long
len	long
=	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
end	*(char)
-	O
buffer	*(char)
;	O
const	O
char	O
*	O
p	*(void)
=	O
buffer	*(char)
;	O
do	O
{	O
p	*(void)
=	O
(	O
char	O
*	O
)	O
memchr2	(*(void),int,int,long)->(*(void))
(	O
p	*(void)
,	O
*	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
*	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
buffer	*(char)
+	O
len	long
-	O
p	*(void)
)	O
;	O
}	O
while	O
(	O
p	*(void)
&&	O
fast	bool
&&	O
(	O
*	O
p	*(void)
++	O
==	O
*	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
?	O
--	O
quote_level	int
:	O
++	O
quote_level	int
)	O
)	O
;	O
if	O
(	O
p	*(void)
)	O
{	O
if	O
(	O
fast	bool
)	O
{	O
assert	O
(	O
!	O
quote_level	int
)	O
;	O
obstack_grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
buffer	*(char)
,	O
p	*(void)
-	O
buffer	*(char)
-	O
1	int
)	O
;	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
string	struct(*(char),long)
+=	O
p	*(void)
-	O
buffer	*(char)
;	O
break	O
;	O
}	O
obstack_grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
buffer	*(char)
,	O
p	*(void)
-	O
buffer	*(char)
)	O
;	O
ch	int
=	O
to_uchar	O
(	O
*	O
p	*(void)
)	O
;	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
string	struct(*(char),long)
+=	O
p	*(void)
-	O
buffer	*(char)
+	O
1	int
;	O
}	O
else	O
{	O
obstack_grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
buffer	*(char)
,	O
len	long
)	O
;	O
isp	*(struct(*(struct(*(struct`),enum(int,int,int),*(char),int,union(struct`,struct`,*`))),enum(int,int,int),*(char),int,union(struct(*(char),*(char)),struct(*(struct`),bool,bool,bool),*((*`,int,*`)->(void)))))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
u_s	struct(*(char),*(char))
.	O
string	struct(*(char),long)
+=	O
len	long
;	O
continue	O
;	O
}	O
}	O
else	O
ch	int
=	O
next_char	O
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
CHAR_EOF	int
)	O
M4ERROR_AT_LINE	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
file	*(char)
,	O
*	O
line	int
,	O
"ERROR: end of file in string"	*(char)
)	O
)	O
;	O
if	O
(	O
MATCH	O
(	O
ch	int
,	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
true	int
)	O
)	O
{	O
if	O
(	O
--	O
quote_level	int
==	O
0	int
)	O
break	O
;	O
obstack_grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
rquote	struct(*(char),long)
.	O
length	long
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
ch	int
,	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
true	int
)	O
)	O
{	O
quote_level	int
++	O
;	O
obstack_grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
lquote	struct(*(char),long)
.	O
length	long
)	O
;	O
}	O
else	O
obstack_1grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
ch	int
)	O
;	O
}	O
type	enum(int,int,int,int)
=	O
TOKEN_STRING	int
;	O
}	O
obstack_1grow	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
'\0'	O
)	O
;	O
TOKEN_DATA_TYPE	O
(	O
td	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
td	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
&	O
token_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
return	O
type	enum(int,int,int,int)
;	O
}	O
token_type	enum(int,int,int,int,int,int,int,int)
peek_token	()->(enum(int,int,int,int,int,int,int,int))
(	O
void	O
)	O
{	O
token_type	enum(int,int,int,int,int,int,int,int)
result	*(*(char))
;	O
int	O
ch	int
=	O
peek_input	()->(int)
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
CHAR_EOF	int
)	O
{	O
result	*(*(char))
=	O
TOKEN_EOF	int
;	O
}	O
else	O
if	O
(	O
ch	int
==	O
CHAR_MACRO	int
)	O
{	O
result	*(*(char))
=	O
TOKEN_MACDEF	int
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
ch	int
,	O
bcomm	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
false	int
)	O
)	O
{	O
result	*(*(char))
=	O
TOKEN_STRING	int
;	O
}	O
else	O
if	O
(	O
(	O
default_word_regexp	int
&&	O
(	O
isalpha	(int)->(int)
(	O
ch	int
)	O
||	O
ch	int
==	O
'_'	O
)	O
)	O
)	O
{	O
result	*(*(char))
=	O
TOKEN_WORD	int
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
ch	int
,	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
false	int
)	O
)	O
{	O
result	*(*(char))
=	O
TOKEN_STRING	int
;	O
}	O
else	O
switch	O
(	O
ch	int
)	O
{	O
case	O
'('	O
:	O
result	*(*(char))
=	O
TOKEN_OPEN	int
;	O
break	O
;	O
case	O
','	O
:	O
result	*(*(char))
=	O
TOKEN_COMMA	int
;	O
break	O
;	O
case	O
')'	O
:	O
result	*(*(char))
=	O
TOKEN_CLOSE	int
;	O
break	O
;	O
default	O
:	O
result	*(*(char))
=	O
TOKEN_SIMPLE	int
;	O
}	O
return	O
result	*(*(char))
;	O
}	O
