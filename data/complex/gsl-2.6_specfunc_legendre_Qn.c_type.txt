static	O
int	O
legendreQ_CF1_xgt1	(int,double,double,double,*(double))->(int)
(	O
int	O
ell	int
,	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
x	double
,	O
double	O
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
RECUR_BIG	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
const	O
int	O
maxiter	int
=	O
5000	int
;	O
int	O
n	int
=	O
1	int
;	O
double	O
Anm2	double
=	O
1.0	int
;	O
double	O
Bnm2	double
=	O
0.0	int
;	O
double	O
Anm1	double
=	O
0.0	int
;	O
double	O
Bnm1	double
=	O
1.0	int
;	O
double	O
a1	double
=	O
ell	int
+	O
1.0	int
+	O
a	double
+	O
b	double
;	O
double	O
b1	double
=	O
(	O
2.0	int
*	O
(	O
ell	int
+	O
1.0	int
+	O
a	double
)	O
+	O
1.0	int
)	O
*	O
x	double
;	O
double	O
An	double
=	O
b1	double
*	O
Anm1	double
+	O
a1	double
*	O
Anm2	double
;	O
double	O
Bn	double
=	O
b1	double
*	O
Bnm1	double
+	O
a1	double
*	O
Bnm2	double
;	O
double	O
an	double
,	O
bn	double
;	O
double	O
fn	double
=	O
An	double
/	O
Bn	double
;	O
while	O
(	O
n	int
<	O
maxiter	int
)	O
{	O
double	O
old_fn	double
;	O
double	O
del	double
;	O
double	O
lna	double
;	O
n	int
++	O
;	O
Anm2	double
=	O
Anm1	double
;	O
Bnm2	double
=	O
Bnm1	double
;	O
Anm1	double
=	O
An	double
;	O
Bnm1	double
=	O
Bn	double
;	O
lna	double
=	O
ell	int
+	O
n	int
+	O
a	double
;	O
an	double
=	O
b	double
*	O
b	double
-	O
lna	double
*	O
lna	double
;	O
bn	double
=	O
(	O
2.0	int
*	O
lna	double
+	O
1.0	int
)	O
*	O
x	double
;	O
An	double
=	O
bn	double
*	O
Anm1	double
+	O
an	double
*	O
Anm2	double
;	O
Bn	double
=	O
bn	double
*	O
Bnm1	double
+	O
an	double
*	O
Bnm2	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
An	double
)	O
>	O
RECUR_BIG	double
||	O
fabs	(double)->(double)
(	O
Bn	double
)	O
>	O
RECUR_BIG	double
)	O
{	O
An	double
/=	O
RECUR_BIG	double
;	O
Bn	double
/=	O
RECUR_BIG	double
;	O
Anm1	double
/=	O
RECUR_BIG	double
;	O
Bnm1	double
/=	O
RECUR_BIG	double
;	O
Anm2	double
/=	O
RECUR_BIG	double
;	O
Bnm2	double
/=	O
RECUR_BIG	double
;	O
}	O
old_fn	double
=	O
fn	double
;	O
fn	double
=	O
An	double
/	O
Bn	double
;	O
del	double
=	O
old_fn	double
/	O
fn	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
del	double
-	O
1.0	int
)	O
<	O
4.0	int
*	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
*	O
result	*(struct(double,double))
=	O
fn	double
;	O
if	O
(	O
n	int
==	O
maxiter	int
)	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
legendre_Ql_asymp_unif	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
ell	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
double	O
u	double
=	O
ell	int
+	O
0.5	int
;	O
double	O
th	double
=	O
acos	(double)->(double)
(	O
x	double
)	O
;	O
gsl_sf_result	struct(double,double)
Y0	struct(double,double)
,	O
Y1	struct(double,double)
;	O
int	O
stat_Y0	int
,	O
stat_Y1	int
;	O
int	O
stat_m	int
;	O
double	O
pre	double
;	O
double	O
B00	double
;	O
double	O
sum	double
;	O
if	O
(	O
th	double
<	O
GSL_ROOT4_DBL_EPSILON	int
)	O
{	O
B00	double
=	O
(	O
1.0	int
+	O
th	double
*	O
th	double
/	O
15.0	int
)	O
/	O
24.0	int
;	O
pre	double
=	O
1.0	int
+	O
th	double
*	O
th	double
/	O
12.0	int
;	O
}	O
else	O
{	O
double	O
sin_th	double
=	O
sqrt	(double)->(double)
(	O
1.0	int
-	O
x	double
*	O
x	double
)	O
;	O
double	O
cot_th	double
=	O
x	double
/	O
sin_th	double
;	O
B00	double
=	O
1.0	int
/	O
8.0	int
*	O
(	O
1.0	int
-	O
th	double
*	O
cot_th	double
)	O
/	O
(	O
th	double
*	O
th	double
)	O
;	O
pre	double
=	O
sqrt	(double)->(double)
(	O
th	double
/	O
sin_th	double
)	O
;	O
}	O
stat_Y0	int
=	O
gsl_sf_bessel_Y0_e	(double,*(struct(double,double)))->(int)
(	O
u	double
*	O
th	double
,	O
&	O
Y0	struct(double,double)
)	O
;	O
stat_Y1	int
=	O
gsl_sf_bessel_Y1_e	(double,*(struct(double,double)))->(int)
(	O
u	double
*	O
th	double
,	O
&	O
Y1	struct(double,double)
)	O
;	O
sum	double
=	O
-	O
0.5	int
*	O
M_PI	int
*	O
(	O
Y0	struct(double,double)
.	O
val	double
+	O
th	double
/	O
u	double
*	O
Y1	struct(double,double)
.	O
val	double
*	O
B00	double
)	O
;	O
stat_m	int
=	O
gsl_sf_multiply_e	(double,double,*(struct(double,double)))->(int)
(	O
pre	double
,	O
sum	double
,	O
result	*(struct(double,double))
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
0.5	int
*	O
M_PI	int
*	O
fabs	(double)->(double)
(	O
pre	double
)	O
*	O
(	O
Y0	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
th	double
/	O
u	double
*	O
B00	double
)	O
*	O
Y1	struct(double,double)
.	O
err	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_m	int
,	O
stat_Y0	int
,	O
stat_Y1	int
)	O
;	O
}	O
else	O
{	O
double	O
u	double
=	O
ell	int
+	O
0.5	int
;	O
double	O
xi	double
=	O
acosh	(double)->(double)
(	O
x	double
)	O
;	O
gsl_sf_result	struct(double,double)
K0_scaled	struct(double,double)
,	O
K1_scaled	struct(double,double)
;	O
int	O
stat_K0	int
,	O
stat_K1	int
;	O
int	O
stat_e	int
;	O
double	O
pre	double
;	O
double	O
B00	double
;	O
double	O
sum	double
;	O
if	O
(	O
xi	double
<	O
GSL_ROOT4_DBL_EPSILON	int
)	O
{	O
B00	double
=	O
(	O
1.0	int
-	O
xi	double
*	O
xi	double
/	O
15.0	int
)	O
/	O
24.0	int
;	O
pre	double
=	O
1.0	int
-	O
xi	double
*	O
xi	double
/	O
12.0	int
;	O
}	O
else	O
{	O
double	O
sinh_xi	double
=	O
sqrt	(double)->(double)
(	O
x	double
*	O
x	double
-	O
1.0	int
)	O
;	O
double	O
coth_xi	double
=	O
x	double
/	O
sinh_xi	double
;	O
B00	double
=	O
-	O
1.0	int
/	O
8.0	int
*	O
(	O
1.0	int
-	O
xi	double
*	O
coth_xi	double
)	O
/	O
(	O
xi	double
*	O
xi	double
)	O
;	O
pre	double
=	O
sqrt	(double)->(double)
(	O
xi	double
/	O
sinh_xi	double
)	O
;	O
}	O
stat_K0	int
=	O
gsl_sf_bessel_K0_scaled_e	(double,*(struct(double,double)))->(int)
(	O
u	double
*	O
xi	double
,	O
&	O
K0_scaled	struct(double,double)
)	O
;	O
stat_K1	int
=	O
gsl_sf_bessel_K1_scaled_e	(double,*(struct(double,double)))->(int)
(	O
u	double
*	O
xi	double
,	O
&	O
K1_scaled	struct(double,double)
)	O
;	O
sum	double
=	O
K0_scaled	struct(double,double)
.	O
val	double
-	O
xi	double
/	O
u	double
*	O
K1_scaled	struct(double,double)
.	O
val	double
*	O
B00	double
;	O
stat_e	int
=	O
gsl_sf_exp_mult_e	(double,double,*(struct(double,double)))->(int)
(	O
-	O
u	double
*	O
xi	double
,	O
pre	double
*	O
sum	double
,	O
result	*(struct(double,double))
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
*	O
fabs	(double)->(double)
(	O
u	double
*	O
xi	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_K0	int
,	O
stat_K1	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_legendre_Q0_e	(double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
<=	O
-	O
1.0	int
||	O
x	double
==	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
*	O
x	double
<	O
GSL_ROOT6_DBL_EPSILON	int
)	O
{	O
const	O
double	O
c3	double
=	O
1.0	int
/	O
3.0	int
;	O
const	O
double	O
c5	double
=	O
1.0	int
/	O
5.0	int
;	O
const	O
double	O
c7	double
=	O
1.0	int
/	O
7.0	int
;	O
const	O
double	O
c9	double
=	O
1.0	int
/	O
9.0	int
;	O
const	O
double	O
c11	double
=	O
1.0	int
/	O
11.0	int
;	O
const	O
double	O
y	double
=	O
x	double
*	O
x	double
;	O
const	O
double	O
series	double
=	O
1.0	int
+	O
y	double
*	O
(	O
c3	double
+	O
y	double
*	O
(	O
c5	double
+	O
y	double
*	O
(	O
c7	double
+	O
y	double
*	O
(	O
c9	double
+	O
y	double
*	O
c11	double
)	O
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
x	double
*	O
series	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.5	int
*	O
log	(double)->(double)
(	O
(	O
1.0	int
+	O
x	double
)	O
/	O
(	O
1.0	int
-	O
x	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
10.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.5	int
*	O
log	(double)->(double)
(	O
(	O
x	double
+	O
1.0	int
)	O
/	O
(	O
x	double
-	O
1.0	int
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
*	O
GSL_DBL_MIN	int
<	O
2.0	int
)	O
{	O
const	O
double	O
y	double
=	O
1.0	int
/	O
(	O
x	double
*	O
x	double
)	O
;	O
const	O
double	O
c1	double
=	O
1.0	int
/	O
3.0	int
;	O
const	O
double	O
c2	double
=	O
1.0	int
/	O
5.0	int
;	O
const	O
double	O
c3	double
=	O
1.0	int
/	O
7.0	int
;	O
const	O
double	O
c4	double
=	O
1.0	int
/	O
9.0	int
;	O
const	O
double	O
c5	double
=	O
1.0	int
/	O
11.0	int
;	O
const	O
double	O
c6	double
=	O
1.0	int
/	O
13.0	int
;	O
const	O
double	O
c7	double
=	O
1.0	int
/	O
15.0	int
;	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
1.0	int
/	O
x	double
)	O
*	O
(	O
1.0	int
+	O
y	double
*	O
(	O
c1	double
+	O
y	double
*	O
(	O
c2	double
+	O
y	double
*	O
(	O
c3	double
+	O
y	double
*	O
(	O
c4	double
+	O
y	double
*	O
(	O
c5	double
+	O
y	double
*	O
(	O
c6	double
+	O
y	double
*	O
c7	double
)	O
)	O
)	O
)	O
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
UNDERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_legendre_Q1_e	(double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
<=	O
-	O
1.0	int
||	O
x	double
==	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
*	O
x	double
<	O
GSL_ROOT6_DBL_EPSILON	int
)	O
{	O
const	O
double	O
c3	double
=	O
1.0	int
/	O
3.0	int
;	O
const	O
double	O
c5	double
=	O
1.0	int
/	O
5.0	int
;	O
const	O
double	O
c7	double
=	O
1.0	int
/	O
7.0	int
;	O
const	O
double	O
c9	double
=	O
1.0	int
/	O
9.0	int
;	O
const	O
double	O
c11	double
=	O
1.0	int
/	O
11.0	int
;	O
const	O
double	O
y	double
=	O
x	double
*	O
x	double
;	O
const	O
double	O
series	double
=	O
1.0	int
+	O
y	double
*	O
(	O
c3	double
+	O
y	double
*	O
(	O
c5	double
+	O
y	double
*	O
(	O
c7	double
+	O
y	double
*	O
(	O
c9	double
+	O
y	double
*	O
c11	double
)	O
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
x	double
*	O
x	double
*	O
series	double
-	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.5	int
*	O
x	double
*	O
(	O
log	(double)->(double)
(	O
(	O
1.0	int
+	O
x	double
)	O
/	O
(	O
1.0	int
-	O
x	double
)	O
)	O
)	O
-	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
6.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.5	int
*	O
x	double
*	O
log	(double)->(double)
(	O
(	O
x	double
+	O
1.0	int
)	O
/	O
(	O
x	double
-	O
1.0	int
)	O
)	O
-	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
*	O
GSL_SQRT_DBL_MIN	int
<	O
0.99	int
/	O
M_SQRT3	int
)	O
{	O
const	O
double	O
y	double
=	O
1	int
/	O
(	O
x	double
*	O
x	double
)	O
;	O
const	O
double	O
c1	double
=	O
3.0	int
/	O
5.0	int
;	O
const	O
double	O
c2	double
=	O
3.0	int
/	O
7.0	int
;	O
const	O
double	O
c3	double
=	O
3.0	int
/	O
9.0	int
;	O
const	O
double	O
c4	double
=	O
3.0	int
/	O
11.0	int
;	O
const	O
double	O
c5	double
=	O
3.0	int
/	O
13.0	int
;	O
const	O
double	O
c6	double
=	O
3.0	int
/	O
15.0	int
;	O
const	O
double	O
c7	double
=	O
3.0	int
/	O
17.0	int
;	O
const	O
double	O
c8	double
=	O
3.0	int
/	O
19.0	int
;	O
const	O
double	O
sum	double
=	O
1.0	int
+	O
y	double
*	O
(	O
c1	double
+	O
y	double
*	O
(	O
c2	double
+	O
y	double
*	O
(	O
c3	double
+	O
y	double
*	O
(	O
c4	double
+	O
y	double
*	O
(	O
c5	double
+	O
y	double
*	O
(	O
c6	double
+	O
y	double
*	O
(	O
c7	double
+	O
y	double
*	O
c8	double
)	O
)	O
)	O
)	O
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sum	double
/	O
(	O
3.0	int
*	O
x	double
*	O
x	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
UNDERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_legendre_Ql_e	(int,double,*(struct(double,double)))->(int)
(	O
const	O
int	O
l	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
<=	O
-	O
1.0	int
||	O
x	double
==	O
1.0	int
||	O
l	int
<	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
l	int
==	O
0	int
)	O
{	O
return	O
gsl_sf_legendre_Q0_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
l	int
==	O
1	int
)	O
{	O
return	O
gsl_sf_legendre_Q1_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
l	int
>	O
100000	int
)	O
{	O
return	O
legendre_Ql_asymp_unif	(double,double,*(struct(double,double)))->(int)
(	O
l	int
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
gsl_sf_result	struct(double,double)
Q0	struct(double,double)
,	O
Q1	struct(double,double)
;	O
int	O
stat_Q0	int
=	O
gsl_sf_legendre_Q0_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
Q0	struct(double,double)
)	O
;	O
int	O
stat_Q1	int
=	O
gsl_sf_legendre_Q1_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
Q1	struct(double,double)
)	O
;	O
double	O
Qellm1	double
=	O
Q0	struct(double,double)
.	O
val	double
;	O
double	O
Qell	double
=	O
Q1	struct(double,double)
.	O
val	double
;	O
double	O
Qellp1	double
;	O
int	O
ell	int
;	O
for	O
(	O
ell	int
=	O
1	int
;	O
ell	int
<	O
l	int
;	O
ell	int
++	O
)	O
{	O
Qellp1	double
=	O
(	O
x	double
*	O
(	O
2.0	int
*	O
ell	int
+	O
1.0	int
)	O
*	O
Qell	double
-	O
ell	int
*	O
Qellm1	double
)	O
/	O
(	O
ell	int
+	O
1.0	int
)	O
;	O
Qellm1	double
=	O
Qell	double
;	O
Qell	double
=	O
Qellp1	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
Qell	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
l	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_Q0	int
,	O
stat_Q1	int
)	O
;	O
}	O
else	O
{	O
double	O
rat	double
;	O
int	O
stat_CF1	int
=	O
legendreQ_CF1_xgt1	(int,double,double,double,*(double))->(int)
(	O
l	int
,	O
0.0	int
,	O
0.0	int
,	O
x	double
,	O
&	O
rat	double
)	O
;	O
int	O
stat_Q	int
;	O
double	O
Qellp1	double
=	O
rat	double
*	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Qell	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Qellm1	double
;	O
int	O
ell	int
;	O
for	O
(	O
ell	int
=	O
l	int
;	O
ell	int
>	O
0	int
;	O
ell	int
--	O
)	O
{	O
Qellm1	double
=	O
(	O
x	double
*	O
(	O
2.0	int
*	O
ell	int
+	O
1.0	int
)	O
*	O
Qell	double
-	O
(	O
ell	int
+	O
1.0	int
)	O
*	O
Qellp1	double
)	O
/	O
ell	int
;	O
Qellp1	double
=	O
Qell	double
;	O
Qell	double
=	O
Qellm1	double
;	O
}	O
if	O
(	O
fabs	(double)->(double)
(	O
Qell	double
)	O
>	O
fabs	(double)->(double)
(	O
Qellp1	double
)	O
)	O
{	O
gsl_sf_result	struct(double,double)
Q0	struct(double,double)
;	O
stat_Q	int
=	O
gsl_sf_legendre_Q0_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
Q0	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
Q0	struct(double,double)
.	O
val	double
/	O
Qell	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
l	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
Q1	struct(double,double)
;	O
stat_Q	int
=	O
gsl_sf_legendre_Q1_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
Q1	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
Q1	struct(double,double)
.	O
val	double
/	O
Qellp1	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
l	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
}	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_Q	int
,	O
stat_CF1	int
)	O
;	O
}	O
}	O
double	O
gsl_sf_legendre_Q0	(double)->(double)
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_legendre_Q0_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_legendre_Q1	(double)->(double)
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_legendre_Q1_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_legendre_Ql	(int,double)->(double)
(	O
const	O
int	O
l	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_legendre_Ql_e	(int,double,*(struct(double,double)))->(int)
(	O
l	int
,	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
