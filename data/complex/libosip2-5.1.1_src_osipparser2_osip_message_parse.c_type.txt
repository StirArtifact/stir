static	O
void	O
osip_util_replace_all_lws	(*(char))->(void)
(	O
char	O
*	O
sip_message	*(char)
)	O
;	O
static	O
int	O
osip_message_set__header	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(char))->(int)
(	O
osip_message_t	struct
*	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
const	O
char	O
*	O
hname	*(char)
,	O
const	O
char	O
*	O
hvalue	*(char)
)	O
;	O
static	O
int	O
msg_headers_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)))->(int)
(	O
osip_message_t	struct
*	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
const	O
char	O
*	O
start_of_header	*(char)
,	O
const	O
char	O
*	O
*	O
body	*(char)
)	O
;	O
static	O
int	O
msg_osip_body_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)),long)->(int)
(	O
osip_message_t	struct
*	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
const	O
char	O
*	O
start_of_buf	*(char)
,	O
const	O
char	O
*	O
*	O
next_body	*(*(char))
,	O
size_t	long
length	long
)	O
;	O
static	O
int	O
__osip_message_startline_parsereq	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)))->(int)
(	O
osip_message_t	struct
*	O
dest	*(char)
,	O
const	O
char	O
*	O
buf	*(char)
,	O
const	O
char	O
*	O
*	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
)	O
{	O
const	O
char	O
*	O
p1	*(char)
;	O
const	O
char	O
*	O
p2	*(char)
;	O
char	O
*	O
requesturi	*(char)
;	O
int	O
i	int
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
dest	*(char)
->	O
status_code	int
=	O
0	int
;	O
dest	*(char)
->	O
reason_phrase	*(char)
=	O
NULL	O
;	O
*	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
=	O
buf	*(char)
;	O
p2	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
buf	*(char)
,	O
' '	O
)	O
;	O
if	O
(	O
p2	*(char)
==	O
NULL	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
*	O
(	O
p2	*(char)
+	O
1	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
p2	*(char)
+	O
2	int
)	O
==	O
'\0'	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
p2	*(char)
-	O
buf	*(char)
==	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"No space allowed here\n"	*(char)
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
dest	*(char)
->	O
sip_method	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
p2	*(char)
-	O
buf	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
dest	*(char)
->	O
sip_method	*(char)
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
osip_strncpy	(*(char),*(char),long)->(*(char))
(	O
dest	*(char)
->	O
sip_method	*(char)
,	O
buf	*(char)
,	O
p2	*(char)
-	O
buf	*(char)
)	O
;	O
p1	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p2	*(char)
+	O
2	int
,	O
' '	O
)	O
;	O
if	O
(	O
p1	*(char)
==	O
NULL	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Uncompliant request-uri\n"	*(char)
)	O
)	O
;	O
osip_free	O
(	O
dest	*(char)
->	O
sip_method	*(char)
)	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
if	O
(	O
p1	*(char)
-	O
p2	*(char)
<	O
2	int
)	O
{	O
osip_free	O
(	O
dest	*(char)
->	O
sip_method	*(char)
)	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
requesturi	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
p1	*(char)
-	O
p2	*(char)
)	O
;	O
if	O
(	O
requesturi	*(char)
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
dest	*(char)
->	O
sip_method	*(char)
)	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
osip_clrncpy	(*(char),*(char),long)->(*(char))
(	O
requesturi	*(char)
,	O
p2	*(char)
+	O
1	int
,	O
(	O
p1	*(char)
-	O
p2	*(char)
-	O
1	int
)	O
)	O
;	O
i	int
=	O
osip_uri_init	(*(*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*`),struct(int,*`),*(char)))))->(int)
(	O
&	O
(	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
)	O
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_free	O
(	O
requesturi	*(char)
)	O
;	O
requesturi	*(char)
=	O
NULL	O
;	O
osip_free	O
(	O
dest	*(char)
->	O
sip_method	*(char)
)	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
i	int
=	O
osip_uri_parse	(*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct`)),struct(int,*(struct`)),*(char))),*(char))->(int)
(	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
,	O
requesturi	*(char)
)	O
;	O
osip_free	O
(	O
requesturi	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_free	O
(	O
dest	*(char)
->	O
sip_method	*(char)
)	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
osip_uri_free	(*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct`)),struct(int,*(struct`)),*(char))))->(void)
(	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
)	O
;	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
{	O
const	O
char	O
*	O
hp	*(char)
=	O
p1	*(char)
;	O
hp	*(char)
++	O
;	O
if	O
(	O
*	O
hp	*(char)
==	O
'\0'	O
||	O
*	O
(	O
hp	*(char)
+	O
1	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
hp	*(char)
+	O
2	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
hp	*(char)
+	O
3	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
hp	*(char)
+	O
4	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
hp	*(char)
+	O
5	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
hp	*(char)
+	O
6	int
)	O
==	O
'\0'	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Uncomplete request line\n"	*(char)
)	O
)	O
;	O
osip_free	O
(	O
dest	*(char)
->	O
sip_method	*(char)
)	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
osip_uri_free	(*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct`)),struct(int,*(struct`)),*(char))))->(void)
(	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
)	O
;	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
if	O
(	O
(	O
(	O
hp	*(char)
[	O
0	int
]	O
!=	O
'S'	O
)	O
&&	O
(	O
hp	*(char)
[	O
0	int
]	O
!=	O
's'	O
)	O
)	O
||	O
(	O
(	O
hp	*(char)
[	O
1	int
]	O
!=	O
'I'	O
)	O
&&	O
(	O
hp	*(char)
[	O
1	int
]	O
!=	O
'i'	O
)	O
)	O
||	O
(	O
(	O
hp	*(char)
[	O
2	int
]	O
!=	O
'P'	O
)	O
&&	O
(	O
hp	*(char)
[	O
2	int
]	O
!=	O
'p'	O
)	O
)	O
||	O
(	O
hp	*(char)
[	O
3	int
]	O
!=	O
'/'	O
)	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"No crlf found/No SIP/2.0 found\n"	*(char)
)	O
)	O
;	O
osip_free	O
(	O
dest	*(char)
->	O
sip_method	*(char)
)	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
osip_uri_free	(*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct`)),struct(int,*(struct`)),*(char))))->(void)
(	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
)	O
;	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
hp	*(char)
=	O
hp	*(char)
+	O
4	int
;	O
while	O
(	O
(	O
*	O
hp	*(char)
!=	O
'\r'	O
)	O
&&	O
(	O
*	O
hp	*(char)
!=	O
'\n'	O
)	O
)	O
{	O
if	O
(	O
*	O
hp	*(char)
)	O
{	O
if	O
(	O
(	O
*	O
hp	*(char)
>=	O
'0'	O
)	O
&&	O
(	O
*	O
hp	*(char)
<=	O
'9'	O
)	O
)	O
hp	*(char)
++	O
;	O
else	O
if	O
(	O
*	O
hp	*(char)
==	O
'.'	O
)	O
hp	*(char)
++	O
;	O
else	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"incorrect sip version string\n"	*(char)
)	O
)	O
;	O
osip_free	O
(	O
dest	*(char)
->	O
sip_method	*(char)
)	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
osip_uri_free	(*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct`)),struct(int,*(struct`)),*(char))))->(void)
(	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
)	O
;	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
}	O
else	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"No crlf found\n"	*(char)
)	O
)	O
;	O
osip_free	O
(	O
dest	*(char)
->	O
sip_method	*(char)
)	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
osip_uri_free	(*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct`)),struct(int,*(struct`)),*(char))))->(void)
(	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
)	O
;	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
}	O
if	O
(	O
hp	*(char)
-	O
p1	*(char)
<	O
2	int
)	O
{	O
osip_free	O
(	O
dest	*(char)
->	O
sip_method	*(char)
)	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
osip_uri_free	(*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct`)),struct(int,*(struct`)),*(char))))->(void)
(	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
)	O
;	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
dest	*(char)
->	O
sip_version	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
hp	*(char)
-	O
p1	*(char)
)	O
;	O
if	O
(	O
dest	*(char)
->	O
sip_version	*(char)
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
dest	*(char)
->	O
sip_method	*(char)
)	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
osip_uri_free	(*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct`)),struct(int,*(struct`)),*(char))))->(void)
(	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
)	O
;	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
=	O
NULL	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
osip_strncpy	(*(char),*(char),long)->(*(char))
(	O
dest	*(char)
->	O
sip_version	*(char)
,	O
p1	*(char)
+	O
1	int
,	O
(	O
hp	*(char)
-	O
p1	*(char)
-	O
1	int
)	O
)	O
;	O
if	O
(	O
0	int
!=	O
osip_strcasecmp	(*(char),*(char))->(int)
(	O
dest	*(char)
->	O
sip_version	*(char)
,	O
"SIP/2.0"	*(char)
)	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_WARNING	O
,	O
NULL	O
,	O
"Wrong version number\n"	*(char)
)	O
)	O
;	O
}	O
hp	*(char)
++	O
;	O
if	O
(	O
(	O
*	O
hp	*(char)
)	O
&&	O
(	O
'\r'	O
==	O
hp	*(char)
[	O
-	O
1	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
hp	*(char)
[	O
0	int
]	O
)	O
)	O
hp	*(char)
++	O
;	O
(	O
*	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
)	O
=	O
hp	*(char)
;	O
}	O
return	O
OSIP_SUCCESS	int
;	O
}	O
static	O
int	O
__osip_message_startline_parseresp	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)))->(int)
(	O
osip_message_t	struct
*	O
dest	*(char)
,	O
const	O
char	O
*	O
buf	*(char)
,	O
const	O
char	O
*	O
*	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
)	O
{	O
const	O
char	O
*	O
statuscode	int
;	O
const	O
char	O
*	O
reasonphrase	*(char)
;	O
dest	*(char)
->	O
req_uri	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(char)))
=	O
NULL	O
;	O
dest	*(char)
->	O
sip_method	*(char)
=	O
NULL	O
;	O
*	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
=	O
buf	*(char)
;	O
statuscode	int
=	O
strchr	(*(char),int)->(*(char))
(	O
buf	*(char)
,	O
' '	O
)	O
;	O
if	O
(	O
statuscode	int
==	O
NULL	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
statuscode	int
-	O
(	O
*	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
)	O
<	O
7	int
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
dest	*(char)
->	O
sip_version	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
statuscode	int
-	O
(	O
*	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
)	O
+	O
1	int
)	O
;	O
if	O
(	O
dest	*(char)
->	O
sip_version	*(char)
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
osip_strncpy	(*(char),*(char),long)->(*(char))
(	O
dest	*(char)
->	O
sip_version	*(char)
,	O
*	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
,	O
statuscode	int
-	O
(	O
*	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
)	O
)	O
;	O
reasonphrase	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
statuscode	int
+	O
1	int
,	O
' '	O
)	O
;	O
if	O
(	O
reasonphrase	*(char)
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
dest	*(char)
->	O
sip_version	*(char)
)	O
;	O
dest	*(char)
->	O
sip_version	*(char)
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
statuscode	int
+	O
1	int
,	O
"%d"	*(char)
,	O
&	O
dest	*(char)
->	O
status_code	int
)	O
!=	O
1	int
)	O
{	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
if	O
(	O
dest	*(char)
->	O
status_code	int
==	O
0	int
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
{	O
const	O
char	O
*	O
hp	*(char)
=	O
reasonphrase	*(char)
;	O
while	O
(	O
(	O
*	O
hp	*(char)
!=	O
'\r'	O
)	O
&&	O
(	O
*	O
hp	*(char)
!=	O
'\n'	O
)	O
)	O
{	O
if	O
(	O
*	O
hp	*(char)
)	O
hp	*(char)
++	O
;	O
else	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"No crlf found\n"	*(char)
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
}	O
dest	*(char)
->	O
reason_phrase	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
hp	*(char)
-	O
reasonphrase	*(char)
)	O
;	O
if	O
(	O
dest	*(char)
->	O
reason_phrase	*(char)
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
dest	*(char)
->	O
sip_version	*(char)
)	O
;	O
dest	*(char)
->	O
sip_version	*(char)
=	O
NULL	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
osip_strncpy	(*(char),*(char),long)->(*(char))
(	O
dest	*(char)
->	O
reason_phrase	*(char)
,	O
reasonphrase	*(char)
+	O
1	int
,	O
hp	*(char)
-	O
reasonphrase	*(char)
-	O
1	int
)	O
;	O
hp	*(char)
++	O
;	O
if	O
(	O
(	O
*	O
hp	*(char)
)	O
&&	O
(	O
'\r'	O
==	O
hp	*(char)
[	O
-	O
1	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
hp	*(char)
[	O
0	int
]	O
)	O
)	O
hp	*(char)
++	O
;	O
(	O
*	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
)	O
=	O
hp	*(char)
;	O
}	O
return	O
OSIP_SUCCESS	int
;	O
}	O
static	O
int	O
__osip_message_startline_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)))->(int)
(	O
osip_message_t	struct
*	O
dest	*(char)
,	O
const	O
char	O
*	O
buf	*(char)
,	O
const	O
char	O
*	O
*	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
)	O
{	O
if	O
(	O
0	int
==	O
strncmp	(*(char),*(char),long)->(int)
(	O
(	O
const	O
char	O
*	O
)	O
buf	*(char)
,	O
(	O
const	O
char	O
*	O
)	O
"SIP/"	*(char)
,	O
4	int
)	O
)	O
return	O
__osip_message_startline_parseresp	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)))->(int)
(	O
dest	*(char)
,	O
buf	*(char)
,	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
)	O
;	O
else	O
return	O
__osip_message_startline_parsereq	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)))->(int)
(	O
dest	*(char)
,	O
buf	*(char)
,	O
headers	*(struct(int,*(struct(*(struct`),*(void)))))
)	O
;	O
}	O
int	O
__osip_find_next_occurence	(*(char),*(char),*(*(char)),*(char))->(int)
(	O
const	O
char	O
*	O
str	*(char)
,	O
const	O
char	O
*	O
buf	*(char)
,	O
const	O
char	O
*	O
*	O
index_of_str	*(*(char))
,	O
const	O
char	O
*	O
end_of_buf	*(char)
)	O
{	O
size_t	long
slen	long
;	O
*	O
index_of_str	*(*(char))
=	O
NULL	O
;	O
if	O
(	O
str	*(char)
==	O
NULL	O
||	O
buf	*(char)
==	O
NULL	O
)	O
return	O
OSIP_BADPARAMETER	O
;	O
slen	long
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
;	O
while	O
(	O
slen	long
<	O
(	O
size_t	long
)	O
(	O
end_of_buf	*(char)
-	O
buf	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
str	*(char)
,	O
buf	*(char)
,	O
slen	long
)	O
)	O
{	O
*	O
index_of_str	*(*(char))
=	O
buf	*(char)
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
++	O
buf	*(char)
;	O
}	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
static	O
void	O
osip_util_replace_all_lws	(*(char))->(void)
(	O
char	O
*	O
sip_message	*(char)
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
if	O
(	O
sip_message	*(char)
==	O
NULL	O
)	O
return	O
;	O
tmp	*(char)
=	O
sip_message	*(char)
;	O
for	O
(	O
;	O
tmp	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
;	O
tmp	*(char)
++	O
)	O
{	O
if	O
(	O
(	O
'\0'	O
==	O
tmp	*(char)
[	O
0	int
]	O
)	O
||	O
(	O
'\0'	O
==	O
tmp	*(char)
[	O
1	int
]	O
)	O
||	O
(	O
'\0'	O
==	O
tmp	*(char)
[	O
2	int
]	O
)	O
||	O
(	O
'\0'	O
==	O
tmp	*(char)
[	O
3	int
]	O
)	O
)	O
return	O
;	O
if	O
(	O
(	O
(	O
'\r'	O
==	O
tmp	*(char)
[	O
0	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
tmp	*(char)
[	O
1	int
]	O
)	O
&&	O
(	O
'\r'	O
==	O
tmp	*(char)
[	O
2	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
tmp	*(char)
[	O
3	int
]	O
)	O
)	O
||	O
(	O
(	O
'\r'	O
==	O
tmp	*(char)
[	O
0	int
]	O
)	O
&&	O
(	O
'\r'	O
==	O
tmp	*(char)
[	O
1	int
]	O
)	O
)	O
||	O
(	O
(	O
'\n'	O
==	O
tmp	*(char)
[	O
0	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
tmp	*(char)
[	O
1	int
]	O
)	O
)	O
)	O
return	O
;	O
if	O
(	O
(	O
(	O
'\r'	O
==	O
tmp	*(char)
[	O
0	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
tmp	*(char)
[	O
1	int
]	O
)	O
&&	O
(	O
(	O
' '	O
==	O
tmp	*(char)
[	O
2	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
tmp	*(char)
[	O
2	int
]	O
)	O
)	O
)	O
||	O
(	O
(	O
'\r'	O
==	O
tmp	*(char)
[	O
0	int
]	O
)	O
&&	O
(	O
(	O
' '	O
==	O
tmp	*(char)
[	O
1	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
tmp	*(char)
[	O
1	int
]	O
)	O
)	O
)	O
||	O
(	O
(	O
'\n'	O
==	O
tmp	*(char)
[	O
0	int
]	O
)	O
&&	O
(	O
(	O
' '	O
==	O
tmp	*(char)
[	O
1	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
tmp	*(char)
[	O
1	int
]	O
)	O
)	O
)	O
)	O
{	O
tmp	*(char)
[	O
0	int
]	O
=	O
' '	O
;	O
tmp	*(char)
[	O
1	int
]	O
=	O
' '	O
;	O
tmp	*(char)
=	O
tmp	*(char)
+	O
2	int
;	O
for	O
(	O
;	O
(	O
'\t'	O
==	O
tmp	*(char)
[	O
0	int
]	O
||	O
' '	O
==	O
tmp	*(char)
[	O
0	int
]	O
)	O
;	O
)	O
{	O
tmp	*(char)
[	O
0	int
]	O
=	O
' '	O
;	O
tmp	*(char)
++	O
;	O
}	O
if	O
(	O
tmp	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
;	O
}	O
}	O
}	O
int	O
__osip_find_next_crlf	(*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
start_of_header	*(char)
,	O
const	O
char	O
*	O
*	O
end_of_header	*(*(char))
)	O
{	O
const	O
char	O
*	O
soh	*(char)
=	O
start_of_header	*(char)
;	O
*	O
end_of_header	*(*(char))
=	O
NULL	O
;	O
while	O
(	O
(	O
'\r'	O
!=	O
*	O
soh	*(char)
)	O
&&	O
(	O
'\n'	O
!=	O
*	O
soh	*(char)
)	O
)	O
{	O
if	O
(	O
*	O
soh	*(char)
)	O
soh	*(char)
++	O
;	O
else	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Final CRLF is missing\n"	*(char)
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
}	O
if	O
(	O
(	O
'\r'	O
==	O
soh	*(char)
[	O
0	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
soh	*(char)
[	O
1	int
]	O
)	O
)	O
soh	*(char)
=	O
soh	*(char)
+	O
1	int
;	O
if	O
(	O
(	O
' '	O
==	O
soh	*(char)
[	O
1	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
soh	*(char)
[	O
1	int
]	O
)	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_BUG	O
,	O
NULL	O
,	O
"Message that contains LWS must be processed with osip_util_replace_all_lws(char *tmp) before being parsed.\n"	*(char)
)	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
*	O
end_of_header	*(*(char))
=	O
soh	*(char)
+	O
1	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
__osip_find_next_crlfcrlf	(*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
start_of_part	*(char)
,	O
const	O
char	O
*	O
*	O
end_of_part	*(*(char))
)	O
{	O
const	O
char	O
*	O
start_of_line	*(char)
;	O
const	O
char	O
*	O
end_of_line	*(char)
;	O
int	O
i	int
;	O
start_of_line	*(char)
=	O
start_of_part	*(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
i	int
=	O
__osip_find_next_crlf	(*(char),*(*(char)))->(int)
(	O
start_of_line	*(char)
,	O
&	O
end_of_line	*(char)
)	O
;	O
if	O
(	O
i	int
==	O
-	O
2	int
)	O
{	O
}	O
else	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Final CRLF is missing\n"	*(char)
)	O
)	O
;	O
return	O
i	int
;	O
}	O
if	O
(	O
'\0'	O
==	O
end_of_line	*(char)
[	O
0	int
]	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Final CRLF is missing\n"	*(char)
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
else	O
if	O
(	O
'\r'	O
==	O
end_of_line	*(char)
[	O
0	int
]	O
)	O
{	O
if	O
(	O
'\n'	O
==	O
end_of_line	*(char)
[	O
1	int
]	O
)	O
end_of_line	*(char)
++	O
;	O
*	O
end_of_part	*(*(char))
=	O
end_of_line	*(char)
+	O
1	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
'\n'	O
==	O
end_of_line	*(char)
[	O
0	int
]	O
)	O
{	O
*	O
end_of_part	*(*(char))
=	O
end_of_line	*(char)
+	O
1	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
start_of_line	*(char)
=	O
end_of_line	*(char)
;	O
}	O
}	O
static	O
int	O
osip_message_set__header	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(char))->(int)
(	O
osip_message_t	struct
*	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
const	O
char	O
*	O
hname	*(char)
,	O
const	O
char	O
*	O
hvalue	*(char)
)	O
{	O
int	O
my_index	int
;	O
if	O
(	O
hname	*(char)
==	O
NULL	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
my_index	int
=	O
__osip_message_is_known_header	(*(char))->(int)
(	O
hname	*(char)
)	O
;	O
if	O
(	O
my_index	int
>=	O
0	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
__osip_message_call_method	(int,*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char))->(int)
(	O
my_index	int
,	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
hvalue	*(char)
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
ret	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
if	O
(	O
osip_message_set_header	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(char))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
hname	*(char)
,	O
hvalue	*(char)
)	O
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_WARNING	O
,	O
NULL	O
,	O
"Could not set unknown header\n"	*(char)
)	O
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
osip_message_set_multiple_header	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(char))->(int)
(	O
osip_message_t	struct
*	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
char	O
*	O
hname	*(char)
,	O
char	O
*	O
hvalue	*(char)
)	O
{	O
int	O
i	int
;	O
char	O
*	O
ptr	*(void)
,	O
*	O
p	*(char)
;	O
char	O
*	O
comma	*(char)
;	O
char	O
*	O
beg	*(char)
;	O
char	O
*	O
end	*(char)
;	O
int	O
inquotes	int
,	O
inuri	int
;	O
osip_tolower	(*(char))->(int)
(	O
hname	*(char)
)	O
;	O
if	O
(	O
hvalue	*(char)
==	O
NULL	O
)	O
{	O
i	int
=	O
osip_message_set__header	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(char))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
hname	*(char)
,	O
hvalue	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
ptr	*(void)
=	O
hvalue	*(char)
;	O
comma	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
ptr	*(void)
,	O
','	O
)	O
;	O
if	O
(	O
comma	*(char)
==	O
NULL	O
||	O
__osip_message_is_header_comma_separated	(*(char))->(int)
(	O
hname	*(char)
)	O
!=	O
OSIP_SUCCESS	int
)	O
{	O
i	int
=	O
osip_message_set__header	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(char))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
hname	*(char)
,	O
hvalue	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
beg	*(char)
=	O
hvalue	*(char)
;	O
inquotes	int
=	O
0	int
;	O
inuri	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
ptr	*(void)
++	O
)	O
{	O
switch	O
(	O
*	O
ptr	*(void)
)	O
{	O
case	O
'"'	O
:	O
for	O
(	O
i	int
=	O
0	int
,	O
p	*(char)
=	O
ptr	*(void)
-	O
1	int
;	O
p	*(char)
>=	O
beg	*(char)
&&	O
*	O
p	*(char)
==	O
'\\'	O
;	O
p	*(char)
--	O
,	O
i	int
++	O
)	O
;	O
if	O
(	O
i	int
%	O
2	int
==	O
0	int
)	O
inquotes	int
=	O
!	O
inquotes	int
;	O
break	O
;	O
case	O
'<'	O
:	O
if	O
(	O
!	O
inquotes	int
)	O
{	O
if	O
(	O
!	O
inuri	int
)	O
{	O
if	O
(	O
(	O
osip_strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(void)
+	O
1	int
,	O
"sip:"	*(char)
,	O
4	int
)	O
==	O
0	int
||	O
osip_strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(void)
+	O
1	int
,	O
"sips:"	*(char)
,	O
5	int
)	O
==	O
0	int
||	O
osip_strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(void)
+	O
1	int
,	O
"http:"	*(char)
,	O
5	int
)	O
==	O
0	int
||	O
osip_strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(void)
+	O
1	int
,	O
"https:"	*(char)
,	O
6	int
)	O
==	O
0	int
||	O
osip_strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(void)
+	O
1	int
,	O
"tel:"	*(char)
,	O
4	int
)	O
==	O
0	int
)	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
ptr	*(void)
,	O
'>'	O
)	O
)	O
inuri	int
=	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
'>'	O
:	O
if	O
(	O
!	O
inquotes	int
)	O
{	O
if	O
(	O
inuri	int
)	O
inuri	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'\0'	O
:	O
inquotes	int
=	O
0	int
;	O
inuri	int
=	O
0	int
;	O
case	O
','	O
:	O
if	O
(	O
!	O
inquotes	int
&&	O
!	O
inuri	int
)	O
{	O
char	O
*	O
avalue	*(char)
;	O
if	O
(	O
beg	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
OSIP_SUCCESS	int
;	O
end	*(char)
=	O
ptr	*(void)
;	O
if	O
(	O
end	*(char)
-	O
beg	*(char)
+	O
1	int
<	O
2	int
)	O
{	O
beg	*(char)
=	O
end	*(char)
+	O
1	int
;	O
break	O
;	O
}	O
avalue	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
end	*(char)
-	O
beg	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
avalue	*(char)
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
osip_clrncpy	(*(char),*(char),long)->(*(char))
(	O
avalue	*(char)
,	O
beg	*(char)
,	O
end	*(char)
-	O
beg	*(char)
)	O
;	O
i	int
=	O
osip_message_set__header	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(char))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
hname	*(char)
,	O
avalue	*(char)
)	O
;	O
osip_free	O
(	O
avalue	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
beg	*(char)
=	O
end	*(char)
+	O
1	int
;	O
}	O
if	O
(	O
*	O
ptr	*(void)
==	O
'\0'	O
)	O
return	O
OSIP_SUCCESS	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
static	O
int	O
msg_headers_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)))->(int)
(	O
osip_message_t	struct
*	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
const	O
char	O
*	O
start_of_header	*(char)
,	O
const	O
char	O
*	O
*	O
body	*(char)
)	O
{	O
const	O
char	O
*	O
colon_index	*(char)
;	O
char	O
*	O
hname	*(char)
;	O
char	O
*	O
hvalue	*(char)
;	O
const	O
char	O
*	O
end_of_header	*(*(char))
;	O
int	O
i	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
start_of_header	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_INFO1	O
,	O
NULL	O
,	O
"SIP message does not end with CRLFCRLF\n"	*(char)
)	O
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
i	int
=	O
__osip_find_next_crlf	(*(char),*(*(char)))->(int)
(	O
start_of_header	*(char)
,	O
&	O
end_of_header	*(*(char))
)	O
;	O
if	O
(	O
i	int
==	O
-	O
2	int
)	O
{	O
}	O
else	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"End of header Not found\n"	*(char)
)	O
)	O
;	O
return	O
i	int
;	O
}	O
if	O
(	O
(	O
start_of_header	*(char)
[	O
0	int
]	O
==	O
'\r'	O
)	O
||	O
(	O
start_of_header	*(char)
[	O
0	int
]	O
==	O
'\n'	O
)	O
)	O
{	O
*	O
body	*(char)
=	O
start_of_header	*(char)
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
colon_index	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
start_of_header	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
colon_index	*(char)
==	O
NULL	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"End of header Not found\n"	*(char)
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
if	O
(	O
colon_index	*(char)
-	O
start_of_header	*(char)
+	O
1	int
<	O
2	int
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
end_of_header	*(*(char))
<=	O
colon_index	*(char)
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Malformed message\n"	*(char)
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
hname	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
colon_index	*(char)
-	O
start_of_header	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
hname	*(char)
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
osip_clrncpy	(*(char),*(char),long)->(*(char))
(	O
hname	*(char)
,	O
start_of_header	*(char)
,	O
colon_index	*(char)
-	O
start_of_header	*(char)
)	O
;	O
{	O
const	O
char	O
*	O
end	*(char)
;	O
if	O
(	O
(	O
end_of_header	*(*(char))
[	O
-	O
2	int
]	O
==	O
'\r'	O
)	O
||	O
(	O
end_of_header	*(*(char))
[	O
-	O
2	int
]	O
==	O
'\n'	O
)	O
)	O
end	*(char)
=	O
end_of_header	*(*(char))
-	O
2	int
;	O
else	O
end	*(char)
=	O
end_of_header	*(*(char))
-	O
1	int
;	O
if	O
(	O
(	O
end	*(char)
)	O
-	O
colon_index	*(char)
<	O
2	int
)	O
hvalue	*(char)
=	O
NULL	O
;	O
else	O
{	O
hvalue	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
(	O
end	*(char)
)	O
-	O
colon_index	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
hvalue	*(char)
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
hname	*(char)
)	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
osip_clrncpy	(*(char),*(char),long)->(*(char))
(	O
hvalue	*(char)
,	O
colon_index	*(char)
+	O
1	int
,	O
(	O
end	*(char)
)	O
-	O
colon_index	*(char)
-	O
1	int
)	O
;	O
}	O
}	O
i	int
=	O
osip_message_set_multiple_header	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(char))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
hname	*(char)
,	O
hvalue	*(char)
)	O
;	O
osip_free	O
(	O
hname	*(char)
)	O
;	O
if	O
(	O
hvalue	*(char)
!=	O
NULL	O
)	O
osip_free	O
(	O
hvalue	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"End of header Not found\n"	*(char)
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
start_of_header	*(char)
=	O
end_of_header	*(*(char))
;	O
}	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
static	O
int	O
msg_osip_body_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)),long)->(int)
(	O
osip_message_t	struct
*	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
const	O
char	O
*	O
start_of_buf	*(char)
,	O
const	O
char	O
*	O
*	O
next_body	*(*(char))
,	O
size_t	long
length	long
)	O
{	O
const	O
char	O
*	O
start_of_body	*(char)
;	O
const	O
char	O
*	O
end_of_body	*(char)
;	O
const	O
char	O
*	O
end_of_buf	*(char)
;	O
char	O
*	O
tmp	*(char)
;	O
int	O
i	int
;	O
char	O
*	O
sep_boundary	*(char)
;	O
size_t	long
len_sep_boundary	long
;	O
osip_generic_param_t	struct(*(char),*(char))
*	O
ct_param	*(struct(*(char),*(char)))
;	O
if	O
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_type	*(struct(*(char),*(char),struct(int,*(struct(*`,*`)))))
==	O
NULL	O
||	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_type	*(struct(*(char),*(char),struct(int,*(struct(*`,*`)))))
->	O
type	*(char)
==	O
NULL	O
||	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_type	*(struct(*(char),*(char),struct(int,*(struct(*`,*`)))))
->	O
subtype	*(char)
==	O
NULL	O
)	O
return	O
OSIP_SUCCESS	int
;	O
if	O
(	O
0	int
!=	O
osip_strcasecmp	(*(char),*(char))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_type	*(struct(*(char),*(char),struct(int,*(struct(*`,*`)))))
->	O
type	*(char)
,	O
"multipart"	*(char)
)	O
)	O
{	O
size_t	long
osip_body_len	long
;	O
if	O
(	O
start_of_buf	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
'\r'	O
==	O
start_of_buf	*(char)
[	O
0	int
]	O
)	O
{	O
if	O
(	O
'\n'	O
==	O
start_of_buf	*(char)
[	O
1	int
]	O
)	O
start_of_body	*(char)
=	O
start_of_buf	*(char)
+	O
2	int
;	O
else	O
start_of_body	*(char)
=	O
start_of_buf	*(char)
+	O
1	int
;	O
}	O
else	O
if	O
(	O
'\n'	O
==	O
start_of_buf	*(char)
[	O
0	int
]	O
)	O
start_of_body	*(char)
=	O
start_of_buf	*(char)
+	O
1	int
;	O
else	O
return	O
OSIP_SYNTAXERROR	O
;	O
length	long
=	O
length	long
-	O
(	O
start_of_body	*(char)
-	O
start_of_buf	*(char)
)	O
;	O
if	O
(	O
length	long
<=	O
0	int
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
!=	O
NULL	O
)	O
osip_body_len	long
=	O
osip_atoi	(*(char))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
->	O
value	*(char)
)	O
;	O
else	O
{	O
char	O
tmp	*(char)
[	O
16	int
]	O
;	O
osip_body_len	long
=	O
length	long
;	O
sprintf	(*(char),*(char))->(int)
(	O
tmp	*(char)
,	O
"%i"	*(char)
,	O
(	O
int	O
)	O
osip_body_len	long
)	O
;	O
i	int
=	O
osip_message_set_content_length	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
tmp	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
}	O
if	O
(	O
length	long
<	O
osip_body_len	long
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Message was not receieved enterely. length=%i osip_body_len=%i\n"	*(char)
,	O
(	O
int	O
)	O
length	long
,	O
(	O
int	O
)	O
osip_body_len	long
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
end_of_body	*(char)
=	O
start_of_body	*(char)
+	O
osip_body_len	long
;	O
tmp	*(char)
=	O
osip_malloc	O
(	O
end_of_body	*(char)
-	O
start_of_body	*(char)
+	O
2	int
)	O
;	O
if	O
(	O
tmp	*(char)
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tmp	*(char)
,	O
start_of_body	*(char)
,	O
end_of_body	*(char)
-	O
start_of_body	*(char)
)	O
;	O
tmp	*(char)
[	O
end_of_body	*(char)
-	O
start_of_body	*(char)
]	O
=	O
'\0'	O
;	O
i	int
=	O
osip_message_set_body	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),long)->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
tmp	*(char)
,	O
end_of_body	*(char)
-	O
start_of_body	*(char)
)	O
;	O
osip_free	O
(	O
tmp	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
i	int
=	O
osip_generic_param_get_byname	O
(	O
&	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_type	*(struct(*(char),*(char),struct(int,*(struct(*`,*`)))))
->	O
gen_params	struct(int,*(struct(*(struct(*`,*`)),*(void))))
,	O
"boundary"	*(char)
,	O
&	O
ct_param	*(struct(*(char),*(char)))
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
if	O
(	O
ct_param	*(struct(*(char),*(char)))
==	O
NULL	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
ct_param	*(struct(*(char),*(char)))
->	O
gvalue	*(char)
==	O
NULL	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
{	O
const	O
char	O
*	O
boundary_prefix	*(char)
=	O
"\n--"	*(char)
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
ct_param	*(struct(*(char),*(char)))
->	O
gvalue	*(char)
)	O
;	O
sep_boundary	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
len	long
+	O
4	int
)	O
;	O
if	O
(	O
sep_boundary	*(char)
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
sep_boundary	*(char)
,	O
boundary_prefix	*(char)
)	O
;	O
if	O
(	O
ct_param	*(struct(*(char),*(char)))
->	O
gvalue	*(char)
[	O
0	int
]	O
==	O
'"'	O
&&	O
ct_param	*(struct(*(char),*(char)))
->	O
gvalue	*(char)
[	O
len	long
-	O
1	int
]	O
==	O
'"'	O
)	O
strncat	(*(char),*(char),long)->(*(char))
(	O
sep_boundary	*(char)
,	O
ct_param	*(struct(*(char),*(char)))
->	O
gvalue	*(char)
+	O
1	int
,	O
len	long
-	O
2	int
)	O
;	O
else	O
strncat	(*(char),*(char),long)->(*(char))
(	O
sep_boundary	*(char)
,	O
ct_param	*(struct(*(char),*(char)))
->	O
gvalue	*(char)
,	O
len	long
)	O
;	O
}	O
len_sep_boundary	long
=	O
strlen	(*(char))->(long)
(	O
sep_boundary	*(char)
)	O
;	O
*	O
next_body	*(*(char))
=	O
NULL	O
;	O
start_of_body	*(char)
=	O
start_of_buf	*(char)
;	O
end_of_buf	*(char)
=	O
start_of_buf	*(char)
+	O
length	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
body_len	long
=	O
0	int
;	O
i	int
=	O
__osip_find_next_occurence	(*(char),*(char),*(*(char)),*(char))->(int)
(	O
sep_boundary	*(char)
,	O
start_of_body	*(char)
,	O
&	O
start_of_body	*(char)
,	O
end_of_buf	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_free	O
(	O
sep_boundary	*(char)
)	O
;	O
return	O
i	int
;	O
}	O
i	int
=	O
__osip_find_next_occurence	(*(char),*(char),*(*(char)),*(char))->(int)
(	O
sep_boundary	*(char)
,	O
start_of_body	*(char)
+	O
len_sep_boundary	long
,	O
&	O
end_of_body	*(char)
,	O
end_of_buf	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_free	O
(	O
sep_boundary	*(char)
)	O
;	O
return	O
i	int
;	O
}	O
start_of_body	*(char)
=	O
start_of_body	*(char)
+	O
len_sep_boundary	long
+	O
1	int
;	O
if	O
(	O
'\n'	O
==	O
start_of_body	*(char)
[	O
0	int
]	O
||	O
'\r'	O
==	O
start_of_body	*(char)
[	O
0	int
]	O
)	O
start_of_body	*(char)
++	O
;	O
if	O
(	O
end_of_body	*(char)
<=	O
start_of_body	*(char)
)	O
{	O
osip_free	O
(	O
sep_boundary	*(char)
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
body_len	long
=	O
end_of_body	*(char)
-	O
start_of_body	*(char)
;	O
if	O
(	O
*	O
(	O
end_of_body	*(char)
-	O
1	int
)	O
==	O
'\r'	O
)	O
body_len	long
--	O
;	O
tmp	*(char)
=	O
osip_malloc	O
(	O
body_len	long
+	O
2	int
)	O
;	O
if	O
(	O
tmp	*(char)
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
sep_boundary	*(char)
)	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tmp	*(char)
,	O
start_of_body	*(char)
,	O
body_len	long
)	O
;	O
tmp	*(char)
[	O
body_len	long
]	O
=	O
'\0'	O
;	O
i	int
=	O
osip_message_set_body_mime	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),long)->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
tmp	*(char)
,	O
body_len	long
)	O
;	O
osip_free	O
(	O
tmp	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_free	O
(	O
sep_boundary	*(char)
)	O
;	O
return	O
i	int
;	O
}	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
end_of_body	*(char)
+	O
len_sep_boundary	long
,	O
"--"	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
*	O
next_body	*(*(char))
=	O
end_of_body	*(char)
;	O
osip_free	O
(	O
sep_boundary	*(char)
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
start_of_body	*(char)
=	O
end_of_body	*(char)
;	O
}	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
static	O
int	O
_osip_message_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),long,int)->(int)
(	O
osip_message_t	struct
*	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
const	O
char	O
*	O
buf	*(char)
,	O
size_t	long
length	long
,	O
int	O
sipfrag	int
)	O
{	O
int	O
i	int
;	O
const	O
char	O
*	O
next_header_index	*(char)
;	O
char	O
*	O
tmp	*(char)
;	O
char	O
*	O
beg	*(char)
;	O
tmp	*(char)
=	O
osip_malloc	O
(	O
length	long
+	O
2	int
)	O
;	O
if	O
(	O
tmp	*(char)
==	O
NULL	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Could not allocate memory.\n"	*(char)
)	O
)	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
beg	*(char)
=	O
tmp	*(char)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tmp	*(char)
,	O
buf	*(char)
,	O
length	long
)	O
;	O
tmp	*(char)
[	O
length	long
]	O
=	O
'\0'	O
;	O
tmp	*(char)
+=	O
strspn	(*(char),*(char))->(long)
(	O
tmp	*(char)
,	O
"\r\n"	*(char)
)	O
;	O
osip_util_replace_all_lws	(*(char))->(void)
(	O
tmp	*(char)
)	O
;	O
i	int
=	O
__osip_message_startline_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
tmp	*(char)
,	O
&	O
next_header_index	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
&&	O
!	O
sipfrag	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Could not parse start line of message.\n"	*(char)
)	O
)	O
;	O
osip_free	O
(	O
beg	*(char)
)	O
;	O
return	O
i	int
;	O
}	O
tmp	*(char)
=	O
(	O
char	O
*	O
)	O
next_header_index	*(char)
;	O
i	int
=	O
msg_headers_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
tmp	*(char)
,	O
&	O
next_header_index	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"error in msg_headers_parse()\n"	*(char)
)	O
)	O
;	O
osip_free	O
(	O
beg	*(char)
)	O
;	O
return	O
i	int
;	O
}	O
tmp	*(char)
=	O
(	O
char	O
*	O
)	O
next_header_index	*(char)
;	O
if	O
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
!=	O
NULL	O
&&	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
->	O
value	*(char)
==	O
NULL	O
)	O
{	O
osip_content_length_free	(*(struct(*(char))))->(void)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
)	O
;	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
=	O
NULL	O
;	O
}	O
if	O
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
!=	O
NULL	O
&&	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
->	O
value	*(char)
!=	O
NULL	O
&&	O
atoi	(*(char))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
->	O
value	*(char)
)	O
>	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
==	O
NULL	O
&&	O
'\r'	O
==	O
next_header_index	*(char)
[	O
0	int
]	O
&&	O
'\n'	O
==	O
next_header_index	*(char)
[	O
1	int
]	O
&&	O
length	long
-	O
(	O
tmp	*(char)
-	O
beg	*(char)
)	O
-	O
(	O
2	int
)	O
>	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
==	O
NULL	O
&&	O
'\n'	O
==	O
next_header_index	*(char)
[	O
0	int
]	O
&&	O
length	long
-	O
(	O
tmp	*(char)
-	O
beg	*(char)
)	O
-	O
(	O
1	int
)	O
>	O
0	int
)	O
{	O
}	O
else	O
{	O
if	O
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
==	O
NULL	O
)	O
osip_message_set_content_length	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
"0"	*(char)
)	O
;	O
osip_free	O
(	O
beg	*(char)
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
i	int
=	O
msg_osip_body_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),*(*(char)),long)->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
tmp	*(char)
,	O
&	O
next_header_index	*(char)
,	O
length	long
-	O
(	O
tmp	*(char)
-	O
beg	*(char)
)	O
)	O
;	O
osip_free	O
(	O
beg	*(char)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"error in msg_osip_body_parse()\n"	*(char)
)	O
)	O
;	O
return	O
i	int
;	O
}	O
if	O
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
->	O
content_length	*(struct(*(char)))
==	O
NULL	O
)	O
osip_message_set_content_length	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char))->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
"0"	*(char)
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
osip_message_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),long)->(int)
(	O
osip_message_t	struct
*	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
const	O
char	O
*	O
buf	*(char)
,	O
size_t	long
length	long
)	O
{	O
return	O
_osip_message_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),long,int)->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
buf	*(char)
,	O
length	long
,	O
0	int
)	O
;	O
}	O
int	O
osip_message_parse_sipfrag	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),long)->(int)
(	O
osip_message_t	struct
*	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
const	O
char	O
*	O
buf	*(char)
,	O
size_t	long
length	long
)	O
{	O
return	O
_osip_message_parse	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),long,int)->(int)
(	O
sip	*(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))))
,	O
buf	*(char)
,	O
length	long
,	O
1	int
)	O
;	O
}	O
int	O
osip_message_fix_last_via_header	(*(struct(*(char),*(struct(*`,*`,*`,*`,*`,struct`,struct`,*`)),*(char),int,*(char),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),*(struct(*`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),*(struct(*`,*`,struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),struct(int,*(struct`)),int,*(char),long,*(void))),*(char),int)->(int)
(	O
osip_message_t	struct
*	O
request	*(struct(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*`),struct(int,*`),*(char))),*(char),int,*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(char))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char))),*(struct(*(char),*(char),struct(int,*`))),*(struct(*(char),*(char))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(struct`),struct(int,*`))),*(struct(*(char))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(struct`),struct(int,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),int,*(char),long,*(void)))
,	O
const	O
char	O
*	O
ip_addr	*(char)
,	O
int	O
port	*(char)
)	O
{	O
osip_generic_param_t	struct(*(char),*(char))
*	O
rport	*(struct(*(char),*(char)))
;	O
osip_via_t	struct
*	O
via	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`)))))
;	O
if	O
(	O
request	*(struct(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*`),struct(int,*`),*(char))),*(char),int,*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(char))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char))),*(struct(*(char),*(char),struct(int,*`))),*(struct(*(char),*(char))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(struct`),struct(int,*`))),*(struct(*(char))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(struct`),struct(int,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),int,*(char),long,*(void)))
==	O
NULL	O
)	O
return	O
OSIP_BADPARAMETER	O
;	O
if	O
(	O
MSG_IS_RESPONSE	O
(	O
request	*(struct(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*`),struct(int,*`),*(char))),*(char),int,*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(char))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char))),*(struct(*(char),*(char),struct(int,*`))),*(struct(*(char),*(char))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(struct`),struct(int,*`))),*(struct(*(char))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(struct`),struct(int,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),int,*(char),long,*(void)))
)	O
)	O
return	O
OSIP_SUCCESS	int
;	O
via	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`)))))
=	O
osip_list_get	(*(struct(int,*(struct(*`,*`)))),int)->(*(void))
(	O
&	O
request	*(struct(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*`),struct(int,*`),*(char))),*(char),int,*(char),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(char))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char))),*(struct(*(char),*(char),struct(int,*`))),*(struct(*(char),*(char))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(struct`),struct(int,*`))),*(struct(*(char))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),*(struct(*(char),*(struct`),struct(int,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),struct(int,*(struct(*`,*`))),int,*(char),long,*(void)))
->	O
vias	struct(int,*(struct(*(struct(*`,*`)),*(void))))
,	O
0	int
)	O
;	O
if	O
(	O
via	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`)))))
==	O
NULL	O
||	O
via	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`)))))
->	O
host	*(char)
==	O
NULL	O
)	O
return	O
OSIP_BADPARAMETER	O
;	O
osip_via_param_get_byname	O
(	O
via	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`)))))
,	O
"rport"	*(char)
,	O
&	O
rport	*(struct(*(char),*(char)))
)	O
;	O
if	O
(	O
rport	*(struct(*(char),*(char)))
!=	O
NULL	O
)	O
{	O
if	O
(	O
rport	*(struct(*(char),*(char)))
->	O
gvalue	*(char)
==	O
NULL	O
)	O
{	O
rport	*(struct(*(char),*(char)))
->	O
gvalue	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
9	int
)	O
;	O
if	O
(	O
rport	*(struct(*(char),*(char)))
->	O
gvalue	*(char)
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
rport	*(struct(*(char),*(char)))
->	O
gvalue	*(char)
,	O
8	int
,	O
"%i"	*(char)
,	O
port	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
0	int
==	O
strcmp	(*(char),*(char))->(int)
(	O
via	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`)))))
->	O
host	*(char)
,	O
ip_addr	*(char)
)	O
)	O
return	O
OSIP_SUCCESS	int
;	O
osip_via_set_received	O
(	O
via	*(struct(*(char),*(char),*(char),*(char),*(char),struct(int,*(struct(*`,*`)))))
,	O
osip_strdup	(*(char))->(*(char))
(	O
ip_addr	*(char)
)	O
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
const	O
char	O
*	O
osip_message_get_reason	(int)->(*(char))
(	O
int	O
replycode	int
)	O
{	O
struct	O
code_to_reason	struct(int,*(char))
{	O
int	O
code	int
;	O
const	O
char	O
*	O
reason	*(char)
;	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct(int,*(char))
reasons1xx	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
{	O
100	int
,	O
"Trying"	*(char)
}	O
,	O
{	O
180	int
,	O
"Ringing"	*(char)
}	O
,	O
{	O
181	int
,	O
"Call Is Being Forwarded"	*(char)
}	O
,	O
{	O
182	int
,	O
"Queued"	*(char)
}	O
,	O
{	O
183	int
,	O
"Session Progress"	*(char)
}	O
,	O
{	O
199	int
,	O
"Early Dialog Terminated"	*(char)
}	O
,	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct(int,*(char))
reasons2xx	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
{	O
200	int
,	O
"OK"	*(char)
}	O
,	O
{	O
202	int
,	O
"Accepted"	*(char)
}	O
,	O
{	O
204	int
,	O
"No Notification"	*(char)
}	O
,	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct(int,*(char))
reasons3xx	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
{	O
300	int
,	O
"Multiple Choices"	*(char)
}	O
,	O
{	O
301	int
,	O
"Moved Permanently"	*(char)
}	O
,	O
{	O
302	int
,	O
"Moved Temporarily"	*(char)
}	O
,	O
{	O
305	int
,	O
"Use Proxy"	*(char)
}	O
,	O
{	O
380	int
,	O
"Alternative Service"	*(char)
}	O
,	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct(int,*(char))
reasons4xx	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
{	O
400	int
,	O
"Bad Request"	*(char)
}	O
,	O
{	O
401	int
,	O
"Unauthorized"	*(char)
}	O
,	O
{	O
402	int
,	O
"Payment Required"	*(char)
}	O
,	O
{	O
403	int
,	O
"Forbidden"	*(char)
}	O
,	O
{	O
404	int
,	O
"Not Found"	*(char)
}	O
,	O
{	O
405	int
,	O
"Method Not Allowed"	*(char)
}	O
,	O
{	O
406	int
,	O
"Not Acceptable"	*(char)
}	O
,	O
{	O
407	int
,	O
"Proxy Authentication Required"	*(char)
}	O
,	O
{	O
408	int
,	O
"Request Timeout"	*(char)
}	O
,	O
{	O
409	int
,	O
"Conflict"	*(char)
}	O
,	O
{	O
410	int
,	O
"Gone"	*(char)
}	O
,	O
{	O
411	int
,	O
"Length Required"	*(char)
}	O
,	O
{	O
412	int
,	O
"Conditional Request Failed"	*(char)
}	O
,	O
{	O
413	int
,	O
"Request Entity Too Large"	*(char)
}	O
,	O
{	O
414	int
,	O
"Request-URI Too Long"	*(char)
}	O
,	O
{	O
415	int
,	O
"Unsupported Media Type"	*(char)
}	O
,	O
{	O
416	int
,	O
"Unsupported URI Scheme"	*(char)
}	O
,	O
{	O
417	int
,	O
"Unknown Resource-Priority"	*(char)
}	O
,	O
{	O
420	int
,	O
"Bad Extension"	*(char)
}	O
,	O
{	O
421	int
,	O
"Extension Required"	*(char)
}	O
,	O
{	O
422	int
,	O
"Session Interval Too Small"	*(char)
}	O
,	O
{	O
423	int
,	O
"Interval Too Brief"	*(char)
}	O
,	O
{	O
424	int
,	O
"Bad Location Information"	*(char)
}	O
,	O
{	O
428	int
,	O
"Use Identity Header"	*(char)
}	O
,	O
{	O
429	int
,	O
"Provide Referrer Identity"	*(char)
}	O
,	O
{	O
430	int
,	O
"Flow Failed"	*(char)
}	O
,	O
{	O
433	int
,	O
"Anonymity Disallowed"	*(char)
}	O
,	O
{	O
436	int
,	O
"Bad Identity Info"	*(char)
}	O
,	O
{	O
437	int
,	O
"Unsupported Credential"	*(char)
}	O
,	O
{	O
438	int
,	O
"Invalid Identity Header"	*(char)
}	O
,	O
{	O
439	int
,	O
"First Hop Lacks Outbound Support"	*(char)
}	O
,	O
{	O
440	int
,	O
"Max-Breadth Exceeded"	*(char)
}	O
,	O
{	O
469	int
,	O
"Bad Info Package"	*(char)
}	O
,	O
{	O
470	int
,	O
"Consent Needed"	*(char)
}	O
,	O
{	O
480	int
,	O
"Temporarily Unavailable"	*(char)
}	O
,	O
{	O
481	int
,	O
"Call/Transaction Does Not Exist"	*(char)
}	O
,	O
{	O
482	int
,	O
"Loop Detected"	*(char)
}	O
,	O
{	O
483	int
,	O
"Too Many Hops"	*(char)
}	O
,	O
{	O
484	int
,	O
"Address Incomplete"	*(char)
}	O
,	O
{	O
485	int
,	O
"Ambiguous"	*(char)
}	O
,	O
{	O
486	int
,	O
"Busy Here"	*(char)
}	O
,	O
{	O
487	int
,	O
"Request Terminated"	*(char)
}	O
,	O
{	O
488	int
,	O
"Not Acceptable Here"	*(char)
}	O
,	O
{	O
489	int
,	O
"Bad Event"	*(char)
}	O
,	O
{	O
491	int
,	O
"Request Pending"	*(char)
}	O
,	O
{	O
493	int
,	O
"Undecipherable"	*(char)
}	O
,	O
{	O
494	int
,	O
"Security Agreement Required"	*(char)
}	O
,	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct(int,*(char))
reasons5xx	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
{	O
500	int
,	O
"Server Internal Error"	*(char)
}	O
,	O
{	O
501	int
,	O
"Not Implemented"	*(char)
}	O
,	O
{	O
502	int
,	O
"Bad Gateway"	*(char)
}	O
,	O
{	O
503	int
,	O
"Service Unavailable"	*(char)
}	O
,	O
{	O
504	int
,	O
"Server Time-out"	*(char)
}	O
,	O
{	O
505	int
,	O
"Version Not Supported"	*(char)
}	O
,	O
{	O
513	int
,	O
"Message Too Large"	*(char)
}	O
,	O
{	O
580	int
,	O
"Precondition Failure"	*(char)
}	O
,	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct(int,*(char))
reasons6xx	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
{	O
600	int
,	O
"Busy Everywhere"	*(char)
}	O
,	O
{	O
603	int
,	O
"Decline"	*(char)
}	O
,	O
{	O
604	int
,	O
"Does Not Exist Anywhere"	*(char)
}	O
,	O
{	O
606	int
,	O
"Not Acceptable"	*(char)
}	O
,	O
{	O
607	int
,	O
"Unwanted"	*(char)
}	O
,	O
{	O
687	int
,	O
"Dialog Terminated"	*(char)
}	O
}	O
;	O
const	O
struct	O
code_to_reason	struct(int,*(char))
*	O
reasons	*(struct(int,*(char)))
;	O
int	O
len	long
,	O
i	int
;	O
switch	O
(	O
replycode	int
/	O
100	int
)	O
{	O
case	O
1	int
:	O
reasons	*(struct(int,*(char)))
=	O
reasons1xx	array(struct(int,*(char)))
;	O
len	long
=	O
sizeof	O
(	O
reasons1xx	array(struct(int,*(char)))
)	O
/	O
sizeof	O
(	O
*	O
reasons	*(struct(int,*(char)))
)	O
;	O
break	O
;	O
case	O
2	int
:	O
reasons	*(struct(int,*(char)))
=	O
reasons2xx	array(struct(int,*(char)))
;	O
len	long
=	O
sizeof	O
(	O
reasons2xx	array(struct(int,*(char)))
)	O
/	O
sizeof	O
(	O
*	O
reasons	*(struct(int,*(char)))
)	O
;	O
break	O
;	O
case	O
3	int
:	O
reasons	*(struct(int,*(char)))
=	O
reasons3xx	array(struct(int,*(char)))
;	O
len	long
=	O
sizeof	O
(	O
reasons3xx	array(struct(int,*(char)))
)	O
/	O
sizeof	O
(	O
*	O
reasons	*(struct(int,*(char)))
)	O
;	O
break	O
;	O
case	O
4	int
:	O
reasons	*(struct(int,*(char)))
=	O
reasons4xx	array(struct(int,*(char)))
;	O
len	long
=	O
sizeof	O
(	O
reasons4xx	array(struct(int,*(char)))
)	O
/	O
sizeof	O
(	O
*	O
reasons	*(struct(int,*(char)))
)	O
;	O
break	O
;	O
case	O
5	int
:	O
reasons	*(struct(int,*(char)))
=	O
reasons5xx	array(struct(int,*(char)))
;	O
len	long
=	O
sizeof	O
(	O
reasons5xx	array(struct(int,*(char)))
)	O
/	O
sizeof	O
(	O
*	O
reasons	*(struct(int,*(char)))
)	O
;	O
break	O
;	O
case	O
6	int
:	O
reasons	*(struct(int,*(char)))
=	O
reasons6xx	array(struct(int,*(char)))
;	O
len	long
=	O
sizeof	O
(	O
reasons6xx	array(struct(int,*(char)))
)	O
/	O
sizeof	O
(	O
*	O
reasons	*(struct(int,*(char)))
)	O
;	O
break	O
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	long
;	O
i	int
++	O
)	O
if	O
(	O
reasons	*(struct(int,*(char)))
[	O
i	int
]	O
.	O
code	int
==	O
replycode	int
)	O
return	O
reasons	*(struct(int,*(char)))
[	O
i	int
]	O
.	O
reason	*(char)
;	O
return	O
NULL	O
;	O
}	O
