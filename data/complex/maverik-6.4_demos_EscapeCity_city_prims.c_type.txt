extern	O
MAV_class	O
*	O
mav_class_citycell	*(int)
;	O
extern	O
MAV_list	O
*	O
list_of_objects	*(int)
;	O
extern	O
MAV_SMS	O
*	O
sms	*(int)
;	O
extern	O
unsigned	O
int	O
current_frame	int
;	O
extern	O
int	O
size	int
;	O
extern	O
int	O
bb_pos	int
;	O
extern	O
BB	O
bb_array	int
[	O
MAX_BILLBOARDS	O
]	O
;	O
extern	O
int	O
num_visible_objects	int
;	O
extern	O
Visible_Object	O
*	O
visible_objects	*(int)
;	O
extern	O
int	O
culling	int
;	O
extern	O
float	O
object_dist	float
;	O
extern	O
MAV_vector	O
object_pos	int
;	O
float	O
max_composite_dist	float
=	O
65.0	int
;	O
int	O
current_texture	int
=	O
-	O
1	int
;	O
int	O
num_rendered_cells	int
;	O
int	O
num_rendered_polygons	int
;	O
int	O
wire	int
=	O
0	int
;	O
void	O
Render_Background	(float)->(void)
(	O
float	O
radius	float
)	O
{	O
float	O
theta0	float
,	O
phi0	float
;	O
float	O
theta1	float
,	O
phi1	float
;	O
float	O
t0	float
,	O
t1	float
;	O
int	O
divn	int
=	O
3	int
;	O
int	O
i	int
,	O
j	int
;	O
MAV_vector	O
cent	O
;	O
float	O
rphi0	float
,	O
rphi1	float
;	O
MAV_vector	O
p	O
;	O
MAV_texCoord	O
t	O
;	O
MAV_surfaceParams	O
sp	O
;	O
sp	O
.	O
mode	O
=	O
MAV_MATERIAL	O
;	O
sp	O
.	O
material	O
=	O
MAT_GRASS	O
;	O
mav_surfaceParamsUse	()->(int)
(	O
&	O
sp	O
)	O
;	O
cent	O
.	O
x	O
=	O
0.5	int
*	O
size	int
*	O
BLOCK_WIDTH	O
;	O
cent	O
.	O
y	O
=	O
-	O
0.1	int
;	O
cent	O
.	O
z	O
=	O
0.5	int
*	O
size	int
*	O
BLOCK_WIDTH	O
;	O
glBegin	()->(int)
(	O
GL_TRIANGLES	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
*	O
divn	int
;	O
i	int
++	O
)	O
{	O
theta0	float
=	O
0.25	int
*	O
i	int
/	O
(	O
float	O
)	O
divn	int
;	O
theta1	float
=	O
0.25	int
*	O
(	O
i	int
+	O
1	int
)	O
/	O
(	O
float	O
)	O
divn	int
;	O
p	O
.	O
x	O
=	O
0.0	int
;	O
p	O
.	O
y	O
=	O
1.0	int
;	O
p	O
.	O
z	O
=	O
0.0	int
;	O
mav_gfxNormal	()->(int)
(	O
p	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
cent	O
)	O
;	O
p	O
.	O
x	O
=	O
cent	O
.	O
x	O
+	O
radius	float
*	O
sin	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta0	float
)	O
;	O
p	O
.	O
y	O
=	O
cent	O
.	O
y	O
;	O
p	O
.	O
z	O
=	O
cent	O
.	O
z	O
+	O
radius	float
*	O
cos	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta0	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
p	O
.	O
x	O
=	O
cent	O
.	O
x	O
+	O
radius	float
*	O
sin	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta1	float
)	O
;	O
p	O
.	O
z	O
=	O
cent	O
.	O
z	O
+	O
radius	float
*	O
cos	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta1	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
}	O
glEnd	()->(int)
(	O
)	O
;	O
glDisable	()->(int)
(	O
GL_FOG	O
)	O
;	O
sp	O
.	O
mode	O
=	O
MAV_TEXTURE	O
;	O
sp	O
.	O
texture	O
=	O
TEX_SKY	O
;	O
mav_surfaceParamsUse	()->(int)
(	O
&	O
sp	O
)	O
;	O
glBegin	()->(int)
(	O
GL_TRIANGLES	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
divn	int
;	O
j	int
++	O
)	O
{	O
phi0	float
=	O
j	int
/	O
(	O
float	O
)	O
divn	int
;	O
phi1	float
=	O
(	O
j	int
+	O
1	int
)	O
/	O
(	O
float	O
)	O
divn	int
;	O
rphi0	float
=	O
radius	float
*	O
sin	(double)->(double)
(	O
MAV_PI_OVER_2	O
*	O
phi0	float
)	O
;	O
rphi1	float
=	O
radius	float
*	O
sin	(double)->(double)
(	O
MAV_PI_OVER_2	O
*	O
phi1	float
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
*	O
divn	int
;	O
i	int
++	O
)	O
{	O
theta0	float
=	O
0.25	int
*	O
i	int
/	O
(	O
float	O
)	O
divn	int
;	O
theta1	float
=	O
0.25	int
*	O
(	O
i	int
+	O
1	int
)	O
/	O
(	O
float	O
)	O
divn	int
;	O
t0	float
=	O
0.01	int
+	O
0.99	int
*	O
fabs	(double)->(double)
(	O
0.99	int
-	O
1.98	int
*	O
theta0	float
)	O
;	O
t1	float
=	O
0.01	int
+	O
0.99	int
*	O
fabs	(double)->(double)
(	O
0.99	int
-	O
1.98	int
*	O
theta1	float
)	O
;	O
if	O
(	O
j	int
==	O
0	int
)	O
{	O
t	O
.	O
s	O
=	O
0.5	int
;	O
t	O
.	O
t	O
=	O
0.99	int
-	O
0.98	int
*	O
phi0	float
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
x	O
=	O
cent	O
.	O
x	O
;	O
p	O
.	O
y	O
=	O
cent	O
.	O
y	O
+	O
radius	float
;	O
p	O
.	O
z	O
=	O
cent	O
.	O
z	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
t	O
.	O
s	O
=	O
t1	float
;	O
t	O
.	O
t	O
=	O
0.99	int
-	O
0.98	int
*	O
phi1	float
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
x	O
=	O
cent	O
.	O
x	O
+	O
rphi1	float
*	O
sin	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta1	float
)	O
;	O
p	O
.	O
y	O
=	O
cent	O
.	O
y	O
+	O
radius	float
*	O
cos	(double)->(double)
(	O
MAV_PI_OVER_2	O
*	O
phi1	float
)	O
;	O
p	O
.	O
z	O
=	O
cent	O
.	O
z	O
+	O
rphi1	float
*	O
cos	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta1	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
t	O
.	O
s	O
=	O
t0	float
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
x	O
=	O
cent	O
.	O
x	O
+	O
rphi1	float
*	O
sin	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta0	float
)	O
;	O
p	O
.	O
z	O
=	O
cent	O
.	O
z	O
+	O
rphi1	float
*	O
cos	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta0	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
}	O
else	O
{	O
t	O
.	O
s	O
=	O
t1	float
;	O
t	O
.	O
t	O
=	O
0.99	int
-	O
0.98	int
*	O
phi0	float
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
x	O
=	O
cent	O
.	O
x	O
+	O
rphi0	float
*	O
sin	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta1	float
)	O
;	O
p	O
.	O
y	O
=	O
cent	O
.	O
y	O
+	O
radius	float
*	O
cos	(double)->(double)
(	O
MAV_PI_OVER_2	O
*	O
phi0	float
)	O
;	O
p	O
.	O
z	O
=	O
cent	O
.	O
z	O
+	O
rphi0	float
*	O
cos	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta1	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
t	O
.	O
s	O
=	O
t1	float
;	O
t	O
.	O
t	O
=	O
0.99	int
-	O
0.98	int
*	O
phi1	float
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
x	O
=	O
cent	O
.	O
x	O
+	O
rphi1	float
*	O
sin	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta1	float
)	O
;	O
p	O
.	O
y	O
=	O
cent	O
.	O
y	O
+	O
radius	float
*	O
cos	(double)->(double)
(	O
MAV_PI_OVER_2	O
*	O
phi1	float
)	O
;	O
p	O
.	O
z	O
=	O
cent	O
.	O
z	O
+	O
rphi1	float
*	O
cos	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta1	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
t	O
.	O
s	O
=	O
t0	float
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
x	O
=	O
cent	O
.	O
x	O
+	O
rphi1	float
*	O
sin	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta0	float
)	O
;	O
p	O
.	O
z	O
=	O
cent	O
.	O
z	O
+	O
rphi1	float
*	O
cos	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta0	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
t	O
.	O
s	O
=	O
t1	float
;	O
t	O
.	O
t	O
=	O
0.99	int
-	O
0.98	int
*	O
phi0	float
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
x	O
=	O
cent	O
.	O
x	O
+	O
rphi0	float
*	O
sin	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta1	float
)	O
;	O
p	O
.	O
y	O
=	O
cent	O
.	O
y	O
+	O
radius	float
*	O
cos	(double)->(double)
(	O
MAV_PI_OVER_2	O
*	O
phi0	float
)	O
;	O
p	O
.	O
z	O
=	O
cent	O
.	O
z	O
+	O
rphi0	float
*	O
cos	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta1	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
t	O
.	O
s	O
=	O
t0	float
;	O
t	O
.	O
t	O
=	O
0.99	int
-	O
0.98	int
*	O
phi1	float
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
x	O
=	O
cent	O
.	O
x	O
+	O
rphi1	float
*	O
sin	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta0	float
)	O
;	O
p	O
.	O
y	O
=	O
cent	O
.	O
y	O
+	O
radius	float
*	O
cos	(double)->(double)
(	O
MAV_PI_OVER_2	O
*	O
phi1	float
)	O
;	O
p	O
.	O
z	O
=	O
cent	O
.	O
z	O
+	O
rphi1	float
*	O
cos	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta0	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
t	O
.	O
t	O
=	O
0.99	int
-	O
0.98	int
*	O
phi0	float
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
x	O
=	O
cent	O
.	O
x	O
+	O
rphi0	float
*	O
sin	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta0	float
)	O
;	O
p	O
.	O
y	O
=	O
cent	O
.	O
y	O
+	O
radius	float
*	O
cos	(double)->(double)
(	O
MAV_PI_OVER_2	O
*	O
phi0	float
)	O
;	O
p	O
.	O
z	O
=	O
cent	O
.	O
z	O
+	O
rphi0	float
*	O
cos	(double)->(double)
(	O
2.0	int
*	O
MAV_PI	O
*	O
theta0	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
}	O
}	O
}	O
glEnd	()->(int)
(	O
)	O
;	O
glEnable	()->(int)
(	O
GL_FOG	O
)	O
;	O
}	O
int	O
mav_objectEnlist	(*(int),*(void),*(void))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
void	O
*	O
v1	*(void)
,	O
void	O
*	O
v2	*(void)
)	O
{	O
visible_objects	*(int)
[	O
num_visible_objects	int
]	O
.	O
obj	*(int)
=	O
obj	*(int)
;	O
num_visible_objects	int
++	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_cityCellGetMatrix	(*(int),*(*(int)))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_matrix	O
*	O
*	O
mat	*(*(int))
)	O
{	O
*	O
mat	*(*(int))
=	O
&	O
(	O
(	O
(	O
MAV_cityCell	O
*	O
)	O
obj	*(int)
->	O
the_data	O
)	O
->	O
matrix	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_cityCellGetUserdef	(*(int),*(*(*(void))))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
void	O
*	O
*	O
*	O
ud	*(*(*(void)))
)	O
{	O
*	O
ud	*(*(*(void)))
=	O
&	O
(	O
(	O
(	O
MAV_cityCell	O
*	O
)	O
obj	*(int)
->	O
the_data	O
)	O
->	O
userdef	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_cityCellBBox	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_BB	O
*	O
bb	*(int)
)	O
{	O
MAV_cityCell	O
*	O
s	O
=	O
(	O
MAV_cityCell	O
*	O
)	O
obj	*(int)
->	O
the_data	O
;	O
mav_BBAlign	()->(int)
(	O
s	O
->	O
bb	*(int)
,	O
s	O
->	O
matrix	O
,	O
bb	*(int)
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_cityCellDraw	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
cobj	*(int)
,	O
MAV_drawInfo	O
*	O
di	*(int)
)	O
{	O
MAV_cityCell	O
*	O
c	O
=	O
(	O
MAV_cityCell	O
*	O
)	O
cobj	*(int)
->	O
the_data	O
;	O
Poly	O
*	O
p	O
;	O
MAV_object	O
*	O
obj	*(int)
;	O
int	O
begin	int
;	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
c	O
->	O
matrix	O
)	O
;	O
if	O
(	O
wire	int
)	O
{	O
mav_gfxLineWidthSet	()->(int)
(	O
1	int
)	O
;	O
mav_BBDisplayWithColour	()->(int)
(	O
mav_win_current	O
,	O
c	O
->	O
bb	*(int)
,	O
MAV_COLOUR_WHITE	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
c	O
->	O
lod_polys	O
&&	O
object_dist	float
>	O
2.0	int
*	O
max_composite_dist	float
)	O
p	O
=	O
c	O
->	O
lod_polys	O
;	O
else	O
p	O
=	O
c	O
->	O
polys	O
;	O
begin	int
=	O
1	int
;	O
while	O
(	O
p	O
)	O
{	O
if	O
(	O
begin	int
)	O
{	O
mav_surfaceParamsUse	()->(int)
(	O
&	O
p	O
->	O
sp	O
)	O
;	O
begin	int
=	O
0	int
;	O
glBegin	()->(int)
(	O
GL_QUADS	O
)	O
;	O
}	O
if	O
(	O
p	O
->	O
sp	O
.	O
texture	O
>	O
-	O
1	int
)	O
{	O
glNormal3fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
normal	O
)	O
;	O
glTexCoord2fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
texcoords	O
[	O
0	int
]	O
)	O
;	O
glVertex3fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
verts	O
[	O
0	int
]	O
)	O
;	O
glTexCoord2fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
texcoords	O
[	O
1	int
]	O
)	O
;	O
glVertex3fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
verts	O
[	O
1	int
]	O
)	O
;	O
glTexCoord2fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
texcoords	O
[	O
2	int
]	O
)	O
;	O
glVertex3fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
verts	O
[	O
2	int
]	O
)	O
;	O
glTexCoord2fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
texcoords	O
[	O
3	int
]	O
)	O
;	O
glVertex3fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
verts	O
[	O
3	int
]	O
)	O
;	O
}	O
else	O
{	O
glNormal3fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
normal	O
)	O
;	O
glVertex3fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
verts	O
[	O
0	int
]	O
)	O
;	O
glVertex3fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
verts	O
[	O
1	int
]	O
)	O
;	O
glVertex3fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
verts	O
[	O
2	int
]	O
)	O
;	O
glVertex3fv	()->(int)
(	O
(	O
GLfloat	O
*	O
)	O
&	O
p	O
->	O
verts	O
[	O
3	int
]	O
)	O
;	O
}	O
if	O
(	O
p	O
->	O
drawn	O
)	O
{	O
glEnd	()->(int)
(	O
)	O
;	O
begin	int
=	O
1	int
;	O
}	O
p	O
=	O
p	O
->	O
next	O
;	O
}	O
}	O
glEnd	()->(int)
(	O
)	O
;	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_occluderGetMatrix	(*(int),*(*(int)))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_matrix	O
*	O
*	O
mat	*(*(int))
)	O
{	O
*	O
mat	*(*(int))
=	O
&	O
(	O
(	O
(	O
MAV_occluder	O
*	O
)	O
obj	*(int)
->	O
the_data	O
)	O
->	O
matrix	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_occluderGetUserdef	(*(int),*(*(*(void))))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
void	O
*	O
*	O
*	O
ud	*(*(*(void)))
)	O
{	O
*	O
ud	*(*(*(void)))
=	O
&	O
(	O
(	O
(	O
MAV_occluder	O
*	O
)	O
obj	*(int)
->	O
the_data	O
)	O
->	O
userdef	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_occluderBBox	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_BB	O
*	O
bb	*(int)
)	O
{	O
MAV_occluder	O
*	O
o	O
=	O
(	O
MAV_occluder	O
*	O
)	O
obj	*(int)
->	O
the_data	O
;	O
mav_BBAlign	()->(int)
(	O
o	O
->	O
occluder	O
,	O
o	O
->	O
matrix	O
,	O
&	O
o	O
->	O
global_bb	O
)	O
;	O
*	O
bb	*(int)
=	O
o	O
->	O
global_bb	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_occluderDraw	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_drawInfo	O
*	O
di	*(int)
)	O
{	O
if	O
(	O
wire	int
)	O
{	O
MAV_occluder	O
*	O
o	O
=	O
(	O
MAV_occluder	O
*	O
)	O
obj	*(int)
->	O
the_data	O
;	O
MAV_BB	O
bb	*(int)
;	O
mav_BBAlign	()->(int)
(	O
o	O
->	O
occluder	O
,	O
o	O
->	O
matrix	O
,	O
&	O
bb	*(int)
)	O
;	O
bb	*(int)
.	O
min	O
.	O
x	O
+=	O
0.1	int
;	O
bb	*(int)
.	O
min	O
.	O
y	O
+=	O
0.1	int
;	O
bb	*(int)
.	O
min	O
.	O
z	O
+=	O
0.1	int
;	O
bb	*(int)
.	O
max	O
.	O
x	O
-=	O
0.1	int
;	O
bb	*(int)
.	O
max	O
.	O
y	O
-=	O
0.1	int
;	O
bb	*(int)
.	O
max	O
.	O
z	O
-=	O
0.1	int
;	O
mav_BBDisplayWithColour	()->(int)
(	O
mav_win_current	O
,	O
bb	*(int)
,	O
MAV_COLOUR_RED	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
mav_billboardGetMatrix	(*(int),*(*(int)))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_matrix	O
*	O
*	O
mat	*(*(int))
)	O
{	O
*	O
mat	*(*(int))
=	O
&	O
(	O
(	O
(	O
MAV_billboard	O
*	O
)	O
obj	*(int)
->	O
the_data	O
)	O
->	O
matrix	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_billboardGetUserdef	(*(int),*(*(*(void))))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
void	O
*	O
*	O
*	O
ud	*(*(*(void)))
)	O
{	O
*	O
ud	*(*(*(void)))
=	O
&	O
(	O
(	O
(	O
MAV_billboard	O
*	O
)	O
obj	*(int)
->	O
the_data	O
)	O
->	O
userdef	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_billboardBBox	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_BB	O
*	O
bb	*(int)
)	O
{	O
MAV_billboard	O
*	O
b	O
=	O
(	O
MAV_billboard	O
*	O
)	O
obj	*(int)
->	O
the_data	O
;	O
mav_BBAlign	()->(int)
(	O
b	O
->	O
bb	*(int)
,	O
b	O
->	O
matrix	O
,	O
bb	*(int)
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_billboardDraw	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_drawInfo	O
*	O
di	*(int)
)	O
{	O
MAV_billboard	O
*	O
bb	*(int)
=	O
(	O
MAV_billboard	O
*	O
)	O
obj	*(int)
->	O
the_data	O
;	O
MAV_vector	O
dr	O
;	O
float	O
rota	float
;	O
MAV_vector	O
p	O
;	O
MAV_texCoord	O
t	O
;	O
MAV_surfaceParams	O
sp	O
;	O
dr	O
.	O
x	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	O
-	O
object_pos	int
.	O
x	O
;	O
dr	O
.	O
z	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	O
-	O
object_pos	int
.	O
z	O
;	O
dr	O
.	O
x	O
/=	O
object_dist	float
;	O
dr	O
.	O
z	O
/=	O
object_dist	float
;	O
rota	float
=	O
57.29577951	int
*	O
acos	(double)->(double)
(	O
dr	O
.	O
z	O
)	O
;	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	O
<	O
object_pos	int
.	O
x	O
)	O
rota	float
=	O
-	O
rota	float
;	O
if	O
(	O
wire	int
)	O
{	O
sp	O
.	O
mode	O
=	O
MAV_COLOUR	O
;	O
sp	O
.	O
colour	O
=	O
MAV_COLOUR_GREEN	O
;	O
mav_surfaceParamsUse	()->(int)
(	O
&	O
sp	O
)	O
;	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
bb	*(int)
->	O
matrix	O
)	O
;	O
glRotatef	()->(int)
(	O
rota	float
,	O
0.0	int
,	O
1.0	int
,	O
0.0	int
)	O
;	O
mav_gfxLineClosedBegin	()->(int)
(	O
)	O
;	O
p	O
.	O
x	O
=	O
-	O
bb	*(int)
->	O
width	O
/	O
2.0	int
;	O
p	O
.	O
y	O
=	O
bb	*(int)
->	O
height	O
;	O
p	O
.	O
z	O
=	O
0.0	int
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
p	O
.	O
y	O
=	O
0.0	int
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
p	O
.	O
x	O
=	O
bb	*(int)
->	O
width	O
/	O
2.0	int
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
p	O
.	O
y	O
=	O
bb	*(int)
->	O
height	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
mav_gfxLineClosedEnd	()->(int)
(	O
)	O
;	O
mav_gfxLineBegin	()->(int)
(	O
)	O
;	O
p	O
.	O
x	O
=	O
0.0	int
;	O
p	O
.	O
y	O
=	O
bb	*(int)
->	O
height	O
/	O
2.0	int
;	O
p	O
.	O
z	O
=	O
0.0	int
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
p	O
.	O
z	O
=	O
5.0	int
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
p	O
.	O
x	O
=	O
-	O
0.5	int
;	O
p	O
.	O
z	O
=	O
4.0	int
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
mav_gfxLineEnd	()->(int)
(	O
)	O
;	O
mav_gfxLineBegin	()->(int)
(	O
)	O
;	O
p	O
.	O
x	O
=	O
0.0	int
;	O
p	O
.	O
z	O
=	O
5.0	int
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
p	O
.	O
x	O
=	O
0.5	int
;	O
p	O
.	O
z	O
=	O
4.0	int
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
mav_gfxLineEnd	()->(int)
(	O
)	O
;	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
}	O
else	O
{	O
mav_surfaceParamsUse	()->(int)
(	O
&	O
bb	*(int)
->	O
sp	O
)	O
;	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
bb	*(int)
->	O
matrix	O
)	O
;	O
glRotatef	()->(int)
(	O
rota	float
,	O
0.0	int
,	O
1.0	int
,	O
0.0	int
)	O
;	O
glEnable	()->(int)
(	O
GL_BLEND	O
)	O
;	O
glBlendFunc	()->(int)
(	O
GL_SRC_ALPHA	O
,	O
GL_ONE_MINUS_SRC_ALPHA	O
)	O
;	O
mav_gfxPolygonBegin	()->(int)
(	O
)	O
;	O
t	O
.	O
s	O
=	O
0.0	int
;	O
t	O
.	O
t	O
=	O
1.0	int
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
x	O
=	O
-	O
bb	*(int)
->	O
width	O
/	O
2.0	int
;	O
p	O
.	O
y	O
=	O
bb	*(int)
->	O
height	O
;	O
p	O
.	O
z	O
=	O
0.0	int
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
t	O
.	O
t	O
=	O
0.0	int
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
y	O
=	O
0.0	int
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
t	O
.	O
s	O
=	O
1.0	int
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
x	O
=	O
bb	*(int)
->	O
width	O
/	O
2.0	int
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
t	O
.	O
t	O
=	O
1.0	int
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	O
.	O
y	O
=	O
bb	*(int)
->	O
height	O
;	O
mav_gfxVertex	()->(int)
(	O
p	O
)	O
;	O
mav_gfxPolygonEnd	()->(int)
(	O
)	O
;	O
glDisable	()->(int)
(	O
GL_BLEND	O
)	O
;	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
