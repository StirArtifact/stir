static	O
int	O
cmp	()->(int)
(	O
void	O
)	O
;	O
static	O
off_t	long
file_position	(int)->(long)
(	O
int	O
)	O
;	O
static	O
size_t	long
block_compare	(*(long),*(long))->(long)
(	O
word	O
const	O
*	O
,	O
word	O
const	O
*	O
)	O
;	O
static	O
size_t	long
block_compare_and_count	(*(long),*(long),*(long))->(long)
(	O
word	O
const	O
*	O
,	O
word	O
const	O
*	O
,	O
off_t	long
*	O
)	O
;	O
static	O
void	O
sprintc	(*(char),char)->(void)
(	O
char	O
*	O
,	O
unsigned	O
char	O
)	O
;	O
static	O
char	O
const	O
*	O
file	array(*(char))
[	O
2	int
]	O
;	O
static	O
int	O
file_desc	array(int)
[	O
2	int
]	O
;	O
static	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
2	int
]	O
;	O
static	O
word	O
*	O
buffer	array(*(long))
[	O
2	int
]	O
;	O
static	O
size_t	long
buf_size	long
;	O
static	O
off_t	long
ignore_initial	array(long)
[	O
2	int
]	O
;	O
static	O
uintmax_t	long
bytes	long
=	O
UINTMAX_MAX	O
;	O
static	O
enum	O
comparison_type	enum(int,int,int,int)
{	O
type_first_diff	int
,	O
type_all_diffs	int
,	O
type_no_stdout	int
,	O
type_status	int
}	O
comparison_type	enum(int,int,int,int)
;	O
static	O
bool	bool
opt_print_bytes	bool
;	O
enum	O
{	O
HELP_OPTION	int
=	O
CHAR_MAX	O
+	O
1	int
}	O
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
const	O
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"print-bytes"	*(char)
,	O
0	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"print-chars"	*(char)
,	O
0	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"ignore-initial"	*(char)
,	O
1	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"verbose"	*(char)
,	O
0	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"bytes"	*(char)
,	O
1	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"silent"	*(char)
,	O
0	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"quiet"	*(char)
,	O
0	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"version"	*(char)
,	O
0	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"help"	*(char)
,	O
0	int
,	O
0	int
,	O
HELP_OPTION	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
void	O
try_help	(*(char),*(char))->(void)
(	O
char	O
const	O
*	O
,	O
char	O
const	O
*	O
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
void	O
try_help	(*(char),*(char))->(void)
(	O
char	O
const	O
*	O
reason_msgid	*(char)
,	O
char	O
const	O
*	O
operand	*(char)
)	O
{	O
if	O
(	O
reason_msgid	*(char)
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
reason_msgid	*(char)
)	O
,	O
operand	*(char)
)	O
;	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"Try `%s --help' for more information."	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
static	O
char	O
const	O
valid_suffixes	array(char)
[	O
]	O
=	O
"kKMGTPEZY0"	*(char)
;	O
static	O
void	O
specify_ignore_initial	(int,*(*(char)),char)->(void)
(	O
int	O
f	int
,	O
char	O
*	O
*	O
argptr	*(*(char))
,	O
char	O
delimiter	char
)	O
{	O
uintmax_t	long
val	array(int)
;	O
char	O
const	O
*	O
arg	*(char)
=	O
*	O
argptr	*(*(char))
;	O
strtol_error	enum(int,int,int,int,int)
e	enum(int,int,int,int,int)
=	O
xstrtoumax	(*(char),*(*(char)),int,*(long),*(char))->(enum(int,int,int,int,int))
(	O
arg	*(char)
,	O
argptr	*(*(char))
,	O
0	int
,	O
&	O
val	array(int)
,	O
valid_suffixes	array(char)
)	O
;	O
if	O
(	O
!	O
(	O
e	enum(int,int,int,int,int)
==	O
LONGINT_OK	int
||	O
(	O
e	enum(int,int,int,int,int)
==	O
LONGINT_INVALID_SUFFIX_CHAR	int
&&	O
*	O
*	O
argptr	*(*(char))
==	O
delimiter	char
)	O
)	O
||	O
TYPE_MAXIMUM	O
(	O
off_t	long
)	O
<	O
val	array(int)
)	O
try_help	(*(char),*(char))->(void)
(	O
"invalid --ignore-initial value `%s'"	*(char)
,	O
arg	*(char)
)	O
;	O
if	O
(	O
ignore_initial	array(long)
[	O
f	int
]	O
<	O
val	array(int)
)	O
ignore_initial	array(long)
[	O
f	int
]	O
=	O
val	array(int)
;	O
}	O
static	O
void	O
specify_comparison_type	(enum(int,int,int,int))->(void)
(	O
enum	O
comparison_type	enum(int,int,int,int)
t	enum(int,int,int,int)
)	O
{	O
if	O
(	O
comparison_type	enum(int,int,int,int)
&&	O
comparison_type	enum(int,int,int,int)
!=	O
t	enum(int,int,int,int)
)	O
try_help	(*(char),*(char))->(void)
(	O
"options -l and -s are incompatible"	*(char)
,	O
0	int
)	O
;	O
comparison_type	enum(int,int,int,int)
=	O
t	enum(int,int,int,int)
;	O
}	O
static	O
void	O
check_stdout	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
"%s"	*(char)
,	O
_	O
(	O
"write failed"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"standard output"	*(char)
)	O
)	O
;	O
}	O
static	O
char	O
const	O
*	O
const	O
option_help_msgid	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"-b, --print-bytes          print differing bytes"	*(char)
)	O
,	O
N_	O
(	O
"-i, --ignore-initial=SKIP         skip first SKIP bytes of both inputs"	*(char)
)	O
,	O
N_	O
(	O
"-i, --ignore-initial=SKIP1:SKIP2  skip first SKIP1 bytes of FILE1 and\n"	*(char)
"                                      first SKIP2 bytes of FILE2"	*(char)
)	O
,	O
N_	O
(	O
"-l, --verbose              output byte numbers and differing byte values"	*(char)
)	O
,	O
N_	O
(	O
"-n, --bytes=LIMIT          compare at most LIMIT bytes"	*(char)
)	O
,	O
N_	O
(	O
"-s, --quiet, --silent      suppress all normal output"	*(char)
)	O
,	O
N_	O
(	O
"    --help                 display this help and exit"	*(char)
)	O
,	O
N_	O
(	O
"-v, --version              output version information and exit"	*(char)
)	O
,	O
0	int
}	O
;	O
static	O
void	O
usage	()->(void)
(	O
void	O
)	O
{	O
char	O
const	O
*	O
const	O
*	O
p	*(void)
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
_	O
(	O
"Compare two files byte by byte."	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n%s\n\n"	*(char)
,	O
_	O
(	O
"The optional SKIP1 and SKIP2 specify the number of bytes to skip\n"	*(char)
"at the beginning of each file (zero by default)."	*(char)
)	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"Mandatory arguments to long options are mandatory for short options too.\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
p	*(void)
=	O
option_help_msgid	array(*(char))
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
printf	(*(char))->(int)
(	O
"  %s\n"	*(char)
,	O
_	O
(	O
*	O
p	*(void)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n%s\n\n%s\n%s\n"	*(char)
,	O
_	O
(	O
"SKIP values may be followed by the following multiplicative suffixes:\nkB 1000, K 1024, MB 1,000,000, M 1,048,576,\nGB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."	*(char)
)	O
,	O
_	O
(	O
"If a FILE is `-' or missing, read standard input."	*(char)
)	O
,	O
_	O
(	O
"Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."	*(char)
)	O
)	O
;	O
emit_bug_reporting_address	()->(void)
(	O
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
c	int
,	O
f	int
,	O
exit_status	int
;	O
size_t	long
words_per_buffer	long
;	O
exit_failure	int
=	O
EXIT_TROUBLE	int
;	O
initialize_main	O
(	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	*(char)
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
c_stack_action	(*((int)->(void)))->(int)
(	O
0	int
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"bci:ln:sv"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
0	int
)	O
)	O
!=	O
-	O
1	int
)	O
switch	O
(	O
c	int
)	O
{	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
opt_print_bytes	bool
=	O
true	int
;	O
break	O
;	O
case	O
'i'	O
:	O
specify_ignore_initial	(int,*(*(char)),char)->(void)
(	O
0	int
,	O
&	O
optarg	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
*	O
optarg	*(char)
++	O
==	O
':'	O
)	O
specify_ignore_initial	(int,*(*(char)),char)->(void)
(	O
1	int
,	O
&	O
optarg	*(char)
,	O
0	int
)	O
;	O
else	O
if	O
(	O
ignore_initial	array(long)
[	O
1	int
]	O
<	O
ignore_initial	array(long)
[	O
0	int
]	O
)	O
ignore_initial	array(long)
[	O
1	int
]	O
=	O
ignore_initial	array(long)
[	O
0	int
]	O
;	O
break	O
;	O
case	O
'l'	O
:	O
specify_comparison_type	(enum(int,int,int,int))->(void)
(	O
type_all_diffs	int
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
{	O
uintmax_t	long
n	long
;	O
if	O
(	O
xstrtoumax	(*(char),*(*(char)),int,*(long),*(char))->(enum(int,int,int,int,int))
(	O
optarg	*(char)
,	O
0	int
,	O
0	int
,	O
&	O
n	long
,	O
valid_suffixes	array(char)
)	O
!=	O
LONGINT_OK	int
)	O
try_help	(*(char),*(char))->(void)
(	O
"invalid --bytes value `%s'"	*(char)
,	O
optarg	*(char)
)	O
;	O
if	O
(	O
n	long
<	O
bytes	long
)	O
bytes	long
=	O
n	long
;	O
}	O
break	O
;	O
case	O
's'	O
:	O
specify_comparison_type	(enum(int,int,int,int))->(void)
(	O
type_status	int
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
version_etc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
PROGRAM_NAME	*(char)
,	O
PACKAGE_NAME	*(char)
,	O
Version	*(char)
,	O
AUTHORS	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
check_stdout	()->(void)
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
case	O
HELP_OPTION	int
:	O
usage	()->(void)
(	O
)	O
;	O
check_stdout	()->(void)
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
default	O
:	O
try_help	(*(char),*(char))->(void)
(	O
0	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
optind	int
==	O
argc	int
)	O
try_help	(*(char),*(char))->(void)
(	O
"missing operand after `%s'"	*(char)
,	O
argv	*(*(char))
[	O
argc	int
-	O
1	int
]	O
)	O
;	O
file	array(*(char))
[	O
0	int
]	O
=	O
argv	*(*(char))
[	O
optind	int
++	O
]	O
;	O
file	array(*(char))
[	O
1	int
]	O
=	O
optind	int
<	O
argc	int
?	O
argv	*(*(char))
[	O
optind	int
++	O
]	O
:	O
"-"	*(char)
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
&&	O
optind	int
<	O
argc	int
;	O
f	int
++	O
)	O
{	O
char	O
*	O
arg	*(char)
=	O
argv	*(*(char))
[	O
optind	int
++	O
]	O
;	O
specify_ignore_initial	(int,*(*(char)),char)->(void)
(	O
f	int
,	O
&	O
arg	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
optind	int
<	O
argc	int
)	O
try_help	(*(char),*(char))->(void)
(	O
"extra operand `%s'"	*(char)
,	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
{	O
int	O
f1	int
=	O
f	int
^	O
(	O
STREQ	O
(	O
file	array(*(char))
[	O
1	int
]	O
,	O
"-"	*(char)
)	O
)	O
;	O
if	O
(	O
f	int
&&	O
ignore_initial	array(long)
[	O
0	int
]	O
==	O
ignore_initial	array(long)
[	O
1	int
]	O
&&	O
file_name_cmp	O
(	O
file	array(*(char))
[	O
0	int
]	O
,	O
file	array(*(char))
[	O
1	int
]	O
)	O
==	O
0	int
)	O
return	O
EXIT_SUCCESS	int
;	O
if	O
(	O
STREQ	O
(	O
file	array(*(char))
[	O
f1	int
]	O
,	O
"-"	*(char)
)	O
)	O
{	O
file_desc	array(int)
[	O
f1	int
]	O
=	O
STDIN_FILENO	int
;	O
if	O
(	O
O_BINARY	int
&&	O
!	O
isatty	(int)->(int)
(	O
STDIN_FILENO	int
)	O
)	O
xfreopen	(*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
NULL	O
,	O
"rb"	*(char)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
file_desc	array(int)
[	O
f1	int
]	O
=	O
open	(*(char),int)->(int)
(	O
file	array(*(char))
[	O
f1	int
]	O
,	O
O_RDONLY	int
|	O
O_BINARY	int
,	O
0	int
)	O
;	O
if	O
(	O
file_desc	array(int)
[	O
f1	int
]	O
<	O
0	int
||	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
file_desc	array(int)
[	O
f1	int
]	O
,	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
+	O
f1	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
file_desc	array(int)
[	O
f1	int
]	O
<	O
0	int
&&	O
comparison_type	enum(int,int,int,int)
==	O
type_status	int
)	O
exit	(int)->(void)
(	O
EXIT_TROUBLE	int
)	O
;	O
else	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
file	array(*(char))
[	O
f1	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
0	int
<	O
same_file	O
(	O
&	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
0	int
]	O
,	O
&	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
1	int
]	O
)	O
&&	O
same_file_attributes	O
(	O
&	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
0	int
]	O
,	O
&	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
1	int
]	O
)	O
&&	O
file_position	(int)->(long)
(	O
0	int
)	O
==	O
file_position	(int)->(long)
(	O
1	int
)	O
)	O
return	O
EXIT_SUCCESS	int
;	O
if	O
(	O
comparison_type	enum(int,int,int,int)
!=	O
type_status	int
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
outstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
nullstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
STDOUT_FILENO	int
,	O
&	O
outstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
&&	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
NULL_DEVICE	*(char)
,	O
&	O
nullstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
&&	O
0	int
<	O
same_file	O
(	O
&	O
outstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
&	O
nullstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
comparison_type	enum(int,int,int,int)
=	O
type_no_stdout	int
;	O
}	O
if	O
(	O
comparison_type	enum(int,int,int,int)
==	O
type_status	int
&&	O
S_ISREG	O
(	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
0	int
]	O
.	O
st_mode	int
)	O
&&	O
S_ISREG	O
(	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
1	int
]	O
.	O
st_mode	int
)	O
)	O
{	O
off_t	long
s0	long
=	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
0	int
]	O
.	O
st_size	long
-	O
file_position	(int)->(long)
(	O
0	int
)	O
;	O
off_t	long
s1	*(char)
=	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
1	int
]	O
.	O
st_size	long
-	O
file_position	(int)->(long)
(	O
1	int
)	O
;	O
if	O
(	O
s0	long
<	O
0	int
)	O
s0	long
=	O
0	int
;	O
if	O
(	O
s1	*(char)
<	O
0	int
)	O
s1	*(char)
=	O
0	int
;	O
if	O
(	O
s0	long
!=	O
s1	*(char)
&&	O
MIN	O
(	O
s0	long
,	O
s1	*(char)
)	O
<	O
bytes	long
)	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
buf_size	long
=	O
buffer_lcm	(long,long,long)->(long)
(	O
STAT_BLOCKSIZE	O
(	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
0	int
]	O
)	O
,	O
STAT_BLOCKSIZE	O
(	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
1	int
]	O
)	O
,	O
PTRDIFF_MAX	O
-	O
sizeof	O
(	O
word	O
)	O
)	O
;	O
words_per_buffer	long
=	O
(	O
buf_size	long
+	O
2	int
*	O
sizeof	O
(	O
word	O
)	O
-	O
1	int
)	O
/	O
sizeof	O
(	O
word	O
)	O
;	O
buffer	array(*(long))
[	O
0	int
]	O
=	O
xmalloc	(long)->(*(void))
(	O
2	int
*	O
sizeof	O
(	O
word	O
)	O
*	O
words_per_buffer	long
)	O
;	O
buffer	array(*(long))
[	O
1	int
]	O
=	O
buffer	array(*(long))
[	O
0	int
]	O
+	O
words_per_buffer	long
;	O
exit_status	int
=	O
cmp	()->(int)
(	O
)	O
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
if	O
(	O
close	(int)->(int)
(	O
file_desc	array(int)
[	O
f	int
]	O
)	O
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
file	array(*(char))
[	O
f	int
]	O
)	O
;	O
if	O
(	O
exit_status	int
!=	O
EXIT_SUCCESS	int
&&	O
comparison_type	enum(int,int,int,int)
<	O
type_no_stdout	int
)	O
check_stdout	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
exit_status	int
)	O
;	O
return	O
exit_status	int
;	O
}	O
static	O
int	O
cmp	()->(int)
(	O
void	O
)	O
{	O
off_t	long
line_number	long
=	O
1	int
;	O
off_t	long
byte_number	long
=	O
1	int
;	O
uintmax_t	long
remaining	long
=	O
bytes	long
;	O
size_t	long
read0	long
,	O
read1	long
;	O
size_t	long
first_diff	long
;	O
size_t	long
smaller	long
;	O
word	O
*	O
buffer0	*(long)
=	O
buffer	array(*(long))
[	O
0	int
]	O
;	O
word	O
*	O
buffer1	*(long)
=	O
buffer	array(*(long))
[	O
1	int
]	O
;	O
char	O
*	O
buf0	*(char)
=	O
(	O
char	O
*	O
)	O
buffer0	*(long)
;	O
char	O
*	O
buf1	*(char)
=	O
(	O
char	O
*	O
)	O
buffer1	*(long)
;	O
int	O
differing	int
=	O
0	int
;	O
int	O
f	int
;	O
int	O
offset_width	int
IF_LINT	O
(	O
=	O
0	int
)	O
;	O
if	O
(	O
comparison_type	enum(int,int,int,int)
==	O
type_all_diffs	int
)	O
{	O
off_t	long
byte_number_max	long
=	O
MIN	O
(	O
bytes	long
,	O
TYPE_MAXIMUM	O
(	O
off_t	long
)	O
)	O
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
if	O
(	O
S_ISREG	O
(	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
f	int
]	O
.	O
st_mode	int
)	O
)	O
{	O
off_t	long
file_bytes	long
=	O
stat_buf	array(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
f	int
]	O
.	O
st_size	long
-	O
file_position	(int)->(long)
(	O
f	int
)	O
;	O
if	O
(	O
file_bytes	long
<	O
byte_number_max	long
)	O
byte_number_max	long
=	O
file_bytes	long
;	O
}	O
for	O
(	O
offset_width	int
=	O
1	int
;	O
(	O
byte_number_max	long
/=	O
10	int
)	O
!=	O
0	int
;	O
offset_width	int
++	O
)	O
continue	O
;	O
}	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
{	O
off_t	long
ig	long
=	O
ignore_initial	array(long)
[	O
f	int
]	O
;	O
if	O
(	O
ig	long
&&	O
file_position	(int)->(long)
(	O
f	int
)	O
==	O
-	O
1	int
)	O
{	O
do	O
{	O
size_t	long
bytes_to_read	long
=	O
MIN	O
(	O
ig	long
,	O
buf_size	long
)	O
;	O
size_t	long
r	long
=	O
block_read	(int,*(char),long)->(long)
(	O
file_desc	array(int)
[	O
f	int
]	O
,	O
buf0	*(char)
,	O
bytes_to_read	long
)	O
;	O
if	O
(	O
r	long
!=	O
bytes_to_read	long
)	O
{	O
if	O
(	O
r	long
==	O
SIZE_MAX	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
file	array(*(char))
[	O
f	int
]	O
)	O
;	O
break	O
;	O
}	O
ig	long
-=	O
r	long
;	O
}	O
while	O
(	O
ig	long
)	O
;	O
}	O
}	O
do	O
{	O
size_t	long
bytes_to_read	long
=	O
buf_size	long
;	O
if	O
(	O
remaining	long
!=	O
UINTMAX_MAX	O
)	O
{	O
if	O
(	O
remaining	long
<	O
bytes_to_read	long
)	O
bytes_to_read	long
=	O
remaining	long
;	O
remaining	long
-=	O
bytes_to_read	long
;	O
}	O
read0	long
=	O
block_read	(int,*(char),long)->(long)
(	O
file_desc	array(int)
[	O
0	int
]	O
,	O
buf0	*(char)
,	O
bytes_to_read	long
)	O
;	O
if	O
(	O
read0	long
==	O
SIZE_MAX	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
file	array(*(char))
[	O
0	int
]	O
)	O
;	O
read1	long
=	O
block_read	(int,*(char),long)->(long)
(	O
file_desc	array(int)
[	O
1	int
]	O
,	O
buf1	*(char)
,	O
bytes_to_read	long
)	O
;	O
if	O
(	O
read1	long
==	O
SIZE_MAX	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
file	array(*(char))
[	O
1	int
]	O
)	O
;	O
buf0	*(char)
[	O
read0	long
]	O
=	O
~	O
buf1	*(char)
[	O
read0	long
]	O
;	O
buf1	*(char)
[	O
read1	long
]	O
=	O
~	O
buf0	*(char)
[	O
read1	long
]	O
;	O
first_diff	long
=	O
(	O
comparison_type	enum(int,int,int,int)
==	O
type_first_diff	int
?	O
block_compare_and_count	(*(long),*(long),*(long))->(long)
(	O
buffer0	*(long)
,	O
buffer1	*(long)
,	O
&	O
line_number	long
)	O
:	O
block_compare	(*(long),*(long))->(long)
(	O
buffer0	*(long)
,	O
buffer1	*(long)
)	O
)	O
;	O
byte_number	long
+=	O
first_diff	long
;	O
smaller	long
=	O
MIN	O
(	O
read0	long
,	O
read1	long
)	O
;	O
if	O
(	O
first_diff	long
<	O
smaller	long
)	O
{	O
switch	O
(	O
comparison_type	enum(int,int,int,int)
)	O
{	O
case	O
type_first_diff	int
:	O
{	O
char	O
byte_buf	array(char)
[	O
INT_BUFSIZE_BOUND	O
(	O
off_t	long
)	O
]	O
;	O
char	O
line_buf	array(char)
[	O
INT_BUFSIZE_BOUND	O
(	O
off_t	long
)	O
]	O
;	O
char	O
const	O
*	O
byte_num	*(char)
=	O
offtostr	(long,*(char))->(*(char))
(	O
byte_number	long
,	O
byte_buf	array(char)
)	O
;	O
char	O
const	O
*	O
line_num	*(char)
=	O
offtostr	(long,*(char))->(*(char))
(	O
line_number	long
,	O
line_buf	array(char)
)	O
;	O
if	O
(	O
!	O
opt_print_bytes	bool
)	O
{	O
static	O
char	O
const	O
char_message	array(char)
[	O
]	O
=	O
"%s %s differ: char %s, line %s\n"	*(char)
;	O
static	O
char	O
const	O
byte_msgid	array(char)
[	O
]	O
=	O
N_	O
(	O
"%s %s differ: byte %s, line %s\n"	*(char)
)	O
;	O
char	O
const	O
*	O
byte_message	*(char)
=	O
_	O
(	O
byte_msgid	array(char)
)	O
;	O
bool	bool
use_byte_message	bool
=	O
(	O
byte_message	*(char)
!=	O
byte_msgid	array(char)
||	O
hard_locale_LC_MESSAGES	O
)	O
;	O
printf	(*(char))->(int)
(	O
use_byte_message	bool
?	O
byte_message	*(char)
:	O
char_message	array(char)
,	O
file	array(*(char))
[	O
0	int
]	O
,	O
file	array(*(char))
[	O
1	int
]	O
,	O
byte_num	*(char)
,	O
line_num	*(char)
)	O
;	O
}	O
else	O
{	O
unsigned	O
char	O
c0	char
=	O
buf0	*(char)
[	O
first_diff	long
]	O
;	O
unsigned	O
char	O
c1	char
=	O
buf1	*(char)
[	O
first_diff	long
]	O
;	O
char	O
s0	long
[	O
5	int
]	O
;	O
char	O
s1	*(char)
[	O
5	int
]	O
;	O
sprintc	(*(char),char)->(void)
(	O
s0	long
,	O
c0	char
)	O
;	O
sprintc	(*(char),char)->(void)
(	O
s1	*(char)
,	O
c1	char
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"%s %s differ: byte %s, line %s is %3o %s %3o %s\n"	*(char)
)	O
,	O
file	array(*(char))
[	O
0	int
]	O
,	O
file	array(*(char))
[	O
1	int
]	O
,	O
byte_num	*(char)
,	O
line_num	*(char)
,	O
c0	char
,	O
s0	long
,	O
c1	char
,	O
s1	*(char)
)	O
;	O
}	O
}	O
case	O
type_status	int
:	O
return	O
EXIT_FAILURE	int
;	O
case	O
type_all_diffs	int
:	O
do	O
{	O
unsigned	O
char	O
c0	char
=	O
buf0	*(char)
[	O
first_diff	long
]	O
;	O
unsigned	O
char	O
c1	char
=	O
buf1	*(char)
[	O
first_diff	long
]	O
;	O
if	O
(	O
c0	char
!=	O
c1	char
)	O
{	O
char	O
byte_buf	array(char)
[	O
INT_BUFSIZE_BOUND	O
(	O
off_t	long
)	O
]	O
;	O
char	O
const	O
*	O
byte_num	*(char)
=	O
offtostr	(long,*(char))->(*(char))
(	O
byte_number	long
,	O
byte_buf	array(char)
)	O
;	O
if	O
(	O
!	O
opt_print_bytes	bool
)	O
{	O
printf	(*(char))->(int)
(	O
"%*s %3o %3o\n"	*(char)
,	O
offset_width	int
,	O
byte_num	*(char)
,	O
c0	char
,	O
c1	char
)	O
;	O
}	O
else	O
{	O
char	O
s0	long
[	O
5	int
]	O
;	O
char	O
s1	*(char)
[	O
5	int
]	O
;	O
sprintc	(*(char),char)->(void)
(	O
s0	long
,	O
c0	char
)	O
;	O
sprintc	(*(char),char)->(void)
(	O
s1	*(char)
,	O
c1	char
)	O
;	O
printf	(*(char))->(int)
(	O
"%*s %3o %-4s %3o %s\n"	*(char)
,	O
offset_width	int
,	O
byte_num	*(char)
,	O
c0	char
,	O
s0	long
,	O
c1	char
,	O
s1	*(char)
)	O
;	O
}	O
}	O
byte_number	long
++	O
;	O
first_diff	long
++	O
;	O
}	O
while	O
(	O
first_diff	long
<	O
smaller	long
)	O
;	O
differing	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
type_no_stdout	int
:	O
differing	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
read0	long
!=	O
read1	long
)	O
{	O
if	O
(	O
differing	int
<=	O
0	int
&&	O
comparison_type	enum(int,int,int,int)
!=	O
type_status	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"cmp: EOF on %s\n"	*(char)
)	O
,	O
file	array(*(char))
[	O
read1	long
<	O
read0	long
]	O
)	O
;	O
}	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
while	O
(	O
differing	int
<=	O
0	int
&&	O
read0	long
==	O
buf_size	long
)	O
;	O
return	O
differing	int
==	O
0	int
?	O
EXIT_SUCCESS	int
:	O
EXIT_FAILURE	int
;	O
}	O
static	O
size_t	long
block_compare_and_count	(*(long),*(long),*(long))->(long)
(	O
word	O
const	O
*	O
p0	*(long)
,	O
word	O
const	O
*	O
p1	*(long)
,	O
off_t	long
*	O
count	*(long)
)	O
{	O
word	O
l	long
;	O
word	O
const	O
*	O
l0	*(long)
,	O
*	O
l1	*(long)
;	O
char	O
const	O
*	O
c0	char
,	O
*	O
c1	char
;	O
size_t	long
cnt	long
=	O
0	int
;	O
word	O
nnnn	long
;	O
int	O
i	int
;	O
nnnn	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
nnnn	long
;	O
i	int
++	O
)	O
nnnn	long
=	O
(	O
nnnn	long
<<	O
CHAR_BIT	O
)	O
|	O
'\n'	O
;	O
for	O
(	O
l0	*(long)
=	O
p0	*(long)
,	O
l1	*(long)
=	O
p1	*(long)
;	O
(	O
l	long
=	O
*	O
l0	*(long)
)	O
==	O
*	O
l1	*(long)
;	O
l0	*(long)
++	O
,	O
l1	*(long)
++	O
)	O
{	O
l	long
^=	O
nnnn	long
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
l	long
;	O
i	int
++	O
)	O
{	O
unsigned	O
char	O
uc	char
=	O
l	long
;	O
cnt	long
+=	O
!	O
uc	char
;	O
l	long
>>=	O
CHAR_BIT	O
;	O
}	O
}	O
for	O
(	O
c0	char
=	O
(	O
char	O
const	O
*	O
)	O
l0	*(long)
,	O
c1	char
=	O
(	O
char	O
const	O
*	O
)	O
l1	*(long)
;	O
*	O
c0	char
==	O
*	O
c1	char
;	O
c0	char
++	O
,	O
c1	char
++	O
)	O
cnt	long
+=	O
*	O
c0	char
==	O
'\n'	O
;	O
*	O
count	*(long)
+=	O
cnt	long
;	O
return	O
c0	char
-	O
(	O
char	O
const	O
*	O
)	O
p0	*(long)
;	O
}	O
static	O
size_t	long
block_compare	(*(long),*(long))->(long)
(	O
word	O
const	O
*	O
p0	*(long)
,	O
word	O
const	O
*	O
p1	*(long)
)	O
{	O
word	O
const	O
*	O
l0	*(long)
,	O
*	O
l1	*(long)
;	O
char	O
const	O
*	O
c0	char
,	O
*	O
c1	char
;	O
for	O
(	O
l0	*(long)
=	O
p0	*(long)
,	O
l1	*(long)
=	O
p1	*(long)
;	O
*	O
l0	*(long)
==	O
*	O
l1	*(long)
;	O
l0	*(long)
++	O
,	O
l1	*(long)
++	O
)	O
continue	O
;	O
for	O
(	O
c0	char
=	O
(	O
char	O
const	O
*	O
)	O
l0	*(long)
,	O
c1	char
=	O
(	O
char	O
const	O
*	O
)	O
l1	*(long)
;	O
*	O
c0	char
==	O
*	O
c1	char
;	O
c0	char
++	O
,	O
c1	char
++	O
)	O
continue	O
;	O
return	O
c0	char
-	O
(	O
char	O
const	O
*	O
)	O
p0	*(long)
;	O
}	O
static	O
void	O
sprintc	(*(char),char)->(void)
(	O
char	O
*	O
buf	*(char)
,	O
unsigned	O
char	O
c	int
)	O
{	O
if	O
(	O
!	O
isprint	(int)->(int)
(	O
c	int
)	O
)	O
{	O
if	O
(	O
c	int
>=	O
128	int
)	O
{	O
*	O
buf	*(char)
++	O
=	O
'M'	O
;	O
*	O
buf	*(char)
++	O
=	O
'-'	O
;	O
c	int
-=	O
128	int
;	O
}	O
if	O
(	O
c	int
<	O
32	int
)	O
{	O
*	O
buf	*(char)
++	O
=	O
'^'	O
;	O
c	int
+=	O
64	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
127	int
)	O
{	O
*	O
buf	*(char)
++	O
=	O
'^'	O
;	O
c	int
=	O
'?'	O
;	O
}	O
}	O
*	O
buf	*(char)
++	O
=	O
c	int
;	O
*	O
buf	*(char)
=	O
0	int
;	O
}	O
static	O
off_t	long
file_position	(int)->(long)
(	O
int	O
f	int
)	O
{	O
static	O
bool	bool
positioned	array(bool)
[	O
2	int
]	O
;	O
static	O
off_t	long
position	array(long)
[	O
2	int
]	O
;	O
if	O
(	O
!	O
positioned	array(bool)
[	O
f	int
]	O
)	O
{	O
positioned	array(bool)
[	O
f	int
]	O
=	O
true	int
;	O
position	array(long)
[	O
f	int
]	O
=	O
lseek	(int,long,int)->(long)
(	O
file_desc	array(int)
[	O
f	int
]	O
,	O
ignore_initial	array(long)
[	O
f	int
]	O
,	O
SEEK_CUR	int
)	O
;	O
}	O
return	O
position	array(long)
[	O
f	int
]	O
;	O
}	O
