void	O
grad_client_random_authenticator	(*(char))->(void)
(	O
char	O
*	O
authenticator	array(char)
)	O
{	O
int	O
randno	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
GRAD_AUTHENTICATOR_LENGTH	int
;	O
)	O
{	O
randno	int
=	O
rand	()->(int)
(	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
authenticator	array(char)
,	O
&	O
randno	int
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
authenticator	array(char)
+=	O
sizeof	O
(	O
int	O
)	O
;	O
i	int
+=	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
}	O
unsigned	O
grad_client_message_id	(*(struct(*(char),int,array(int),*(char),long)))->(int)
(	O
grad_server_t	struct
*	O
server	*(struct(*(char),int,array(int),*(char),long))
)	O
{	O
grad_server_id_t	struct(int,char)
sid	struct(int,char)
;	O
int	O
fd	int
;	O
unsigned	O
id	char
;	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
grad_msgid_file	*(char)
,	O
O_RDWR	int
|	O
O_CREAT	int
,	O
PERM	O
)	O
;	O
if	O
(	O
fd	int
!=	O
-	O
1	int
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
id_offset	long
!=	O
(	O
off_t	long
)	O
-	O
1	int
&&	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
id_offset	long
+	O
sizeof	O
(	O
sid	struct(int,char)
)	O
<=	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
{	O
grad_lock_file	(int,long,long,int)->(void)
(	O
fd	int
,	O
sizeof	O
(	O
sid	struct(int,char)
)	O
,	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
id_offset	long
,	O
SEEK_SET	int
)	O
;	O
lseek	(int,long,int)->(long)
(	O
fd	int
,	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
id_offset	long
,	O
SEEK_SET	int
)	O
;	O
read	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
&	O
sid	struct(int,char)
,	O
sizeof	O
(	O
sid	struct(int,char)
)	O
)	O
;	O
id	char
=	O
sid	struct(int,char)
.	O
id	char
++	O
;	O
lseek	(int,long,int)->(long)
(	O
fd	int
,	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
id_offset	long
,	O
SEEK_SET	int
)	O
;	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
&	O
sid	struct(int,char)
,	O
sizeof	O
(	O
sid	struct(int,char)
)	O
)	O
;	O
grad_unlock_file	(int,long,long,int)->(void)
(	O
fd	int
,	O
sizeof	O
(	O
sid	struct(int,char)
)	O
,	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
id_offset	long
,	O
SEEK_SET	int
)	O
;	O
}	O
else	O
{	O
off_t	long
off	long
=	O
0	int
;	O
lseek	(int,long,int)->(long)
(	O
fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
grad_lock_file	(int,long,long,int)->(void)
(	O
fd	int
,	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
+	O
sizeof	O
(	O
sid	struct(int,char)
)	O
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
while	O
(	O
read	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
&	O
sid	struct(int,char)
,	O
sizeof	O
(	O
sid	struct(int,char)
)	O
)	O
==	O
sizeof	O
(	O
sid	struct(int,char)
)	O
)	O
{	O
if	O
(	O
sid	struct(int,char)
.	O
addr	int
==	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
addr	int
)	O
{	O
id	char
=	O
sid	struct(int,char)
.	O
id	char
++	O
;	O
lseek	(int,long,int)->(long)
(	O
fd	int
,	O
off	long
,	O
SEEK_SET	int
)	O
;	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
&	O
sid	struct(int,char)
,	O
sizeof	O
(	O
sid	struct(int,char)
)	O
)	O
;	O
break	O
;	O
}	O
off	long
+=	O
sizeof	O
(	O
sid	struct(int,char)
)	O
;	O
}	O
if	O
(	O
off	long
==	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
{	O
sid	struct(int,char)
.	O
addr	int
=	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
addr	int
;	O
sid	struct(int,char)
.	O
id	char
=	O
1	int
;	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
&	O
sid	struct(int,char)
,	O
sizeof	O
(	O
sid	struct(int,char)
)	O
)	O
;	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
id_offset	long
=	O
off	long
;	O
id	char
=	O
0	int
;	O
}	O
grad_unlock_file	(int,long,long,int)->(void)
(	O
fd	int
,	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
+	O
sizeof	O
(	O
sid	struct(int,char)
)	O
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
}	O
else	O
{	O
id	char
=	O
random	()->(long)
(	O
)	O
%	O
256	int
;	O
}	O
return	O
id	char
;	O
}	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
grad_client_recv	(int,short,*(char),*(char),*(char),int)->(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
(	O
grad_uint32_t	int
host	int
,	O
u_short	short
udp_port	short
,	O
char	O
*	O
secret	*(char)
,	O
char	O
*	O
authenticator	array(char)
,	O
char	O
*	O
buffer	*(char)
,	O
int	O
length	short
)	O
{	O
grad_packet_header_t	struct(char,char,short,array(char))
*	O
auth	*(struct(char,char,short,array(char)))
;	O
int	O
totallen	int
;	O
u_char	char
reply_digest	array(char)
[	O
GRAD_AUTHENTICATOR_LENGTH	int
]	O
;	O
u_char	char
calc_digest	array(char)
[	O
GRAD_AUTHENTICATOR_LENGTH	int
]	O
;	O
int	O
secretlen	int
;	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
;	O
auth	*(struct(char,char,short,array(char)))
=	O
(	O
grad_packet_header_t	struct(char,char,short,array(char))
*	O
)	O
buffer	*(char)
;	O
totallen	int
=	O
ntohs	(short)->(short)
(	O
auth	*(struct(char,char,short,array(char)))
->	O
length	short
)	O
;	O
if	O
(	O
totallen	int
!=	O
length	short
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"Actual request length does not match reported length (%d, %d)"	*(char)
)	O
,	O
totallen	int
,	O
length	short
)	O
;	O
return	O
NULL	O
;	O
}	O
secretlen	int
=	O
strlen	(*(char))->(long)
(	O
secret	*(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
reply_digest	array(char)
,	O
auth	*(struct(char,char,short,array(char)))
->	O
authenticator	array(char)
,	O
GRAD_AUTHENTICATOR_LENGTH	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
auth	*(struct(char,char,short,array(char)))
->	O
authenticator	array(char)
,	O
authenticator	array(char)
,	O
GRAD_AUTHENTICATOR_LENGTH	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buffer	*(char)
+	O
length	short
,	O
secret	*(char)
,	O
secretlen	int
)	O
;	O
grad_md5_calc	()->(int)
(	O
calc_digest	array(char)
,	O
(	O
unsigned	O
char	O
*	O
)	O
auth	*(struct(char,char,short,array(char)))
,	O
length	short
+	O
secretlen	int
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"received %s"	*(char)
,	O
grad_request_code_to_name	(int)->(*(char))
(	O
auth	*(struct(char,char,short,array(char)))
->	O
code	char
)	O
)	O
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
reply_digest	array(char)
,	O
calc_digest	array(char)
,	O
GRAD_AUTHENTICATOR_LENGTH	int
)	O
!=	O
0	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_WARN	int
,	O
_	O
(	O
"Received invalid reply digest from server"	*(char)
)	O
)	O
;	O
}	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
=	O
grad_decode_pdu	(int,short,*(char),long)->(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
(	O
host	int
,	O
udp_port	short
,	O
buffer	*(char)
,	O
length	short
)	O
;	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
secret	*(char)
=	O
secret	*(char)
;	O
return	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
;	O
}	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
grad_client_encrypt_pairlist	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),*(char))->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
plist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
u_char	char
*	O
authenticator	array(char)
,	O
u_char	char
*	O
secret	*(char)
)	O
{	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
p	*(struct)
;	O
for	O
(	O
p	*(struct)
=	O
plist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
p	*(struct)
;	O
p	*(struct)
=	O
p	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
if	O
(	O
p	*(struct)
->	O
prop	int
&	O
GRAD_AP_ENCRYPT_RFC2138	int
)	O
{	O
char	O
*	O
pass	*(char)
=	O
p	*(struct)
->	O
avp_strvalue	O
;	O
grad_encrypt_password	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),*(char),*(char))->(void)
(	O
p	*(struct)
,	O
pass	*(char)
,	O
authenticator	array(char)
,	O
secret	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
pass	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
p	*(struct)
->	O
prop	int
&	O
GRAD_AP_ENCRYPT_RFC2868	int
)	O
{	O
char	O
*	O
pass	*(char)
=	O
p	*(struct)
->	O
avp_strvalue	O
;	O
grad_encrypt_tunnel_password	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),char,*(char),*(char),*(char))->(void)
(	O
p	*(struct)
,	O
0	int
,	O
pass	*(char)
,	O
authenticator	array(char)
,	O
secret	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
pass	*(char)
)	O
;	O
}	O
}	O
return	O
plist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
}	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
grad_client_decrypt_pairlist	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),*(char))->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
plist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
u_char	char
*	O
authenticator	array(char)
,	O
u_char	char
*	O
secret	*(char)
)	O
{	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
p	*(struct)
;	O
char	O
password	*(char)
[	O
GRAD_STRING_LENGTH	int
+	O
1	int
]	O
;	O
for	O
(	O
p	*(struct)
=	O
plist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
p	*(struct)
;	O
p	*(struct)
=	O
p	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
if	O
(	O
p	*(struct)
->	O
prop	int
&	O
GRAD_AP_ENCRYPT_RFC2138	int
)	O
{	O
grad_decrypt_password	(*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),*(char))->(void)
(	O
password	*(char)
,	O
p	*(struct)
,	O
authenticator	array(char)
,	O
secret	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
p	*(struct)
->	O
avp_strvalue	O
)	O
;	O
p	*(struct)
->	O
avp_strvalue	O
=	O
grad_estrdup	(*(char))->(*(char))
(	O
password	*(char)
)	O
;	O
p	*(struct)
->	O
avp_strlength	O
=	O
strlen	(*(char))->(long)
(	O
p	*(struct)
->	O
avp_strvalue	O
)	O
;	O
}	O
else	O
if	O
(	O
p	*(struct)
->	O
prop	int
&	O
GRAD_AP_ENCRYPT_RFC2868	int
)	O
{	O
u_char	char
tag	char
;	O
grad_decrypt_tunnel_password	(*(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),*(char))->(void)
(	O
password	*(char)
,	O
&	O
tag	char
,	O
p	*(struct)
,	O
authenticator	array(char)
,	O
secret	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
p	*(struct)
->	O
avp_strvalue	O
)	O
;	O
p	*(struct)
->	O
avp_strvalue	O
=	O
grad_estrdup	(*(char))->(*(char))
(	O
password	*(char)
)	O
;	O
p	*(struct)
->	O
avp_strlength	O
=	O
strlen	(*(char))->(long)
(	O
p	*(struct)
->	O
avp_strvalue	O
)	O
;	O
}	O
}	O
return	O
plist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
}	O
static	O
int	O
wait_for_reply	(int,int)->(int)
(	O
int	O
fd	int
,	O
unsigned	O
timeout	int
)	O
{	O
fd_set	struct(array(long))
readfds	struct(array(long))
;	O
struct	O
timeval	struct(long,long)
start	*(struct(long,long))
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
gettimeofday	(*(struct(long,long)),*(void))->(int)
(	O
&	O
start	*(struct(long,long))
,	O
NULL	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tv_usec	long
=	O
0L	int
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tv_sec	long
=	O
(	O
long	O
)	O
timeout	int
;	O
FD_ZERO	O
(	O
&	O
readfds	struct(array(long))
)	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
readfds	struct(array(long))
)	O
;	O
if	O
(	O
grad_recompute_timeout	(*(struct(long,long)),*(struct(long,long)))->(int)
(	O
&	O
start	*(struct(long,long))
,	O
&	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
)	O
return	O
0	int
;	O
if	O
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
fd	int
+	O
1	int
,	O
&	O
readfds	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
{	O
GRAD_DEBUG	O
(	O
20	int
,	O
"select interrupted. retrying."	*(char)
)	O
;	O
continue	O
;	O
}	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"select() interrupted"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
return	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
readfds	struct(array(long))
)	O
;	O
}	O
return	O
1	int
;	O
}	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
grad_client_send0	(*(struct(int,int,int,long,*(struct))),int,int,*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int,*(int),*(char))->(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
(	O
grad_server_queue_t	struct(int,int,int,long,*(struct))
*	O
config	*(struct(int,int,int,long,*(struct)))
,	O
int	O
port_type	int
,	O
int	O
code	char
,	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pairlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
int	O
flags	int
,	O
int	O
*	O
authid	*(int)
,	O
u_char	char
*	O
authvec	*(char)
)	O
{	O
struct	O
sockaddr	struct(short,array(char))
salocal	struct(short,array(char))
;	O
struct	O
sockaddr	struct(short,array(char))
saremote	struct(short,array(char))
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
*	O
sin	*(struct(short,short,struct(int),array(char)))
;	O
int	O
sockfd	int
;	O
int	O
salen	int
;	O
int	O
i	int
;	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
=	O
NULL	O
;	O
grad_server_t	struct
*	O
server	*(struct(*(char),int,array(int),*(char),long))
;	O
char	O
ipbuf	array(char)
[	O
GRAD_IPV4_STRING_LENGTH	int
]	O
;	O
char	O
*	O
recv_buf	*(char)
;	O
grad_iterator_t	struct
*	O
itr	*((*(void),*(void))->(int))
;	O
int	O
id	char
;	O
if	O
(	O
port_type	int
<	O
0	int
||	O
port_type	int
>	O
2	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"invalid port type"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
sockfd	int
=	O
socket	(int,int,int)->(int)
(	O
PF_INET	int
,	O
SOCK_DGRAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sockfd	int
<	O
0	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"socket"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
sin	*(struct(short,short,struct(int),array(char)))
=	O
(	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
*	O
)	O
&	O
salocal	struct(short,array(char))
;	O
memset	(*(void),int,long)->(*(void))
(	O
sin	*(struct(short,short,struct(int),array(char)))
,	O
0	int
,	O
sizeof	O
(	O
salocal	struct(short,array(char))
)	O
)	O
;	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_family	short
=	O
AF_INET	O
;	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_addr	struct(int)
.	O
s_addr	int
=	O
config	*(struct(int,int,int,long,*(struct)))
->	O
source_ip	int
?	O
htonl	(int)->(int)
(	O
config	*(struct(int,int,int,long,*(struct)))
->	O
source_ip	int
)	O
:	O
INADDR_ANY	O
;	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_port	short
=	O
0	int
;	O
if	O
(	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
sockfd	int
,	O
&	O
salocal	struct(short,array(char))
,	O
sizeof	O
(	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
)	O
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"bind"	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
sockfd	int
)	O
;	O
return	O
NULL	O
;	O
}	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"sending %s"	*(char)
,	O
grad_request_code_to_name	(int)->(*(char))
(	O
code	char
)	O
)	O
;	O
recv_buf	*(char)
=	O
grad_emalloc	(long)->(*(void))
(	O
config	*(struct(int,int,int,long,*(struct)))
->	O
buffer_size	long
)	O
;	O
itr	*((*(void),*(void))->(int))
=	O
grad_iterator_create	(*(struct))->(*(struct))
(	O
config	*(struct(int,int,int,long,*(struct)))
->	O
servers	*(struct)
)	O
;	O
server	*(struct(*(char),int,array(int),*(char),long))
=	O
grad_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
do	O
{	O
int	O
result	*(struct)
;	O
u_char	char
authenticator	array(char)
[	O
GRAD_AUTHENTICATOR_LENGTH	int
]	O
;	O
void	O
*	O
pdu	*(void)
;	O
size_t	long
size	int
;	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
if	O
(	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
port_type	int
]	O
<=	O
0	int
)	O
continue	O
;	O
GRAD_DEBUG2	O
(	O
10	int
,	O
"server %s:%d"	*(char)
,	O
grad_ip_iptostr	(int,*(char))->(*(char))
(	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
addr	int
,	O
ipbuf	array(char)
)	O
,	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
port_type	int
]	O
)	O
;	O
if	O
(	O
authid	*(int)
&&	O
(	O
flags	int
&	O
RADCLT_AUTHENTICATOR	int
)	O
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
authenticator	array(char)
,	O
authvec	*(char)
,	O
sizeof	O
authenticator	array(char)
)	O
;	O
else	O
grad_client_random_authenticator	(*(char))->(void)
(	O
authenticator	array(char)
)	O
;	O
if	O
(	O
authid	*(int)
&&	O
(	O
flags	int
&	O
RADCLT_ID	int
)	O
)	O
id	char
=	O
*	O
authid	*(int)
;	O
else	O
id	char
=	O
grad_client_message_id	(*(struct(*(char),int,array(int),*(char),long)))->(int)
(	O
server	*(struct(*(char),int,array(int),*(char),long))
)	O
;	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_client_encrypt_pairlist	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),*(char))->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
grad_avl_dup	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
pairlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
,	O
authenticator	array(char)
,	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
secret	*(char)
)	O
;	O
size	int
=	O
grad_create_pdu	(*(*(void)),int,int,*(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char))->(long)
(	O
&	O
pdu	*(void)
,	O
code	char
,	O
id	char
,	O
authenticator	array(char)
,	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
secret	*(char)
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
NULL	O
)	O
;	O
if	O
(	O
authid	*(int)
&&	O
!	O
(	O
flags	int
&	O
RADCLT_ID	int
)	O
)	O
*	O
authid	*(int)
=	O
id	char
;	O
if	O
(	O
authvec	*(char)
&&	O
!	O
(	O
flags	int
&	O
RADCLT_AUTHENTICATOR	int
)	O
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
authvec	*(char)
,	O
authenticator	array(char)
,	O
sizeof	O
authenticator	array(char)
)	O
;	O
grad_avl_free	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
if	O
(	O
size	int
<=	O
0	int
)	O
break	O
;	O
sin	*(struct(short,short,struct(int),array(char)))
=	O
(	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
*	O
)	O
&	O
saremote	struct(short,array(char))
;	O
memset	(*(void),int,long)->(*(void))
(	O
sin	*(struct(short,short,struct(int),array(char)))
,	O
0	int
,	O
sizeof	O
(	O
saremote	struct(short,array(char))
)	O
)	O
;	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_family	short
=	O
AF_INET	O
;	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_addr	struct(int)
.	O
s_addr	int
=	O
htonl	(int)->(int)
(	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
addr	int
)	O
;	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_port	short
=	O
htons	(short)->(short)
(	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
port_type	int
]	O
)	O
;	O
GRAD_DEBUG2	O
(	O
10	int
,	O
"sending request (timeout=%u, retries=%u)"	*(char)
,	O
config	*(struct(int,int,int,long,*(struct)))
->	O
timeout	int
,	O
config	*(struct(int,int,int,long,*(struct)))
->	O
retries	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
config	*(struct(int,int,int,long,*(struct)))
->	O
retries	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
)	O
GRAD_DEBUG	O
(	O
10	int
,	O
"no response. retrying."	*(char)
)	O
;	O
if	O
(	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
sockfd	int
,	O
pdu	*(void)
,	O
size	int
,	O
0	int
,	O
&	O
saremote	struct(short,array(char))
,	O
sizeof	O
(	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
)	O
)	O
==	O
-	O
1	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"sendto"	*(char)
)	O
;	O
}	O
salen	int
=	O
sizeof	O
(	O
saremote	struct(short,array(char))
)	O
;	O
if	O
(	O
wait_for_reply	(int,int)->(int)
(	O
sockfd	int
,	O
config	*(struct(int,int,int,long,*(struct)))
->	O
timeout	int
)	O
)	O
{	O
result	*(struct)
=	O
recvfrom	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(long)
(	O
sockfd	int
,	O
recv_buf	*(char)
,	O
config	*(struct(int,int,int,long,*(struct)))
->	O
buffer_size	long
,	O
0	int
,	O
&	O
saremote	struct(short,array(char))
,	O
&	O
salen	int
)	O
;	O
if	O
(	O
result	*(struct)
>	O
0	int
)	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
=	O
grad_client_recv	(int,short,*(char),*(char),*(char),int)->(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
(	O
ntohl	(int)->(int)
(	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_addr	struct(int)
.	O
s_addr	int
)	O
,	O
ntohs	(short)->(short)
(	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_port	short
)	O
,	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
secret	*(char)
,	O
authenticator	array(char)
,	O
recv_buf	*(char)
,	O
result	*(struct)
)	O
;	O
else	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"error receiving data from %s:%d"	*(char)
)	O
,	O
grad_ip_iptostr	(int,*(char))->(*(char))
(	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
addr	int
,	O
ipbuf	array(char)
)	O
,	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
port_type	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
grad_free	(*(void))->(void)
(	O
pdu	*(void)
)	O
;	O
if	O
(	O
!	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
GRAD_DEBUG2	O
(	O
10	int
,	O
"no reply from %s:%d"	*(char)
,	O
grad_ip_iptostr	(int,*(char))->(*(char))
(	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
addr	int
,	O
ipbuf	array(char)
)	O
,	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
port_type	int
]	O
)	O
;	O
}	O
while	O
(	O
!	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
&&	O
(	O
server	*(struct(*(char),int,array(int),*(char),long))
=	O
grad_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
!=	O
NULL	O
)	O
;	O
grad_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
grad_free	(*(void))->(void)
(	O
recv_buf	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
sockfd	int
)	O
;	O
return	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
;	O
}	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
grad_client_send	(*(struct(int,int,int,long,*(struct))),int,int,*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
(	O
grad_server_queue_t	struct(int,int,int,long,*(struct))
*	O
config	*(struct(int,int,int,long,*(struct)))
,	O
int	O
port_type	int
,	O
int	O
code	char
,	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pairlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
return	O
grad_client_send0	(*(struct(int,int,int,long,*(struct))),int,int,*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int,*(int),*(char))->(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
(	O
config	*(struct(int,int,int,long,*(struct)))
,	O
port_type	int
,	O
code	char
,	O
pairlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
static	O
grad_keyword_t	struct
kwd	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"source_ip"	*(char)
,	O
TOK_SOURCE_IP	int
}	O
,	O
{	O
"source-ip"	*(char)
,	O
TOK_SOURCE_IP	int
}	O
,	O
{	O
"server"	*(char)
,	O
TOK_SERVER	int
}	O
,	O
{	O
"timeout"	*(char)
,	O
TOK_TIMEOUT	int
}	O
,	O
{	O
"retry"	*(char)
,	O
TOK_RETRY	int
}	O
,	O
{	O
"debug"	*(char)
,	O
TOK_DEBUG	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
parse_client_config	(*(void),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
void	O
*	O
closure	*(void)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
grad_server_queue_t	struct(int,int,int,long,*(struct))
*	O
client	*(struct(int,int,int,long,*(struct)))
=	O
closure	*(void)
;	O
char	O
*	O
p	*(struct)
;	O
grad_server_t	struct
serv	struct(*(char),int,array(int),*(char),long)
;	O
int	O
i	int
;	O
switch	O
(	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
kwd	array(struct(*(char),int))
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
TOK_INVALID	int
)	O
)	O
{	O
case	O
TOK_INVALID	int
:	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"unknown keyword"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
TOK_SOURCE_IP	int
:	O
client	*(struct(int,int,int,long,*(struct)))
->	O
source_ip	int
=	O
grad_ip_gethostaddr	(*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
TOK_SERVER	int
:	O
if	O
(	O
argc	int
!=	O
6	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"wrong number of fields"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
serv	struct(*(char),int,array(int),*(char),long)
,	O
0	int
,	O
sizeof	O
serv	struct(*(char),int,array(int),*(char),long)
)	O
;	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
name	*(char)
=	O
argv	*(*(char))
[	O
1	int
]	O
;	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
addr	int
=	O
grad_ip_gethostaddr	(*(char))->(int)
(	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
if	O
(	O
!	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
addr	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"bad IP address or host name"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
secret	*(char)
=	O
argv	*(*(char))
[	O
3	int
]	O
;	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
port	array(int)
[	O
0	int
]	O
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
4	int
]	O
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"bad port number %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
4	int
]	O
)	O
;	O
break	O
;	O
}	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
port	array(int)
[	O
1	int
]	O
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
5	int
]	O
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"bad port number %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
4	int
]	O
)	O
;	O
break	O
;	O
}	O
grad_client_append_server	(*(struct(int,int,int,long,*(struct))),*(struct(*(char),int,array(int),*(char),long)))->(void)
(	O
client	*(struct(int,int,int,long,*(struct)))
,	O
grad_client_alloc_server	(*(struct(*(char),int,array(int),*(char),long)))->(*(struct(*(char),int,array(int),*(char),long)))
(	O
&	O
serv	struct(*(char),int,array(int),*(char),long)
)	O
)	O
;	O
break	O
;	O
case	O
TOK_TIMEOUT	int
:	O
client	*(struct(int,int,int,long,*(struct)))
->	O
timeout	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
)	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"bad timeout value"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
TOK_RETRY	int
:	O
client	*(struct(int,int,int,long,*(struct)))
->	O
retries	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
)	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"bad retry value"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
TOK_DEBUG	int
:	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
grad_set_debug_levels	(*(char))->(void)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
grad_server_queue_t	struct(int,int,int,long,*(struct))
*	O
grad_client_create_queue	(int,int,long)->(*(struct(int,int,int,long,*(struct))))
(	O
int	O
read_cfg	int
,	O
grad_uint32_t	int
source_ip	int
,	O
size_t	long
bufsize	long
)	O
{	O
grad_server_queue_t	struct(int,int,int,long,*(struct))
*	O
client	*(struct(int,int,int,long,*(struct)))
;	O
char	O
*	O
filename	*(char)
;	O
client	*(struct(int,int,int,long,*(struct)))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
*	O
client	*(struct(int,int,int,long,*(struct)))
)	O
;	O
client	*(struct(int,int,int,long,*(struct)))
->	O
source_ip	int
=	O
source_ip	int
;	O
client	*(struct(int,int,int,long,*(struct)))
->	O
timeout	int
=	O
1	int
;	O
client	*(struct(int,int,int,long,*(struct)))
->	O
retries	int
=	O
3	int
;	O
client	*(struct(int,int,int,long,*(struct)))
->	O
buffer_size	long
=	O
bufsize	long
?	O
bufsize	long
:	O
4096	int
;	O
client	*(struct(int,int,int,long,*(struct)))
->	O
servers	*(struct)
=	O
0	int
;	O
if	O
(	O
read_cfg	int
)	O
{	O
filename	*(char)
=	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
grad_config_dir	*(char)
,	O
"client.conf"	*(char)
)	O
;	O
grad_read_raddb_file	(*(char),int,*(char),*((*(void),int,*(*(char)),*(struct(*`,long)))->(int)),*(void))->(int)
(	O
filename	*(char)
,	O
1	int
,	O
NULL	O
,	O
parse_client_config	(*(void),int,*(*(char)),*(struct(*(char),long)))->(int)
,	O
client	*(struct(int,int,int,long,*(struct)))
)	O
;	O
grad_free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
}	O
return	O
client	*(struct(int,int,int,long,*(struct)))
;	O
}	O
void	O
grad_client_destroy_queue	(*(struct(int,int,int,long,*(struct))))->(void)
(	O
grad_server_queue_t	struct(int,int,int,long,*(struct))
*	O
queue	*(struct(int,int,int,long,*(struct)))
)	O
{	O
if	O
(	O
queue	*(struct(int,int,int,long,*(struct)))
)	O
{	O
grad_client_clear_server_list	(*(struct(int,int,int,long,*(struct))))->(void)
(	O
queue	*(struct(int,int,int,long,*(struct)))
)	O
;	O
grad_free	(*(void))->(void)
(	O
queue	*(struct(int,int,int,long,*(struct)))
)	O
;	O
}	O
}	O
grad_server_t	struct
*	O
grad_client_alloc_server	(*(struct(*(char),int,array(int),*(char),long)))->(*(struct(*(char),int,array(int),*(char),long)))
(	O
grad_server_t	struct
*	O
src	*(struct(*(char),int,array(int),*(char),long))
)	O
{	O
grad_server_t	struct
*	O
server	*(struct(*(char),int,array(int),*(char),long))
;	O
server	*(struct(*(char),int,array(int),*(char),long))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
server	*(struct(*(char),int,array(int),*(char),long))
)	O
)	O
;	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
name	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
src	*(struct(*(char),int,array(int),*(char),long))
->	O
name	*(char)
)	O
;	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
addr	int
=	O
src	*(struct(*(char),int,array(int),*(char),long))
->	O
addr	int
;	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
0	int
]	O
=	O
src	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
0	int
]	O
;	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
1	int
]	O
=	O
src	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
1	int
]	O
;	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
secret	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
src	*(struct(*(char),int,array(int),*(char),long))
->	O
secret	*(char)
)	O
;	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
id_offset	long
=	O
(	O
off_t	long
)	O
-	O
1	int
;	O
return	O
server	*(struct(*(char),int,array(int),*(char),long))
;	O
}	O
grad_server_t	struct
*	O
grad_client_dup_server	(*(struct(*(char),int,array(int),*(char),long)))->(*(struct(*(char),int,array(int),*(char),long)))
(	O
grad_server_t	struct
*	O
src	*(struct(*(char),int,array(int),*(char),long))
)	O
{	O
grad_server_t	struct
*	O
dest	*(struct(*(char),int,array(int),*(char),long))
;	O
dest	*(struct(*(char),int,array(int),*(char),long))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
dest	*(struct(*(char),int,array(int),*(char),long))
)	O
)	O
;	O
dest	*(struct(*(char),int,array(int),*(char),long))
->	O
addr	int
=	O
src	*(struct(*(char),int,array(int),*(char),long))
->	O
addr	int
;	O
dest	*(struct(*(char),int,array(int),*(char),long))
->	O
name	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
src	*(struct(*(char),int,array(int),*(char),long))
->	O
name	*(char)
)	O
;	O
dest	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
0	int
]	O
=	O
src	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
0	int
]	O
;	O
dest	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
1	int
]	O
=	O
src	*(struct(*(char),int,array(int),*(char),long))
->	O
port	array(int)
[	O
1	int
]	O
;	O
dest	*(struct(*(char),int,array(int),*(char),long))
->	O
secret	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
src	*(struct(*(char),int,array(int),*(char),long))
->	O
secret	*(char)
)	O
;	O
return	O
dest	*(struct(*(char),int,array(int),*(char),long))
;	O
}	O
void	O
grad_client_free_server	(*(struct(*(char),int,array(int),*(char),long)))->(void)
(	O
grad_server_t	struct
*	O
server	*(struct(*(char),int,array(int),*(char),long))
)	O
{	O
grad_free	(*(void))->(void)
(	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
name	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
secret	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
server	*(struct(*(char),int,array(int),*(char),long))
)	O
;	O
}	O
void	O
grad_client_append_server	(*(struct(int,int,int,long,*(struct))),*(struct(*(char),int,array(int),*(char),long)))->(void)
(	O
grad_server_queue_t	struct(int,int,int,long,*(struct))
*	O
qp	*(struct(int,int,int,long,*(struct)))
,	O
grad_server_t	struct
*	O
server	*(struct(*(char),int,array(int),*(char),long))
)	O
{	O
if	O
(	O
!	O
qp	*(struct(int,int,int,long,*(struct)))
->	O
servers	*(struct)
)	O
qp	*(struct(int,int,int,long,*(struct)))
->	O
servers	*(struct)
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
grad_list_append	(*(struct),*(void))->(void)
(	O
qp	*(struct(int,int,int,long,*(struct)))
->	O
servers	*(struct)
,	O
server	*(struct(*(char),int,array(int),*(char),long))
)	O
;	O
}	O
static	O
int	O
grad_client_internal_free_server	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
grad_server_t	struct
*	O
server	*(struct(*(char),int,array(int),*(char),long))
=	O
item	*(void)
;	O
grad_free	(*(void))->(void)
(	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
name	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
server	*(struct(*(char),int,array(int),*(char),long))
->	O
secret	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
server	*(struct(*(char),int,array(int),*(char),long))
)	O
;	O
return	O
0	int
;	O
}	O
void	O
grad_client_clear_server_list	(*(struct(int,int,int,long,*(struct))))->(void)
(	O
grad_server_queue_t	struct(int,int,int,long,*(struct))
*	O
qp	*(struct(int,int,int,long,*(struct)))
)	O
{	O
grad_list_destroy	(*(*(struct)),*((*(void),*(void))->(int)),*(void))->(void)
(	O
&	O
qp	*(struct(int,int,int,long,*(struct)))
->	O
servers	*(struct)
,	O
grad_client_internal_free_server	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
server_cmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
data	*(void)
)	O
{	O
const	O
grad_server_t	struct
*	O
serv	struct(*(char),int,array(int),*(char),long)
=	O
item	*(void)
;	O
const	O
char	O
*	O
id	char
=	O
data	*(void)
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
serv	struct(*(char),int,array(int),*(char),long)
->	O
name	*(char)
,	O
id	char
)	O
;	O
}	O
grad_server_t	struct
*	O
grad_client_find_server	(*(struct(int,int,int,long,*(struct))),*(char))->(*(struct(*(char),int,array(int),*(char),long)))
(	O
grad_server_queue_t	struct(int,int,int,long,*(struct))
*	O
qp	*(struct(int,int,int,long,*(struct)))
,	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
grad_list_locate	(*(struct),*(void),*((*(void),*(void))->(int)))->(*(void))
(	O
qp	*(struct(int,int,int,long,*(struct)))
->	O
servers	*(struct)
,	O
name	*(char)
,	O
server_cmp	(*(void),*(void))->(int)
)	O
;	O
}	O
