static	O
void	O
_fill_map	(int,*(char),*(struct(int,short,int,int,int)))->(void)
(	O
uint32_t	int
c	int
,	O
const	O
uint8_t	char
*	O
p	*(char)
,	O
IDNAMap	struct(int,short,int,int,int)
*	O
map	*(struct(int,short,int,int,int))
)	O
{	O
uint32_t	int
value	int
;	O
if	O
(	O
c	int
<=	O
0xFF	int
)	O
{	O
map	*(struct(int,short,int,int,int))
->	O
cp1	int
=	O
*	O
p	*(char)
++	O
;	O
map	*(struct(int,short,int,int,int))
->	O
range	short
=	O
*	O
p	*(char)
++	O
;	O
}	O
else	O
if	O
(	O
c	int
<=	O
0xFFFF	int
)	O
{	O
map	*(struct(int,short,int,int,int))
->	O
cp1	int
=	O
(	O
p	*(char)
[	O
0	int
]	O
<<	O
8	int
)	O
|	O
p	*(char)
[	O
1	int
]	O
;	O
map	*(struct(int,short,int,int,int))
->	O
range	short
=	O
(	O
p	*(char)
[	O
2	int
]	O
<<	O
8	int
)	O
|	O
p	*(char)
[	O
3	int
]	O
;	O
p	*(char)
+=	O
4	int
;	O
}	O
else	O
{	O
map	*(struct(int,short,int,int,int))
->	O
cp1	int
=	O
(	O
p	*(char)
[	O
0	int
]	O
<<	O
16	int
)	O
|	O
(	O
p	*(char)
[	O
1	int
]	O
<<	O
8	int
)	O
|	O
p	*(char)
[	O
2	int
]	O
;	O
map	*(struct(int,short,int,int,int))
->	O
range	short
=	O
(	O
p	*(char)
[	O
3	int
]	O
<<	O
8	int
)	O
|	O
p	*(char)
[	O
4	int
]	O
;	O
p	*(char)
+=	O
5	int
;	O
}	O
value	int
=	O
(	O
p	*(char)
[	O
0	int
]	O
<<	O
16	int
)	O
|	O
(	O
p	*(char)
[	O
1	int
]	O
<<	O
8	int
)	O
|	O
p	*(char)
[	O
2	int
]	O
;	O
map	*(struct(int,short,int,int,int))
->	O
flag_index	int
=	O
value	int
&	O
0x7	int
;	O
map	*(struct(int,short,int,int,int))
->	O
offset	int
=	O
(	O
value	int
>>	O
3	int
)	O
&	O
0x3FFF	int
;	O
map	*(struct(int,short,int,int,int))
->	O
nmappings	int
=	O
(	O
value	int
>>	O
17	int
)	O
&	O
0x1F	int
;	O
}	O
static	O
int	O
_compare_idna_map	(*(int),*(char))->(int)
(	O
const	O
uint32_t	int
*	O
c	int
,	O
const	O
uint8_t	char
*	O
p	*(char)
)	O
{	O
IDNAMap	struct(int,short,int,int,int)
map	*(struct(int,short,int,int,int))
;	O
_fill_map	(int,*(char),*(struct(int,short,int,int,int)))->(void)
(	O
*	O
c	int
,	O
p	*(char)
,	O
&	O
map	*(struct(int,short,int,int,int))
)	O
;	O
if	O
(	O
*	O
c	int
<	O
map	*(struct(int,short,int,int,int))
.	O
cp1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
c	int
>	O
map	*(struct(int,short,int,int,int))
.	O
cp1	int
+	O
map	*(struct(int,short,int,int,int))
.	O
range	short
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
get_idna_map	(int,*(struct(int,short,int,int,int)))->(int)
(	O
uint32_t	int
c	int
,	O
IDNAMap	struct(int,short,int,int,int)
*	O
map	*(struct(int,short,int,int,int))
)	O
{	O
uint8_t	char
*	O
p	*(char)
;	O
if	O
(	O
c	int
<=	O
0xFF	int
)	O
p	*(char)
=	O
(	O
uint8_t	char
*	O
)	O
bsearch	(*(void),*(void),long,long,*((*(void),*(void))->(int)))->(*(void))
(	O
&	O
c	int
,	O
idna_map_8	array(char)
,	O
sizeof	O
(	O
idna_map_8	array(char)
)	O
/	O
5	int
,	O
5	int
,	O
(	O
int	O
(	O
*	O
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
_compare_idna_map	(*(int),*(char))->(int)
)	O
;	O
else	O
if	O
(	O
c	int
<=	O
0xFFFF	int
)	O
p	*(char)
=	O
(	O
uint8_t	char
*	O
)	O
bsearch	(*(void),*(void),long,long,*((*(void),*(void))->(int)))->(*(void))
(	O
&	O
c	int
,	O
idna_map_16	array(char)
,	O
sizeof	O
(	O
idna_map_16	array(char)
)	O
/	O
7	int
,	O
7	int
,	O
(	O
int	O
(	O
*	O
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
_compare_idna_map	(*(int),*(char))->(int)
)	O
;	O
else	O
if	O
(	O
c	int
<=	O
0xFFFFFF	int
)	O
p	*(char)
=	O
(	O
uint8_t	char
*	O
)	O
bsearch	(*(void),*(void),long,long,*((*(void),*(void))->(int)))->(*(void))
(	O
&	O
c	int
,	O
idna_map_24	array(char)
,	O
sizeof	O
(	O
idna_map_24	array(char)
)	O
/	O
8	int
,	O
8	int
,	O
(	O
int	O
(	O
*	O
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
_compare_idna_map	(*(int),*(char))->(int)
)	O
;	O
else	O
p	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
map	*(struct(int,short,int,int,int))
,	O
0	int
,	O
sizeof	O
(	O
IDNAMap	struct(int,short,int,int,int)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
_fill_map	(int,*(char),*(struct(int,short,int,int,int)))->(void)
(	O
c	int
,	O
p	*(char)
,	O
map	*(struct(int,short,int,int,int))
)	O
;	O
return	O
0	int
;	O
}	O
int	O
map_is	(*(struct(int,short,int,int,int)),int)->(int)
(	O
const	O
IDNAMap	struct(int,short,int,int,int)
*	O
map	*(struct(int,short,int,int,int))
,	O
unsigned	O
flags	int
)	O
{	O
return	O
(	O
idna_flags	array(char)
[	O
map	*(struct(int,short,int,int,int))
->	O
flag_index	int
]	O
&	O
flags	int
)	O
==	O
flags	int
;	O
}	O
static	O
int	O
G_GNUC_IDN2_ATTRIBUTE_PURE	O
_compare_nfcqc_map	(*(int),*(struct(int,int,char)))->(int)
(	O
uint32_t	int
*	O
c	int
,	O
NFCQCMap	struct(int,int,char)
*	O
m2	*(struct(int,int,char))
)	O
{	O
if	O
(	O
*	O
c	int
<	O
m2	*(struct(int,int,char))
->	O
cp1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
c	int
>	O
m2	*(struct(int,int,char))
->	O
cp2	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
NFCQCMap	struct(int,int,char)
*	O
get_nfcqc_map	(int)->(*(struct(int,int,char)))
(	O
uint32_t	int
c	int
)	O
{	O
return	O
(	O
NFCQCMap	struct(int,int,char)
*	O
)	O
bsearch	(*(void),*(void),long,long,*((*(void),*(void))->(int)))->(*(void))
(	O
&	O
c	int
,	O
nfcqc_map	array(struct(int,int,char))
,	O
countof	O
(	O
nfcqc_map	array(struct(int,int,char))
)	O
,	O
sizeof	O
(	O
NFCQCMap	struct(int,int,char)
)	O
,	O
(	O
int	O
(	O
*	O
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
_compare_nfcqc_map	(*(int),*(struct(int,int,char)))->(int)
)	O
;	O
}	O
int	O
get_map_data	(*(int),*(struct(int,short,int,int,int)))->(int)
(	O
uint32_t	int
*	O
dst	*(int)
,	O
const	O
IDNAMap	struct(int,short,int,int,int)
*	O
map	*(struct(int,short,int,int,int))
)	O
{	O
int	O
n	int
=	O
map	*(struct(int,short,int,int,int))
->	O
nmappings	int
;	O
const	O
uint8_t	char
*	O
src	*(char)
=	O
mapdata	array(char)
+	O
map	*(struct(int,short,int,int,int))
->	O
offset	int
;	O
for	O
(	O
;	O
n	int
>	O
0	int
;	O
n	int
--	O
)	O
{	O
uint32_t	int
cp	int
=	O
0	int
;	O
do	O
cp	int
=	O
(	O
cp	int
<<	O
7	int
)	O
|	O
(	O
*	O
src	*(char)
&	O
0x7F	int
)	O
;	O
while	O
(	O
*	O
src	*(char)
++	O
&	O
0x80	int
)	O
;	O
*	O
dst	*(int)
++	O
=	O
cp	int
;	O
}	O
return	O
map	*(struct(int,short,int,int,int))
->	O
nmappings	int
;	O
}	O
