int	O
verbose	int
;	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
;	O
int	O
nifs	int
;	O
static	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
ifconfig_initializer	struct(*(char),int,*(struct(int,int)),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
=	O
{	O
NULL	O
,	O
0	int
,	O
}	O
;	O
struct	O
format	*(char)
formats	array(struct(*(char),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"default"	*(char)
,	O
"Default format.  Equivalent to \"gnu\"."	*(char)
,	O
"${format}{gnu}"	*(char)
}	O
,	O
{	O
"gnu"	*(char)
,	O
"Standard GNU output format."	*(char)
,	O
"${first?}{}{${\\n}}${format}{gnu-one-entry}"	*(char)
}	O
,	O
{	O
"gnu-one-entry"	*(char)
,	O
"Same as GNU, but without additional newlines between the entries."	*(char)
,	O
"${format}{check-existence}"	*(char)
"${ifdisplay?}{"	*(char)
"${name} (${index}):${\\n}"	*(char)
"${addr?}{  inet address ${tab}{16}${addr}${\\n}}"	*(char)
"${netmask?}{  netmask ${tab}{16}${netmask}${\\n}}"	*(char)
"${brdaddr?}{  broadcast ${tab}{16}${brdaddr}${\\n}}"	*(char)
"${dstaddr?}{  peer address ${tab}{16}${dstaddr}${\\n}}"	*(char)
"${flags?}{  flags ${tab}{16}${flags}${\\n}}"	*(char)
"${mtu?}{  mtu ${tab}{16}${mtu}${\\n}}"	*(char)
"${metric?}{  metric ${tab}{16}${metric}${\\n}}"	*(char)
"${exists?}{hwtype?}{${hwtype?}{  link encap ${tab}{16}${hwtype}${\\n}}}"	*(char)
"${exists?}{hwaddr?}{${hwaddr?}{  hardware addr ${tab}{16}${hwaddr}${\\n}}}"	*(char)
"${exists?}{txqlen?}{${txqlen?}{  tx queue len ${tab}{16}${txqlen}${\\n}}}"	*(char)
"}"	*(char)
}	O
,	O
{	O
"net-tools"	*(char)
,	O
"Similar to the output of net-tools.  Default for GNU/Linux."	*(char)
,	O
"${format}{check-existence}"	*(char)
"${ifdisplay?}{"	*(char)
"${name}${exists?}{hwtype?}{${hwtype?}{${tab}{10}Link encap:${hwtype}}"	*(char)
"${hwaddr?}{  HWaddr ${hwaddr}}}${\\n}"	*(char)
"${addr?}{${tab}{10}inet addr:${addr}"	*(char)
"${brdaddr?}{  Bcast:${brdaddr}}"	*(char)
"${netmask?}{  Mask:${netmask}}"	*(char)
"${newline}}"	*(char)
"${tab}{10}${flags}"	*(char)
"${mtu?}{  MTU:${mtu}}"	*(char)
"${metric?}{  Metric:${metric}}"	*(char)
"${exists?}{ifstat?}{"	*(char)
"${ifstat?}{"	*(char)
"${newline}          RX packets:${rxpackets}"	*(char)
" errors:${rxerrors} dropped:${rxdropped} overruns:${rxfifoerr}"	*(char)
" frame:${rxframeerr}"	*(char)
"${newline}          TX packets:${txpackets}"	*(char)
" errors:${txerrors} dropped:${txdropped} overruns:${txfifoerr}"	*(char)
" carrier:${txcarrier}"	*(char)
"${newline}"	*(char)
"          collisions:${collisions}"	*(char)
"${exists?}{txqlen?}{${txqlen?}{ txqueuelen:${txqlen}}}"	*(char)
"${newline}"	*(char)
"          RX bytes:${rxbytes}  TX bytes:${txbytes}"	*(char)
"}}{"	*(char)
"${newline}"	*(char)
"${exists?}{txqlen?}{${txqlen?}{ ${tab}{10}txqueuelen:${txqlen}}${\\n}}}"	*(char)
"${newline}"	*(char)
"${exists?}{map?}{${map?}{${irq?}{"	*(char)
"          Interrupt:${irq}"	*(char)
"${baseaddr?}{ Base address:0x${baseaddr}{%x}}"	*(char)
"${memstart?}{ Memory:${memstart}{%lx}-${memend}{%lx}}"	*(char)
"${dma?}{ DMA chan:${dma}{%x}}"	*(char)
"${newline}"	*(char)
"}}}"	*(char)
"${newline}"	*(char)
"}"	*(char)
}	O
,	O
{	O
"netstat"	*(char)
,	O
"Terse output, similar to that of \"netstat -i\"."	*(char)
,	O
"${first?}{Iface    MTU Met    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg${newline}}"	*(char)
"${format}{check-existence}"	*(char)
"${name}${tab}{6}${mtu}{%6d} ${metric}{%3d}"	*(char)
"${ifstat?}{"	*(char)
" ${rxpackets}{%8lu} ${rxerrors}{%6lu} ${rxdropped}{%6lu} ${rxfifoerr}{%6lu}"	*(char)
" ${txpackets}{%8lu} ${txerrors}{%6lu} ${txdropped}{%6lu} ${txfifoerr}{%6lu}"	*(char)
"}{   - no statistics available -}"	*(char)
"${tab}{76} ${flags?}{${flags}{short}}{[NO FLAGS]}"	*(char)
"${newline}"	*(char)
}	O
,	O
{	O
"unix"	*(char)
,	O
"Traditional UNIX interface listing.  Default for Solaris and HPUX."	*(char)
,	O
"${format}{check-existence}"	*(char)
"${ifdisplay?}{"	*(char)
"${name}: flags=${flags}{number}{%hx}<${flags}{string}{,}>"	*(char)
"${mtu?}{ mtu ${mtu}}${\\n}"	*(char)
"${addr?}{${\\t}inet ${addr}"	*(char)
" netmask ${netmask}{0}{%#02x}${netmask}{1}{%02x}"	*(char)
"${netmask}{2}{%02x}${netmask}{3}{%02x}"	*(char)
"${brdaddr?}{ broadcast ${brdaddr}}${\\n}}"	*(char)
"${exists?}{hwtype?}{${hwtype?}{${\\t}${hwtype}"	*(char)
"}${exists?}{hwaddr?}{${hwaddr?}{ ${hwaddr}}}${\\n}}"	*(char)
"}"	*(char)
}	O
,	O
{	O
"osf"	*(char)
,	O
"OSF-style output."	*(char)
,	O
"${format}{check-existence}"	*(char)
"${ifdisplay?}{"	*(char)
"${name}: flags=${flags}{number}{%x}<${flags}{string}{,}>${\\n}"	*(char)
"${addr?}{${\\t}inet ${addr}"	*(char)
" netmask ${netmask}{0}{%02x}${netmask}{1}{%02x}"	*(char)
"${netmask}{2}{%02x}${netmask}{3}{%02x}"	*(char)
"${brdaddr?}{ broadcast ${brdaddr}}"	*(char)
"${mtu?}{ ipmtu ${mtu}}${\\n}}"	*(char)
"}"	*(char)
}	O
,	O
{	O
"check-existence"	*(char)
,	O
"If interface does not exist, print error message and exit."	*(char)
,	O
"${index?}{}"	*(char)
"{${error}{${progname}: error: interface `${name}' does not exist${\\n}}"	*(char)
"${exit}{1}}"	*(char)
}	O
,	O
{	O
"help"	*(char)
,	O
"Display this help output."	*(char)
,	O
"${foreachformat}{"	*(char)
"${name}:${tab}{17}${docstr}"	*(char)
"${verbose?}{"	*(char)
"${newline}"	*(char)
"${rep}{79}{-}"	*(char)
"${newline}"	*(char)
"${defn}"	*(char)
"${newline}"	*(char)
"}"	*(char)
"${newline}"	*(char)
"}"	*(char)
"${exit}{0}"	*(char)
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
const	O
char	O
*	O
default_format	*(char)
;	O
int	O
all_option	int
;	O
int	O
ifs_cmdline	int
;	O
enum	O
{	O
METRIC_OPTION	int
=	O
256	int
,	O
FORMAT_OPTION	int
,	O
UP_OPTION	int
,	O
DOWN_OPTION	int
,	O
}	O
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
argp_options	array(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
"verbose"	*(char)
,	O
'v'	O
,	O
NULL	O
,	O
0	int
,	O
"output information when configuring interface"	*(char)
}	O
,	O
{	O
"all"	*(char)
,	O
'a'	O
,	O
NULL	O
,	O
0	int
,	O
"display all available interfaces"	*(char)
}	O
,	O
{	O
"interface"	*(char)
,	O
'i'	O
,	O
"NAME"	*(char)
,	O
0	int
,	O
"configure network interface NAME"	*(char)
}	O
,	O
{	O
"address"	*(char)
,	O
'A'	O
,	O
"ADDR"	*(char)
,	O
0	int
,	O
"set interface address to ADDR"	*(char)
}	O
,	O
{	O
"netmask"	*(char)
,	O
'm'	O
,	O
"MASK"	*(char)
,	O
0	int
,	O
"set netmask to MASK"	*(char)
}	O
,	O
{	O
"dstaddr"	*(char)
,	O
'd'	O
,	O
"ADDR"	*(char)
,	O
0	int
,	O
"set destination (peer) address to ADDR"	*(char)
}	O
,	O
{	O
"peer"	*(char)
,	O
'p'	O
,	O
"ADDR"	*(char)
,	O
OPTION_ALIAS	int
}	O
,	O
{	O
"broadcast"	*(char)
,	O
'B'	O
,	O
"ADDR"	*(char)
,	O
0	int
,	O
"set broadcast address to ADDR"	*(char)
}	O
,	O
{	O
"brdaddr"	*(char)
,	O
'b'	O
,	O
NULL	O
,	O
OPTION_ALIAS	int
,	O
}	O
,	O
{	O
"mtu"	*(char)
,	O
'M'	O
,	O
"N"	*(char)
,	O
0	int
,	O
"set mtu of interface to N"	*(char)
}	O
,	O
{	O
"metric"	*(char)
,	O
METRIC_OPTION	int
,	O
"N"	*(char)
,	O
0	int
,	O
"set metric of interface to N"	*(char)
}	O
,	O
{	O
"format"	*(char)
,	O
FORMAT_OPTION	int
,	O
"FORMAT"	*(char)
,	O
0	int
,	O
"select output format (or set back to default)"	*(char)
}	O
,	O
{	O
"up"	*(char)
,	O
UP_OPTION	int
,	O
NULL	O
,	O
0	int
,	O
"activate the interface (default if address is given)"	*(char)
}	O
,	O
{	O
"down"	*(char)
,	O
DOWN_OPTION	int
,	O
NULL	O
,	O
0	int
,	O
"shut the interface down"	*(char)
}	O
,	O
{	O
"flags"	*(char)
,	O
'F'	O
,	O
"FLAG[,FLAG...]"	*(char)
,	O
0	int
,	O
"set interface flags"	*(char)
}	O
,	O
{	O
"short"	*(char)
,	O
's'	O
,	O
NULL	O
,	O
0	int
,	O
"short output format"	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
const	O
char	O
doc	*(char)
[	O
]	O
=	O
"Configure network interfaces."	*(char)
;	O
const	O
char	O
*	O
program_authors	array(*(char))
[	O
]	O
=	O
{	O
"Marcus Brinkmann"	*(char)
,	O
NULL	O
}	O
;	O
struct	O
format	*(char)
*	O
format_find	(*(char))->(*(struct(*(char),*(char),*(char))))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
format	*(char)
*	O
frm	*(struct(*(char),*(char),*(char)))
;	O
for	O
(	O
frm	*(struct(*(char),*(char),*(char)))
=	O
formats	array(struct(*(char),*(char),*(char)))
;	O
frm	*(struct(*(char),*(char),*(char)))
->	O
name	*(char)
;	O
frm	*(struct(*(char),*(char),*(char)))
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
frm	*(struct(*(char),*(char),*(char)))
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
frm	*(struct(*(char),*(char),*(char)))
;	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
parse_opt_new_ifs	(*(char))->(*(struct))
(	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
;	O
ifs_cmdline	int
=	O
1	int
;	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
=	O
realloc	(*(void),long)->(*(void))
(	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
++	O
nifs	int
*	O
sizeof	O
(	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
)	O
)	O
;	O
if	O
(	O
!	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't get memory for interface configuration"	*(char)
)	O
;	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
=	O
&	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
[	O
nifs	int
-	O
1	int
]	O
;	O
*	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
=	O
ifconfig_initializer	struct(*(char),int,*(struct(int,int)),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
;	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
name	*(char)
=	O
name	*(char)
;	O
return	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
;	O
}	O
PARSE_OPT_SET_ADDR	O
(	O
address	*(char)
,	O
address	*(char)
,	O
ADDR	O
)	O
PARSE_OPT_SET_ADDR	O
(	O
netmask	*(char)
,	O
netmask	*(char)
,	O
NETMASK	O
)	O
PARSE_OPT_SET_ADDR	O
(	O
dstaddr	*(char)
,	O
destination	O
/	O
peer	O
address	*(char)
,	O
DSTADDR	O
)	O
PARSE_OPT_SET_ADDR	O
(	O
brdaddr	*(char)
,	O
broadcast	O
address	*(char)
,	O
BRDADDR	O
)	O
PARSE_OPT_SET_INT	O
(	O
mtu	int
,	O
mtu	int
value	O
,	O
MTU	O
)	O
PARSE_OPT_SET_INT	O
(	O
metric	int
,	O
metric	int
value	O
,	O
METRIC	O
)	O
void	O
parse_opt_set_af	(*(struct(*(char),int,*(struct(int,int)),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),*(char))->(void)
(	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
char	O
*	O
af	short
)	O
{	O
if	O
(	O
!	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"no interface specified for address family `%s'"	*(char)
,	O
af	short
)	O
;	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
af	short
,	O
"inet"	*(char)
)	O
)	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
af	short
=	O
AF_INET	O
;	O
else	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"unknown address family `%s' for interface `%s': is not a number"	*(char)
,	O
af	short
,	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
name	*(char)
)	O
;	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
valid	int
|=	O
IF_VALID_AF	int
;	O
}	O
void	O
parse_opt_set_flag	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),int,int)->(void)
(	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
int	O
flag	int
,	O
int	O
rev	int
)	O
{	O
if	O
(	O
rev	int
)	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
clrflags	int
|=	O
flag	int
;	O
else	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
setflags	int
|=	O
flag	int
;	O
}	O
void	O
parse_opt_flag_list	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),*(char))->(void)
(	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
while	O
(	O
*	O
name	*(char)
)	O
{	O
int	O
mask	int
,	O
rev	int
;	O
char	O
*	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
name	*(char)
,	O
','	O
)	O
;	O
size_t	long
len	long
;	O
if	O
(	O
p	*(char)
)	O
len	long
=	O
p	*(char)
-	O
name	*(char)
;	O
else	O
len	long
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
if	O
(	O
(	O
mask	int
=	O
if_nametoflag	(*(char),long,*(int))->(int)
(	O
name	*(char)
,	O
len	long
,	O
&	O
rev	int
)	O
)	O
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"unknown flag %*.*s"	*(char)
,	O
len	long
,	O
len	long
,	O
name	*(char)
)	O
;	O
parse_opt_set_flag	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),int,int)->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
mask	int
,	O
rev	int
)	O
;	O
name	*(char)
+=	O
len	long
;	O
if	O
(	O
p	*(char)
)	O
name	*(char)
++	O
;	O
}	O
}	O
void	O
parse_opt_set_point_to_point	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),*(char))->(void)
(	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
char	O
*	O
addr	*(char)
)	O
{	O
parse_opt_set_dstaddr	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),*(char))->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
addr	*(char)
)	O
;	O
parse_opt_set_flag	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),int,int)->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
IFF_POINTOPOINT	int
,	O
0	int
)	O
;	O
}	O
void	O
parse_opt_set_default_format	(*(char))->(void)
(	O
const	O
char	O
*	O
format	*(char)
)	O
{	O
struct	O
format	*(char)
*	O
frm	*(struct(*(char),*(char),*(char)))
;	O
if	O
(	O
!	O
format	*(char)
)	O
format	*(char)
=	O
system_default_format	*(char)
?	O
system_default_format	*(char)
:	O
"default"	*(char)
;	O
for	O
(	O
frm	*(struct(*(char),*(char),*(char)))
=	O
formats	array(struct(*(char),*(char),*(char)))
;	O
frm	*(struct(*(char),*(char),*(char)))
->	O
name	*(char)
;	O
frm	*(struct(*(char),*(char),*(char)))
++	O
)	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
format	*(char)
,	O
frm	*(struct(*(char),*(char),*(char)))
->	O
name	*(char)
)	O
)	O
break	O
;	O
if	O
(	O
frm	*(struct(*(char),*(char),*(char)))
==	O
NULL	O
||	O
frm	*(struct(*(char),*(char),*(char)))
->	O
templ	*(char)
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"%s: unknown output format"	*(char)
,	O
format	*(char)
)	O
;	O
default_format	*(char)
=	O
frm	*(struct(*(char),*(char),*(char)))
->	O
templ	*(char)
;	O
}	O
static	O
int	O
is_comment_line	(*(char),long)->(int)
(	O
const	O
char	O
*	O
p	*(char)
,	O
size_t	long
len	long
)	O
{	O
while	O
(	O
len	long
--	O
)	O
{	O
int	O
c	char
=	O
*	O
p	*(char)
++	O
;	O
switch	O
(	O
c	char
)	O
{	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
continue	O
;	O
case	O
'#'	O
:	O
return	O
1	int
;	O
default	O
:	O
return	O
0	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
parse_opt_set_default_format_from_file	(*(char))->(void)
(	O
const	O
char	O
*	O
file	*(char)
)	O
{	O
static	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
buf	*(char)
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot open format file %s"	*(char)
,	O
file	*(char)
)	O
;	O
obstack_init	O
(	O
&	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
while	O
(	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
buf	*(char)
,	O
&	O
size	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
>	O
0	int
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
len	long
>=	O
1	int
&&	O
buf	*(char)
[	O
len	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
len	long
--	O
;	O
if	O
(	O
len	long
==	O
0	int
||	O
is_comment_line	(*(char),long)->(int)
(	O
buf	*(char)
,	O
len	long
)	O
)	O
continue	O
;	O
obstack_grow	O
(	O
&	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
buf	*(char)
,	O
len	long
)	O
;	O
}	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
obstack_1grow	O
(	O
&	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
0	int
)	O
;	O
default_format	*(char)
=	O
obstack_finish	O
(	O
&	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
void	O
parse_opt_finalize	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)))->(void)
(	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
)	O
{	O
if	O
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
&&	O
!	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
valid	int
)	O
{	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
valid	int
=	O
IF_VALID_FORMAT	int
;	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
format	*(char)
=	O
default_format	*(char)
;	O
}	O
}	O
static	O
error_t	int
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
=	O
*	O
(	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
*	O
)	O
state	*(int)
->	O
input	*(void)
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
ARGP_KEY_INIT	int
:	O
state	*(int)
->	O
child_inputs	*(*(void))
[	O
0	int
]	O
=	O
state	*(int)
->	O
input	*(void)
;	O
break	O
;	O
case	O
'i'	O
:	O
parse_opt_finalize	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)))->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
)	O
;	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
=	O
parse_opt_new_ifs	(*(char))->(*(struct))
(	O
arg	*(char)
)	O
;	O
*	O
(	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
*	O
)	O
state	*(int)
->	O
input	*(void)
=	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
;	O
break	O
;	O
case	O
'a'	O
:	O
all_option	int
=	O
1	int
;	O
break	O
;	O
case	O
'A'	O
:	O
parse_opt_set_address	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),*(char))->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
parse_opt_set_netmask	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),*(char))->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'p'	O
:	O
parse_opt_set_point_to_point	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),*(char))->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
case	O
'B'	O
:	O
parse_opt_set_brdaddr	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),*(char))->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
parse_opt_flag_list	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),*(char))->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
parse_opt_set_mtu	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),*(char))->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
parse_opt_set_default_format	(*(char))->(void)
(	O
"netstat"	*(char)
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
METRIC_OPTION	int
:	O
parse_opt_set_metric	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),*(char))->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
FORMAT_OPTION	int
:	O
if	O
(	O
arg	*(char)
&&	O
arg	*(char)
[	O
0	int
]	O
==	O
'@'	O
)	O
parse_opt_set_default_format_from_file	(*(char))->(void)
(	O
arg	*(char)
+	O
1	int
)	O
;	O
else	O
parse_opt_set_default_format	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
UP_OPTION	int
:	O
parse_opt_set_flag	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),int,int)->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
IFF_UP	int
|	O
IFF_RUNNING	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
DOWN_OPTION	int
:	O
parse_opt_set_flag	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)),int,int)->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
IFF_UP	int
,	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
default_help_filter	(int,*(char),*(void))->(*(char))
(	O
int	O
key	int
,	O
const	O
char	O
*	O
text	*(char)
,	O
void	O
*	O
input	*(void)
)	O
{	O
char	O
*	O
s	*(char)
;	O
switch	O
(	O
key	int
)	O
{	O
default	O
:	O
s	*(char)
=	O
(	O
char	O
*	O
)	O
text	*(char)
;	O
break	O
;	O
case	O
ARGP_KEY_HELP_EXTRA	int
:	O
s	*(char)
=	O
if_list_flags	(*(char))->(*(char))
(	O
"Known flags are: "	*(char)
)	O
;	O
}	O
return	O
s	*(char)
;	O
}	O
static	O
struct	O
argp_child	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(char),int)
argp_children	array(struct(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
[	O
2	int
]	O
;	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
argp_options	array(struct(*(char),int,*(char),int,*(char),int))
,	O
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
NULL	O
,	O
doc	*(char)
,	O
NULL	O
,	O
default_help_filter	(int,*(char),*(void))->(*(char))
}	O
;	O
static	O
int	O
cmp_if_name	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(void)
,	O
const	O
void	O
*	O
b	*(void)
)	O
{	O
const	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifa	*(struct(*(char),int,*(struct(int,int)),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
=	O
a	*(void)
;	O
const	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifb	*(struct(*(char),int,*(struct(int,int)),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
=	O
b	*(void)
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
ifa	*(struct(*(char),int,*(struct(int,int)),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
name	*(char)
,	O
ifb	*(struct(*(char),int,*(struct(int,int)),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
name	*(char)
)	O
;	O
}	O
void	O
parse_cmdline	(int,array(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
=	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
;	O
parse_opt_set_default_format	(*(char))->(void)
(	O
NULL	O
)	O
;	O
iu_argp_init	O
(	O
"ifconfig"	*(char)
,	O
program_authors	array(*(char))
)	O
;	O
argp_children	array(struct(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
[	O
0	int
]	O
=	O
system_argp_child	struct
;	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
.	O
children	*(struct)
=	O
argp_children	array(struct(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
;	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
.	O
args_doc	*(char)
=	O
system_help	*(char)
;	O
argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	int
,	O
argv	array(*(char))
,	O
ARGP_IN_ORDER	int
,	O
&	O
index	(*(char),int)->(*(char))
,	O
&	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
)	O
;	O
parse_opt_finalize	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)))->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
)	O
;	O
if	O
(	O
index	(*(char),int)->(*(char))
<	O
argc	int
)	O
{	O
if	O
(	O
!	O
system_parse_opt_rest	(*(*(struct(*(char),int,*(struct`),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))),int,array(*(char)))->(int)
(	O
&	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
argc	int
-	O
index	(*(char),int)->(*(char))
,	O
&	O
argv	array(*(char))
[	O
index	(*(char),int)->(*(char))
]	O
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"invalid arguments"	*(char)
)	O
;	O
parse_opt_finalize	(*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)))->(void)
(	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
)	O
;	O
}	O
if	O
(	O
!	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
)	O
{	O
struct	O
if_nameindex	struct(int,*(char))
*	O
ifnx	*(struct(int,*(char)))
,	O
*	O
ifnxp	*(struct(int,*(char)))
;	O
ifnx	*(struct(int,*(char)))
=	O
ifnxp	*(struct(int,*(char)))
=	O
system_if_nameindex	*(()->(*(struct(int,*(char)))))
(	O
)	O
;	O
if	O
(	O
!	O
ifnx	*(struct(int,*(char)))
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"could not get list of interfaces"	*(char)
)	O
;	O
while	O
(	O
ifnxp	*(struct(int,*(char)))
->	O
if_index	int
!=	O
0	int
||	O
ifnxp	*(struct(int,*(char)))
->	O
if_name	*(char)
!=	O
NULL	O
)	O
{	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
*	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
;	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
=	O
realloc	(*(void),long)->(*(void))
(	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
++	O
nifs	int
*	O
sizeof	O
(	O
struct	O
ifconfig	struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
)	O
)	O
;	O
if	O
(	O
!	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't get memory for interface configuration"	*(char)
)	O
;	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
=	O
&	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
[	O
nifs	int
-	O
1	int
]	O
;	O
*	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
=	O
ifconfig_initializer	struct(*(char),int,*(struct(int,int)),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int)
;	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
name	*(char)
=	O
ifnxp	*(struct(int,*(char)))
->	O
if_name	*(char)
;	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
valid	int
=	O
IF_VALID_FORMAT	int
;	O
ifp	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
->	O
format	*(char)
=	O
default_format	*(char)
;	O
ifnxp	*(struct(int,*(char)))
++	O
;	O
}	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
,	O
nifs	int
,	O
sizeof	O
(	O
ifs	*(struct(*(char),int,*(struct),*(char),short,*(char),*(char),*(char),*(char),int,int,int,int))
[	O
0	int
]	O
)	O
,	O
cmp_if_name	(*(void),*(void))->(int)
)	O
;	O
}	O
}	O
