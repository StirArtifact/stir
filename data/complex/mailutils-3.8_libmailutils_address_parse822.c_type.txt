static	O
int	O
str_append_n	(*(*(char)),*(char),long)->(int)
(	O
char	O
*	O
*	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
const	O
char	O
*	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
size_t	long
n	long
)	O
{	O
size_t	long
l	long
=	O
0	int
;	O
if	O
(	O
!	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
{	O
return	O
EOK	int
;	O
}	O
if	O
(	O
*	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
{	O
char	O
*	O
bigger	*(char)
;	O
l	long
=	O
strlen	(*(char))->(long)
(	O
*	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
bigger	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
*	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
l	long
+	O
n	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
bigger	*(char)
)	O
{	O
return	O
ENOMEM	int
;	O
}	O
*	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
bigger	*(char)
;	O
}	O
else	O
{	O
*	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
malloc	(long)->(*(void))
(	O
n	long
+	O
1	int
)	O
;	O
}	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
&	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
[	O
0	int
]	O
[	O
l	long
]	O
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
n	long
)	O
;	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
[	O
0	int
]	O
[	O
l	long
+	O
n	long
]	O
=	O
0	int
;	O
return	O
EOK	int
;	O
}	O
static	O
int	O
str_append	(*(*(char)),*(char))->(int)
(	O
char	O
*	O
*	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
const	O
char	O
*	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
{	O
if	O
(	O
!	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
return	O
0	int
;	O
return	O
str_append_n	(*(*(char)),*(char),long)->(int)
(	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
strlen	(*(char))->(long)
(	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
)	O
;	O
}	O
static	O
int	O
str_append_char	(*(*(char)),char)->(int)
(	O
char	O
*	O
*	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
char	O
c	char
)	O
{	O
return	O
str_append_n	(*(*(char)),*(char),long)->(int)
(	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
&	O
c	char
,	O
1	int
)	O
;	O
}	O
static	O
int	O
str_append_range	(*(*(char)),*(char),*(char))->(int)
(	O
char	O
*	O
*	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
const	O
char	O
*	O
b	*(char)
,	O
const	O
char	O
*	O
e	int
)	O
{	O
return	O
str_append_n	(*(*(char)),*(char),long)->(int)
(	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
b	*(char)
,	O
e	int
-	O
b	*(char)
)	O
;	O
}	O
static	O
void	O
str_free	(*(*(char)))->(void)
(	O
char	O
*	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
s	*(char)
&&	O
*	O
s	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
*	O
s	*(char)
)	O
;	O
*	O
s	*(char)
=	O
0	int
;	O
}	O
}	O
int	O
mu_parse822_skip_nl	(*(*(char)),*(char))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
)	O
{	O
const	O
char	O
*	O
s	*(char)
=	O
*	O
p	*(char)
;	O
if	O
(	O
(	O
&	O
s	*(char)
[	O
1	int
]	O
<	O
e	int
)	O
&&	O
s	*(char)
[	O
0	int
]	O
==	O
'\r'	O
&&	O
s	*(char)
[	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
*	O
p	*(char)
+=	O
2	int
;	O
return	O
EOK	int
;	O
}	O
if	O
(	O
(	O
&	O
s	*(char)
[	O
0	int
]	O
<	O
e	int
)	O
&&	O
s	*(char)
[	O
0	int
]	O
==	O
'\n'	O
)	O
{	O
*	O
p	*(char)
+=	O
1	int
;	O
return	O
EOK	int
;	O
}	O
return	O
EPARSE	O
;	O
}	O
int	O
mu_parse822_skip_lwsp_char	(*(*(char)),*(char))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
)	O
{	O
if	O
(	O
*	O
p	*(char)
<	O
e	int
&&	O
mu_parse822_is_lwsp_char	(char)->(int)
(	O
*	O
*	O
p	*(char)
)	O
)	O
{	O
*	O
p	*(char)
+=	O
1	int
;	O
return	O
EOK	int
;	O
}	O
return	O
EPARSE	O
;	O
}	O
int	O
mu_parse822_skip_lwsp	(*(*(char)),*(char))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
)	O
{	O
int	O
space	int
=	O
0	int
;	O
while	O
(	O
*	O
p	*(char)
!=	O
e	int
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
if	O
(	O
mu_parse822_skip_lwsp_char	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
==	O
EOK	int
)	O
{	O
space	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
mu_parse822_skip_nl	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
==	O
EOK	int
)	O
{	O
if	O
(	O
mu_parse822_skip_lwsp_char	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
==	O
EOK	int
)	O
{	O
continue	O
;	O
}	O
*	O
p	*(char)
=	O
save	*(char)
;	O
return	O
EPARSE	O
;	O
}	O
break	O
;	O
}	O
return	O
space	int
?	O
EOK	int
:	O
EPARSE	O
;	O
}	O
int	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
)	O
{	O
int	O
status	int
;	O
while	O
(	O
(	O
status	int
=	O
mu_parse822_comment	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
0	int
)	O
)	O
==	O
EOK	int
)	O
;	O
return	O
EOK	int
;	O
}	O
int	O
mu_parse822_digits	(*(*(char)),*(char),int,int,*(int))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
int	O
min	int
,	O
int	O
max	long
,	O
int	O
*	O
digits	*(int)
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
int	O
i	int
=	O
0	int
;	O
assert	O
(	O
digits	*(int)
)	O
;	O
*	O
digits	*(int)
=	O
0	int
;	O
while	O
(	O
*	O
p	*(char)
<	O
e	int
&&	O
mu_parse822_is_digit	(char)->(int)
(	O
*	O
*	O
p	*(char)
)	O
)	O
{	O
*	O
digits	*(int)
=	O
*	O
digits	*(int)
*	O
10	int
+	O
*	O
*	O
p	*(char)
-	O
'0'	O
;	O
*	O
p	*(char)
+=	O
1	int
;	O
++	O
i	int
;	O
if	O
(	O
max	long
!=	O
0	int
&&	O
i	int
==	O
max	long
)	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
i	int
<	O
min	int
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
return	O
EPARSE	O
;	O
}	O
return	O
EOK	int
;	O
}	O
int	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
c	char
)	O
{	O
mu_parse822_skip_lwsp	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
!=	O
e	int
&&	O
*	O
*	O
p	*(char)
==	O
c	char
)	O
{	O
++	O
*	O
p	*(char)
;	O
return	O
EOK	int
;	O
}	O
return	O
EPARSE	O
;	O
}	O
int	O
mu_parse822_comment	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
comment	*(*(char))
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
int	O
rc	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
'('	O
)	O
)	O
)	O
{	O
return	O
rc	int
;	O
}	O
while	O
(	O
*	O
p	*(char)
!=	O
e	int
)	O
{	O
char	O
c	char
=	O
*	O
*	O
p	*(char)
;	O
if	O
(	O
c	char
==	O
')'	O
)	O
{	O
*	O
p	*(char)
+=	O
1	int
;	O
return	O
EOK	int
;	O
}	O
else	O
if	O
(	O
c	char
==	O
'('	O
)	O
{	O
rc	int
=	O
mu_parse822_comment	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
comment	*(*(char))
)	O
;	O
}	O
else	O
if	O
(	O
c	char
==	O
'\\'	O
)	O
{	O
rc	int
=	O
mu_parse822_quoted_pair	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
comment	*(*(char))
)	O
;	O
}	O
else	O
if	O
(	O
c	char
==	O
'\r'	O
)	O
{	O
*	O
p	*(char)
+=	O
1	int
;	O
}	O
else	O
if	O
(	O
mu_parse822_is_char	(char)->(int)
(	O
c	char
)	O
)	O
{	O
rc	int
=	O
str_append_char	(*(*(char)),char)->(int)
(	O
comment	*(*(char))
,	O
c	char
)	O
;	O
*	O
p	*(char)
+=	O
1	int
;	O
}	O
else	O
{	O
*	O
p	*(char)
+=	O
1	int
;	O
}	O
if	O
(	O
rc	int
!=	O
EOK	int
)	O
break	O
;	O
}	O
if	O
(	O
*	O
p	*(char)
==	O
e	int
)	O
{	O
rc	int
=	O
EPARSE	O
;	O
}	O
*	O
p	*(char)
=	O
save	*(char)
;	O
assert	O
(	O
rc	int
!=	O
EOK	int
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_atom	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
atom	*(*(char))
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
int	O
rc	int
=	O
EPARSE	O
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
save	*(char)
=	O
*	O
p	*(char)
;	O
while	O
(	O
(	O
*	O
p	*(char)
!=	O
e	int
)	O
&&	O
(	O
*	O
*	O
p	*(char)
==	O
'.'	O
||	O
mu_parse822_is_atom_char	(char)->(int)
(	O
*	O
*	O
p	*(char)
)	O
)	O
)	O
{	O
rc	int
=	O
str_append_char	(*(*(char)),char)->(int)
(	O
atom	*(*(char))
,	O
*	O
*	O
p	*(char)
)	O
;	O
*	O
p	*(char)
+=	O
1	int
;	O
if	O
(	O
rc	int
!=	O
EOK	int
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
break	O
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
int	O
parse822_atom_ex	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
atom	*(*(char))
)	O
{	O
const	O
char	O
*	O
ptr	*(char)
;	O
int	O
rc	int
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
for	O
(	O
ptr	*(char)
=	O
*	O
p	*(char)
;	O
(	O
ptr	*(char)
!=	O
e	int
)	O
&&	O
mu_parse822_is_atom_char	(char)->(int)
(	O
*	O
ptr	*(char)
)	O
;	O
ptr	*(char)
++	O
)	O
;	O
if	O
(	O
ptr	*(char)
-	O
*	O
p	*(char)
==	O
0	int
)	O
return	O
EPARSE	O
;	O
rc	int
=	O
str_append_n	(*(*(char)),*(char),long)->(int)
(	O
atom	*(*(char))
,	O
*	O
p	*(char)
,	O
ptr	*(char)
-	O
*	O
p	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
*	O
p	*(char)
=	O
ptr	*(char)
;	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_quoted_pair	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
qpair	*(*(char))
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
(	O
e	int
-	O
*	O
p	*(char)
)	O
<	O
2	int
)	O
return	O
EPARSE	O
;	O
if	O
(	O
*	O
*	O
p	*(char)
!=	O
'\\'	O
)	O
return	O
EPARSE	O
;	O
if	O
(	O
(	O
rc	int
=	O
str_append_char	(*(*(char)),char)->(int)
(	O
qpair	*(*(char))
,	O
*	O
(	O
*	O
p	*(char)
+	O
1	int
)	O
)	O
)	O
)	O
return	O
rc	int
;	O
*	O
p	*(char)
+=	O
2	int
;	O
return	O
EOK	int
;	O
}	O
int	O
mu_parse822_quoted_string	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
qstr	*(*(char))
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
int	O
rc	int
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
save	*(char)
=	O
*	O
p	*(char)
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
'"'	O
)	O
)	O
)	O
return	O
rc	int
;	O
while	O
(	O
*	O
p	*(char)
!=	O
e	int
)	O
{	O
char	O
c	char
=	O
*	O
*	O
p	*(char)
;	O
if	O
(	O
c	char
==	O
'"'	O
)	O
{	O
*	O
p	*(char)
+=	O
1	int
;	O
return	O
EOK	int
;	O
}	O
else	O
if	O
(	O
c	char
==	O
'\\'	O
)	O
{	O
rc	int
=	O
mu_parse822_quoted_pair	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
qstr	*(*(char))
)	O
;	O
}	O
else	O
if	O
(	O
c	char
==	O
'\r'	O
)	O
{	O
*	O
p	*(char)
+=	O
1	int
;	O
}	O
else	O
if	O
(	O
mu_parse822_is_char	(char)->(int)
(	O
c	char
)	O
)	O
{	O
rc	int
=	O
str_append_char	(*(*(char)),char)->(int)
(	O
qstr	*(*(char))
,	O
c	char
)	O
;	O
*	O
p	*(char)
+=	O
1	int
;	O
}	O
else	O
{	O
*	O
p	*(char)
+=	O
1	int
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
str_free	(*(*(char)))->(void)
(	O
qstr	*(*(char))
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
*	O
p	*(char)
=	O
save	*(char)
;	O
str_free	(*(*(char)))->(void)
(	O
qstr	*(*(char))
)	O
;	O
return	O
EPARSE	O
;	O
}	O
int	O
mu_parse822_word	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
word	*(*(char))
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
int	O
rc	int
=	O
EOK	int
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
save	*(char)
=	O
*	O
p	*(char)
;	O
{	O
char	O
*	O
qstr	*(*(char))
=	O
0	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_quoted_string	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
qstr	*(*(char))
)	O
)	O
==	O
EOK	int
&&	O
qstr	*(*(char))
)	O
{	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
word	*(*(char))
,	O
qstr	*(*(char))
)	O
;	O
str_free	(*(*(char)))->(void)
(	O
&	O
qstr	*(*(char))
)	O
;	O
if	O
(	O
rc	int
!=	O
EOK	int
)	O
*	O
p	*(char)
=	O
save	*(char)
;	O
return	O
rc	int
;	O
}	O
assert	O
(	O
qstr	*(*(char))
==	O
NULL	O
)	O
;	O
}	O
if	O
(	O
rc	int
!=	O
EPARSE	O
)	O
{	O
return	O
rc	int
;	O
}	O
{	O
char	O
*	O
atom	*(*(char))
=	O
0	int
;	O
if	O
(	O
parse822_atom_ex	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
atom	*(*(char))
)	O
==	O
EOK	int
)	O
{	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
word	*(*(char))
,	O
atom	*(*(char))
)	O
;	O
str_free	(*(*(char)))->(void)
(	O
&	O
atom	*(*(char))
)	O
;	O
if	O
(	O
rc	int
!=	O
EOK	int
)	O
*	O
p	*(char)
=	O
save	*(char)
;	O
return	O
rc	int
;	O
}	O
assert	O
(	O
atom	*(*(char))
==	O
NULL	O
)	O
;	O
}	O
return	O
EPARSE	O
;	O
}	O
int	O
parse822_word_dot	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
word	*(*(char))
)	O
{	O
int	O
rc	int
=	O
mu_parse822_word	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
word	*(*(char))
)	O
;	O
for	O
(	O
;	O
rc	int
==	O
0	int
&&	O
(	O
*	O
p	*(char)
!=	O
e	int
)	O
&&	O
*	O
*	O
p	*(char)
==	O
'.'	O
;	O
++	O
*	O
p	*(char)
)	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
word	*(*(char))
,	O
"."	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_phrase	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
phrase	*(*(char))
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
int	O
rc	int
;	O
if	O
(	O
(	O
rc	int
=	O
parse822_word_dot	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
phrase	*(*(char))
)	O
)	O
)	O
return	O
rc	int
;	O
{	O
char	O
*	O
word	*(*(char))
=	O
0	int
;	O
while	O
(	O
(	O
rc	int
=	O
parse822_word_dot	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
word	*(*(char))
)	O
)	O
==	O
EOK	int
)	O
{	O
rc	int
=	O
str_append_char	(*(*(char)),char)->(int)
(	O
phrase	*(*(char))
,	O
' '	O
)	O
;	O
if	O
(	O
rc	int
==	O
EOK	int
)	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
phrase	*(*(char))
,	O
word	*(*(char))
)	O
;	O
str_free	(*(*(char)))->(void)
(	O
&	O
word	*(*(char))
)	O
;	O
if	O
(	O
rc	int
!=	O
EOK	int
)	O
break	O
;	O
}	O
assert	O
(	O
word	*(*(char))
==	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
EPARSE	O
)	O
rc	int
=	O
EOK	int
;	O
}	O
if	O
(	O
rc	int
)	O
*	O
p	*(char)
=	O
save	*(char)
;	O
return	O
rc	int
;	O
}	O
static	O
mu_address_t	*(struct)
new_mb	()->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
(	O
void	O
)	O
{	O
return	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
struct	O
mu_address	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`))))))
)	O
)	O
;	O
}	O
static	O
char	O
*	O
addr_field_by_mask	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(*(char))
(	O
mu_address_t	*(struct)
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
int	O
mask	int
)	O
{	O
switch	O
(	O
mask	int
)	O
{	O
case	O
MU_ADDR_HINT_PRINTABLE	int
:	O
return	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
->	O
printable	*(char)
;	O
case	O
MU_ADDR_HINT_COMMENTS	int
:	O
return	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
->	O
comments	*(char)
;	O
case	O
MU_ADDR_HINT_PERSONAL	int
:	O
return	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
->	O
personal	*(char)
;	O
case	O
MU_ADDR_HINT_EMAIL	int
:	O
return	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
->	O
email	*(char)
;	O
case	O
MU_ADDR_HINT_LOCAL	int
:	O
return	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
->	O
local_part	*(*(char))
;	O
case	O
MU_ADDR_HINT_DOMAIN	int
:	O
return	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
->	O
domain	*(*(char))
;	O
case	O
MU_ADDR_HINT_ROUTE	int
:	O
return	O
addr	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
->	O
route	*(*(char))
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
get_val	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int,*(char),int,*(int))->(*(char))
(	O
mu_address_t	*(struct)
hint	*(struct)
,	O
int	O
hflags	int
,	O
char	O
*	O
value	*(char)
,	O
int	O
mask	int
,	O
int	O
*	O
memflag	*(int)
)	O
{	O
if	O
(	O
!	O
value	*(char)
&&	O
hint	*(struct)
&&	O
(	O
hflags	int
&	O
mask	int
)	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
addr_field_by_mask	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(*(char))
(	O
hint	*(struct)
,	O
mask	int
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
if	O
(	O
memflag	*(int)
)	O
*	O
memflag	*(int)
|=	O
mask	int
;	O
value	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
}	O
}	O
return	O
value	*(char)
;	O
}	O
static	O
void	O
addr_free_fields	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(void)
(	O
mu_address_t	*(struct)
a	*(char)
,	O
int	O
memflag	*(int)
)	O
{	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
(	O
p	*(char)
=	O
addr_field_by_mask	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(*(char))
(	O
a	*(char)
,	O
memflag	*(int)
&	O
MU_ADDR_HINT_PRINTABLE	int
)	O
)	O
)	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
if	O
(	O
(	O
p	*(char)
=	O
addr_field_by_mask	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(*(char))
(	O
a	*(char)
,	O
memflag	*(int)
&	O
MU_ADDR_HINT_COMMENTS	int
)	O
)	O
)	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
if	O
(	O
(	O
p	*(char)
=	O
addr_field_by_mask	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(*(char))
(	O
a	*(char)
,	O
memflag	*(int)
&	O
MU_ADDR_HINT_PERSONAL	int
)	O
)	O
)	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
if	O
(	O
(	O
p	*(char)
=	O
addr_field_by_mask	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(*(char))
(	O
a	*(char)
,	O
memflag	*(int)
&	O
MU_ADDR_HINT_EMAIL	int
)	O
)	O
)	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
if	O
(	O
(	O
p	*(char)
=	O
addr_field_by_mask	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(*(char))
(	O
a	*(char)
,	O
memflag	*(int)
&	O
MU_ADDR_HINT_LOCAL	int
)	O
)	O
)	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
if	O
(	O
(	O
p	*(char)
=	O
addr_field_by_mask	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(*(char))
(	O
a	*(char)
,	O
memflag	*(int)
&	O
MU_ADDR_HINT_DOMAIN	int
)	O
)	O
)	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
if	O
(	O
(	O
p	*(char)
=	O
addr_field_by_mask	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(*(char))
(	O
a	*(char)
,	O
memflag	*(int)
&	O
MU_ADDR_HINT_ROUTE	int
)	O
)	O
)	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
}	O
static	O
int	O
fill_mb	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(int)
(	O
mu_address_t	*(struct)
*	O
pa	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
char	O
*	O
comments	*(char)
,	O
char	O
*	O
personal	*(char)
,	O
char	O
*	O
local	*(char)
,	O
char	O
*	O
domain	*(*(char))
,	O
mu_address_t	*(struct)
hint	*(struct)
,	O
int	O
hflags	int
)	O
{	O
int	O
rc	int
=	O
EOK	int
;	O
mu_address_t	*(struct)
a	*(char)
;	O
int	O
memflag	*(int)
=	O
0	int
;	O
a	*(char)
=	O
new_mb	()->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
(	O
)	O
;	O
if	O
(	O
!	O
a	*(char)
)	O
return	O
ENOMEM	int
;	O
a	*(char)
->	O
comments	*(char)
=	O
get_val	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int,*(char),int,*(int))->(*(char))
(	O
hint	*(struct)
,	O
hflags	int
,	O
comments	*(char)
,	O
MU_ADDR_HINT_COMMENTS	int
,	O
&	O
memflag	*(int)
)	O
;	O
a	*(char)
->	O
personal	*(char)
=	O
get_val	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int,*(char),int,*(int))->(*(char))
(	O
hint	*(struct)
,	O
hflags	int
,	O
personal	*(char)
,	O
MU_ADDR_HINT_PERSONAL	int
,	O
&	O
memflag	*(int)
)	O
;	O
domain	*(*(char))
=	O
get_val	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int,*(char),int,*(int))->(*(char))
(	O
hint	*(struct)
,	O
hflags	int
,	O
domain	*(*(char))
,	O
MU_ADDR_HINT_DOMAIN	int
,	O
&	O
memflag	*(int)
)	O
;	O
local	*(char)
=	O
get_val	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int,*(char),int,*(int))->(*(char))
(	O
hint	*(struct)
,	O
hflags	int
,	O
local	*(char)
,	O
MU_ADDR_HINT_LOCAL	int
,	O
&	O
memflag	*(int)
)	O
;	O
do	O
{	O
if	O
(	O
!	O
local	*(char)
)	O
break	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_quote_local_part	(*(*(char)),*(char))->(int)
(	O
&	O
a	*(char)
->	O
email	*(char)
,	O
local	*(char)
)	O
)	O
)	O
break	O
;	O
if	O
(	O
domain	*(*(char))
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
&	O
a	*(char)
->	O
email	*(char)
,	O
"@"	*(char)
)	O
)	O
)	O
break	O
;	O
if	O
(	O
(	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
&	O
a	*(char)
->	O
email	*(char)
,	O
domain	*(*(char))
)	O
)	O
)	O
break	O
;	O
}	O
}	O
while	O
(	O
0	int
)	O
;	O
a	*(char)
->	O
local_part	*(*(char))
=	O
local	*(char)
;	O
a	*(char)
->	O
domain	*(*(char))
=	O
domain	*(*(char))
;	O
if	O
(	O
rc	int
!=	O
EOK	int
)	O
{	O
addr_free_fields	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(void)
(	O
a	*(char)
,	O
memflag	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
a	*(char)
)	O
;	O
}	O
else	O
*	O
pa	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
=	O
a	*(char)
;	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_address_list	(*(*(struct)),*(char),*(struct),int)->(int)
(	O
mu_address_t	*(struct)
*	O
a	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
mu_address_t	*(struct)
hint	*(struct)
,	O
int	O
hflags	int
)	O
{	O
const	O
char	O
*	O
*	O
p	*(char)
=	O
&	O
s	*(char)
;	O
const	O
char	O
*	O
e	int
=	O
&	O
s	*(char)
[	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
]	O
;	O
int	O
rc	int
=	O
EOK	int
;	O
mu_address_t	*(struct)
*	O
n	long
=	O
a	*(char)
;	O
rc	int
=	O
mu_parse822_address	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
p	*(char)
,	O
e	int
,	O
n	long
,	O
hint	*(struct)
,	O
hflags	int
)	O
;	O
if	O
(	O
rc	int
!=	O
EOK	int
&&	O
rc	int
!=	O
EPARSE	O
)	O
{	O
return	O
rc	int
;	O
}	O
while	O
(	O
*	O
p	*(char)
<	O
e	int
)	O
{	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
while	O
(	O
*	O
n	long
)	O
{	O
n	long
=	O
&	O
(	O
*	O
n	long
)	O
->	O
next	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
','	O
)	O
)	O
)	O
{	O
break	O
;	O
}	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
rc	int
=	O
mu_parse822_address	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
p	*(char)
,	O
e	int
,	O
n	long
,	O
hint	*(struct)
,	O
hflags	int
)	O
;	O
if	O
(	O
rc	int
==	O
EOK	int
||	O
rc	int
==	O
EPARSE	O
)	O
{	O
rc	int
=	O
EOK	int
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
rc	int
)	O
{	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
a	*(char)
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_address	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
mu_address_t	*(struct)
*	O
a	*(char)
,	O
mu_address_t	*(struct)
hint	*(struct)
,	O
int	O
hflags	int
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_mail_box	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
p	*(char)
,	O
e	int
,	O
a	*(char)
,	O
hint	*(struct)
,	O
hflags	int
)	O
)	O
==	O
EPARSE	O
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_group	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
p	*(char)
,	O
e	int
,	O
a	*(char)
,	O
hint	*(struct)
,	O
hflags	int
)	O
)	O
==	O
EPARSE	O
)	O
{	O
rc	int
=	O
mu_parse822_unix_mbox	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
p	*(char)
,	O
e	int
,	O
a	*(char)
,	O
hint	*(struct)
,	O
hflags	int
)	O
;	O
}	O
}	O
if	O
(	O
rc	int
==	O
0	int
&&	O
*	O
a	*(char)
&&	O
!	O
(	O
*	O
a	*(char)
)	O
->	O
route	*(*(char))
)	O
(	O
*	O
a	*(char)
)	O
->	O
route	*(*(char))
=	O
get_val	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int,*(char),int,*(int))->(*(char))
(	O
hint	*(struct)
,	O
hflags	int
,	O
NULL	O
,	O
MU_ADDR_HINT_ROUTE	int
,	O
NULL	O
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_group	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
mu_address_t	*(struct)
*	O
a	*(char)
,	O
mu_address_t	*(struct)
hint	*(struct)
,	O
int	O
hflags	int
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
mu_address_t	*(struct)
*	O
asave	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
=	O
a	*(char)
;	O
int	O
rc	int
;	O
char	O
*	O
phrase	*(*(char))
=	O
0	int
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
*	O
p	*(char)
=	O
save	*(char)
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_phrase	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
phrase	*(*(char))
)	O
)	O
)	O
{	O
return	O
rc	int
;	O
}	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
':'	O
)	O
)	O
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
str_free	(*(*(char)))->(void)
(	O
&	O
phrase	*(*(char))
)	O
;	O
return	O
rc	int
;	O
}	O
str_free	(*(*(char)))->(void)
(	O
&	O
phrase	*(*(char))
)	O
;	O
while	O
(	O
!	O
rc	int
)	O
{	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
rc	int
=	O
mu_parse822_mail_box	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
p	*(char)
,	O
e	int
,	O
a	*(char)
,	O
hint	*(struct)
,	O
hflags	int
)	O
;	O
if	O
(	O
rc	int
==	O
EOK	int
)	O
{	O
a	*(char)
=	O
&	O
(	O
*	O
a	*(char)
)	O
->	O
next	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
}	O
else	O
if	O
(	O
rc	int
!=	O
EPARSE	O
)	O
{	O
break	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
','	O
)	O
)	O
)	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
rc	int
==	O
EPARSE	O
)	O
{	O
rc	int
=	O
EOK	int
;	O
}	O
if	O
(	O
rc	int
||	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
';'	O
)	O
)	O
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
asave	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_mail_box	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
mu_address_t	*(struct)
*	O
a	*(char)
,	O
mu_address_t	*(struct)
hint	*(struct)
,	O
int	O
hflags	int
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
int	O
rc	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_addr_spec	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
p	*(char)
,	O
e	int
,	O
a	*(char)
,	O
hint	*(struct)
,	O
hflags	int
)	O
)	O
==	O
EOK	int
)	O
{	O
mu_parse822_skip_lwsp	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_comment	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
(	O
*	O
a	*(char)
)	O
->	O
personal	*(char)
)	O
)	O
==	O
EPARSE	O
)	O
{	O
rc	int
=	O
EOK	int
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
a	*(char)
)	O
;	O
*	O
p	*(char)
=	O
save	*(char)
;	O
}	O
return	O
rc	int
;	O
}	O
{	O
char	O
*	O
phrase	*(*(char))
=	O
0	int
;	O
rc	int
=	O
mu_parse822_phrase	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
phrase	*(*(char))
)	O
;	O
if	O
(	O
rc	int
!=	O
EPARSE	O
&&	O
rc	int
!=	O
EOK	int
)	O
{	O
return	O
rc	int
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_route_addr	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
p	*(char)
,	O
e	int
,	O
a	*(char)
,	O
hint	*(struct)
,	O
hflags	int
)	O
)	O
==	O
EOK	int
)	O
{	O
(	O
*	O
a	*(char)
)	O
->	O
personal	*(char)
=	O
phrase	*(*(char))
;	O
return	O
EOK	int
;	O
}	O
str_free	(*(*(char)))->(void)
(	O
&	O
phrase	*(*(char))
)	O
;	O
*	O
p	*(char)
=	O
save	*(char)
;	O
return	O
rc	int
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_route_addr	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
mu_address_t	*(struct)
*	O
a	*(char)
,	O
mu_address_t	*(struct)
hint	*(struct)
,	O
int	O
hflags	int
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
char	O
*	O
route	*(*(char))
=	O
NULL	O
;	O
int	O
rc	int
;	O
int	O
memflag	*(int)
=	O
0	int
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
'<'	O
)	O
)	O
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
!	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
'>'	O
)	O
)	O
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
fill_mb	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(int)
(	O
a	*(char)
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
hint	*(struct)
,	O
hflags	int
)	O
)	O
==	O
EOK	int
)	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
&	O
(	O
*	O
a	*(char)
)	O
->	O
email	*(char)
,	O
""	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
mu_parse822_route	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
route	*(*(char))
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_addr_spec	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
p	*(char)
,	O
e	int
,	O
a	*(char)
,	O
hint	*(struct)
,	O
hflags	int
)	O
)	O
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
str_free	(*(*(char)))->(void)
(	O
&	O
route	*(*(char))
)	O
;	O
return	O
rc	int
;	O
}	O
(	O
*	O
a	*(char)
)	O
->	O
route	*(*(char))
=	O
get_val	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int,*(char),int,*(int))->(*(char))
(	O
hint	*(struct)
,	O
hflags	int
,	O
route	*(*(char))
,	O
MU_ADDR_HINT_ROUTE	int
,	O
&	O
memflag	*(int)
)	O
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
'>'	O
)	O
)	O
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
a	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
return	O
EOK	int
;	O
}	O
int	O
mu_parse822_route	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
route	*(*(char))
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
char	O
*	O
accumulator	*(char)
=	O
0	int
;	O
int	O
rc	int
=	O
EOK	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
'@'	O
)	O
)	O
)	O
{	O
break	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
&	O
accumulator	*(char)
,	O
"@"	*(char)
)	O
)	O
)	O
{	O
break	O
;	O
}	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_domain	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
accumulator	*(char)
)	O
)	O
)	O
{	O
break	O
;	O
}	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
','	O
)	O
)	O
==	O
EPARSE	O
)	O
{	O
rc	int
=	O
EOK	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
&	O
accumulator	*(char)
,	O
", "	*(char)
)	O
)	O
)	O
{	O
break	O
;	O
}	O
}	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
!	O
rc	int
)	O
{	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
':'	O
)	O
;	O
}	O
if	O
(	O
!	O
rc	int
)	O
{	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
route	*(*(char))
,	O
accumulator	*(char)
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
}	O
str_free	(*(*(char)))->(void)
(	O
&	O
accumulator	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_addr_spec	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
mu_address_t	*(struct)
*	O
a	*(char)
,	O
mu_address_t	*(struct)
hint	*(struct)
,	O
int	O
hflags	int
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
char	O
*	O
local_part	*(*(char))
=	O
0	int
;	O
char	O
*	O
domain	*(*(char))
=	O
0	int
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_parse822_local_part	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
local_part	*(*(char))
)	O
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
!	O
rc	int
)	O
{	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
'@'	O
)	O
;	O
if	O
(	O
!	O
rc	int
)	O
{	O
rc	int
=	O
mu_parse822_domain	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
domain	*(*(char))
)	O
;	O
if	O
(	O
!	O
rc	int
)	O
rc	int
=	O
fill_mb	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(int)
(	O
a	*(char)
,	O
0	int
,	O
0	int
,	O
local_part	*(*(char))
,	O
domain	*(*(char))
,	O
hint	*(struct)
,	O
hflags	int
)	O
;	O
}	O
}	O
if	O
(	O
rc	int
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
str_free	(*(*(char)))->(void)
(	O
&	O
local_part	*(*(char))
)	O
;	O
str_free	(*(*(char)))->(void)
(	O
&	O
domain	*(*(char))
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_unix_mbox	(*(*(char)),*(char),*(*(struct)),*(struct),int)->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
mu_address_t	*(struct)
*	O
a	*(char)
,	O
mu_address_t	*(struct)
hint	*(struct)
,	O
int	O
hflags	int
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
char	O
*	O
mbox	*(char)
=	O
0	int
;	O
int	O
rc	int
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
rc	int
=	O
mu_parse822_atom	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
mbox	*(char)
)	O
;	O
if	O
(	O
!	O
rc	int
)	O
rc	int
=	O
fill_mb	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),int)->(int)
(	O
a	*(char)
,	O
0	int
,	O
0	int
,	O
mbox	*(char)
,	O
0	int
,	O
hint	*(struct)
,	O
hflags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
str_free	(*(*(char)))->(void)
(	O
&	O
mbox	*(char)
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_local_part	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
local_part	*(*(char))
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
const	O
char	O
*	O
save2	*(char)
=	O
*	O
p	*(char)
;	O
int	O
rc	int
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_word	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
local_part	*(*(char))
)	O
)	O
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
return	O
rc	int
;	O
}	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
save2	*(char)
=	O
*	O
p	*(char)
;	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
'.'	O
)	O
;	O
if	O
(	O
!	O
rc	int
)	O
{	O
char	O
*	O
more	*(char)
=	O
0	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_local_part	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
more	*(char)
)	O
)	O
==	O
EOK	int
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
local_part	*(*(char))
,	O
"."	*(char)
)	O
)	O
==	O
EOK	int
)	O
{	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
local_part	*(*(char))
,	O
more	*(char)
)	O
;	O
}	O
}	O
str_free	(*(*(char)))->(void)
(	O
&	O
more	*(char)
)	O
;	O
}	O
if	O
(	O
rc	int
==	O
EPARSE	O
)	O
{	O
*	O
p	*(char)
=	O
save2	*(char)
;	O
rc	int
=	O
EOK	int
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
str_free	(*(*(char)))->(void)
(	O
local_part	*(*(char))
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_domain	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
domain	*(*(char))
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
const	O
char	O
*	O
save2	*(char)
=	O
0	int
;	O
int	O
rc	int
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_sub_domain	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
domain	*(*(char))
)	O
)	O
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
return	O
rc	int
;	O
}	O
save2	*(char)
=	O
*	O
p	*(char)
;	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
'.'	O
)	O
;	O
if	O
(	O
!	O
rc	int
)	O
{	O
char	O
*	O
more	*(char)
=	O
0	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_domain	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
more	*(char)
)	O
)	O
==	O
EOK	int
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
domain	*(*(char))
,	O
"."	*(char)
)	O
)	O
==	O
EOK	int
)	O
{	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
domain	*(*(char))
,	O
more	*(char)
)	O
;	O
}	O
}	O
str_free	(*(*(char)))->(void)
(	O
&	O
more	*(char)
)	O
;	O
}	O
if	O
(	O
rc	int
==	O
EPARSE	O
)	O
{	O
*	O
p	*(char)
=	O
save2	*(char)
;	O
rc	int
=	O
EOK	int
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
str_free	(*(*(char)))->(void)
(	O
domain	*(*(char))
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_sub_domain	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
sub_domain	*(*(char))
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_domain_ref	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
sub_domain	*(*(char))
)	O
)	O
==	O
EPARSE	O
)	O
rc	int
=	O
mu_parse822_domain_literal	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
sub_domain	*(*(char))
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_domain_ref	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
domain_ref	*(*(char))
)	O
{	O
return	O
mu_parse822_atom	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
domain_ref	*(*(char))
)	O
;	O
}	O
int	O
mu_parse822_d_text	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
dtext	*(*(char))
)	O
{	O
const	O
char	O
*	O
start	*(char)
=	O
*	O
p	*(char)
;	O
int	O
rc	int
=	O
EOK	int
;	O
while	O
(	O
*	O
p	*(char)
<	O
e	int
&&	O
mu_parse822_is_d_text	(char)->(int)
(	O
*	O
*	O
p	*(char)
)	O
)	O
{	O
*	O
p	*(char)
+=	O
1	int
;	O
}	O
if	O
(	O
start	*(char)
==	O
*	O
p	*(char)
)	O
{	O
return	O
EPARSE	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
str_append_range	(*(*(char)),*(char),*(char))->(int)
(	O
dtext	*(*(char))
,	O
start	*(char)
,	O
*	O
p	*(char)
)	O
)	O
)	O
{	O
*	O
p	*(char)
=	O
start	*(char)
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_domain_literal	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
domain_literal	*(*(char))
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
char	O
*	O
literal	*(char)
=	O
0	int
;	O
int	O
rc	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
'['	O
)	O
)	O
)	O
{	O
return	O
rc	int
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
str_append_char	(*(*(char)),char)->(int)
(	O
&	O
literal	*(char)
,	O
'['	O
)	O
)	O
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
return	O
rc	int
;	O
}	O
while	O
(	O
(	O
rc	int
=	O
mu_parse822_d_text	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
literal	*(char)
)	O
)	O
==	O
EOK	int
||	O
(	O
rc	int
=	O
mu_parse822_quoted_pair	(*(*(char)),*(char),*(*(char)))->(int)
(	O
p	*(char)
,	O
e	int
,	O
&	O
literal	*(char)
)	O
)	O
==	O
EOK	int
)	O
{	O
}	O
if	O
(	O
rc	int
==	O
EPARSE	O
)	O
{	O
rc	int
=	O
EOK	int
;	O
}	O
if	O
(	O
!	O
rc	int
)	O
{	O
rc	int
=	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
']'	O
)	O
;	O
}	O
if	O
(	O
!	O
rc	int
)	O
{	O
rc	int
=	O
str_append_char	(*(*(char)),char)->(int)
(	O
&	O
literal	*(char)
,	O
']'	O
)	O
;	O
}	O
if	O
(	O
!	O
rc	int
)	O
{	O
rc	int
=	O
str_append	(*(*(char)),*(char))->(int)
(	O
domain_literal	*(*(char))
,	O
literal	*(char)
)	O
;	O
}	O
str_free	(*(*(char)))->(void)
(	O
&	O
literal	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_date_time	(*(*(char)),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
struct	O
mu_timezone	struct(int,*(char))
*	O
tz	*(struct(int,*(char)))
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
char	O
*	O
end	*(char)
;	O
size_t	long
len	long
=	O
e	int
-	O
*	O
p	*(char)
;	O
int	O
rc	int
;	O
tmp	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
tmp	*(char)
)	O
return	O
ENOMEM	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tmp	*(char)
,	O
*	O
p	*(char)
,	O
len	long
)	O
;	O
tmp	*(char)
[	O
len	long
]	O
=	O
0	int
;	O
rc	int
=	O
mu_scan_datetime	(*(char),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))),*(*(char)))->(int)
(	O
tmp	*(char)
,	O
MU_DATETIME_SCAN_RFC822	*(char)
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
tz	*(struct(int,*(char)))
,	O
&	O
end	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
*	O
p	*(char)
=	O
end	*(char)
;	O
free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_field_name	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
fieldname	*(*(char))
)	O
{	O
const	O
char	O
*	O
save	*(char)
=	O
*	O
p	*(char)
;	O
char	O
*	O
fn	*(char)
=	O
NULL	O
;	O
while	O
(	O
*	O
p	*(char)
!=	O
e	int
)	O
{	O
char	O
c	char
=	O
*	O
*	O
p	*(char)
;	O
if	O
(	O
!	O
mu_parse822_is_char	(char)->(int)
(	O
c	char
)	O
)	O
break	O
;	O
if	O
(	O
mu_parse822_is_ctl	(char)->(int)
(	O
c	char
)	O
)	O
break	O
;	O
if	O
(	O
mu_parse822_is_space	(char)->(int)
(	O
c	char
)	O
)	O
break	O
;	O
if	O
(	O
c	char
==	O
':'	O
)	O
break	O
;	O
str_append_char	(*(*(char)),char)->(int)
(	O
&	O
fn	*(char)
,	O
c	char
)	O
;	O
*	O
p	*(char)
+=	O
1	int
;	O
}	O
if	O
(	O
!	O
fn	*(char)
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
return	O
EPARSE	O
;	O
}	O
mu_parse822_skip_comments	(*(*(char)),*(char))->(int)
(	O
p	*(char)
,	O
e	int
)	O
;	O
if	O
(	O
!	O
mu_parse822_special	(*(*(char)),*(char),char)->(int)
(	O
p	*(char)
,	O
e	int
,	O
':'	O
)	O
)	O
{	O
*	O
p	*(char)
=	O
save	*(char)
;	O
if	O
(	O
fn	*(char)
)	O
free	(*(void))->(void)
(	O
fn	*(char)
)	O
;	O
return	O
EPARSE	O
;	O
}	O
*	O
fieldname	*(*(char))
=	O
fn	*(char)
;	O
return	O
EOK	int
;	O
}	O
int	O
mu_parse822_field_body	(*(*(char)),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
e	int
,	O
char	O
*	O
*	O
fieldbody	*(*(char))
)	O
{	O
char	O
*	O
fb	*(char)
=	O
NULL	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
const	O
char	O
*	O
eol	*(char)
=	O
*	O
p	*(char)
;	O
while	O
(	O
eol	*(char)
!=	O
e	int
)	O
{	O
if	O
(	O
eol	*(char)
[	O
0	int
]	O
==	O
'\r'	O
&&	O
(	O
eol	*(char)
+	O
1	int
)	O
!=	O
e	int
&&	O
eol	*(char)
[	O
1	int
]	O
==	O
'\n'	O
)	O
break	O
;	O
++	O
eol	*(char)
;	O
}	O
str_append_range	(*(*(char)),*(char),*(char))->(int)
(	O
&	O
fb	*(char)
,	O
*	O
p	*(char)
,	O
eol	*(char)
)	O
;	O
*	O
p	*(char)
=	O
eol	*(char)
;	O
if	O
(	O
eol	*(char)
==	O
e	int
)	O
break	O
;	O
*	O
p	*(char)
+=	O
2	int
;	O
if	O
(	O
*	O
p	*(char)
==	O
e	int
)	O
break	O
;	O
if	O
(	O
*	O
*	O
p	*(char)
!=	O
' '	O
&&	O
*	O
*	O
p	*(char)
!=	O
'\t'	O
)	O
break	O
;	O
}	O
*	O
fieldbody	*(*(char))
=	O
fb	*(char)
;	O
return	O
EOK	int
;	O
}	O
int	O
mu_parse822_quote_string	(*(*(char)),*(char))->(int)
(	O
char	O
*	O
*	O
quoted	*(*(char))
,	O
const	O
char	O
*	O
raw	*(char)
)	O
{	O
int	O
rc	int
=	O
EOK	int
;	O
const	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
!	O
raw	*(char)
||	O
!	O
quoted	*(*(char))
||	O
*	O
quoted	*(*(char))
)	O
{	O
return	O
EINVAL	int
;	O
}	O
s	*(char)
=	O
raw	*(char)
;	O
rc	int
=	O
str_append_char	(*(*(char)),char)->(int)
(	O
quoted	*(*(char))
,	O
'"'	O
)	O
;	O
while	O
(	O
!	O
rc	int
&&	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
!	O
mu_parse822_is_q_text	(char)->(int)
(	O
*	O
s	*(char)
)	O
)	O
{	O
rc	int
=	O
str_append_char	(*(*(char)),char)->(int)
(	O
quoted	*(*(char))
,	O
'\\'	O
)	O
;	O
}	O
if	O
(	O
!	O
rc	int
)	O
{	O
rc	int
=	O
str_append_char	(*(*(char)),char)->(int)
(	O
quoted	*(*(char))
,	O
*	O
s	*(char)
)	O
;	O
}	O
++	O
s	*(char)
;	O
}	O
if	O
(	O
!	O
rc	int
)	O
{	O
rc	int
=	O
str_append_char	(*(*(char)),char)->(int)
(	O
quoted	*(*(char))
,	O
'"'	O
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
str_free	(*(*(char)))->(void)
(	O
quoted	*(*(char))
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_parse822_quote_local_part	(*(*(char)),*(char))->(int)
(	O
char	O
*	O
*	O
quoted	*(*(char))
,	O
const	O
char	O
*	O
raw	*(char)
)	O
{	O
const	O
char	O
*	O
s	*(char)
=	O
0	int
;	O
if	O
(	O
!	O
raw	*(char)
||	O
!	O
quoted	*(*(char))
||	O
*	O
quoted	*(*(char))
)	O
{	O
return	O
EINVAL	int
;	O
}	O
s	*(char)
=	O
raw	*(char)
;	O
while	O
(	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
*	O
s	*(char)
!=	O
'.'	O
&&	O
!	O
mu_parse822_is_atom_char	(char)->(int)
(	O
*	O
s	*(char)
)	O
)	O
{	O
return	O
mu_parse822_quote_string	(*(*(char)),*(char))->(int)
(	O
quoted	*(*(char))
,	O
raw	*(char)
)	O
;	O
}	O
++	O
s	*(char)
;	O
}	O
return	O
str_append	(*(*(char)),*(char))->(int)
(	O
quoted	*(*(char))
,	O
raw	*(char)
)	O
;	O
}	O
