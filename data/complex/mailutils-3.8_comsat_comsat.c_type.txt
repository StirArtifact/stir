typedef	O
struct	O
utmpx	struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char))
UTMP	struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char))
;	O
const	O
char	O
*	O
program_version	*(char)
=	O
"comsatd ("	*(char)
PACKAGE_STRING	*(char)
")"	*(char)
;	O
char	O
*	O
test_mode	*(char)
;	O
char	O
*	O
biffrc	*(char)
=	O
BIFF_RC	*(char)
;	O
mu_m_server_t	*(struct)
server	int
;	O
static	O
void	O
set_inetd_mode	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
mu_m_server_set_mode	(*(struct),int)->(void)
(	O
server	int
,	O
MODE_INTERACTIVE	int
)	O
;	O
}	O
static	O
void	O
set_test_mode	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
if	O
(	O
arg	*(char)
)	O
{	O
if	O
(	O
arg	*(char)
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
test_mode	*(char)
=	O
mu_make_file_name	O
(	O
mu_getcwd	()->(*(char))
(	O
)	O
,	O
arg	*(char)
)	O
;	O
if	O
(	O
!	O
test_mode	*(char)
)	O
mu_alloc_die	()->(void)
(	O
)	O
;	O
}	O
else	O
test_mode	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
}	O
else	O
test_mode	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
"/dev/tty"	*(char)
)	O
;	O
}	O
static	O
void	O
set_daemon_mode	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
mu_m_server_set_mode	(*(struct),int)->(void)
(	O
server	int
,	O
MODE_DAEMON	int
)	O
;	O
if	O
(	O
arg	*(char)
)	O
{	O
size_t	long
max_children	long
;	O
char	O
*	O
errmsg	*(*(char))
;	O
int	O
rc	int
=	O
mu_str_to_c	(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*(*(char)))->(int)
(	O
arg	*(char)
,	O
mu_c_size	int
,	O
&	O
max_children	long
,	O
&	O
errmsg	*(*(char))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"%s: bad argument"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
}	O
mu_m_server_set_max_children	(*(struct),long)->(void)
(	O
server	int
,	O
max_children	long
)	O
;	O
}	O
}	O
static	O
void	O
set_foreground	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
mu_m_server_set_foreground	(*(struct),int)->(int)
(	O
server	int
,	O
1	int
)	O
;	O
}	O
static	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
comsat_options	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
[	O
]	O
=	O
{	O
{	O
"test"	*(char)
,	O
't'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
MU_OPTION_ARG_OPTIONAL	int
,	O
N_	O
(	O
"run in test mode; use FILE as tty (default: /dev/tty)"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
test_mode	*(char)
,	O
set_test_mode	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"foreground"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"remain in foreground"	*(char)
)	O
,	O
mu_c_bool	int
,	O
NULL	O
,	O
set_foreground	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"inetd"	*(char)
,	O
'i'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"run in inetd mode"	*(char)
)	O
,	O
mu_c_bool	int
,	O
NULL	O
,	O
set_inetd_mode	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"daemon"	*(char)
,	O
'd'	O
,	O
N_	O
(	O
"NUMBER"	*(char)
)	O
,	O
MU_OPTION_ARG_OPTIONAL	int
,	O
N_	O
(	O
"runs in daemon mode with a maximum of NUMBER children"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
set_daemon_mode	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"file"	*(char)
,	O
'f'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"read FILE instead of .biffrc"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
biffrc	*(char)
}	O
,	O
MU_OPTION_END	O
}	O
,	O
*	O
options	array(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))))
[	O
]	O
=	O
{	O
comsat_options	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
,	O
NULL	O
}	O
;	O
int	O
maxlines	int
=	O
5	int
;	O
char	O
*	O
hostname	*(char)
;	O
const	O
char	O
*	O
username	*(char)
;	O
int	O
require_tty	int
;	O
int	O
biffrc_errors	int
=	O
BIFFRC_ERRORS_TO_TTY	int
|	O
BIFFRC_ERRORS_TO_ERR	int
;	O
static	O
void	O
comsat_init	()->(void)
(	O
void	O
)	O
;	O
static	O
int	O
comsat_main	(int)->(int)
(	O
int	O
fd	int
)	O
;	O
static	O
void	O
notify_user	(*(char),*(char),*(char),*(char))->(void)
(	O
const	O
char	O
*	O
user	*(char)
,	O
const	O
char	O
*	O
device	*(char)
,	O
const	O
char	O
*	O
path	*(char)
,	O
mu_message_qid_t	*(char)
qid	*(char)
)	O
;	O
static	O
int	O
find_user	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
tty	*(char)
)	O
;	O
static	O
char	O
*	O
mailbox_path	(*(char))->(*(char))
(	O
const	O
char	O
*	O
user	*(char)
)	O
;	O
static	O
int	O
change_user	(*(char))->(int)
(	O
const	O
char	O
*	O
user	*(char)
)	O
;	O
static	O
int	O
reload	int
=	O
0	int
;	O
static	O
int	O
biffrc_error_ctl	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
mu_config_value_t	struct
*	O
val	array(int)
,	O
int	O
flag	int
)	O
{	O
int	O
res	*(int)
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
mu_str_to_c	(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*(*(char)))->(int)
(	O
val	array(int)
->	O
v	union(struct(long),struct(*(struct(struct(int,int,int,int,int,int,int,int,int,long,*`),struct(int,*`),*(char),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),*(char))),*(struct(enum(int,int,int,int),*(char),*(char),*(struct`),*(char),*(char),*(char),long,*(char),*(char),*(struct`),*(char),*(char),union(struct`,struct`,struct`))),long),struct(*(struct)))
.	O
string	*(char)
,	O
mu_c_bool	int
,	O
&	O
res	*(int)
,	O
NULL	O
)	O
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
_	O
(	O
"not a boolean"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
res	*(int)
)	O
biffrc_errors	int
|=	O
flag	int
;	O
else	O
biffrc_errors	int
&=	O
~	O
flag	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_biffrc_errors_to_tty	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
return	O
biffrc_error_ctl	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
BIFFRC_ERRORS_TO_TTY	int
)	O
;	O
}	O
static	O
int	O
cb_biffrc_errors_to_err	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
return	O
biffrc_error_ctl	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
BIFFRC_ERRORS_TO_ERR	int
)	O
;	O
}	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
comsat_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"allow-biffrc"	*(char)
,	O
mu_c_bool	int
,	O
&	O
allow_biffrc	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Read .biffrc file from the user home directory."	*(char)
)	O
}	O
,	O
{	O
"require-tty"	*(char)
,	O
mu_c_bool	int
,	O
&	O
require_tty	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Notify only if the user is logged on one of the ttys."	*(char)
)	O
}	O
,	O
{	O
"biffrc-errors-to-tty"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_biffrc_errors_to_tty	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Send biffrc errors to user's tty."	*(char)
)	O
,	O
N_	O
(	O
"arg: bool"	*(char)
)	O
}	O
,	O
{	O
"biffrc-errors-to-err"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_biffrc_errors_to_err	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Send biffrc errors to Mailutils error output."	*(char)
)	O
,	O
N_	O
(	O
"arg: bool"	*(char)
)	O
}	O
,	O
{	O
"max-lines"	*(char)
,	O
mu_c_int	int
,	O
&	O
maxlines	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Maximum number of message body lines to be output."	*(char)
)	O
}	O
,	O
{	O
"max-requests"	*(char)
,	O
mu_c_uint	int
,	O
&	O
maxrequests	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Maximum number of incoming requests per request control interval."	*(char)
)	O
}	O
,	O
{	O
"request-control-interval"	*(char)
,	O
mu_c_time	int
,	O
&	O
request_control_interval	long
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Set control interval."	*(char)
)	O
}	O
,	O
{	O
"overflow-control-interval"	*(char)
,	O
mu_c_time	int
,	O
&	O
overflow_control_interval	long
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Set overflow control interval."	*(char)
)	O
}	O
,	O
{	O
"overflow-delay-time"	*(char)
,	O
mu_c_time	int
,	O
&	O
overflow_delay_time	long
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Time to sleep after the first overflow occurs."	*(char)
)	O
}	O
,	O
{	O
".server"	*(char)
,	O
mu_cfg_section	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Server configuration."	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
char	O
const	O
*	O
alt_args	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"--test MBOX-URL MSG-QID"	*(char)
)	O
,	O
NULL	O
}	O
;	O
static	O
struct	O
mu_cli_setup	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
cli	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
=	O
{	O
.	O
optv	*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))))
=	O
options	array(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))))
,	O
.	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
=	O
comsat_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
,	O
.	O
prog_doc	*(char)
=	O
N_	O
(	O
"GNU comsatd -- notify users about incoming mail"	*(char)
)	O
,	O
.	O
prog_alt_args	*(*(char))
=	O
alt_args	array(*(char))
,	O
.	O
server	int
=	O
1	int
}	O
;	O
static	O
char	O
*	O
capa	*(struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
[	O
]	O
=	O
{	O
"debug"	*(char)
,	O
"logging"	*(char)
,	O
"mailbox"	*(char)
,	O
"locking"	*(char)
,	O
NULL	O
}	O
;	O
static	O
RETSIGTYPE	void
sig_hup	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
mu_m_server_stop	(int)->(void)
(	O
1	int
)	O
;	O
reload	int
=	O
1	int
;	O
}	O
void	O
comsat_init	()->(void)
(	O
)	O
{	O
int	O
rc	int
;	O
mu_register_all_mbox_formats	O
(	O
)	O
;	O
rc	int
=	O
mu_get_host_name	(*(*(char)))->(int)
(	O
&	O
hostname	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_get_host_name"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTTOU	int
,	O
SIG_IGN	O
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
SIG_IGN	O
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGHUP	int
,	O
SIG_IGN	O
)	O
;	O
}	O
int	O
allow_biffrc	int
=	O
1	int
;	O
unsigned	O
maxrequests	int
=	O
16	int
;	O
time_t	long
request_control_interval	long
=	O
10	int
;	O
time_t	long
overflow_control_interval	long
=	O
10	int
;	O
time_t	long
overflow_delay_time	long
=	O
5	int
;	O
void	O
comsat_process	(*(char),long)->(void)
(	O
char	O
*	O
buffer	*(char)
,	O
size_t	long
rdlen	long
)	O
{	O
char	O
tty	*(char)
[	O
MAX_TTY_SIZE	O
]	O
;	O
char	O
*	O
p	*(char)
;	O
char	O
*	O
path	*(char)
=	O
NULL	O
;	O
mu_message_qid_t	*(char)
qid	*(char)
;	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
buffer	*(char)
,	O
'@'	O
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"malformed input: %s"	*(char)
)	O
,	O
buffer	*(char)
)	O
;	O
return	O
;	O
}	O
*	O
p	*(char)
++	O
=	O
0	int
;	O
qid	*(char)
=	O
p	*(char)
;	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
qid	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
*	O
p	*(char)
++	O
=	O
0	int
;	O
path	*(char)
=	O
p	*(char)
;	O
}	O
if	O
(	O
find_user	(*(char),*(char))->(int)
(	O
buffer	*(char)
,	O
tty	*(char)
)	O
!=	O
SUCCESS	int
)	O
{	O
if	O
(	O
require_tty	int
)	O
return	O
;	O
tty	*(char)
[	O
0	int
]	O
=	O
0	int
;	O
}	O
notify_user	(*(char),*(char),*(char),*(char))->(void)
(	O
buffer	*(char)
,	O
tty	*(char)
,	O
path	*(char)
,	O
qid	*(char)
)	O
;	O
}	O
int	O
comsat_main	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
int	O
rdlen	long
;	O
socklen_t	int
len	int
;	O
struct	O
sockaddr	struct(short,array(char))
fromaddr	struct(short,array(char))
;	O
char	O
buffer	*(char)
[	O
216	int
]	O
;	O
len	int
=	O
sizeof	O
fromaddr	struct(short,array(char))
;	O
rdlen	long
=	O
recvfrom	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(long)
(	O
fd	int
,	O
buffer	*(char)
,	O
sizeof	O
buffer	*(char)
,	O
0	int
,	O
&	O
fromaddr	struct(short,array(char))
,	O
&	O
len	int
)	O
;	O
if	O
(	O
rdlen	long
<=	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
return	O
0	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
"recvfrom: %m"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
buffer	*(char)
[	O
rdlen	long
]	O
=	O
0	int
;	O
if	O
(	O
mu_m_server_check_acl	(*(struct),*(struct(short,array(char))),int)->(int)
(	O
server	int
,	O
&	O
fromaddr	struct(short,array(char))
,	O
len	int
)	O
)	O
return	O
0	int
;	O
comsat_process	(*(char),long)->(void)
(	O
buffer	*(char)
,	O
rdlen	long
)	O
;	O
return	O
0	int
;	O
}	O
static	O
time_t	long
last_request_time	long
;	O
static	O
unsigned	O
reqcount	int
=	O
0	int
;	O
static	O
time_t	long
last_overflow_time	long
;	O
static	O
unsigned	O
overflow_count	int
=	O
0	int
;	O
int	O
comsat_prefork	(int,*(struct(short,array(char))),int,*(struct(*(struct),*(struct),*(struct),int,int,long)),*(void))->(int)
(	O
int	O
fd	int
,	O
struct	O
sockaddr	struct(short,array(char))
*	O
s	*(char)
,	O
int	O
size	*(long)
,	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
*	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
retval	*(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
=	O
0	int
;	O
time_t	long
now	*(long)
;	O
if	O
(	O
maxrequests	int
!=	O
0	int
)	O
{	O
now	*(long)
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
if	O
(	O
reqcount	int
>	O
maxrequests	int
)	O
{	O
unsigned	O
delay	int
;	O
delay	int
=	O
overflow_delay_time	long
<<	O
(	O
overflow_count	int
+	O
1	int
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_NOTICE	O
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"too many requests: pausing for %u second"	*(char)
,	O
"too many requests: pausing for %u seconds"	*(char)
,	O
delay	int
)	O
,	O
delay	int
)	O
;	O
sleep	(int)->(int)
(	O
delay	int
)	O
;	O
reqcount	int
=	O
0	int
;	O
if	O
(	O
now	*(long)
-	O
last_overflow_time	long
<=	O
overflow_control_interval	long
)	O
{	O
if	O
(	O
(	O
overflow_delay_time	long
<<	O
(	O
overflow_count	int
+	O
2	int
)	O
)	O
>	O
overflow_delay_time	long
)	O
++	O
overflow_count	int
;	O
}	O
else	O
overflow_count	int
=	O
0	int
;	O
last_overflow_time	long
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
retval	*(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
=	O
1	int
;	O
}	O
if	O
(	O
now	*(long)
-	O
last_request_time	long
<=	O
request_control_interval	long
)	O
reqcount	int
++	O
;	O
else	O
{	O
last_request_time	long
=	O
now	*(long)
;	O
reqcount	int
=	O
1	int
;	O
}	O
}	O
return	O
retval	*(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
;	O
}	O
int	O
comsat_connection	(int,*(struct(short,array(char))),int,*(struct(*(struct),*(struct),*(struct),int,int,long)),*(void))->(int)
(	O
int	O
fd	int
,	O
struct	O
sockaddr	struct(short,array(char))
*	O
sa	*(struct(short,array(char)))
,	O
int	O
salen	int
,	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
*	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
,	O
void	O
*	O
data	*(void)
)	O
{	O
char	O
*	O
buffer	*(char)
;	O
size_t	long
rdlen	long
,	O
size	*(long)
;	O
if	O
(	O
mu_udp_server_get_rdata	(*(struct),*(*(char)),*(long))->(int)
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
tcpsrv	*(struct)
,	O
&	O
buffer	*(char)
,	O
&	O
rdlen	long
)	O
)	O
return	O
0	int
;	O
if	O
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
transcript	int
)	O
{	O
char	O
*	O
p	*(char)
=	O
mu_sys_sockaddr_to_astr	(*(struct(short,array(char))),int)->(*(char))
(	O
sa	*(struct(short,array(char)))
,	O
salen	int
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"received %lu byte from %s"	*(char)
,	O
"received %lu bytes from %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
rdlen	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
rdlen	long
,	O
p	*(char)
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
"string: %s"	*(char)
,	O
buffer	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
}	O
mu_udp_server_get_bufsize	(*(struct),*(long))->(int)
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
tcpsrv	*(struct)
,	O
&	O
size	*(long)
)	O
;	O
if	O
(	O
size	*(long)
<	O
rdlen	long
+	O
1	int
)	O
{	O
int	O
rc	int
=	O
mu_udp_server_set_bufsize	(*(struct),long)->(int)
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
tcpsrv	*(struct)
,	O
rdlen	long
+	O
1	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot resize buffer: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
buffer	*(char)
[	O
rdlen	long
]	O
=	O
0	int
;	O
comsat_process	(*(char),long)->(void)
(	O
buffer	*(char)
,	O
rdlen	long
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
notify_user	(*(char),*(char),*(char),*(char))->(void)
(	O
const	O
char	O
*	O
user	*(char)
,	O
const	O
char	O
*	O
device	*(char)
,	O
const	O
char	O
*	O
path	*(char)
,	O
mu_message_qid_t	*(char)
qid	*(char)
)	O
{	O
mu_mailbox_t	*(struct)
mbox	*(struct)
=	O
NULL	O
;	O
mu_message_t	*(struct)
msg	*(struct)
;	O
int	O
status	int
;	O
if	O
(	O
change_user	(*(char))->(int)
(	O
user	*(char)
)	O
)	O
return	O
;	O
if	O
(	O
!	O
path	*(char)
)	O
{	O
path	*(char)
=	O
mailbox_path	(*(char))->(*(char))
(	O
user	*(char)
)	O
;	O
if	O
(	O
!	O
path	*(char)
)	O
return	O
;	O
}	O
if	O
(	O
(	O
status	int
=	O
mu_mailbox_create	(*(*(struct)),*(char))->(int)
(	O
&	O
mbox	*(struct)
,	O
path	*(char)
)	O
)	O
!=	O
0	int
||	O
(	O
status	int
=	O
mu_mailbox_open	(*(struct),int)->(int)
(	O
mbox	*(struct)
,	O
MU_STREAM_READ	int
|	O
MU_STREAM_QACCESS	int
)	O
)	O
!=	O
0	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open mailbox %s: %s"	*(char)
)	O
,	O
path	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
return	O
;	O
}	O
status	int
=	O
mu_mailbox_quick_get_message	(*(struct),*(char),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
qid	*(char)
,	O
&	O
msg	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot get message (mailbox %s, qid %s): %s"	*(char)
)	O
,	O
path	*(char)
,	O
qid	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
return	O
;	O
}	O
run_user_action	(*(char),*(struct))->(void)
(	O
device	*(char)
,	O
msg	*(struct)
)	O
;	O
}	O
static	O
int	O
find_user	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
tty	*(char)
)	O
{	O
UTMP	struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char))
*	O
uptr	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
;	O
int	O
status	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
char	O
ftty	array(char)
[	O
MAX_TTY_SIZE	O
]	O
;	O
time_t	long
last_time	long
=	O
0	int
;	O
status	int
=	O
NOT_HERE	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
ftty	array(char)
,	O
"%s/"	*(char)
,	O
PATH_TTY_PFX	O
)	O
;	O
SETUTENT	O
(	O
)	O
;	O
while	O
(	O
(	O
uptr	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
=	O
GETUTENT	O
(	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
uptr	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
->	O
ut_type	short
!=	O
USER_PROCESS	int
)	O
continue	O
;	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
uptr	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
->	O
ut_user	array(char)
,	O
name	*(char)
,	O
sizeof	O
(	O
uptr	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
->	O
ut_user	array(char)
)	O
)	O
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
ftty	array(char)
+	O
sizeof	O
(	O
PATH_DEV	O
)	O
,	O
uptr	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
->	O
ut_line	array(char)
,	O
sizeof	O
(	O
ftty	array(char)
)	O
-	O
sizeof	O
(	O
PATH_DEV	O
)	O
-	O
2	int
)	O
;	O
ftty	array(char)
[	O
sizeof	O
(	O
ftty	array(char)
)	O
-	O
1	int
]	O
=	O
0	int
;	O
mu_normalize_path	(*(char))->(*(char))
(	O
ftty	array(char)
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
ftty	array(char)
,	O
PATH_TTY_PFX	O
,	O
strlen	(*(char))->(long)
(	O
PATH_TTY_PFX	O
)	O
)	O
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ALERT	O
,	O
_	O
(	O
"bad line name in utmp record: %s"	*(char)
)	O
,	O
ftty	array(char)
)	O
;	O
return	O
NOT_HERE	int
;	O
}	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
ftty	array(char)
,	O
&	O
statb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
S_ISCHR	O
(	O
statb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ALERT	O
,	O
_	O
(	O
"not a character device: %s"	*(char)
)	O
,	O
ftty	array(char)
)	O
;	O
return	O
NOT_HERE	int
;	O
}	O
if	O
(	O
!	O
(	O
statb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IEXEC	O
)	O
)	O
{	O
if	O
(	O
status	int
!=	O
SUCCESS	int
)	O
status	int
=	O
PERMISSION_DENIED	int
;	O
continue	O
;	O
}	O
if	O
(	O
statb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_atime	O
>	O
last_time	long
)	O
{	O
last_time	long
=	O
statb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_atime	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
tty	*(char)
,	O
ftty	array(char)
)	O
;	O
status	int
=	O
SUCCESS	int
;	O
}	O
continue	O
;	O
}	O
}	O
}	O
ENDUTENT	O
(	O
)	O
;	O
return	O
status	int
;	O
}	O
int	O
change_user	(*(char))->(int)
(	O
const	O
char	O
*	O
user	*(char)
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
user	*(char)
)	O
;	O
if	O
(	O
!	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_CRIT	O
,	O
_	O
(	O
"no such user: %s"	*(char)
)	O
,	O
user	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
setgid	(int)->(int)
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_gid	int
)	O
;	O
setuid	(int)->(int)
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
)	O
;	O
chdir	(*(char))->(int)
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_dir	*(char)
)	O
;	O
username	*(char)
=	O
user	*(char)
;	O
return	O
0	int
;	O
}	O
char	O
*	O
mailbox_path	(*(char))->(*(char))
(	O
const	O
char	O
*	O
user	*(char)
)	O
{	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
;	O
char	O
*	O
mailbox_name	*(char)
;	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
mu_get_auth_by_name	(*(char))->(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
(	O
user	*(char)
)	O
;	O
if	O
(	O
!	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ALERT	O
,	O
_	O
(	O
"user nonexistent: %s"	*(char)
)	O
,	O
user	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
mailbox_name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
mailbox	*(char)
)	O
;	O
mu_auth_data_free	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(void)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
;	O
return	O
mailbox_name	*(char)
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
c	char
;	O
char	O
*	O
*	O
save_argv	*(*(char))
;	O
MU_APP_INIT_NLS	O
(	O
)	O
;	O
comsat_init	()->(void)
(	O
)	O
;	O
mu_acl_cfg_init	()->(void)
(	O
)	O
;	O
mu_m_server_create	(*(*(struct)),*(char))->(void)
(	O
&	O
server	int
,	O
program_version	*(char)
)	O
;	O
mu_m_server_set_type	(*(struct),int)->(void)
(	O
server	int
,	O
MU_IP_UDP	int
)	O
;	O
mu_m_server_set_conn	(*(struct),*((int,*(struct(short,array(char))),int,*(struct(*`,*`,*`,int,int,long)),*(void))->(int)))->(void)
(	O
server	int
,	O
comsat_connection	(int,*(struct(short,array(char))),int,*(struct(*(struct),*(struct),*(struct),int,int,long)),*(void))->(int)
)	O
;	O
mu_m_server_set_prefork	(*(struct),*((int,*(struct(short,array(char))),int,*(struct(*`,*`,*`,int,int,long)),*(void))->(int)))->(void)
(	O
server	int
,	O
comsat_prefork	(int,*(struct(short,array(char))),int,*(struct(*(struct),*(struct),*(struct),int,int,long)),*(void))->(int)
)	O
;	O
mu_m_server_set_mode	(*(struct),int)->(void)
(	O
server	int
,	O
MODE_INTERACTIVE	int
)	O
;	O
mu_m_server_set_max_children	(*(struct),long)->(void)
(	O
server	int
,	O
20	int
)	O
;	O
mu_m_server_set_default_port	(*(struct),int)->(void)
(	O
server	int
,	O
512	int
)	O
;	O
mu_m_server_cfg_init	(*(struct),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))))->(void)
(	O
server	int
,	O
NULL	O
)	O
;	O
mu_log_syslog	int
=	O
1	int
;	O
save_argv	*(*(char))
=	O
argv	*(*(char))
;	O
mu_cli	(int,*(*(char)),*(struct(*(*(struct`)),*(struct(*`,int,*`,long,*`,*`,*`)),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*`)->(void)))),*(*(char)),*(void),*(int),*(*(*(char))))->(void)
(	O
argc	int
,	O
argv	*(*(char))
,	O
&	O
cli	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
,	O
capa	*(struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*((*(void))->(void))))
,	O
server	int
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
if	O
(	O
test_mode	*(char)
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
char	O
*	O
user	*(char)
;	O
mu_stdstream_strerr_setup	(int)->(int)
(	O
MU_STRERR_STDERR	int
)	O
;	O
biffrc_errors	int
=	O
BIFFRC_ERRORS_TO_ERR	int
;	O
if	O
(	O
argc	int
<	O
2	int
||	O
argc	int
>	O
2	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"mailbox URL and message QID are required in test mode"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
getuid	()->(int)
(	O
)	O
)	O
;	O
if	O
(	O
!	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot determine user name"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
user	*(char)
=	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
;	O
if	O
(	O
biffrc	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
(	O
biffrc	*(char)
[	O
1	int
]	O
==	O
'/'	O
||	O
(	O
biffrc	*(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
biffrc	*(char)
[	O
2	int
]	O
==	O
'/'	O
)	O
)	O
)	O
{	O
char	O
*	O
cwd	short
=	O
mu_getcwd	()->(*(char))
(	O
)	O
;	O
biffrc	*(char)
=	O
mu_make_file_name	O
(	O
cwd	short
,	O
biffrc	*(char)
)	O
;	O
if	O
(	O
!	O
biffrc	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
ENOMEM	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
mu_normalize_path	(*(char))->(*(char))
(	O
biffrc	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cwd	short
)	O
;	O
}	O
notify_user	(*(char),*(char),*(char),*(char))->(void)
(	O
user	*(char)
,	O
test_mode	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
mu_stdstream_strerr_setup	(int)->(int)
(	O
mu_log_syslog	int
?	O
MU_STRERR_SYSLOG	int
:	O
MU_STRERR_STDERR	int
)	O
;	O
if	O
(	O
mu_m_server_mode	(*(struct))->(int)
(	O
server	int
)	O
==	O
MODE_DAEMON	int
)	O
{	O
if	O
(	O
save_argv	*(*(char))
[	O
0	int
]	O
[	O
0	int
]	O
!=	O
'/'	O
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"program name is not absolute; reloading will not "	*(char)
"be possible"	*(char)
)	O
)	O
;	O
else	O
{	O
sigset_t	struct(array(long))
set	struct(array(long))
;	O
mu_m_server_get_sigset	(*(struct),*(struct(array(long))))->(void)
(	O
server	int
,	O
&	O
set	struct(array(long))
)	O
;	O
sigdelset	(*(struct(array(long))),int)->(int)
(	O
&	O
set	struct(array(long))
,	O
SIGHUP	int
)	O
;	O
mu_m_server_set_sigset	(*(struct),*(struct(array(long))))->(void)
(	O
server	int
,	O
&	O
set	struct(array(long))
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGHUP	int
,	O
sig_hup	(int)->(void)
)	O
;	O
}	O
mu_m_server_begin	(*(struct))->(void)
(	O
server	int
)	O
;	O
c	char
=	O
mu_m_server_run	(*(struct))->(int)
(	O
server	int
)	O
;	O
mu_m_server_end	(*(struct))->(void)
(	O
server	int
)	O
;	O
mu_m_server_destroy	(*(*(struct)))->(void)
(	O
&	O
server	int
)	O
;	O
if	O
(	O
reload	int
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"restarting"	*(char)
)	O
)	O
;	O
execvp	(*(char),array(*(char)))->(int)
(	O
save_argv	*(*(char))
[	O
0	int
]	O
,	O
save_argv	*(*(char))
)	O
;	O
}	O
}	O
else	O
{	O
chdir	(*(char))->(int)
(	O
"/"	*(char)
)	O
;	O
c	char
=	O
comsat_main	(int)->(int)
(	O
0	int
)	O
;	O
}	O
return	O
c	char
!=	O
0	int
;	O
}	O
