PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
void	O
)	O
{	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
=	O
(	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
LIST	struct(*(struct(*(void),*(struct(*`,*`)))),*(struct(*(void),*(struct(*`,*`)))),int)
)	O
)	O
;	O
if	O
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
{	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
NULL	O
;	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleTail	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
NULL	O
;	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
iSize	int
=	O
0	int
;	O
}	O
else	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"InitList"	*(char)
,	O
NULL	O
)	O
;	O
return	O
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
;	O
}	O
void	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
*	O
pplist	*(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
,	O
PFV_FREELISTCALLBACK	*((*(void))->(void))
pfvFreeData	*((*(void))->(void))
,	O
BOOL	int
bAndData	int
)	O
{	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
=	O
*	O
pplist	*(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
;	O
if	O
(	O
!	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
return	O
;	O
while	O
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
if	O
(	O
pfvFreeData	*((*(void))->(void))
)	O
(	O
*	O
pfvFreeData	*((*(void))->(void))
)	O
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
pData	*(void)
)	O
;	O
else	O
if	O
(	O
bAndData	int
&&	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
pData	*(void)
)	O
free	(*(void))->(void)
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
pData	*(void)
)	O
;	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleTail	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
pleNext	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
free	(*(void))->(void)
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleTail	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
;	O
*	O
pplist	*(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
=	O
NULL	O
;	O
}	O
void	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
PVOID	*(void)
pData	*(void)
)	O
{	O
PLISTELEM	*(struct(*(void),*(struct(*(void),*(struct`)))))
pNewElem	O
;	O
if	O
(	O
!	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
return	O
;	O
if	O
(	O
!	O
(	O
pNewElem	O
=	O
(	O
PLISTELEM	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
LISTELEM	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
)	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"QueueListItem"	*(char)
,	O
NULL	O
)	O
;	O
pNewElem	O
->	O
pData	*(void)
=	O
pData	*(void)
;	O
pNewElem	O
->	O
pleNext	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleTail	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleTail	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
pleNext	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
pNewElem	O
;	O
else	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
pNewElem	O
;	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleTail	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
pNewElem	O
;	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
iSize	int
++	O
;	O
}	O
int	O
ForAllList	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void))->(int)),*(void))->(int)
(	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
PFI_FORLISTCALLBACK	*((*(void),*(void))->(int))
pfiCallback	*((*(void),*(void),*(void),*(void))->(void))
,	O
PVOID	*(void)
pUserInfo	*(void)
)	O
{	O
int	O
iTotal	O
=	O
0	int
;	O
PLISTELEM	*(struct(*(void),*(struct(*(void),*(struct`)))))
ple	O
;	O
if	O
(	O
!	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
||	O
!	O
pfiCallback	*((*(void),*(void),*(void),*(void))->(void))
)	O
return	O
0	int
;	O
ple	O
=	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
while	O
(	O
ple	O
)	O
{	O
iTotal	O
+=	O
(	O
*	O
pfiCallback	*((*(void),*(void),*(void),*(void))->(void))
)	O
(	O
ple	O
->	O
pData	*(void)
,	O
pUserInfo	*(void)
)	O
;	O
ple	O
=	O
ple	O
->	O
pleNext	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
return	O
(	O
iTotal	O
)	O
;	O
}	O
void	O
ForAllList3	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void),*(void),*(void))->(void)),*(void),*(void),*(void))->(void)
(	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
PFI_FORLISTCALLBACK3	*((*(void),*(void),*(void),*(void))->(void))
pfiCallback	*((*(void),*(void),*(void),*(void))->(void))
,	O
PVOID	*(void)
pUserInfo1	*(void)
,	O
PVOID	*(void)
pUserInfo2	*(void)
,	O
PVOID	*(void)
pUserInfo3	*(void)
)	O
{	O
PLISTELEM	*(struct(*(void),*(struct(*(void),*(struct`)))))
ple	O
;	O
if	O
(	O
!	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
||	O
!	O
pfiCallback	*((*(void),*(void),*(void),*(void))->(void))
)	O
return	O
;	O
ple	O
=	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
while	O
(	O
ple	O
)	O
{	O
(	O
*	O
pfiCallback	*((*(void),*(void),*(void),*(void))->(void))
)	O
(	O
ple	O
->	O
pData	*(void)
,	O
pUserInfo1	*(void)
,	O
pUserInfo2	*(void)
,	O
pUserInfo3	*(void)
)	O
;	O
ple	O
=	O
ple	O
->	O
pleNext	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
}	O
