mu_stream_t	*(struct)
iostream	*(struct)
;	O
void	O
pop3d_parse_command	(*(char),*(*(char)),*(*(char)))->(void)
(	O
char	O
*	O
cmd	enum(int,int,int,int,int)
,	O
char	O
*	O
*	O
pcmd	*(*(char))
,	O
char	O
*	O
*	O
parg	*(*(char))
)	O
{	O
char	O
*	O
p	*(char)
;	O
cmd	enum(int,int,int,int,int)
=	O
mu_str_skip_class	(*(char),int)->(*(char))
(	O
cmd	enum(int,int,int,int,int)
,	O
MU_CTYPE_BLANK	int
)	O
;	O
*	O
pcmd	*(*(char))
=	O
cmd	enum(int,int,int,int,int)
;	O
p	*(char)
=	O
mu_str_skip_class_comp	(*(char),int)->(*(char))
(	O
cmd	enum(int,int,int,int,int)
,	O
MU_CTYPE_SPACE	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
0	int
;	O
if	O
(	O
*	O
p	*(char)
)	O
{	O
*	O
parg	*(*(char))
=	O
p	*(char)
;	O
mu_rtrim_class	(*(char),int)->(long)
(	O
p	*(char)
,	O
MU_CTYPE_SPACE	int
)	O
;	O
}	O
else	O
*	O
parg	*(*(char))
=	O
""	*(char)
;	O
}	O
int	O
pop3d_abquit	(int)->(int)
(	O
int	O
reason	int
)	O
{	O
int	O
code	int
;	O
if	O
(	O
state	*(int)
!=	O
AUTHORIZATION	int
)	O
{	O
mu_mailbox_flush	(*(struct),int)->(int)
(	O
mbox	*(struct)
,	O
0	int
)	O
;	O
mu_mailbox_close	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
;	O
manlock_unlock	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
;	O
mu_mailbox_destroy	(*(*(struct)))->(void)
(	O
&	O
mbox	*(struct)
)	O
;	O
}	O
switch	O
(	O
reason	int
)	O
{	O
case	O
ERR_NO_MEM	int
:	O
code	int
=	O
EX_SOFTWARE	int
;	O
pop3d_outf	(*(char))->(void)
(	O
"-ERR %s\n"	*(char)
,	O
pop3d_error_string	(int)->(*(char))
(	O
reason	int
)	O
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"not enough memory"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_SIGNAL	int
:	O
code	int
=	O
EX_SOFTWARE	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"quitting on signal"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_TERMINATE	int
:	O
code	int
=	O
EX_OK	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"terminating on request"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_TIMEOUT	int
:	O
code	int
=	O
EX_TEMPFAIL	int
;	O
pop3d_outf	(*(char))->(void)
(	O
"-ERR %s\n"	*(char)
,	O
pop3d_error_string	(int)->(*(char))
(	O
reason	int
)	O
)	O
;	O
if	O
(	O
state	*(int)
==	O
TRANSACTION	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"session timed out for user: %s"	*(char)
)	O
,	O
username	*(char)
)	O
;	O
else	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"session timed out for no user"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_NO_IFILE	int
:	O
code	int
=	O
EX_NOINPUT	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"no input stream"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_NO_OFILE	int
:	O
code	int
=	O
EX_IOERR	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"no socket to send to"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_FILE	int
:	O
code	int
=	O
EX_IOERR	int
;	O
break	O
;	O
case	O
ERR_PROTO	int
:	O
code	int
=	O
EX_PROTOCOL	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"remote protocol error"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_IO	int
:	O
code	int
=	O
EX_IOERR	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"I/O error"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_MBOX_SYNC	int
:	O
code	int
=	O
EX_OSERR	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"mailbox was updated by other party: %s"	*(char)
)	O
,	O
username	*(char)
)	O
;	O
pop3d_outf	(*(char))->(void)
(	O
"-ERR [OUT-SYNC] Mailbox updated by other party or corrupt\n"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
code	int
=	O
EX_SOFTWARE	int
;	O
pop3d_outf	(*(char))->(void)
(	O
"-ERR Quitting: %s\n"	*(char)
,	O
pop3d_error_string	(int)->(*(char))
(	O
reason	int
)	O
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"quitting (numeric reason %d)"	*(char)
)	O
,	O
reason	int
)	O
;	O
break	O
;	O
}	O
closelog	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
code	int
)	O
;	O
}	O
static	O
void	O
log_cipher	(*(struct))->(void)
(	O
mu_stream_t	*(struct)
stream	*(struct)
)	O
{	O
mu_property_t	*(struct)
prop	*(struct)
;	O
int	O
rc	int
=	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
stream	*(struct)
,	O
MU_IOCTL_TLSSTREAM	int
,	O
MU_IOCTL_TLS_GET_CIPHER_INFO	int
,	O
&	O
prop	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"TLS established"	*(char)
)	O
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"can't get TLS details: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
else	O
{	O
char	O
const	O
*	O
cipher	*(char)
,	O
*	O
mac	*(char)
,	O
*	O
proto	*(char)
;	O
if	O
(	O
mu_property_sget_value	(*(struct),*(char),*(*(char)))->(int)
(	O
prop	*(struct)
,	O
"cipher"	*(char)
,	O
&	O
cipher	*(char)
)	O
)	O
cipher	*(char)
=	O
"UNKNOWN"	*(char)
;	O
if	O
(	O
mu_property_sget_value	(*(struct),*(char),*(*(char)))->(int)
(	O
prop	*(struct)
,	O
"mac"	*(char)
,	O
&	O
mac	*(char)
)	O
)	O
mac	*(char)
=	O
"UNKNOWN"	*(char)
;	O
if	O
(	O
mu_property_sget_value	(*(struct),*(char),*(*(char)))->(int)
(	O
prop	*(struct)
,	O
"protocol"	*(char)
,	O
&	O
proto	*(char)
)	O
)	O
proto	*(char)
=	O
"UNKNOWN"	*(char)
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"TLS established using %s-%s (%s)"	*(char)
)	O
,	O
cipher	*(char)
,	O
mac	*(char)
,	O
proto	*(char)
)	O
;	O
mu_property_destroy	(*(*(struct)))->(void)
(	O
&	O
prop	*(struct)
)	O
;	O
}	O
}	O
void	O
pop3d_setio	(int,int,*(struct(*(char),*(char),*(char),*(char))))->(void)
(	O
int	O
ifd	int
,	O
int	O
ofd	int
,	O
struct	O
mu_tls_config	struct(*(char),*(char),*(char),*(char))
*	O
tls_conf	*(struct(*(char),*(char),*(char),*(char)))
)	O
{	O
mu_stream_t	*(struct)
str	*(struct)
,	O
istream	*(struct)
,	O
ostream	*(struct)
;	O
if	O
(	O
ifd	int
==	O
-	O
1	int
)	O
pop3d_abquit	(int)->(int)
(	O
ERR_NO_IFILE	int
)	O
;	O
if	O
(	O
ofd	int
==	O
-	O
1	int
)	O
pop3d_abquit	(int)->(int)
(	O
ERR_NO_OFILE	int
)	O
;	O
if	O
(	O
mu_stdio_stream_create	(*(*(struct)),int,int)->(int)
(	O
&	O
istream	*(struct)
,	O
ifd	int
,	O
MU_STREAM_READ	int
)	O
)	O
pop3d_abquit	(int)->(int)
(	O
ERR_NO_IFILE	int
)	O
;	O
mu_stream_set_buffer	(*(struct),enum(int,int,int),long)->(int)
(	O
istream	*(struct)
,	O
mu_buffer_line	int
,	O
0	int
)	O
;	O
if	O
(	O
mu_stdio_stream_create	(*(*(struct)),int,int)->(int)
(	O
&	O
ostream	*(struct)
,	O
ofd	int
,	O
MU_STREAM_WRITE	int
)	O
)	O
pop3d_abquit	(int)->(int)
(	O
ERR_NO_OFILE	int
)	O
;	O
if	O
(	O
tls_conf	*(struct(*(char),*(char),*(char),*(char)))
)	O
{	O
int	O
rc	int
=	O
mu_tls_stream_create	(*(*(struct)),*(struct),*(struct),*(struct(*(char),*(char),*(char),*(char))),enum(int,int),int)->(int)
(	O
&	O
str	*(struct)
,	O
istream	*(struct)
,	O
ostream	*(struct)
,	O
tls_conf	*(struct(*(char),*(char),*(char),*(char)))
,	O
MU_TLS_SERVER	int
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_unref	(*(struct))->(void)
(	O
istream	*(struct)
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
ostream	*(struct)
)	O
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"failed to create TLS stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
pop3d_abquit	(int)->(int)
(	O
ERR_FILE	int
)	O
;	O
}	O
log_cipher	(*(struct))->(void)
(	O
str	*(struct)
)	O
;	O
}	O
else	O
if	O
(	O
mu_iostream_create	(*(*(struct)),*(struct),*(struct))->(int)
(	O
&	O
str	*(struct)
,	O
istream	*(struct)
,	O
ostream	*(struct)
)	O
)	O
pop3d_abquit	(int)->(int)
(	O
ERR_FILE	int
)	O
;	O
if	O
(	O
mu_filter_create	(*(*(struct)),*(struct),*(char),int,int)->(int)
(	O
&	O
iostream	*(struct)
,	O
str	*(struct)
,	O
"CRLF"	*(char)
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_RDTHRU	int
)	O
)	O
pop3d_abquit	(int)->(int)
(	O
ERR_NO_IFILE	int
)	O
;	O
mu_stream_set_buffer	(*(struct),enum(int,int,int),long)->(int)
(	O
iostream	*(struct)
,	O
mu_buffer_line	int
,	O
0	int
)	O
;	O
if	O
(	O
pop3d_transcript	int
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
dstr	*(struct)
,	O
xstr	*(struct)
;	O
rc	int
=	O
mu_dbgstream_create	(*(*(struct)),int)->(int)
(	O
&	O
dstr	*(struct)
,	O
MU_DIAG_DEBUG	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create debug stream; transcript disabled: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
else	O
{	O
rc	int
=	O
mu_xscript_stream_create	(*(*(struct)),*(struct),*(struct),array(*(char)))->(int)
(	O
&	O
xstr	*(struct)
,	O
iostream	*(struct)
,	O
dstr	*(struct)
,	O
NULL	O
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
dstr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create transcript stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
else	O
{	O
mu_stream_unref	(*(struct))->(void)
(	O
iostream	*(struct)
)	O
;	O
iostream	*(struct)
=	O
xstr	*(struct)
;	O
}	O
}	O
}	O
}	O
int	O
pop3d_init_tls_server	(*(struct(*(char),*(char),*(char),*(char))))->(int)
(	O
struct	O
mu_tls_config	struct(*(char),*(char),*(char),*(char))
*	O
tls_conf	*(struct(*(char),*(char),*(char),*(char)))
)	O
{	O
mu_stream_t	*(struct)
tlsstream	*(struct)
,	O
stream	*(struct)
[	O
2	int
]	O
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
iostream	*(struct)
,	O
MU_IOCTL_SUBSTREAM	int
,	O
MU_IOCTL_OP_GET	int
,	O
stream	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s failed: %s"	*(char)
)	O
,	O
"MU_IOCTL_GET_STREAM"	*(char)
,	O
mu_stream_strerror	(*(struct),int)->(*(char))
(	O
iostream	*(struct)
,	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_tls_stream_create	(*(*(struct)),*(struct),*(struct),*(struct(*(char),*(char),*(char),*(char))),enum(int,int),int)->(int)
(	O
&	O
tlsstream	*(struct)
,	O
stream	*(struct)
[	O
0	int
]	O
,	O
stream	*(struct)
[	O
1	int
]	O
,	O
tls_conf	*(struct(*(char),*(char),*(char),*(char)))
,	O
MU_TLS_SERVER	int
,	O
0	int
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
stream	*(struct)
[	O
0	int
]	O
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
stream	*(struct)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
1	int
;	O
log_cipher	(*(struct))->(void)
(	O
tlsstream	*(struct)
)	O
;	O
stream	*(struct)
[	O
0	int
]	O
=	O
stream	*(struct)
[	O
1	int
]	O
=	O
tlsstream	*(struct)
;	O
rc	int
=	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
iostream	*(struct)
,	O
MU_IOCTL_SUBSTREAM	int
,	O
MU_IOCTL_OP_SET	int
,	O
stream	*(struct)
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
stream	*(struct)
[	O
0	int
]	O
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
stream	*(struct)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s failed: %s"	*(char)
)	O
,	O
"MU_IOCTL_SET_STREAM"	*(char)
,	O
mu_stream_strerror	(*(struct),int)->(*(char))
(	O
iostream	*(struct)
,	O
rc	int
)	O
)	O
;	O
pop3d_abquit	(int)->(int)
(	O
ERR_IO	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
pop3d_bye	()->(void)
(	O
)	O
{	O
mu_stream_close	(*(struct))->(int)
(	O
iostream	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
iostream	*(struct)
)	O
;	O
}	O
void	O
pop3d_flush_output	()->(void)
(	O
)	O
{	O
mu_stream_flush	(*(struct))->(int)
(	O
iostream	*(struct)
)	O
;	O
}	O
int	O
pop3d_is_master	()->(int)
(	O
)	O
{	O
return	O
iostream	*(struct)
==	O
NULL	O
;	O
}	O
void	O
pop3d_outf	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
int	O
rc	int
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
rc	int
=	O
mu_stream_vprintf	(*(struct),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
iostream	*(struct)
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"Write failed: %s"	*(char)
)	O
,	O
mu_stream_strerror	(*(struct),int)->(*(char))
(	O
iostream	*(struct)
,	O
rc	int
)	O
)	O
;	O
pop3d_abquit	(int)->(int)
(	O
ERR_IO	int
)	O
;	O
}	O
}	O
char	O
*	O
pop3d_readline	(*(char),long)->(*(char))
(	O
char	O
*	O
buffer	*(char)
,	O
size_t	long
size	long
)	O
{	O
int	O
rc	int
;	O
size_t	long
nbytes	long
;	O
alarm	(int)->(int)
(	O
idle_timeout	int
)	O
;	O
rc	int
=	O
mu_stream_readline	(*(struct),*(char),long,*(long))->(int)
(	O
iostream	*(struct)
,	O
buffer	*(char)
,	O
size	long
,	O
&	O
nbytes	long
)	O
;	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"Read failed: %s"	*(char)
)	O
,	O
mu_stream_strerror	(*(struct),int)->(*(char))
(	O
iostream	*(struct)
,	O
rc	int
)	O
)	O
;	O
pop3d_abquit	(int)->(int)
(	O
ERR_IO	int
)	O
;	O
}	O
else	O
if	O
(	O
nbytes	long
==	O
0	int
)	O
{	O
if	O
(	O
state	*(int)
==	O
AUTHORIZATION	int
)	O
exit	(int)->(void)
(	O
EX_OK	int
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"Unexpected eof on input"	*(char)
)	O
)	O
;	O
pop3d_abquit	(int)->(int)
(	O
ERR_PROTO	int
)	O
;	O
}	O
return	O
buffer	*(char)
;	O
}	O
void	O
pop3d_mark_deleted	(*(struct))->(void)
(	O
mu_attribute_t	*(struct)
attr	*(struct)
)	O
{	O
mu_attribute_set_userflag	(*(struct),int)->(int)
(	O
attr	*(struct)
,	O
POP3_ATTRIBUTE_DELE	int
)	O
;	O
}	O
int	O
pop3d_is_deleted	(*(struct))->(int)
(	O
mu_attribute_t	*(struct)
attr	*(struct)
)	O
{	O
return	O
mu_attribute_is_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
||	O
mu_attribute_is_userflag	(*(struct),int)->(int)
(	O
attr	*(struct)
,	O
POP3_ATTRIBUTE_DELE	int
)	O
;	O
}	O
void	O
pop3d_unset_deleted	(*(struct))->(void)
(	O
mu_attribute_t	*(struct)
attr	*(struct)
)	O
{	O
if	O
(	O
mu_attribute_is_userflag	(*(struct),int)->(int)
(	O
attr	*(struct)
,	O
POP3_ATTRIBUTE_DELE	int
)	O
)	O
mu_attribute_unset_userflag	(*(struct),int)->(int)
(	O
attr	*(struct)
,	O
POP3_ATTRIBUTE_DELE	int
)	O
;	O
}	O
void	O
pop3d_undelete_all	()->(void)
(	O
)	O
{	O
size_t	long
i	long
;	O
size_t	long
total	array(int)
=	O
0	int
;	O
mu_mailbox_messages_count	(*(struct),*(long))->(int)
(	O
mbox	*(struct)
,	O
&	O
total	array(int)
)	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<=	O
total	array(int)
;	O
i	long
++	O
)	O
{	O
mu_message_t	*(struct)
msg	*(struct)
=	O
NULL	O
;	O
mu_attribute_t	*(struct)
attr	*(struct)
=	O
NULL	O
;	O
mu_mailbox_get_message	(*(struct),long,*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
i	long
,	O
&	O
msg	*(struct)
)	O
;	O
mu_message_get_attribute	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
attr	*(struct)
)	O
;	O
mu_attribute_unset_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
;	O
}	O
}	O
int	O
set_xscript_level	(int)->(int)
(	O
int	O
xlev	int
)	O
{	O
if	O
(	O
pop3d_transcript	int
)	O
{	O
if	O
(	O
xlev	int
!=	O
MU_XSCRIPT_NORMAL	int
)	O
{	O
if	O
(	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_REMOTE	int
,	O
xlev	int
==	O
MU_XSCRIPT_SECURE	int
?	O
MU_DEBUG_TRACE6	int
:	O
MU_DEBUG_TRACE7	int
)	O
)	O
return	O
MU_XSCRIPT_NORMAL	int
;	O
}	O
if	O
(	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
iostream	*(struct)
,	O
MU_IOCTL_XSCRIPTSTREAM	int
,	O
MU_IOCTL_XSCRIPTSTREAM_LEVEL	int
,	O
&	O
xlev	int
)	O
==	O
0	int
)	O
return	O
xlev	int
;	O
}	O
return	O
0	int
;	O
}	O
