int	O
imap4d_bye	(int)->(int)
(	O
int	O
reason	int
)	O
{	O
return	O
imap4d_bye_command	(int,*(struct(*(char),*((*`,*`,*`)->(int)),int,int,int,*(char))))->(int)
(	O
reason	int
,	O
NULL	O
)	O
;	O
}	O
static	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
pipejmp	array(struct(array(long),int,struct(array(long))))
;	O
static	O
RETSIGTYPE	void
sigpipe	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
pipejmp	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
int	O
imap4d_bye_command	(int,*(struct(*(char),*((*`,*`,*`)->(int)),int,int,int,*(char))))->(int)
(	O
int	O
reason	int
,	O
struct	O
imap4d_command	struct(*(char),*((*(struct),*(struct(*(char),*((*`,*`,*`)->(int)),int,int,int,*(char))),*(struct))->(int)),int,int,int,*(char))
*	O
command	*(char)
)	O
{	O
int	O
status	int
=	O
EX_SOFTWARE	int
;	O
static	O
int	O
sigtab	array(int)
[	O
]	O
=	O
{	O
SIGPIPE	int
}	O
;	O
mu_set_signals	(*((int)->(void)),*(int),int)->(void)
(	O
sigpipe	(int)->(void)
,	O
sigtab	array(int)
,	O
MU_ARRAY_SIZE	O
(	O
sigtab	array(int)
)	O
)	O
;	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
pipejmp	array(struct(array(long),int,struct(array(long))))
)	O
)	O
{	O
mu_set_signals	(*((int)->(void)),*(int),int)->(void)
(	O
SIG_IGN	O
,	O
sigtab	array(int)
,	O
MU_ARRAY_SIZE	O
(	O
sigtab	array(int)
)	O
)	O
;	O
iostream	*(struct)
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
mbox	*(struct)
)	O
{	O
imap4d_enter_critical	()->(void)
(	O
)	O
;	O
mu_mailbox_flush	(*(struct),int)->(int)
(	O
mbox	*(struct)
,	O
0	int
)	O
;	O
mu_mailbox_close	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
;	O
manlock_unlock	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
;	O
mu_mailbox_destroy	(*(*(struct)))->(void)
(	O
&	O
mbox	*(struct)
)	O
;	O
imap4d_leave_critical	()->(void)
(	O
)	O
;	O
}	O
switch	O
(	O
reason	int
)	O
{	O
case	O
ERR_NO_MEM	int
:	O
io_untagged_response	(int,*(char))->(int)
(	O
RESP_BYE	int
,	O
"Server terminating: no more resources."	*(char)
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"not enough memory"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_TERMINATE	int
:	O
status	int
=	O
EX_OK	int
;	O
io_untagged_response	(int,*(char))->(int)
(	O
RESP_BYE	int
,	O
"Server terminating on request."	*(char)
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"terminating on request"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_SIGNAL	int
:	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"quitting on signal"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
case	O
ERR_TIMEOUT	int
:	O
status	int
=	O
EX_TEMPFAIL	int
;	O
io_untagged_response	(int,*(char))->(int)
(	O
RESP_BYE	int
,	O
"Session timed out"	*(char)
)	O
;	O
if	O
(	O
state	*(int)
==	O
STATE_NONAUTH	O
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"session timed out for no user"	*(char)
)	O
)	O
;	O
else	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"session timed out for user: %s"	*(char)
)	O
,	O
auth_data	*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))
->	O
name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_NO_OFILE	int
:	O
status	int
=	O
EX_IOERR	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"write error on control stream"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_NO_IFILE	int
:	O
status	int
=	O
EX_IOERR	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"read error on control stream"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_MAILBOX_CORRUPTED	int
:	O
status	int
=	O
EX_OSERR	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"mailbox modified by third party"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
ERR_STREAM_CREATE	int
:	O
status	int
=	O
EX_UNAVAILABLE	int
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"cannot create transport stream"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OK	int
:	O
status	int
=	O
EX_OK	int
;	O
io_untagged_response	(int,*(char))->(int)
(	O
RESP_BYE	int
,	O
"Session terminating."	*(char)
)	O
;	O
if	O
(	O
state	*(int)
==	O
STATE_NONAUTH	O
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"session terminating"	*(char)
)	O
)	O
;	O
else	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"session terminating for user: %s"	*(char)
)	O
,	O
auth_data	*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int))
->	O
name	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
io_untagged_response	(int,*(char))->(int)
(	O
RESP_BYE	int
,	O
"Quitting (reason unknown)"	*(char)
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"quitting (numeric reason %d)"	*(char)
)	O
,	O
reason	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
status	int
==	O
EX_OK	int
&&	O
command	*(char)
)	O
io_completion_response	(*(struct(*(char),*((*`,*`,*`)->(int)),int,int,int,*(char))),int,*(char))->(int)
(	O
command	*(char)
,	O
RESP_OK	int
,	O
"Completed"	*(char)
)	O
;	O
}	O
util_bye	()->(void)
(	O
)	O
;	O
closelog	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
