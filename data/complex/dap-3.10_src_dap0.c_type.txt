dataobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
3	int
]	O
;	O
dataobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
;	O
static	O
dataobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
;	O
static	O
RFILE	struct(*(char),*(char),*(char))
*	O
rfile	*(struct(*(char),*(char),*(char)))
;	O
static	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
;	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
3	int
]	O
;	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
3	int
]	O
;	O
FILE	struct
*	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
FILE	struct
*	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
FILE	struct
*	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
dap_ono	int
;	O
int	O
dap_delim	int
;	O
static	O
int	O
*	O
fieldwd	*(int)
;	O
static	O
int	O
nfields	int
;	O
static	O
int	O
lineno	array(int)
[	O
2	int
]	O
;	O
static	O
int	O
outline	int
;	O
static	O
int	O
pageno	int
;	O
static	O
int	O
eof	array(int)
[	O
2	int
]	O
;	O
static	O
long	O
filepos	array(long)
[	O
2	int
]	O
;	O
static	O
int	O
intype	int
;	O
static	O
int	O
inlen	int
;	O
static	O
int	O
toolong	int
;	O
char	O
*	O
dap_title	*(char)
=	O
NULL	O
;	O
char	O
*	O
dap_dapname	*(char)
;	O
char	O
*	O
dap_psname	*(char)
;	O
extern	O
int	O
dap_dblhigh	int
;	O
extern	O
int	O
dap_dbllow	int
;	O
extern	O
double	O
dap_double	double
;	O
static	O
int	O
nmallocs	int
=	O
0	int
;	O
static	O
int	O
nfrees	int
=	O
0	int
;	O
char	O
*	O
dap_malloc	(int,*(char))->(*(char))
(	O
int	O
nbytes	int
,	O
char	O
*	O
mesg	*(char)
)	O
{	O
char	O
*	O
m	*(char)
;	O
nmallocs	int
++	O
;	O
if	O
(	O
!	O
(	O
m	*(char)
=	O
malloc	(long)->(*(void))
(	O
nbytes	int
)	O
)	O
)	O
{	O
perror	(*(char))->(void)
(	O
dap_dapname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dap_memtrace	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"malloc %x %s\n"	*(char)
,	O
(	O
unsigned	O
int	O
)	O
m	*(char)
,	O
mesg	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
dap_mabort	int
&&	O
m	*(char)
==	O
dap_memtrace	*(char)
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
return	O
m	*(char)
;	O
}	O
void	O
dap_free	(*(void),*(char))->(void)
(	O
void	O
*	O
ptr	*(void)
,	O
char	O
*	O
mesg	*(char)
)	O
{	O
nfrees	int
++	O
;	O
if	O
(	O
dap_memtrace	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"free %x %s\n"	*(char)
,	O
(	O
unsigned	O
int	O
)	O
ptr	*(void)
,	O
mesg	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
dap_fabort	int
&&	O
ptr	*(void)
==	O
dap_memtrace	*(char)
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
ptr	*(void)
)	O
;	O
}	O
static	O
void	O
initdo	(*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)))->(void)
(	O
dataobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
*	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
)	O
{	O
int	O
d	int
;	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_int	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_int"	*(char)
)	O
;	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_il	*(*(int))
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_il"	*(char)
)	O
;	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_dbl	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_dbl"	*(char)
)	O
;	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_dl	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_dl"	*(char)
)	O
;	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_str	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_str"	*(char)
)	O
;	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_sl	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_sl"	*(char)
)	O
;	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_nam	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_nam"	*(char)
)	O
;	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_len	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_len"	*(char)
)	O
;	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_in	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_in"	*(char)
)	O
;	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_out	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_out"	*(char)
)	O
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dap_maxvar	int
;	O
d	int
++	O
)	O
{	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_str	*(*(char))
[	O
d	int
]	O
=	O
NULL	O
;	O
dato	*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
->	O
do_nam	*(*(char))
[	O
d	int
]	O
=	O
NULL	O
;	O
}	O
}	O
static	O
double	O
testd	double
;	O
static	O
unsigned	O
int	O
*	O
ptesti	*(int)
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
char	O
*	O
lstname	*(char)
;	O
char	O
*	O
logname	*(char)
;	O
char	O
*	O
errname	*(char)
;	O
int	O
len	int
;	O
int	O
v	int
;	O
dap_dapname	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
lstname	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	int
+	O
5	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
lstname	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
len	int
>=	O
4	int
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
lstname	*(char)
+	O
len	int
-	O
4	int
,	O
".dap"	*(char)
)	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
lstname	*(char)
+	O
len	int
-	O
3	int
,	O
"lst"	*(char)
)	O
;	O
else	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
lstname	*(char)
,	O
".lst"	*(char)
)	O
;	O
len	int
+=	O
4	int
;	O
}	O
if	O
(	O
!	O
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
lstname	*(char)
,	O
"a"	*(char)
)	O
)	O
)	O
{	O
perror	(*(char))->(void)
(	O
dap_dapname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
logname	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
logname	*(char)
,	O
lstname	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
logname	*(char)
+	O
len	int
-	O
3	int
,	O
"log"	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
logname	*(char)
,	O
"w"	*(char)
)	O
)	O
)	O
{	O
perror	(*(char))->(void)
(	O
dap_dapname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
errname	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
errname	*(char)
,	O
lstname	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
errname	*(char)
+	O
len	int
-	O
3	int
,	O
"err"	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
errname	*(char)
,	O
"w"	*(char)
)	O
)	O
)	O
{	O
perror	(*(char))->(void)
(	O
dap_dapname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
initdo	(*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
)	O
;	O
initdo	(*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
+	O
1	int
)	O
;	O
initdo	(*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
+	O
2	int
)	O
;	O
initdo	(*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)))->(void)
(	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
)	O
;	O
initdo	(*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)))->(void)
(	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
+	O
1	int
)	O
;	O
initdo	(*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)))->(void)
(	O
&	O
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
)	O
;	O
rfile	*(struct(*(char),*(char),*(char)))
=	O
(	O
RFILE	struct(*(char),*(char),*(char))
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
RFILE	struct(*(char),*(char),*(char))
)	O
*	O
dap_nrfiles	int
,	O
"main: rfile"	*(char)
)	O
;	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
)	O
*	O
(	O
dap_nrfiles	int
+	O
NDFILES	int
)	O
,	O
"main: dfile"	*(char)
)	O
;	O
pageno	int
=	O
1	int
;	O
dap_psname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
len	int
+	O
1	int
,	O
"main: dap_psname"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_psname	*(char)
,	O
lstname	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_psname	*(char)
+	O
len	int
-	O
3	int
,	O
"ps"	*(char)
)	O
;	O
dap_initpict	()->(void)
(	O
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxvar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
dap_ono	int
=	O
0	int
;	O
dap_ono	int
<	O
3	int
;	O
dap_ono	int
++	O
)	O
{	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_sl	*(int)
[	O
v	int
]	O
=	O
0	int
;	O
if	O
(	O
dap_ono	int
<	O
2	int
)	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
=	O
NULL	O
;	O
}	O
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_str	*(*(char))
[	O
v	int
]	O
=	O
NULL	O
;	O
}	O
dap_ono	int
=	O
0	int
;	O
testd	double
=	O
-	O
2.0	int
;	O
ptesti	*(int)
=	O
(	O
int	O
*	O
)	O
&	O
testd	double
;	O
if	O
(	O
!	O
(	O
*	O
ptesti	*(int)
)	O
)	O
{	O
dap_dbllow	int
=	O
0	int
;	O
dap_dblhigh	int
=	O
1	int
;	O
}	O
else	O
{	O
dap_dbllow	int
=	O
1	int
;	O
dap_dblhigh	int
=	O
0	int
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
3	int
;	O
v	int
++	O
)	O
{	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
v	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
v	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
}	O
dap_main	()->(int)
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
FILE	struct
*	O
dopen	(array(char),array(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
char	O
fname	array(char)
[	O
]	O
,	O
char	O
mode	array(char)
[	O
]	O
)	O
{	O
char	O
*	O
dname	array(char)
;	O
FILE	struct
*	O
f	*(()->(double))
;	O
dname	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
dap_setdir	*(char)
)	O
+	O
2	int
,	O
"dopen: dname"	*(char)
)	O
;	O
dap_name	(array(char),array(char))->(void)
(	O
dname	array(char)
,	O
fname	array(char)
)	O
;	O
f	*(()->(double))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
dname	array(char)
,	O
mode	array(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
dname	array(char)
,	O
"dopen: dname"	*(char)
)	O
;	O
return	O
f	*(()->(double))
;	O
}	O
static	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
dfopen	(*(char),*(char))->(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
mode	array(char)
)	O
{	O
static	O
int	O
rfileinit	int
=	O
0	int
;	O
int	O
f	*(()->(double))
;	O
char	O
truemode	array(char)
[	O
2	int
]	O
;	O
if	O
(	O
!	O
rfileinit	int
)	O
{	O
rfileinit	int
=	O
1	int
;	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f	*(()->(double))
<	O
dap_nrfiles	int
;	O
f	*(()->(double))
++	O
)	O
{	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
f	*(()->(double))
]	O
.	O
dfile_name	*(char)
=	O
NULL	O
;	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
f	*(()->(double))
]	O
.	O
dfile_ram	*(struct(*(char),*(char),*(char)))
=	O
rfile	*(struct(*(char),*(char),*(char)))
+	O
f	*(()->(double))
;	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
f	*(()->(double))
]	O
.	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_str	*(char)
=	O
NULL	O
;	O
}	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f	*(()->(double))
<	O
NDFILES	int
;	O
f	*(()->(double))
++	O
)	O
{	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
f	*(()->(double))
]	O
.	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
f	*(()->(double))
]	O
.	O
dfile_ram	*(struct(*(char),*(char),*(char)))
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
!	O
fname	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(dfopen) no file name given\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fname	array(char)
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
mode	array(char)
,	O
"r"	*(char)
)	O
)	O
{	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f	*(()->(double))
<	O
dap_nrfiles	int
;	O
f	*(()->(double))
++	O
)	O
{	O
if	O
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
f	*(()->(double))
]	O
.	O
dfile_name	*(char)
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
f	*(()->(double))
]	O
.	O
dfile_name	*(char)
,	O
fname	array(char)
+	O
1	int
)	O
)	O
{	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_pos	*(char)
=	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_str	*(char)
;	O
return	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
+	O
NDFILES	int
+	O
f	*(()->(double))
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
mode	array(char)
,	O
"w"	*(char)
)	O
)	O
{	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f	*(()->(double))
<	O
dap_nrfiles	int
;	O
f	*(()->(double))
++	O
)	O
{	O
if	O
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
f	*(()->(double))
]	O
.	O
dfile_name	*(char)
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
f	*(()->(double))
]	O
.	O
dfile_name	*(char)
,	O
fname	array(char)
+	O
1	int
)	O
)	O
{	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_end	*(char)
=	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_str	*(char)
;	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_pos	*(char)
=	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_str	*(char)
;	O
return	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
+	O
NDFILES	int
+	O
f	*(()->(double))
;	O
}	O
}	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f	*(()->(double))
<	O
dap_nrfiles	int
;	O
f	*(()->(double))
++	O
)	O
{	O
if	O
(	O
!	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
f	*(()->(double))
]	O
.	O
dfile_name	*(char)
)	O
{	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_str	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_rfilesize	int
,	O
"dfopen: rfile[f].rfile_str"	*(char)
)	O
;	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
f	*(()->(double))
]	O
.	O
dfile_name	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
,	O
"dfopen: dfile[NDFILES + f].dfile_name"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
f	*(()->(double))
]	O
.	O
dfile_name	*(char)
,	O
fname	array(char)
+	O
1	int
)	O
;	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_end	*(char)
=	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_str	*(char)
;	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_pos	*(char)
=	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_str	*(char)
;	O
return	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
+	O
NDFILES	int
+	O
f	*(()->(double))
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
mode	array(char)
,	O
"a"	*(char)
)	O
)	O
{	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f	*(()->(double))
<	O
dap_nrfiles	int
;	O
f	*(()->(double))
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
f	*(()->(double))
]	O
.	O
dfile_name	*(char)
,	O
fname	array(char)
+	O
1	int
)	O
)	O
{	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_pos	*(char)
=	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
f	*(()->(double))
]	O
.	O
rfile_end	*(char)
;	O
return	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
+	O
NDFILES	int
+	O
f	*(()->(double))
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dfopen) bad mode: %s\n"	*(char)
,	O
mode	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f	*(()->(double))
<	O
NDFILES	int
;	O
f	*(()->(double))
++	O
)	O
{	O
if	O
(	O
!	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
f	*(()->(double))
]	O
.	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
if	O
(	O
mode	array(char)
[	O
1	int
]	O
==	O
'f'	O
)	O
{	O
truemode	array(char)
[	O
0	int
]	O
=	O
mode	array(char)
[	O
0	int
]	O
;	O
truemode	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
f	*(()->(double))
]	O
.	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fname	array(char)
,	O
truemode	array(char)
)	O
;	O
}	O
else	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
f	*(()->(double))
]	O
.	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
dopen	(array(char),array(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fname	array(char)
,	O
mode	array(char)
)	O
;	O
if	O
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
f	*(()->(double))
]	O
.	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
f	*(()->(double))
]	O
.	O
dfile_name	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
1	int
,	O
"dfopen: dfile[f].dfile_name"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
f	*(()->(double))
]	O
.	O
dfile_name	*(char)
,	O
fname	array(char)
)	O
;	O
return	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
+	O
f	*(()->(double))
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
{	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
}	O
else	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_pos	*(char)
=	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
;	O
}	O
static	O
int	O
dgetc	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
{	O
int	O
c	int
;	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_pos	*(char)
<	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_end	*(char)
)	O
c	int
=	O
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_pos	*(char)
++	O
;	O
else	O
c	int
=	O
EOF	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
undgetc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
int	O
c	int
,	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
{	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_pos	*(char)
>	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
)	O
{	O
--	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_pos	*(char)
;	O
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_pos	*(char)
=	O
c	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(undgetc) can't unget past beginning of file %s\n"	*(char)
,	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
void	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
int	O
c	int
,	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
{	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_pos	*(char)
<	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
+	O
dap_rfilesize	int
)	O
{	O
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_pos	*(char)
++	O
=	O
c	int
;	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_end	*(char)
++	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_putc) too many characters: %s\n"	*(char)
,	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
dputs	(*(char),*(char),*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
char	O
*	O
s	*(char)
,	O
char	O
*	O
suff	array(char)
,	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
{	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
s	*(char)
,	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
suff	array(char)
,	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
while	O
(	O
*	O
s	*(char)
)	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
*	O
s	*(char)
++	O
,	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
;	O
while	O
(	O
*	O
suff	array(char)
)	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
*	O
suff	array(char)
++	O
,	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
;	O
}	O
}	O
static	O
void	O
dputi	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
int	O
i	int
,	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
{	O
static	O
char	O
*	O
istr	*(char)
=	O
NULL	O
;	O
int	O
s	*(char)
;	O
if	O
(	O
!	O
istr	*(char)
)	O
istr	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_intlen	int
+	O
1	int
,	O
"dputi: istr"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d"	*(char)
,	O
i	int
)	O
;	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
istr	*(char)
,	O
"%d"	*(char)
,	O
i	int
)	O
;	O
for	O
(	O
s	*(char)
=	O
0	int
;	O
s	*(char)
<	O
strlen	(*(char))->(long)
(	O
istr	*(char)
)	O
;	O
s	*(char)
++	O
)	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
istr	*(char)
[	O
s	*(char)
]	O
,	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
;	O
}	O
}	O
static	O
void	O
dflush	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
{	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
dap_suffix	(array(char),array(char),array(char))->(void)
(	O
char	O
dst	array(char)
[	O
]	O
,	O
char	O
src	array(char)
[	O
]	O
,	O
char	O
suff	array(char)
[	O
]	O
)	O
{	O
int	O
n	int
,	O
s	*(char)
;	O
for	O
(	O
n	int
=	O
0	int
;	O
src	array(char)
[	O
n	int
]	O
;	O
n	int
++	O
)	O
dst	array(char)
[	O
n	int
]	O
=	O
src	array(char)
[	O
n	int
]	O
;	O
if	O
(	O
suff	array(char)
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
while	O
(	O
--	O
n	int
>=	O
0	int
)	O
{	O
if	O
(	O
dst	array(char)
[	O
n	int
]	O
==	O
'.'	O
)	O
break	O
;	O
}	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_suffix) source name has no '.': %s\n"	*(char)
,	O
src	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
n	int
++	O
;	O
s	*(char)
=	O
1	int
;	O
}	O
else	O
s	*(char)
=	O
0	int
;	O
for	O
(	O
;	O
suff	array(char)
[	O
s	*(char)
]	O
;	O
s	*(char)
++	O
)	O
dst	array(char)
[	O
n	int
++	O
]	O
=	O
suff	array(char)
[	O
s	*(char)
]	O
;	O
dst	array(char)
[	O
n	int
]	O
=	O
'\0'	O
;	O
}	O
int	O
dap_varnum	(array(char))->(int)
(	O
char	O
*	O
vname	array(char)
)	O
{	O
int	O
v	int
;	O
int	O
nonblank	int
;	O
while	O
(	O
*	O
vname	array(char)
==	O
' '	O
)	O
vname	array(char)
++	O
;	O
for	O
(	O
nonblank	int
=	O
0	int
;	O
vname	array(char)
[	O
nonblank	int
]	O
&&	O
vname	array(char)
[	O
nonblank	int
]	O
!=	O
' '	O
;	O
nonblank	int
++	O
)	O
;	O
if	O
(	O
vname	array(char)
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
vname	array(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
,	O
nonblank	int
)	O
&&	O
!	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
[	O
nonblank	int
]	O
)	O
return	O
v	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
dap_arrnum	(array(char),*(int))->(int)
(	O
char	O
vname	array(char)
[	O
]	O
,	O
int	O
*	O
dim	*(int)
)	O
{	O
int	O
v	int
;	O
int	O
n	int
;	O
int	O
d	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
vname	array(char)
[	O
n	int
]	O
&&	O
vname	array(char)
[	O
n	int
]	O
==	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
[	O
n	int
]	O
;	O
n	int
++	O
)	O
;	O
if	O
(	O
!	O
vname	array(char)
[	O
n	int
]	O
&&	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
[	O
n	int
]	O
==	O
'['	O
)	O
{	O
for	O
(	O
d	int
=	O
1	int
;	O
v	int
+	O
d	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
d	int
++	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
vname	array(char)
[	O
n	int
]	O
&&	O
vname	array(char)
[	O
n	int
]	O
==	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
+	O
d	int
]	O
[	O
n	int
]	O
;	O
n	int
++	O
)	O
;	O
if	O
(	O
vname	array(char)
[	O
n	int
]	O
||	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
+	O
d	int
]	O
[	O
n	int
]	O
!=	O
'['	O
)	O
break	O
;	O
}	O
*	O
dim	*(int)
=	O
d	int
;	O
return	O
v	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
dap_getline	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))),*(char))->(int)
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
,	O
char	O
*	O
line	*(char)
)	O
{	O
int	O
l	int
;	O
int	O
c	int
;	O
int	O
cc	int
;	O
c	int
=	O
EOF	O
;	O
switch	O
(	O
intype	int
)	O
{	O
case	O
TEXT	int
:	O
case	O
DSET	int
:	O
for	O
(	O
l	int
=	O
0	int
;	O
(	O
c	int
=	O
dgetc	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
)	O
!=	O
EOF	O
;	O
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
else	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
{	O
if	O
(	O
(	O
cc	int
=	O
dgetc	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
)	O
!=	O
'\n'	O
)	O
undgetc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
cc	int
,	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
;	O
break	O
;	O
}	O
if	O
(	O
l	int
<	O
dap_linelen	int
)	O
line	*(char)
[	O
l	int
++	O
]	O
=	O
c	int
;	O
else	O
{	O
line	*(char)
[	O
l	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_getline) line too long:\n%s\n"	*(char)
,	O
line	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
line	*(char)
[	O
l	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
DBASE	int
:	O
dgetc	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
inlen	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
dgetc	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
)	O
==	O
EOF	O
)	O
break	O
;	O
else	O
line	*(char)
[	O
l	int
]	O
=	O
c	int
;	O
}	O
if	O
(	O
l	int
<	O
inlen	int
)	O
l	int
=	O
0	int
;	O
line	*(char)
[	O
l	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_getline) bad infile type: %d\n"	*(char)
,	O
intype	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
l	int
&&	O
c	int
==	O
EOF	O
)	O
return	O
-	O
1	int
;	O
return	O
l	int
;	O
}	O
void	O
dap_swap	()->(void)
(	O
)	O
{	O
int	O
iv	int
;	O
double	O
dbltmp	double
;	O
int	O
inttmp	int
;	O
char	O
strtmp	char
;	O
int	O
s	*(char)
;	O
char	O
*	O
so	*(char)
,	O
*	O
sp	*(char)
;	O
for	O
(	O
iv	int
=	O
0	int
;	O
iv	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
;	O
iv	int
++	O
)	O
{	O
switch	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
)	O
{	O
case	O
DBL	O
:	O
dbltmp	double
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dbltmp	double
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
)	O
*	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
case	O
INT	int
:	O
inttmp	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
inttmp	int
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
)	O
*	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
default	O
:	O
so	*(char)
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
sp	*(char)
=	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
for	O
(	O
s	*(char)
=	O
0	int
;	O
s	*(char)
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
s	*(char)
++	O
)	O
{	O
strtmp	char
=	O
so	*(char)
[	O
s	*(char)
]	O
;	O
so	*(char)
[	O
s	*(char)
]	O
=	O
sp	*(char)
[	O
s	*(char)
]	O
;	O
sp	*(char)
[	O
s	*(char)
]	O
=	O
strtmp	char
;	O
}	O
break	O
;	O
}	O
}	O
}	O
void	O
dap_save	()->(void)
(	O
)	O
{	O
int	O
iv	int
;	O
for	O
(	O
iv	int
=	O
0	int
;	O
iv	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
;	O
iv	int
++	O
)	O
{	O
switch	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
)	O
{	O
case	O
DBL	O
:	O
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
case	O
INT	int
:	O
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
,	O
"dap_save: dosave.do_str[dap_obs[dap_ono].do_in[iv]]"	*(char)
)	O
;	O
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
+	O
1	int
,	O
"dap_save: dap_obs[dap_ono].do_nam[dap_obs[dap_ono].do_in[iv]]"	*(char)
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
+	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
void	O
dap_rest	()->(void)
(	O
)	O
{	O
int	O
iv	int
;	O
for	O
(	O
iv	int
=	O
0	int
;	O
iv	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
;	O
iv	int
++	O
)	O
{	O
switch	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
)	O
{	O
case	O
DBL	O
:	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
)	O
*	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
case	O
INT	int
:	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
)	O
*	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
default	O
:	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
,	O
dosave	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
+	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
long	O
dap_ftell	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(long)
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
{	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
return	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_pos	*(char)
-	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
;	O
}	O
void	O
dap_mark	()->(void)
(	O
)	O
{	O
filepos	array(long)
[	O
dap_ono	int
]	O
=	O
dap_ftell	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(long)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
}	O
static	O
void	O
dfseek	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))),long,int)->(void)
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
,	O
long	O
pos	long
,	O
int	O
mode	array(char)
)	O
{	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_disk	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
pos	long
,	O
mode	array(char)
)	O
;	O
else	O
{	O
if	O
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
+	O
pos	long
<	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_end	*(char)
)	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_pos	*(char)
=	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
+	O
pos	long
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dfseek) seek past end of ramfile %s\n"	*(char)
,	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
->	O
dfile_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
dap_rewind	()->(void)
(	O
)	O
{	O
if	O
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
{	O
if	O
(	O
filepos	array(long)
[	O
dap_ono	int
]	O
<	O
dap_ftell	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(long)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
)	O
eof	array(int)
[	O
dap_ono	int
]	O
=	O
0	int
;	O
dfseek	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))),long,int)->(void)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
,	O
filepos	array(long)
[	O
dap_ono	int
]	O
,	O
SEEK_SET	int
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_valid	int
=	O
0	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_rewind) file (%d) is closed.\n"	*(char)
,	O
dap_ono	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
int	O
dap_blank	(array(char))->(int)
(	O
char	O
str	array(char)
[	O
]	O
)	O
{	O
int	O
b	double
;	O
for	O
(	O
b	double
=	O
0	int
;	O
str	array(char)
[	O
b	double
]	O
==	O
' '	O
;	O
b	double
++	O
)	O
;	O
if	O
(	O
str	array(char)
[	O
b	double
]	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
void	O
skip	(int)->(void)
(	O
int	O
nlines	int
)	O
{	O
char	O
*	O
line	*(char)
;	O
line	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_linelen	int
+	O
1	int
,	O
"skip: line"	*(char)
)	O
;	O
while	O
(	O
--	O
nlines	int
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
||	O
eof	array(int)
[	O
dap_ono	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(skip) tried to read past end of file (%d).\n"	*(char)
,	O
dap_ono	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dap_getline	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))),*(char))->(int)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
,	O
line	*(char)
)	O
<	O
0	int
)	O
eof	array(int)
[	O
dap_ono	int
]	O
=	O
1	int
;	O
lineno	array(int)
[	O
dap_ono	int
]	O
++	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
line	*(char)
,	O
"skip: line"	*(char)
)	O
;	O
}	O
int	O
step	()->(int)
(	O
)	O
{	O
static	O
int	O
stepinit	int
=	O
0	int
;	O
static	O
char	O
*	O
line	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
value	*(char)
=	O
NULL	O
;	O
int	O
v	int
;	O
int	O
l	int
;	O
int	O
i	int
;	O
int	O
iv	int
;	O
int	O
nread	int
;	O
if	O
(	O
!	O
stepinit	int
)	O
{	O
stepinit	int
=	O
1	int
;	O
line	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_linelen	int
+	O
1	int
,	O
"step: line"	*(char)
)	O
;	O
value	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_linelen	int
+	O
1	int
,	O
"step: value"	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
||	O
eof	array(int)
[	O
dap_ono	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(step) ERROR: tried to read past end of file (%s).\n"	*(char)
,	O
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
?	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
->	O
dfile_name	*(char)
:	O
"?"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
iv	int
=	O
0	int
;	O
iv	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
;	O
iv	int
++	O
)	O
{	O
switch	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
)	O
{	O
case	O
DBL	O
:	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
case	O
INT	int
:	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
default	O
:	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
iv	int
]	O
]	O
+	O
1	int
)	O
;	O
}	O
}	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_valid	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_valid	int
;	O
if	O
(	O
(	O
nread	int
=	O
dap_getline	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))),*(char))->(int)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
,	O
line	*(char)
)	O
)	O
<=	O
0	int
)	O
{	O
eof	array(int)
[	O
dap_ono	int
]	O
=	O
1	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_valid	int
=	O
0	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(step) %d lines read from %s\n"	*(char)
,	O
lineno	array(int)
[	O
dap_ono	int
]	O
-	O
1	int
,	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
->	O
dfile_name	*(char)
)	O
;	O
if	O
(	O
!	O
nread	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(step) WARNING: terminated on null line\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(step) %d lines read from  %s\n"	*(char)
,	O
lineno	array(int)
[	O
dap_ono	int
]	O
-	O
1	int
,	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
->	O
dfile_name	*(char)
)	O
;	O
if	O
(	O
!	O
nread	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(step) WARNING: terminated on null line\n"	*(char)
,	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
nfields	int
&&	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
!=	O
nfields	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(step) ERROR: number of input variables %d different from number of fields specified %d for %s.\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
,	O
nfields	int
,	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
->	O
dfile_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
,	O
l	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nfields	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
line	*(char)
[	O
l	int
+	O
i	int
]	O
&&	O
i	int
<	O
fieldwd	*(int)
[	O
v	int
]	O
;	O
i	int
++	O
)	O
value	*(char)
[	O
i	int
]	O
=	O
line	*(char)
[	O
l	int
+	O
i	int
]	O
;	O
value	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
i	int
<	O
fieldwd	*(int)
[	O
v	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(step (%s:%d)) ERROR: got %d of %d characters for fixed length field for %s: %s\n"	*(char)
,	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
->	O
dfile_name	*(char)
,	O
lineno	array(int)
[	O
dap_ono	int
]	O
,	O
i	int
,	O
fieldwd	*(int)
[	O
v	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
,	O
value	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(step (%s:%d)) ERROR: got %d of %d characters for fixed length field for %s: %s\n"	*(char)
,	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
->	O
dfile_name	*(char)
,	O
lineno	array(int)
[	O
dap_ono	int
]	O
,	O
i	int
,	O
fieldwd	*(int)
[	O
v	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
,	O
value	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
line	*(char)
[	O
l	int
+	O
i	int
]	O
&&	O
line	*(char)
[	O
l	int
+	O
i	int
]	O
!=	O
dap_delim	int
;	O
i	int
++	O
)	O
value	*(char)
[	O
i	int
]	O
=	O
line	*(char)
[	O
l	int
+	O
i	int
]	O
;	O
value	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
{	O
if	O
(	O
intype	int
==	O
DSET	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
=	O
dap_getint	(array(char))->(int)
(	O
value	*(char)
)	O
;	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
value	*(char)
,	O
" %d"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
+	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
)	O
!=	O
1	int
)	O
{	O
if	O
(	O
dap_blank	(array(char))->(int)
(	O
value	*(char)
)	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
=	O
0	int
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(step (%s:%d)) ERROR: invalid integer data for %s: %s\n"	*(char)
,	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
->	O
dfile_name	*(char)
,	O
lineno	array(int)
[	O
dap_ono	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
,	O
value	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
dap_ono	int
&&	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
)	O
*	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
{	O
if	O
(	O
intype	int
==	O
DSET	int
)	O
{	O
dap_getdouble	(array(char))->(void)
(	O
value	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
=	O
dap_double	double
;	O
}	O
else	O
{	O
if	O
(	O
!	O
i	int
||	O
(	O
nfields	int
&&	O
dap_blank	(array(char))->(int)
(	O
value	*(char)
)	O
)	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
value	*(char)
,	O
"."	*(char)
)	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
value	*(char)
,	O
" %lf"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
+	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
)	O
!=	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(step (%s:%d)) ERROR: invalid double data for %s: %s\n"	*(char)
,	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
->	O
dfile_name	*(char)
,	O
lineno	array(int)
[	O
dap_ono	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
,	O
value	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
dap_ono	int
&&	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
)	O
*	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
;	O
}	O
else	O
{	O
if	O
(	O
i	int
<=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
,	O
value	*(char)
)	O
;	O
else	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
,	O
value	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
toolong	int
<	O
dap_toolong	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(step (%s:%d)) WARNING: string data too long (%d) for %s (%d): %s\n"	*(char)
,	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
->	O
dfile_name	*(char)
,	O
lineno	array(int)
[	O
dap_ono	int
]	O
,	O
i	int
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
v	int
]	O
]	O
,	O
value	*(char)
)	O
;	O
toolong	int
++	O
;	O
}	O
}	O
}	O
l	int
+=	O
i	int
;	O
if	O
(	O
!	O
nfields	int
&&	O
line	*(char)
[	O
l	int
]	O
==	O
dap_delim	int
)	O
l	int
++	O
;	O
}	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_valid	int
=	O
1	int
;	O
lineno	array(int)
[	O
dap_ono	int
]	O
++	O
;	O
return	O
1	int
;	O
}	O
int	O
dap_vd	(array(char),int)->(int)
(	O
char	O
*	O
varspec	array(char)
,	O
int	O
invar	int
)	O
{	O
int	O
s	*(char)
;	O
int	O
i	int
;	O
char	O
*	O
varnam	*(char)
;	O
int	O
sign	int
;	O
int	O
v	int
;	O
int	O
vlen	int
;	O
int	O
redeclare	int
;	O
v	int
=	O
-	O
1	int
;	O
varnam	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varspec	array(char)
)	O
,	O
"dap_vd: varnam"	*(char)
)	O
;	O
for	O
(	O
s	*(char)
=	O
0	int
;	O
varspec	array(char)
[	O
s	*(char)
]	O
==	O
' '	O
;	O
)	O
s	*(char)
++	O
;	O
while	O
(	O
varspec	array(char)
[	O
s	*(char)
]	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
<	O
dap_maxvar	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varspec	array(char)
[	O
s	*(char)
+	O
i	int
]	O
&&	O
varspec	array(char)
[	O
s	*(char)
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
varnam	*(char)
[	O
i	int
]	O
=	O
varspec	array(char)
[	O
s	*(char)
+	O
i	int
]	O
;	O
varnam	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
varnam	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
redeclare	int
=	O
0	int
;	O
v	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
,	O
"dap_vd: dap_obs[dap_ono].do_nam[v]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
i	int
+	O
1	int
,	O
"dap_vd: dap_obs[dap_ono].do_nam[v]"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
,	O
varnam	*(char)
)	O
;	O
if	O
(	O
invar	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
++	O
]	O
=	O
v	int
;	O
}	O
else	O
redeclare	int
=	O
1	int
;	O
while	O
(	O
varspec	array(char)
[	O
s	*(char)
+	O
i	int
]	O
&&	O
varspec	array(char)
[	O
s	*(char)
+	O
i	int
]	O
==	O
' '	O
)	O
i	int
++	O
;	O
if	O
(	O
!	O
varspec	array(char)
[	O
s	*(char)
+	O
i	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_vd) missing variable length: %s\n"	*(char)
,	O
varspec	array(char)
+	O
s	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
s	*(char)
+=	O
i	int
;	O
if	O
(	O
varspec	array(char)
[	O
s	*(char)
]	O
==	O
'-'	O
)	O
{	O
sign	int
=	O
-	O
1	int
;	O
for	O
(	O
s	*(char)
++	O
;	O
varspec	array(char)
[	O
s	*(char)
]	O
==	O
' '	O
;	O
s	*(char)
++	O
)	O
;	O
}	O
else	O
sign	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
vlen	int
=	O
0	int
;	O
'0'	O
<=	O
varspec	array(char)
[	O
s	*(char)
+	O
i	int
]	O
&&	O
varspec	array(char)
[	O
s	*(char)
+	O
i	int
]	O
<=	O
'9'	O
;	O
i	int
++	O
)	O
vlen	int
=	O
10	int
*	O
vlen	int
+	O
varspec	array(char)
[	O
s	*(char)
+	O
i	int
]	O
-	O
'0'	O
;	O
vlen	int
*=	O
sign	int
;	O
if	O
(	O
redeclare	int
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
!=	O
vlen	int
)	O
{	O
if	O
(	O
vlen	int
>	O
0	int
&&	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
>	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_vd) respecification of length of %s from %d to %d\n"	*(char)
,	O
varnam	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
+	O
1	int
,	O
vlen	int
+	O
1	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_vd) respecification of type of %s\n"	*(char)
,	O
varnam	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
=	O
vlen	int
;	O
if	O
(	O
varspec	array(char)
[	O
s	*(char)
+	O
i	int
]	O
&&	O
varspec	array(char)
[	O
s	*(char)
+	O
i	int
]	O
!=	O
' '	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_vd) invalid variable length for %s: %s\n"	*(char)
,	O
varnam	*(char)
,	O
varspec	array(char)
+	O
s	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
redeclare	int
&&	O
vlen	int
>	O
0	int
)	O
{	O
if	O
(	O
!	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_sl	*(int)
[	O
v	int
]	O
&&	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
,	O
"dap_vd: dap_obs[dap_ono].do_str[v]"	*(char)
)	O
;	O
if	O
(	O
dap_ono	int
<	O
2	int
&&	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
,	O
"dap_vd: dap_prev[dap_ono].do_str[v]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
vlen	int
+	O
1	int
,	O
"dap_vd: dap_obs[dap_ono].do_str[v]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_sl	*(int)
[	O
v	int
]	O
=	O
0	int
;	O
if	O
(	O
dap_ono	int
<	O
2	int
)	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
vlen	int
+	O
1	int
,	O
"dap_vd: dap_prev[dap_ono].do_str[v]"	*(char)
)	O
;	O
}	O
if	O
(	O
vlen	int
==	O
DBL	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
v	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
else	O
if	O
(	O
vlen	int
==	O
INT	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
v	int
]	O
=	O
0	int
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
s	*(char)
+=	O
i	int
;	O
while	O
(	O
varspec	array(char)
[	O
s	*(char)
]	O
==	O
' '	O
)	O
s	*(char)
++	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_vd) too many variables: %s\n"	*(char)
,	O
varspec	array(char)
+	O
s	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
redeclare	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
++	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
varnam	*(char)
,	O
"dap_vd: varnam"	*(char)
)	O
;	O
return	O
v	int
;	O
}	O
void	O
dap_dl	(array(char),*(double))->(void)
(	O
char	O
varname	array(char)
[	O
]	O
,	O
double	O
*	O
dbl	*(double)
)	O
{	O
int	O
v	int
;	O
int	O
dim	*(int)
;	O
int	O
d	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
varname	array(char)
)	O
)	O
>=	O
0	int
)	O
{	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
v	int
]	O
=	O
dbl	*(double)
;	O
*	O
dbl	*(double)
=	O
0.0	int
/	O
0.0	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
v	int
=	O
dap_arrnum	(array(char),*(int))->(int)
(	O
varname	array(char)
,	O
&	O
dim	*(int)
)	O
)	O
>	O
0	int
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dim	*(int)
;	O
d	int
++	O
)	O
{	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
v	int
+	O
d	int
]	O
=	O
dbl	*(double)
+	O
d	int
;	O
dbl	*(double)
[	O
d	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_dl) unknown variable %s\n"	*(char)
,	O
varname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
dap_il	(array(char),*(int))->(void)
(	O
char	O
varname	array(char)
[	O
]	O
,	O
int	O
*	O
i	int
)	O
{	O
int	O
v	int
;	O
int	O
dim	*(int)
;	O
int	O
d	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
varname	array(char)
)	O
)	O
>	O
0	int
)	O
{	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
v	int
]	O
=	O
i	int
;	O
*	O
i	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
v	int
=	O
dap_arrnum	(array(char),*(int))->(int)
(	O
varname	array(char)
,	O
&	O
dim	*(int)
)	O
)	O
>	O
0	int
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dim	*(int)
;	O
d	int
++	O
)	O
{	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
v	int
+	O
d	int
]	O
=	O
i	int
+	O
d	int
;	O
i	int
[	O
d	int
]	O
=	O
0	int
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_il) unknown variable %s\n"	*(char)
,	O
varname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
dap_sl	(array(char),*(char))->(void)
(	O
char	O
varname	array(char)
[	O
]	O
,	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
v	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
varname	array(char)
)	O
)	O
>=	O
0	int
)	O
{	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
,	O
"dap_sl: dap_obs[dap_ono].do_str[v]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
=	O
s	*(char)
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_sl	*(int)
[	O
v	int
]	O
=	O
1	int
;	O
s	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_sl) unknown variable %s\n"	*(char)
,	O
varname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
void	O
dap_name	(array(char),array(char))->(void)
(	O
char	O
dname	array(char)
[	O
]	O
,	O
char	O
*	O
fname	array(char)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
!	O
fname	array(char)
||	O
!	O
fname	array(char)
[	O
0	int
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dname	array(char)
,	O
"/dev/null"	*(char)
)	O
;	O
return	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
dname	array(char)
,	O
dap_setdir	*(char)
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
dname	array(char)
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
{	O
if	O
(	O
mkdir	(*(char),int)->(int)
(	O
dname	array(char)
,	O
(	O
mode_t	int
)	O
0700	int
)	O
<	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
dap_dapname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
(	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IFDIR	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: non-directory file exists: %s\n"	*(char)
,	O
dap_dapname	*(char)
,	O
dname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
dname	array(char)
,	O
"/"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
dname	array(char)
,	O
fname	array(char)
)	O
;	O
}	O
static	O
int	O
dblcmp	(*(double),*(double))->(int)
(	O
double	O
*	O
d1	*(double)
,	O
double	O
*	O
d2	*(double)
)	O
{	O
if	O
(	O
*	O
d1	*(double)
<	O
*	O
d2	*(double)
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
*	O
d1	*(double)
>	O
*	O
d2	*(double)
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
intcmp	(*(int),*(int))->(int)
(	O
int	O
*	O
i1	*(int)
,	O
int	O
*	O
i2	*(int)
)	O
{	O
if	O
(	O
*	O
i1	*(int)
<	O
*	O
i2	*(int)
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
*	O
i1	*(int)
>	O
*	O
i2	*(int)
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
stcmp	(*(*(char)),*(*(char)))->(int)
(	O
char	O
*	O
*	O
s1	*(*(char))
,	O
char	O
*	O
*	O
s2	*(*(char))
)	O
{	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
s1	*(*(char))
,	O
*	O
s2	*(*(char))
)	O
;	O
}	O
static	O
int	O
findlev	(int,array(double),array(int),array(*(char)),int)->(int)
(	O
int	O
class	int
,	O
double	O
dlevel	array(double)
[	O
]	O
,	O
int	O
ilevel	array(int)
[	O
]	O
,	O
char	O
*	O
slevel	array(*(char))
[	O
]	O
,	O
int	O
nlevels	int
)	O
{	O
int	O
v	int
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
class	int
]	O
==	O
DBL	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nlevels	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
class	int
]	O
==	O
dlevel	array(double)
[	O
v	int
]	O
)	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
class	int
]	O
==	O
INT	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nlevels	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
class	int
]	O
==	O
ilevel	array(int)
[	O
v	int
]	O
)	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nlevels	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
class	int
]	O
,	O
slevel	array(*(char))
[	O
v	int
]	O
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
v	int
<	O
nlevels	int
)	O
return	O
v	int
;	O
return	O
-	O
1	int
;	O
}	O
int	O
inclev	(array(int),array(int),int)->(int)
(	O
int	O
lev	array(int)
[	O
]	O
,	O
int	O
nlevels	int
[	O
]	O
,	O
int	O
nclass	int
)	O
{	O
int	O
c	int
;	O
for	O
(	O
c	int
=	O
nclass	int
-	O
1	int
;	O
c	int
>=	O
0	int
;	O
--	O
c	int
)	O
{	O
if	O
(	O
lev	array(int)
[	O
c	int
]	O
<	O
nlevels	int
[	O
c	int
]	O
-	O
1	int
)	O
break	O
;	O
}	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
0	int
;	O
lev	array(int)
[	O
c	int
]	O
++	O
;	O
while	O
(	O
++	O
c	int
<	O
nclass	int
)	O
lev	array(int)
[	O
c	int
]	O
=	O
0	int
;	O
return	O
1	int
;	O
}	O
void	O
dataset	(array(char),array(char),*(char))->(void)
(	O
char	O
oldname	array(char)
[	O
]	O
,	O
char	O
newname	array(char)
[	O
]	O
,	O
char	O
action	*(char)
[	O
]	O
)	O
{	O
static	O
int	O
datsetinit	int
=	O
0	int
;	O
char	O
*	O
dold	*(char)
,	O
*	O
dnew	*(char)
;	O
int	O
fold	int
,	O
fnew	int
;	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
doldf	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
,	O
*	O
dnewf	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
;	O
int	O
c	int
;	O
int	O
v	int
;	O
int	O
onum	int
;	O
int	O
maxnamlen	int
;	O
static	O
dataobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
;	O
char	O
*	O
varspec	array(char)
;	O
char	O
*	O
oldvmem	*(char)
;	O
char	O
*	O
newvmem	*(char)
;	O
char	O
*	O
*	O
oldvar	*(*(char))
;	O
char	O
*	O
*	O
newvar	*(*(char))
;	O
int	O
nvar	int
;	O
int	O
ncell	int
,	O
nclass	int
;	O
char	O
*	O
celllist	*(char)
;	O
int	O
*	O
cellv	*(int)
,	O
*	O
classv	*(int)
;	O
char	O
*	O
*	O
slevelmem	*(*(char))
;	O
char	O
*	O
*	O
*	O
slevel	array(*(char))
;	O
double	O
*	O
dlevelmem	*(double)
;	O
double	O
*	O
*	O
dlevel	array(double)
;	O
int	O
*	O
ilevelmem	*(int)
;	O
int	O
*	O
*	O
ilevel	array(int)
;	O
int	O
*	O
inlev	*(int)
;	O
int	O
*	O
outlev	*(int)
;	O
int	O
*	O
nlevels	int
;	O
int	O
(	O
*	O
dcmp	*(()->(int))
)	O
(	O
)	O
=	O
&	O
dblcmp	(*(double),*(double))->(int)
;	O
int	O
(	O
*	O
icmp	*(()->(int))
)	O
(	O
)	O
=	O
&	O
intcmp	(*(int),*(int))->(int)
;	O
int	O
(	O
*	O
scmp	*(()->(int))
)	O
(	O
)	O
=	O
&	O
stcmp	(*(*(char)),*(*(char)))->(int)
;	O
int	O
vn	int
,	O
nv	int
;	O
int	O
dim	*(int)
,	O
ndim	int
;	O
char	O
*	O
outlist	*(char)
;	O
static	O
char	O
dimstr	array(char)
[	O
7	int
]	O
;	O
int	O
*	O
clearvar	*(int)
;	O
int	O
nclear	int
;	O
if	O
(	O
!	O
datsetinit	int
)	O
{	O
datsetinit	int
=	O
1	int
;	O
initdo	(*(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)))->(void)
(	O
&	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
)	O
;	O
}	O
if	O
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
{	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
;	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
{	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
;	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
}	O
celllist	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
slevelmem	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
cellv	*(int)
=	O
(	O
int	O
*	O
)	O
NULL	O
;	O
classv	*(int)
=	O
(	O
int	O
*	O
)	O
NULL	O
;	O
outlist	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
,	O
"dataset: outlist"	*(char)
)	O
;	O
oldvmem	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxvar	int
*	O
(	O
dap_namelen	int
+	O
1	int
)	O
,	O
"dataset: oldvmem"	*(char)
)	O
;	O
oldvar	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"dataset: oldvar"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxvar	int
;	O
v	int
++	O
)	O
oldvar	*(*(char))
[	O
v	int
]	O
=	O
oldvmem	*(char)
+	O
v	int
*	O
(	O
dap_namelen	int
+	O
1	int
)	O
;	O
newvmem	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxvar	int
*	O
(	O
dap_namelen	int
+	O
1	int
)	O
,	O
"dataset: newvmem"	*(char)
)	O
;	O
newvar	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"dataset: newvar"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxvar	int
;	O
v	int
++	O
)	O
newvar	*(*(char))
[	O
v	int
]	O
=	O
newvmem	*(char)
+	O
v	int
*	O
(	O
dap_namelen	int
+	O
1	int
)	O
;	O
dold	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
oldname	array(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
dap_setdir	*(char)
)	O
+	O
2	int
,	O
"dataset: dold"	*(char)
)	O
;	O
dnew	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
newname	array(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
dap_setdir	*(char)
)	O
+	O
2	int
,	O
"dataset: dnew"	*(char)
)	O
;	O
dap_name	(array(char),array(char))->(void)
(	O
dold	*(char)
,	O
oldname	array(char)
)	O
;	O
dap_name	(array(char),array(char))->(void)
(	O
dnew	*(char)
,	O
newname	array(char)
)	O
;	O
clearvar	*(int)
=	O
NULL	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
action	*(char)
,	O
"RENAME"	*(char)
)	O
)	O
{	O
if	O
(	O
oldname	array(char)
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
if	O
(	O
newname	array(char)
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
for	O
(	O
fold	int
=	O
0	int
;	O
fold	int
<	O
dap_nrfiles	int
;	O
fold	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
fold	int
]	O
.	O
dfile_name	*(char)
,	O
oldname	array(char)
+	O
1	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
fold	int
<	O
dap_nrfiles	int
)	O
{	O
for	O
(	O
fnew	int
=	O
0	int
;	O
fnew	int
<	O
dap_nrfiles	int
;	O
fnew	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
fnew	int
]	O
.	O
dfile_name	*(char)
,	O
newname	array(char)
+	O
1	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
fnew	int
<	O
dap_nrfiles	int
)	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
fnew	int
]	O
.	O
dfile_name	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
fold	int
]	O
.	O
dfile_name	*(char)
,	O
newname	array(char)
+	O
1	int
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) can't find ramfile %s\n"	*(char)
,	O
oldname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) can't rename ramfile %s to disk file %s\n"	*(char)
,	O
oldname	array(char)
,	O
newname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
newname	array(char)
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) can't rename disk file %s to ramfile %s\n"	*(char)
,	O
oldname	array(char)
,	O
newname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
else	O
rename	(*(char),*(char))->(int)
(	O
dold	*(char)
,	O
dnew	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
action	*(char)
,	O
"COPY"	*(char)
,	O
4	int
)	O
)	O
{	O
for	O
(	O
v	int
=	O
4	int
;	O
action	*(char)
[	O
v	int
]	O
==	O
' '	O
;	O
v	int
++	O
)	O
;	O
for	O
(	O
nvar	int
=	O
0	int
;	O
action	*(char)
[	O
v	int
]	O
;	O
nvar	int
++	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
action	*(char)
[	O
v	int
]	O
&&	O
action	*(char)
[	O
v	int
]	O
!=	O
' '	O
&&	O
action	*(char)
[	O
v	int
]	O
!=	O
'>'	O
;	O
)	O
{	O
if	O
(	O
c	int
<	O
dap_namelen	int
)	O
oldvar	*(*(char))
[	O
nvar	int
]	O
[	O
c	int
++	O
]	O
=	O
action	*(char)
[	O
v	int
++	O
]	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) variable name too long: %s\n"	*(char)
,	O
action	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
oldvar	*(*(char))
[	O
nvar	int
]	O
[	O
c	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
action	*(char)
[	O
v	int
]	O
==	O
' '	O
)	O
v	int
++	O
;	O
if	O
(	O
action	*(char)
[	O
v	int
]	O
==	O
'>'	O
)	O
{	O
for	O
(	O
v	int
++	O
;	O
action	*(char)
[	O
v	int
]	O
==	O
' '	O
;	O
v	int
++	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
action	*(char)
[	O
v	int
]	O
&&	O
action	*(char)
[	O
v	int
]	O
!=	O
' '	O
;	O
)	O
{	O
if	O
(	O
c	int
<	O
dap_namelen	int
)	O
newvar	*(*(char))
[	O
nvar	int
]	O
[	O
c	int
++	O
]	O
=	O
action	*(char)
[	O
v	int
++	O
]	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) new variable name too long: %s\n"	*(char)
,	O
action	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
newvar	*(*(char))
[	O
nvar	int
]	O
[	O
c	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
action	*(char)
[	O
v	int
]	O
==	O
' '	O
)	O
v	int
++	O
;	O
}	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
newvar	*(*(char))
[	O
nvar	int
]	O
,	O
oldvar	*(*(char))
[	O
nvar	int
]	O
)	O
;	O
}	O
if	O
(	O
nvar	int
)	O
{	O
inset	(array(char))->(void)
(	O
oldname	array(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
,	O
outlist	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
v	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
newvar	*(*(char))
[	O
v	int
]	O
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
oldvar	*(*(char))
[	O
v	int
]	O
,	O
newvar	*(*(char))
[	O
v	int
]	O
)	O
)	O
{	O
if	O
(	O
(	O
vn	int
=	O
dap_varnum	(array(char))->(int)
(	O
oldvar	*(*(char))
[	O
v	int
]	O
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
(	O
nv	int
=	O
dap_varnum	(array(char))->(int)
(	O
newvar	*(*(char))
[	O
v	int
]	O
)	O
)	O
>=	O
0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
nv	int
]	O
[	O
0	int
]	O
=	O
'0'	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
vn	int
]	O
,	O
"dataset: dap_obs[0].do_nam[vn]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
vn	int
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
newvar	*(*(char))
[	O
v	int
]	O
)	O
+	O
1	int
,	O
"dataset: dap_obs[0].do_nam[vn]"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
vn	int
]	O
,	O
newvar	*(*(char))
[	O
v	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
vn	int
=	O
dap_arrnum	(array(char),*(int))->(int)
(	O
oldvar	*(*(char))
[	O
v	int
]	O
,	O
&	O
dim	*(int)
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
(	O
nv	int
=	O
dap_arrnum	(array(char),*(int))->(int)
(	O
newvar	*(*(char))
[	O
v	int
]	O
,	O
&	O
ndim	int
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
ndim	int
;	O
c	int
++	O
)	O
{	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
nv	int
+	O
c	int
]	O
[	O
0	int
]	O
=	O
'0'	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
dimstr	array(char)
,	O
"[%d]"	*(char)
,	O
c	int
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
vn	int
+	O
c	int
]	O
,	O
dimstr	array(char)
)	O
;	O
}	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
dim	*(int)
;	O
c	int
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
dimstr	array(char)
,	O
"[%d]"	*(char)
,	O
c	int
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
vn	int
+	O
c	int
]	O
,	O
"dataset: dap_obs[0].do_nam[vn + c]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
vn	int
+	O
c	int
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
newvar	*(*(char))
[	O
v	int
]	O
)	O
+	O
strlen	(*(char))->(long)
(	O
dimstr	array(char)
)	O
+	O
1	int
,	O
"dataset: dap_obs[0].do_nam[vn + c]"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
vn	int
+	O
c	int
]	O
,	O
newvar	*(*(char))
[	O
v	int
]	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
vn	int
+	O
c	int
]	O
,	O
dimstr	array(char)
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) unknown variable %s\n"	*(char)
,	O
oldvar	*(*(char))
[	O
v	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
outset	(array(char),array(char))->(void)
(	O
newname	array(char)
,	O
outlist	*(char)
)	O
;	O
while	O
(	O
step	()->(int)
(	O
)	O
)	O
output	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
doldf	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
=	O
dfopen	(*(char),*(char))->(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))
(	O
oldname	array(char)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) can't read %s for copy.\n"	*(char)
,	O
oldname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
(	O
dnewf	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
=	O
dfopen	(*(char),*(char))->(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))
(	O
newname	array(char)
,	O
"w"	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) can't write %s for copy.\n"	*(char)
,	O
newname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
while	O
(	O
(	O
c	int
=	O
dgetc	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
doldf	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
)	O
!=	O
EOF	O
)	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
c	int
,	O
dnewf	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
;	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dnewf	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
;	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
doldf	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
action	*(char)
,	O
"FILL"	*(char)
,	O
4	int
)	O
)	O
{	O
inset	(array(char))->(void)
(	O
oldname	array(char)
)	O
;	O
celllist	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
action	*(char)
)	O
,	O
"dataset: celllist"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
4	int
,	O
c	int
=	O
0	int
;	O
action	*(char)
[	O
v	int
]	O
&&	O
action	*(char)
[	O
v	int
]	O
!=	O
':'	O
;	O
)	O
celllist	*(char)
[	O
c	int
++	O
]	O
=	O
action	*(char)
[	O
v	int
++	O
]	O
;	O
celllist	*(char)
[	O
c	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
action	*(char)
[	O
v	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) missing ':' between variable lists in %s\n"	*(char)
,	O
action	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
ncell	int
=	O
c	int
/	O
2	int
;	O
cellv	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
ncell	int
,	O
"dataset: cellv"	*(char)
)	O
;	O
ncell	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
celllist	*(char)
,	O
cellv	*(int)
,	O
ncell	int
)	O
;	O
nclass	int
=	O
(	O
strlen	(*(char))->(long)
(	O
action	*(char)
)	O
-	O
v	int
)	O
/	O
2	int
;	O
classv	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
"dataset: classv"	*(char)
)	O
;	O
nclass	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
action	*(char)
+	O
v	int
+	O
1	int
,	O
classv	*(int)
,	O
nclass	int
)	O
;	O
inlev	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
"dataset: inlev"	*(char)
)	O
;	O
outlev	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
"dataset: outlev"	*(char)
)	O
;	O
slevelmem	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
nclass	int
*	O
dap_maxlev	int
,	O
"dataset: slevelmem"	*(char)
)	O
;	O
slevel	array(*(char))
=	O
(	O
char	O
*	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
*	O
)	O
*	O
nclass	int
,	O
"dataset: slevel"	*(char)
)	O
;	O
dlevelmem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nclass	int
*	O
dap_maxlev	int
,	O
"dataset: dlevelmem"	*(char)
)	O
;	O
dlevel	array(double)
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nclass	int
,	O
"dataset: dlevel"	*(char)
)	O
;	O
ilevelmem	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
*	O
dap_maxlev	int
,	O
"dataset: ilevelmem"	*(char)
)	O
;	O
ilevel	array(int)
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
nclass	int
,	O
"dataset: ilevel"	*(char)
)	O
;	O
nlevels	int
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
"dataset: nlevels"	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
slevel	array(*(char))
[	O
c	int
]	O
=	O
slevelmem	*(*(char))
+	O
c	int
*	O
dap_maxlev	int
;	O
dlevel	array(double)
[	O
c	int
]	O
=	O
dlevelmem	*(double)
+	O
c	int
*	O
dap_maxlev	int
;	O
ilevel	array(int)
[	O
c	int
]	O
=	O
ilevelmem	*(int)
+	O
c	int
*	O
dap_maxlev	int
;	O
}	O
outset	(array(char),array(char))->(void)
(	O
newname	array(char)
,	O
""	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
nlevels	int
[	O
c	int
]	O
=	O
0	int
;	O
for	O
(	O
dap_mark	()->(void)
(	O
)	O
;	O
step	()->(int)
(	O
)	O
;	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
(	O
v	int
=	O
findlev	(int,array(double),array(int),array(*(char)),int)->(int)
(	O
classv	*(int)
[	O
c	int
]	O
,	O
dlevel	array(double)
[	O
c	int
]	O
,	O
ilevel	array(int)
[	O
c	int
]	O
,	O
slevel	array(*(char))
[	O
c	int
]	O
,	O
nlevels	int
[	O
c	int
]	O
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
nlevels	int
[	O
c	int
]	O
<	O
dap_maxlev	int
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
classv	*(int)
[	O
c	int
]	O
]	O
==	O
DBL	O
)	O
{	O
dlevel	array(double)
[	O
c	int
]	O
[	O
nlevels	int
[	O
c	int
]	O
++	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
classv	*(int)
[	O
c	int
]	O
]	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
classv	*(int)
[	O
c	int
]	O
]	O
==	O
INT	int
)	O
{	O
ilevel	array(int)
[	O
c	int
]	O
[	O
nlevels	int
[	O
c	int
]	O
++	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
classv	*(int)
[	O
c	int
]	O
]	O
;	O
}	O
else	O
{	O
slevel	array(*(char))
[	O
c	int
]	O
[	O
nlevels	int
[	O
c	int
]	O
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
classv	*(int)
[	O
c	int
]	O
]	O
)	O
+	O
1	int
,	O
"dataset: slevel[c][nlevels[c]]"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
slevel	array(*(char))
[	O
c	int
]	O
[	O
nlevels	int
[	O
c	int
]	O
++	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
classv	*(int)
[	O
c	int
]	O
]	O
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) too many levels for \%s\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
classv	*(int)
[	O
c	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
classv	*(int)
[	O
c	int
]	O
]	O
==	O
DBL	O
)	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
dlevel	array(double)
[	O
c	int
]	O
,	O
nlevels	int
[	O
c	int
]	O
,	O
sizeof	O
(	O
double	O
)	O
,	O
dcmp	*(()->(int))
)	O
;	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
classv	*(int)
[	O
c	int
]	O
]	O
==	O
INT	int
)	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
ilevel	array(int)
[	O
c	int
]	O
,	O
nlevels	int
[	O
c	int
]	O
,	O
sizeof	O
(	O
int	O
)	O
,	O
icmp	*(()->(int))
)	O
;	O
else	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
slevel	array(*(char))
[	O
c	int
]	O
,	O
nlevels	int
[	O
c	int
]	O
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
scmp	*(()->(int))
)	O
;	O
outlev	*(int)
[	O
c	int
]	O
=	O
0	int
;	O
}	O
dap_rewind	()->(void)
(	O
)	O
;	O
while	O
(	O
step	()->(int)
(	O
)	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
inlev	*(int)
[	O
c	int
]	O
=	O
findlev	(int,array(double),array(int),array(*(char)),int)->(int)
(	O
classv	*(int)
[	O
c	int
]	O
,	O
dlevel	array(double)
[	O
c	int
]	O
,	O
ilevel	array(int)
[	O
c	int
]	O
,	O
slevel	array(*(char))
[	O
c	int
]	O
,	O
nlevels	int
[	O
c	int
]	O
)	O
;	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
outlev	*(int)
[	O
c	int
]	O
<	O
inlev	*(int)
[	O
c	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
c	int
<	O
nclass	int
)	O
{	O
dap_save	()->(void)
(	O
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
ncell	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
cellv	*(int)
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
cellv	*(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
;	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
cellv	*(int)
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
cellv	*(int)
[	O
v	int
]	O
]	O
=	O
0	int
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
cellv	*(int)
[	O
v	int
]	O
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
do	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
outlev	*(int)
[	O
c	int
]	O
<	O
inlev	*(int)
[	O
c	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
nclass	int
)	O
break	O
;	O
for	O
(	O
v	int
=	O
c	int
;	O
v	int
<	O
nclass	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
classv	*(int)
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
classv	*(int)
[	O
v	int
]	O
]	O
=	O
dlevel	array(double)
[	O
v	int
]	O
[	O
outlev	*(int)
[	O
v	int
]	O
]	O
;	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
classv	*(int)
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
classv	*(int)
[	O
v	int
]	O
]	O
=	O
ilevel	array(int)
[	O
v	int
]	O
[	O
outlev	*(int)
[	O
v	int
]	O
]	O
;	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
classv	*(int)
[	O
v	int
]	O
]	O
,	O
slevel	array(*(char))
[	O
v	int
]	O
[	O
outlev	*(int)
[	O
v	int
]	O
]	O
)	O
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
while	O
(	O
inclev	(array(int),array(int),int)->(int)
(	O
outlev	*(int)
,	O
nlevels	int
,	O
nclass	int
)	O
)	O
;	O
dap_rest	()->(void)
(	O
)	O
;	O
}	O
output	()->(void)
(	O
)	O
;	O
inclev	(array(int),array(int),int)->(int)
(	O
outlev	*(int)
,	O
nlevels	int
,	O
nclass	int
)	O
;	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nlevels	int
[	O
c	int
]	O
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
classv	*(int)
[	O
c	int
]	O
]	O
>	O
0	int
)	O
dap_free	(*(void),*(char))->(void)
(	O
slevel	array(*(char))
[	O
c	int
]	O
[	O
v	int
]	O
,	O
"dataset: slevel[c][v]"	*(char)
)	O
;	O
}	O
nlevels	int
[	O
c	int
]	O
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
action	*(char)
,	O
"REMOVE"	*(char)
)	O
)	O
{	O
if	O
(	O
oldname	array(char)
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
for	O
(	O
fold	int
=	O
0	int
;	O
fold	int
<	O
dap_nrfiles	int
;	O
fold	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
fold	int
]	O
.	O
dfile_name	*(char)
,	O
oldname	array(char)
+	O
1	int
)	O
)	O
{	O
dap_free	(*(void),*(char))->(void)
(	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
fold	int
]	O
.	O
dfile_name	*(char)
,	O
"dataset: dfile[NDFILES + fold].dfile_name"	*(char)
)	O
;	O
dfile	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
[	O
NDFILES	int
+	O
fold	int
]	O
.	O
dfile_name	*(char)
=	O
NULL	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
rfile	*(struct(*(char),*(char),*(char)))
[	O
fold	int
]	O
.	O
rfile_str	*(char)
,	O
"dataset: rfile[fold].rfile_str"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
}	O
else	O
unlink	(*(char))->(int)
(	O
dold	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
action	*(char)
,	O
"APPEND"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
=	O
dfopen	(*(char),*(char))->(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))
(	O
newname	array(char)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
!	O
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
=	O
dfopen	(*(char),*(char))->(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))
(	O
newname	array(char)
,	O
"w"	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) Can't create new data set for append: %s\n"	*(char)
,	O
newname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
=	O
dfopen	(*(char),*(char))->(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))
(	O
oldname	array(char)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) can't read old data set for append: %s\n"	*(char)
,	O
oldname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
while	O
(	O
(	O
c	int
=	O
dgetc	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
)	O
!=	O
EOF	O
)	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
c	int
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
;	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
;	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
;	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
return	O
;	O
}	O
else	O
{	O
inset	(array(char))->(void)
(	O
newname	array(char)
)	O
;	O
outset	(array(char),array(char))->(void)
(	O
"dap_null"	*(char)
,	O
""	*(char)
)	O
;	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nvar	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nvar	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_len	*(int)
[	O
v	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
;	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nam	*(*(char))
[	O
v	int
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
)	O
+	O
1	int
,	O
"dataset: baseobs.do_nam[v]"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nam	*(*(char))
[	O
v	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
)	O
;	O
}	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
;	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
inset	(array(char))->(void)
(	O
oldname	array(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_ovar	int
=	O
0	int
;	O
for	O
(	O
v	int
=	O
0	int
,	O
maxnamlen	int
=	O
0	int
;	O
v	int
<	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
maxnamlen	int
<	O
strlen	(*(char))->(long)
(	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nam	*(*(char))
[	O
v	int
]	O
)	O
)	O
maxnamlen	int
=	O
strlen	(*(char))->(long)
(	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nam	*(*(char))
[	O
v	int
]	O
)	O
;	O
}	O
varspec	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
maxnamlen	int
+	O
dap_intlen	int
+	O
2	int
,	O
"dataset: varspec"	*(char)
)	O
;	O
clearvar	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nvar	int
,	O
"dataset: clearvar"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
,	O
nclear	int
=	O
0	int
;	O
v	int
<	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
(	O
onum	int
=	O
dap_varnum	(array(char))->(int)
(	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nam	*(*(char))
[	O
v	int
]	O
)	O
)	O
<	O
0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
varspec	array(char)
,	O
"%s %d"	*(char)
,	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nam	*(*(char))
[	O
v	int
]	O
,	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_len	*(int)
[	O
v	int
]	O
)	O
;	O
onum	int
=	O
dap_vd	(array(char),int)->(int)
(	O
varspec	array(char)
,	O
0	int
)	O
;	O
clearvar	*(int)
[	O
nclear	int
++	O
]	O
=	O
onum	int
;	O
}	O
else	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
onum	int
]	O
!=	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_len	*(int)
[	O
v	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) variable %s has different lengths (%d appended to %d) in datasets\n"	*(char)
,	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nam	*(*(char))
[	O
v	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
onum	int
]	O
,	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_len	*(int)
[	O
v	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_out	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_ovar	int
++	O
]	O
=	O
onum	int
;	O
}	O
if	O
(	O
!	O
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
=	O
dfopen	(*(char),*(char))->(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))
(	O
newname	array(char)
,	O
"a"	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) can't append to new data set: %s\n"	*(char)
,	O
newname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
while	O
(	O
step	()->(int)
(	O
)	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nclear	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
clearvar	*(int)
[	O
v	int
]	O
]	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
clearvar	*(int)
[	O
v	int
]	O
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_sl	*(int)
[	O
clearvar	*(int)
[	O
v	int
]	O
]	O
=	O
0	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
clearvar	*(int)
[	O
v	int
]	O
]	O
=	O
0	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
clearvar	*(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
dap_free	(*(void),*(char))->(void)
(	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nam	*(*(char))
[	O
v	int
]	O
,	O
"dataset: baseobs.do_nam[v]"	*(char)
)	O
;	O
baseobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
.	O
do_nam	*(*(char))
[	O
v	int
]	O
=	O
NULL	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
varspec	array(char)
,	O
"dataset: varspec"	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dataset) unknown action: %s\n"	*(char)
,	O
action	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
dold	*(char)
,	O
"dataset: dold"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
dnew	*(char)
,	O
"dataset: dnew"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
oldvmem	*(char)
,	O
"dataset: oldvmem"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
oldvar	*(*(char))
,	O
"dataset: oldvar"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
newvmem	*(char)
,	O
"dataset: newvmem"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
newvar	*(*(char))
,	O
"dataset: newvar"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
outlist	*(char)
,	O
"dataset: outlist"	*(char)
)	O
;	O
if	O
(	O
clearvar	*(int)
)	O
dap_free	(*(void),*(char))->(void)
(	O
clearvar	*(int)
,	O
"dataset: clearvar"	*(char)
)	O
;	O
if	O
(	O
celllist	*(char)
)	O
dap_free	(*(void),*(char))->(void)
(	O
celllist	*(char)
,	O
"dataset: celllist"	*(char)
)	O
;	O
if	O
(	O
cellv	*(int)
)	O
dap_free	(*(void),*(char))->(void)
(	O
cellv	*(int)
,	O
"dataset: cellv"	*(char)
)	O
;	O
if	O
(	O
classv	*(int)
)	O
dap_free	(*(void),*(char))->(void)
(	O
classv	*(int)
,	O
"dataset: classv"	*(char)
)	O
;	O
if	O
(	O
slevelmem	*(*(char))
)	O
{	O
dap_free	(*(void),*(char))->(void)
(	O
slevelmem	*(*(char))
,	O
"dataset: slevelmem"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
slevel	array(*(char))
,	O
"dataset: slevel"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
dlevelmem	*(double)
,	O
"dataset: dlevelmem"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
dlevel	array(double)
,	O
"dataset: dlevel"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
ilevelmem	*(int)
,	O
"dataset: ilevelmem"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
ilevel	array(int)
,	O
"dataset: ilevel"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
inlev	*(int)
,	O
"dataset: inlev"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
outlev	*(int)
,	O
"dataset: outlev"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
nlevels	int
,	O
"dataset: nlevels"	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
getblock	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
{	O
char	O
block	array(char)
[	O
BLOCKLEN	int
]	O
;	O
int	O
b	double
;	O
if	O
(	O
(	O
block	array(char)
[	O
0	int
]	O
=	O
dgetc	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
)	O
==	O
'\r'	O
)	O
return	O
0	int
;	O
for	O
(	O
b	double
=	O
1	int
;	O
b	double
<	O
BLOCKLEN	int
;	O
b	double
++	O
)	O
block	array(char)
[	O
b	double
]	O
=	O
dgetc	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
fp	*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char)))))
)	O
;	O
return	O
(	O
block	array(char)
[	O
16	int
]	O
&	O
0xff	int
)	O
;	O
}	O
int	O
dap_clearobs	(*(char))->(int)
(	O
char	O
*	O
varspec	array(char)
)	O
{	O
int	O
v	int
;	O
if	O
(	O
dap_ono	int
<	O
2	int
)	O
{	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
=	O
0	int
;	O
eof	array(int)
[	O
dap_ono	int
]	O
=	O
0	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
,	O
"clearobs: dap_prev[dap_ono].do_str[v]"	*(char)
)	O
;	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
=	O
NULL	O
;	O
}	O
}	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
=	O
0	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
=	O
0	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
=	O
0	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_valid	int
=	O
0	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
,	O
"clearobs: dap_obs[dap_ono].do_nam[v]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
v	int
]	O
=	O
NULL	O
;	O
if	O
(	O
!	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_sl	*(int)
[	O
v	int
]	O
&&	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
,	O
"clearobs: dap_obs[dap_ono].do_str[v]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_sl	*(int)
[	O
v	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
varspec	array(char)
)	O
dap_vd	(array(char),int)->(int)
(	O
varspec	array(char)
,	O
1	int
)	O
;	O
else	O
dap_vd	(array(char),int)->(int)
(	O
"_type_ 8"	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(clearobs) missing _type_ variable\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
++	O
]	O
=	O
v	int
;	O
return	O
v	int
;	O
}	O
void	O
infile	(array(char),array(char))->(void)
(	O
char	O
*	O
ifname	*(char)
,	O
char	O
*	O
idelim	*(char)
)	O
{	O
static	O
int	O
infinit	int
=	O
0	int
;	O
int	O
v	int
;	O
int	O
d	int
;	O
int	O
infldlen	int
;	O
char	O
*	O
fname	array(char)
;	O
static	O
char	O
*	O
delim	array(char)
;	O
static	O
int	O
delimlen	int
;	O
if	O
(	O
!	O
infinit	int
)	O
{	O
infinit	int
=	O
1	int
;	O
delimlen	int
=	O
(	O
dap_linelen	int
+	O
1	int
)	O
/	O
8	int
-	O
1	int
;	O
delim	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
delimlen	int
+	O
1	int
,	O
"infile: delim"	*(char)
)	O
;	O
fieldwd	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"infile: fieldwd"	*(char)
)	O
;	O
}	O
if	O
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
!	O
ifname	*(char)
||	O
!	O
ifname	*(char)
[	O
0	int
]	O
)	O
{	O
fname	array(char)
=	O
"/dev/null"	*(char)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
delim	array(char)
,	O
"|"	*(char)
)	O
;	O
}	O
else	O
{	O
fname	array(char)
=	O
ifname	*(char)
;	O
if	O
(	O
!	O
idelim	*(char)
||	O
!	O
idelim	*(char)
[	O
0	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(infile) Delimiter string must be at least one character: %s\n"	*(char)
,	O
delim	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strlen	(*(char))->(long)
(	O
idelim	*(char)
)	O
<=	O
delimlen	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
delim	array(char)
,	O
idelim	*(char)
)	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(infile) Delimiter string too long: %s\n"	*(char)
,	O
idelim	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
=	O
dfopen	(*(char),*(char))->(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))
(	O
fname	array(char)
,	O
"rf"	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(infile) can't read data file: %s\n"	*(char)
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
intype	int
=	O
TEXT	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
fname	array(char)
+	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
-	O
4	int
,	O
".dbf"	*(char)
)	O
)	O
{	O
intype	int
=	O
DBASE	int
;	O
getblock	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
for	O
(	O
inlen	int
=	O
0	int
;	O
(	O
infldlen	int
=	O
getblock	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(int)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
)	O
;	O
inlen	int
+=	O
infldlen	int
)	O
;	O
}	O
dap_delim	int
=	O
delim	array(char)
[	O
0	int
]	O
;	O
for	O
(	O
nfields	int
=	O
0	int
,	O
d	int
=	O
1	int
;	O
delim	array(char)
[	O
d	int
]	O
;	O
nfields	int
++	O
)	O
{	O
if	O
(	O
nfields	int
<	O
dap_maxvar	int
)	O
{	O
for	O
(	O
fieldwd	*(int)
[	O
nfields	int
]	O
=	O
0	int
;	O
delim	array(char)
[	O
d	int
]	O
&&	O
delim	array(char)
[	O
d	int
]	O
!=	O
dap_delim	int
;	O
)	O
{	O
fieldwd	*(int)
[	O
nfields	int
]	O
=	O
10	int
*	O
fieldwd	*(int)
[	O
nfields	int
]	O
+	O
delim	array(char)
[	O
d	int
++	O
]	O
-	O
'0'	O
;	O
}	O
if	O
(	O
delim	array(char)
[	O
d	int
]	O
)	O
d	int
++	O
;	O
}	O
else	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(infile) too many field width specifiers.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
v	int
=	O
dap_clearobs	(*(char))->(int)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
,	O
"OBS"	*(char)
)	O
;	O
lineno	array(int)
[	O
dap_ono	int
]	O
=	O
1	int
;	O
toolong	int
=	O
0	int
;	O
}	O
void	O
input	(array(char))->(void)
(	O
char	O
varlist	array(char)
[	O
]	O
)	O
{	O
int	O
v	int
;	O
int	O
l	int
;	O
int	O
i	int
;	O
static	O
char	O
*	O
vname	array(char)
=	O
NULL	O
;	O
int	O
dim	*(int)
;	O
int	O
d	int
;	O
if	O
(	O
!	O
vname	array(char)
)	O
vname	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_namelen	int
+	O
1	int
,	O
"input: vname"	*(char)
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
while	O
(	O
varlist	array(char)
[	O
l	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array(char)
[	O
l	int
+	O
i	int
]	O
&&	O
varlist	array(char)
[	O
l	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
vname	array(char)
[	O
i	int
]	O
=	O
varlist	array(char)
[	O
l	int
+	O
i	int
]	O
;	O
else	O
{	O
vname	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(input) variable name too long: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
vname	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
vname	array(char)
)	O
)	O
>=	O
0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
++	O
]	O
=	O
v	int
;	O
else	O
if	O
(	O
(	O
v	int
=	O
dap_arrnum	(array(char),*(int))->(int)
(	O
vname	array(char)
,	O
&	O
dim	*(int)
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dim	*(int)
;	O
d	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_in	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ivar	int
++	O
]	O
=	O
v	int
+	O
d	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(input) unknown variable: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
l	int
+=	O
i	int
;	O
while	O
(	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
}	O
}	O
void	O
inset	(array(char))->(void)
(	O
char	O
*	O
fname	array(char)
)	O
{	O
int	O
v	int
;	O
static	O
char	O
*	O
varspec	array(char)
=	O
NULL	O
;	O
double	O
testd	double
;	O
if	O
(	O
!	O
varspec	array(char)
)	O
varspec	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_linelen	int
+	O
1	int
,	O
"inset: varspec"	*(char)
)	O
;	O
if	O
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
!	O
fname	array(char)
)	O
return	O
;	O
if	O
(	O
!	O
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
=	O
dfopen	(*(char),*(char))->(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))
(	O
fname	array(char)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(inset) can't read data set: %s\n"	*(char)
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
intype	int
=	O
DSET	int
;	O
dap_delim	int
=	O
'\0'	O
;	O
if	O
(	O
dap_getline	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))),*(char))->(int)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
,	O
varspec	array(char)
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(inset) data set empty: %s\n"	*(char)
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
nfields	int
=	O
0	int
;	O
dap_clearobs	(*(char))->(int)
(	O
varspec	array(char)
)	O
;	O
dap_delim	int
=	O
SETDELIM	char
;	O
lineno	array(int)
[	O
dap_ono	int
]	O
=	O
1	int
;	O
}	O
static	O
void	O
fixlist	(*(char),*(char))->(void)
(	O
char	O
*	O
varl	*(char)
,	O
char	O
*	O
varlist	array(char)
)	O
{	O
static	O
int	O
fixinit	int
=	O
0	int
;	O
int	O
l	int
;	O
int	O
f	*(()->(double))
;	O
int	O
inbrack	int
;	O
static	O
char	O
*	O
vname	array(char)
;	O
int	O
dim	*(int)
;	O
static	O
int	O
*	O
outv	*(int)
;	O
int	O
l0	int
;	O
int	O
l1	int
;	O
int	O
f1	int
;	O
int	O
nv	int
;	O
int	O
v	int
;	O
int	O
vn	int
;	O
if	O
(	O
!	O
fixinit	int
)	O
{	O
fixinit	int
=	O
1	int
;	O
vname	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_namelen	int
+	O
1	int
,	O
"fixlist: vname"	*(char)
)	O
;	O
outv	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"fixlist: outv"	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
varl	*(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(fixlist) missing variable list.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
varlist	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(fixlist) missing string for fixed variable list.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
inbrack	int
=	O
0	int
,	O
l	int
=	O
0	int
,	O
f	*(()->(double))
=	O
0	int
;	O
varl	*(char)
[	O
l	int
]	O
;	O
l	int
++	O
)	O
{	O
if	O
(	O
inbrack	int
)	O
{	O
if	O
(	O
varl	*(char)
[	O
l	int
]	O
==	O
']'	O
)	O
inbrack	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
varl	*(char)
[	O
l	int
]	O
==	O
'['	O
)	O
inbrack	int
=	O
1	int
;	O
else	O
varlist	array(char)
[	O
f	*(()->(double))
++	O
]	O
=	O
varl	*(char)
[	O
l	int
]	O
;	O
}	O
varlist	array(char)
[	O
f	*(()->(double))
]	O
=	O
'\0'	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
l0	int
=	O
0	int
;	O
if	O
(	O
varlist	array(char)
[	O
l	int
]	O
==	O
'!'	O
)	O
{	O
for	O
(	O
l	int
++	O
;	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
varlist	array(char)
[	O
l0	int
++	O
]	O
=	O
'!'	O
;	O
}	O
for	O
(	O
nv	int
=	O
0	int
,	O
l1	int
=	O
l0	int
;	O
varlist	array(char)
[	O
l	int
]	O
;	O
)	O
{	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
varlist	array(char)
[	O
l	int
+	O
f	*(()->(double))
]	O
&&	O
varlist	array(char)
[	O
l	int
+	O
f	*(()->(double))
]	O
!=	O
' '	O
;	O
f	*(()->(double))
++	O
)	O
{	O
if	O
(	O
f	*(()->(double))
<	O
dap_namelen	int
)	O
vname	array(char)
[	O
f	*(()->(double))
]	O
=	O
varlist	array(char)
[	O
l	int
+	O
f	*(()->(double))
]	O
;	O
else	O
{	O
vname	array(char)
[	O
f	*(()->(double))
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(fixlist) variable name too long: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
vname	array(char)
[	O
f	*(()->(double))
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
vname	array(char)
)	O
)	O
<	O
0	int
)	O
&&	O
(	O
(	O
v	int
=	O
dap_arrnum	(array(char),*(int))->(int)
(	O
vname	array(char)
,	O
&	O
dim	*(int)
)	O
)	O
<	O
0	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(fixlist) unknown variable: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
vn	int
=	O
0	int
;	O
vn	int
<	O
nv	int
;	O
vn	int
++	O
)	O
{	O
if	O
(	O
outv	*(int)
[	O
vn	int
]	O
==	O
v	int
)	O
break	O
;	O
}	O
if	O
(	O
vn	int
==	O
nv	int
)	O
{	O
outv	*(int)
[	O
nv	int
++	O
]	O
=	O
v	int
;	O
if	O
(	O
l1	int
>	O
l0	int
)	O
varlist	array(char)
[	O
l1	int
++	O
]	O
=	O
' '	O
;	O
for	O
(	O
f1	int
=	O
0	int
;	O
f1	int
<	O
f	*(()->(double))
;	O
f1	int
++	O
)	O
varlist	array(char)
[	O
l1	int
++	O
]	O
=	O
varlist	array(char)
[	O
l	int
++	O
]	O
;	O
}	O
else	O
l	int
+=	O
f	*(()->(double))
;	O
while	O
(	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
}	O
varlist	array(char)
[	O
l1	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
outset	(array(char),array(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
varl	*(char)
)	O
{	O
static	O
int	O
outinit	int
=	O
0	int
;	O
int	O
l	int
;	O
int	O
i	int
;	O
static	O
char	O
*	O
varlist	array(char)
;	O
static	O
char	O
*	O
vname	array(char)
;	O
int	O
v	int
;	O
int	O
w	int
;	O
int	O
first	int
;	O
int	O
dim	*(int)
;	O
int	O
d	int
;	O
double	O
testd	double
;	O
if	O
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
!	O
fname	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(outset) no dataset name.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
outinit	int
)	O
{	O
outinit	int
=	O
1	int
;	O
varlist	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
,	O
"outset: varlist"	*(char)
)	O
;	O
vname	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
,	O
"outset: vname"	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
=	O
dfopen	(*(char),*(char))->(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))
(	O
fname	array(char)
,	O
"w"	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(outset) Can't write data set: %s\n"	*(char)
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
varl	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(outset (%s)) Missing variable list.\n"	*(char)
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
fixlist	(*(char),*(char))->(void)
(	O
varl	*(char)
,	O
varlist	array(char)
)	O
;	O
if	O
(	O
varlist	array(char)
[	O
0	int
]	O
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
if	O
(	O
varlist	array(char)
[	O
l	int
]	O
==	O
'!'	O
)	O
{	O
for	O
(	O
l	int
++	O
;	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
=	O
v	int
;	O
while	O
(	O
varlist	array(char)
[	O
l	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array(char)
[	O
l	int
+	O
i	int
]	O
&&	O
varlist	array(char)
[	O
l	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
vname	array(char)
[	O
i	int
]	O
=	O
varlist	array(char)
[	O
l	int
+	O
i	int
]	O
;	O
vname	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
w	int
=	O
dap_varnum	(array(char))->(int)
(	O
vname	array(char)
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
==	O
w	int
)	O
break	O
;	O
}	O
if	O
(	O
v	int
==	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(outset (%s)) variable not in list of variables to exclude: %s\n"	*(char)
,	O
fname	array(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
while	O
(	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
-	O
1	int
)	O
{	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
+	O
1	int
]	O
;	O
v	int
++	O
;	O
}	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
--	O
;	O
}	O
else	O
if	O
(	O
(	O
w	int
=	O
dap_arrnum	(array(char),*(int))->(int)
(	O
vname	array(char)
,	O
&	O
dim	*(int)
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
==	O
w	int
)	O
break	O
;	O
}	O
while	O
(	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
-	O
dim	*(int)
)	O
{	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
+	O
dim	*(int)
]	O
;	O
v	int
++	O
;	O
}	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
-=	O
dim	*(int)
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(outset(%s)) unknown variable: %s\n"	*(char)
,	O
fname	array(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
l	int
+=	O
i	int
;	O
while	O
(	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
varlist	array(char)
[	O
l	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array(char)
[	O
l	int
+	O
i	int
]	O
&&	O
varlist	array(char)
[	O
l	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
vname	array(char)
[	O
i	int
]	O
=	O
varlist	array(char)
[	O
l	int
+	O
i	int
]	O
;	O
vname	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
vname	array(char)
)	O
)	O
>=	O
0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
++	O
]	O
=	O
v	int
;	O
else	O
if	O
(	O
(	O
v	int
=	O
dap_arrnum	(array(char),*(int))->(int)
(	O
vname	array(char)
,	O
&	O
dim	*(int)
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dim	*(int)
;	O
d	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
++	O
]	O
=	O
v	int
+	O
d	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(outset(%s)) unknown variable: %s\n"	*(char)
,	O
fname	array(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
l	int
+=	O
i	int
;	O
while	O
(	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
}	O
}	O
}	O
else	O
{	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
=	O
v	int
;	O
}	O
if	O
(	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(outset (%s)) missing _type_ variable\n"	*(char)
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
w	int
=	O
v	int
+	O
1	int
;	O
w	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
w	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
==	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
w	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(outset (%s)) duplicate variable in output list: %s\n"	*(char)
,	O
fname	array(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
w	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
v	int
=	O
0	int
,	O
first	int
=	O
1	int
;	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
first	int
)	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
' '	O
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
dputs	(*(char),*(char),*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
,	O
" "	*(char)
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
dputi	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
first	int
=	O
0	int
;	O
}	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
'\n'	O
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
dflush	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
outline	int
=	O
0	int
;	O
}	O
void	O
output	()->(void)
(	O
)	O
{	O
int	O
v	int
;	O
int	O
first	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(output) missing _type_ variable\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
,	O
first	int
=	O
1	int
;	O
v	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
first	int
)	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
SETDELIM	char
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
{	O
if	O
(	O
!	O
dap_ono	int
&&	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
=	O
*	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_il	*(*(int))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
;	O
dap_putint	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
{	O
if	O
(	O
!	O
dap_ono	int
&&	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
=	O
*	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dl	*(*(double))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
;	O
dap_double	double
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
;	O
dap_putdouble	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
}	O
else	O
{	O
dputs	(*(char),*(char),*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_out	*(int)
[	O
v	int
]	O
]	O
,	O
""	*(char)
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
}	O
first	int
=	O
0	int
;	O
}	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
'\n'	O
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
dflush	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
if	O
(	O
dap_outreport	int
&&	O
!	O
(	O
++	O
outline	int
%	O
dap_outreport	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(output) %d lines written to %s...\n"	*(char)
,	O
outline	int
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
->	O
dfile_name	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
static	O
int	O
expand	(*(char),*(int),int)->(int)
(	O
char	O
*	O
varlist	array(char)
,	O
int	O
*	O
varv	array(int)
,	O
int	O
maxvars	int
)	O
{	O
int	O
nvars	int
;	O
int	O
m	*(char)
;	O
int	O
i	int
;	O
char	O
*	O
mname	*(char)
;	O
char	O
*	O
newname	array(char)
;	O
int	O
arrn	int
;	O
int	O
dim	*(int)
;	O
int	O
d	int
;	O
int	O
include	int
;	O
if	O
(	O
!	O
varlist	array(char)
)	O
return	O
0	int
;	O
if	O
(	O
!	O
varv	array(int)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(expand) Missing variable index list.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
mname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
1	int
,	O
"expand: mname"	*(char)
)	O
;	O
newname	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
1	int
,	O
"expand: newname"	*(char)
)	O
;	O
include	int
=	O
1	int
;	O
for	O
(	O
m	*(char)
=	O
0	int
;	O
varlist	array(char)
[	O
m	*(char)
]	O
==	O
' '	O
;	O
m	*(char)
++	O
)	O
;	O
if	O
(	O
varlist	array(char)
[	O
m	*(char)
]	O
==	O
'!'	O
)	O
{	O
for	O
(	O
m	*(char)
++	O
;	O
varlist	array(char)
[	O
m	*(char)
]	O
==	O
' '	O
;	O
m	*(char)
++	O
)	O
;	O
include	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
nvars	int
=	O
0	int
;	O
varlist	array(char)
[	O
m	*(char)
]	O
;	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array(char)
[	O
m	*(char)
+	O
i	int
]	O
&&	O
varlist	array(char)
[	O
m	*(char)
+	O
i	int
]	O
!=	O
' '	O
&&	O
varlist	array(char)
[	O
m	*(char)
+	O
i	int
]	O
!=	O
'>'	O
;	O
i	int
++	O
)	O
mname	*(char)
[	O
i	int
]	O
=	O
varlist	array(char)
[	O
m	*(char)
+	O
i	int
]	O
;	O
mname	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
m	*(char)
+=	O
i	int
;	O
while	O
(	O
varlist	array(char)
[	O
m	*(char)
]	O
==	O
' '	O
)	O
m	*(char)
++	O
;	O
newname	array(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
varlist	array(char)
[	O
m	*(char)
]	O
==	O
'>'	O
)	O
{	O
if	O
(	O
include	int
<	O
0	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(expand) Can't rename variables being excluded\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
m	*(char)
++	O
;	O
varlist	array(char)
[	O
m	*(char)
]	O
==	O
' '	O
;	O
m	*(char)
++	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array(char)
[	O
m	*(char)
+	O
i	int
]	O
&&	O
varlist	array(char)
[	O
m	*(char)
+	O
i	int
]	O
!=	O
' '	O
&&	O
varlist	array(char)
[	O
m	*(char)
+	O
i	int
]	O
!=	O
'>'	O
;	O
i	int
++	O
)	O
newname	array(char)
[	O
i	int
]	O
=	O
varlist	array(char)
[	O
m	*(char)
+	O
i	int
]	O
;	O
newname	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
m	*(char)
+=	O
i	int
;	O
while	O
(	O
varlist	array(char)
[	O
m	*(char)
]	O
==	O
' '	O
)	O
m	*(char)
++	O
;	O
}	O
if	O
(	O
nvars	int
>=	O
maxvars	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(expand) More than %d variables: %s\n"	*(char)
,	O
maxvars	int
,	O
varlist	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
arrn	int
=	O
dap_arrnum	(array(char),*(int))->(int)
(	O
mname	*(char)
,	O
&	O
dim	*(int)
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dim	*(int)
;	O
d	int
++	O
)	O
{	O
if	O
(	O
newname	array(char)
[	O
0	int
]	O
)	O
{	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
arrn	int
]	O
,	O
"expand: dap_obs[dap_ono].do_nam[arrn]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
arrn	int
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
newname	array(char)
)	O
+	O
6	int
,	O
"expand: dap_obs[dap_ono].do_nam[arrn]"	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
arrn	int
]	O
,	O
"%s[%d]"	*(char)
,	O
newname	array(char)
,	O
d	int
)	O
;	O
}	O
varv	array(int)
[	O
nvars	int
++	O
]	O
=	O
arrn	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
varv	array(int)
[	O
nvars	int
]	O
=	O
dap_varnum	(array(char))->(int)
(	O
mname	*(char)
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
newname	array(char)
[	O
0	int
]	O
)	O
{	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
nvars	int
]	O
]	O
,	O
"expand: dap_obs[dap_ono].do_nam[varv[nvars]]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
nvars	int
]	O
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
newname	array(char)
)	O
+	O
1	int
,	O
"expand: dap_obs[dap_ono].do_nam[varv[nvars]]"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
nvars	int
]	O
]	O
,	O
newname	array(char)
)	O
;	O
}	O
nvars	int
++	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(expand) Variable unknown: %s\n"	*(char)
,	O
mname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
mname	*(char)
,	O
"expand: mname"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
newname	array(char)
,	O
"expand: newname"	*(char)
)	O
;	O
return	O
include	int
*	O
nvars	int
;	O
}	O
static	O
void	O
varcat	(*(char),*(char))->(void)
(	O
char	O
*	O
to	*(char)
,	O
char	O
*	O
from	*(char)
)	O
{	O
int	O
t	int
,	O
f	*(()->(double))
,	O
ff	int
;	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
from	*(char)
[	O
f	*(()->(double))
]	O
==	O
' '	O
;	O
f	*(()->(double))
++	O
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
to	*(char)
[	O
t	int
]	O
;	O
t	int
++	O
)	O
;	O
while	O
(	O
from	*(char)
[	O
f	*(()->(double))
]	O
)	O
{	O
for	O
(	O
ff	int
=	O
f	*(()->(double))
;	O
from	*(char)
[	O
ff	int
]	O
&&	O
from	*(char)
[	O
ff	int
]	O
!=	O
' '	O
&&	O
from	*(char)
[	O
ff	int
]	O
!=	O
'>'	O
;	O
ff	int
++	O
)	O
;	O
while	O
(	O
from	*(char)
[	O
ff	int
]	O
==	O
' '	O
)	O
ff	int
++	O
;	O
if	O
(	O
from	*(char)
[	O
ff	int
]	O
==	O
'>'	O
)	O
{	O
for	O
(	O
f	*(()->(double))
=	O
ff	int
+	O
1	int
;	O
from	*(char)
[	O
f	*(()->(double))
]	O
==	O
' '	O
;	O
f	*(()->(double))
++	O
)	O
;	O
}	O
while	O
(	O
from	*(char)
[	O
f	*(()->(double))
]	O
&&	O
from	*(char)
[	O
f	*(()->(double))
]	O
!=	O
' '	O
)	O
to	*(char)
[	O
t	int
++	O
]	O
=	O
from	*(char)
[	O
f	*(()->(double))
++	O
]	O
;	O
to	*(char)
[	O
t	int
++	O
]	O
=	O
' '	O
;	O
while	O
(	O
from	*(char)
[	O
f	*(()->(double))
]	O
==	O
' '	O
)	O
f	*(()->(double))
++	O
;	O
}	O
to	*(char)
[	O
t	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
merge	(*(char),*(char),*(char),*(char),*(char),*(char))->(void)
(	O
char	O
*	O
fname1	*(char)
,	O
char	O
*	O
vars1	*(char)
,	O
char	O
*	O
fname2	*(char)
,	O
char	O
*	O
vars2	*(char)
,	O
char	O
*	O
marks	array(char)
,	O
char	O
*	O
outname	*(char)
)	O
{	O
int	O
*	O
varv1	*(int)
,	O
*	O
varv2	*(int)
;	O
int	O
*	O
ovarv1	*(int)
,	O
*	O
ovarv2	*(int)
;	O
int	O
nvar1	int
,	O
nvar2	int
;	O
int	O
*	O
markv1	*(int)
;	O
int	O
*	O
markv2	*(int)
;	O
int	O
nmark	int
;	O
int	O
v1	int
,	O
v2	int
;	O
int	O
vv1	int
,	O
vv2	int
;	O
char	O
*	O
outlist	*(char)
;	O
char	O
*	O
outlist1	*(char)
;	O
char	O
*	O
outlist2	*(char)
;	O
int	O
goon1	int
;	O
double	O
ddiff	double
;	O
int	O
isdiff	int
;	O
int	O
vars1null	int
,	O
vars2null	int
;	O
char	O
*	O
vars1a	*(char)
,	O
*	O
vars2a	*(char)
;	O
int	O
exclude1	int
,	O
exclude2	int
;	O
int	O
nvar1a	int
,	O
nvar2a	int
;	O
int	O
*	O
varv1a	*(int)
,	O
*	O
varv2a	*(int)
;	O
if	O
(	O
!	O
fname1	*(char)
||	O
!	O
fname2	*(char)
||	O
!	O
outname	*(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(merge) Missing dataset name.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
vars1	*(char)
&&	O
index	(*(char),int)->(*(char))
(	O
vars1	*(char)
,	O
'['	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(merge) Variable lists may not contain individual array elements: %s\n"	*(char)
,	O
vars1	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
vars2	*(char)
&&	O
index	(*(char),int)->(*(char))
(	O
vars2	*(char)
,	O
'['	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(merge) Variable lists may not contain individual array elements: %s\n"	*(char)
,	O
vars2	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
vars1null	int
=	O
0	int
;	O
vars2null	int
=	O
0	int
;	O
outlist	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
,	O
"merge: outlist"	*(char)
)	O
;	O
outlist1	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
,	O
"merge: outlist1"	*(char)
)	O
;	O
outlist2	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
,	O
"merge:outlist2"	*(char)
)	O
;	O
varv1	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: varv1"	*(char)
)	O
;	O
varv2	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: varv2"	*(char)
)	O
;	O
ovarv1	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: ovarv1"	*(char)
)	O
;	O
ovarv2	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: ovarv2"	*(char)
)	O
;	O
markv1	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: markv1"	*(char)
)	O
;	O
markv2	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: markv2"	*(char)
)	O
;	O
dap_ono	int
=	O
0	int
;	O
inset	(array(char))->(void)
(	O
fname1	*(char)
)	O
;	O
if	O
(	O
vars1	*(char)
&&	O
!	O
vars1	*(char)
[	O
0	int
]	O
)	O
{	O
vars1null	int
=	O
1	int
;	O
vars1	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
,	O
"merge: vars1"	*(char)
)	O
;	O
vars1	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
v1	int
=	O
0	int
;	O
v1	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v1	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v1	int
]	O
,	O
"_type_"	*(char)
)	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
vars1	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
vars1	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v1	int
]	O
)	O
;	O
}	O
}	O
}	O
nvar1	int
=	O
expand	(*(char),*(int),int)->(int)
(	O
vars1	*(char)
,	O
varv1	*(int)
,	O
dap_maxvar	int
)	O
;	O
exclude1	int
=	O
0	int
;	O
if	O
(	O
nvar1	int
<	O
0	int
)	O
{	O
exclude1	int
=	O
1	int
;	O
nvar1	int
=	O
-	O
nvar1	int
;	O
vars1a	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
,	O
"merge: vars1a"	*(char)
)	O
;	O
vars1a	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
varv1a	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxvar	int
,	O
"merge: varv1a"	*(char)
)	O
;	O
for	O
(	O
v1	int
=	O
0	int
,	O
nvar1a	int
=	O
0	int
;	O
v1	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v1	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v1	int
]	O
,	O
"_type_"	*(char)
)	O
)	O
continue	O
;	O
for	O
(	O
vv1	int
=	O
0	int
;	O
vv1	int
<	O
nvar1	int
;	O
vv1	int
++	O
)	O
{	O
if	O
(	O
varv1	*(int)
[	O
vv1	int
]	O
==	O
v1	int
)	O
break	O
;	O
}	O
if	O
(	O
vv1	int
==	O
nvar1	int
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
vars1a	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
vars1a	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v1	int
]	O
)	O
;	O
varv1a	*(int)
[	O
nvar1a	int
++	O
]	O
=	O
v1	int
;	O
}	O
}	O
if	O
(	O
vars1null	int
)	O
dap_free	(*(void),*(char))->(void)
(	O
vars1	*(char)
,	O
"merge: vars1"	*(char)
)	O
;	O
vars1	*(char)
=	O
vars1a	*(char)
;	O
nvar1	int
=	O
nvar1a	int
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv1	*(int)
,	O
"merge: varv1"	*(char)
)	O
;	O
varv1	*(int)
=	O
varv1a	*(int)
;	O
}	O
if	O
(	O
marks	array(char)
)	O
nmark	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
marks	array(char)
,	O
markv1	*(int)
,	O
dap_maxvar	int
)	O
;	O
else	O
nmark	int
=	O
0	int
;	O
dap_ono	int
=	O
1	int
;	O
inset	(array(char))->(void)
(	O
fname2	*(char)
)	O
;	O
if	O
(	O
vars2	*(char)
&&	O
!	O
vars2	*(char)
[	O
0	int
]	O
)	O
{	O
vars2null	int
=	O
1	int
;	O
vars2	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
,	O
"merge: vars2"	*(char)
)	O
;	O
vars2	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
v2	int
=	O
0	int
;	O
v2	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v2	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v2	int
]	O
,	O
"_type_"	*(char)
)	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
vars2	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
vars2	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v2	int
]	O
)	O
;	O
}	O
}	O
}	O
nvar2	int
=	O
expand	(*(char),*(int),int)->(int)
(	O
vars2	*(char)
,	O
varv2	*(int)
,	O
dap_maxvar	int
)	O
;	O
exclude2	int
=	O
0	int
;	O
if	O
(	O
nvar2	int
<	O
0	int
)	O
{	O
exclude2	int
=	O
1	int
;	O
nvar2	int
=	O
-	O
nvar2	int
;	O
vars2a	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
,	O
"merge: vars2a"	*(char)
)	O
;	O
vars2a	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
varv2a	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxvar	int
,	O
"merge: varv2a"	*(char)
)	O
;	O
for	O
(	O
v2	int
=	O
0	int
,	O
nvar2a	int
=	O
0	int
;	O
v2	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v2	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v2	int
]	O
,	O
"_type_"	*(char)
)	O
)	O
continue	O
;	O
for	O
(	O
vv2	int
=	O
0	int
;	O
vv2	int
<	O
nvar2	int
;	O
vv2	int
++	O
)	O
{	O
if	O
(	O
varv2	*(int)
[	O
vv2	int
]	O
==	O
v2	int
)	O
break	O
;	O
}	O
if	O
(	O
vv2	int
==	O
nvar2	int
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
vars2a	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
vars2a	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
v2	int
]	O
)	O
;	O
varv2a	*(int)
[	O
nvar2a	int
++	O
]	O
=	O
v2	int
;	O
}	O
}	O
if	O
(	O
vars2null	int
)	O
dap_free	(*(void),*(char))->(void)
(	O
vars2	*(char)
,	O
"merge: vars2"	*(char)
)	O
;	O
vars2	*(char)
=	O
vars2a	*(char)
;	O
nvar2	int
=	O
nvar2a	int
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv2	*(int)
,	O
"merge: varv2"	*(char)
)	O
;	O
varv2	*(int)
=	O
varv2a	*(int)
;	O
}	O
dap_list	(array(char),array(int),int)->(int)
(	O
marks	array(char)
,	O
markv2	*(int)
,	O
dap_maxvar	int
)	O
;	O
for	O
(	O
v1	int
=	O
0	int
;	O
v1	int
<	O
nmark	int
;	O
v1	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
markv1	*(int)
[	O
v1	int
]	O
]	O
!=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_len	*(int)
[	O
markv2	*(int)
[	O
v1	int
]	O
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(merge) Part variables of different types: %s (%d) and %s (%d)\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
markv1	*(int)
[	O
v1	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
markv1	*(int)
[	O
v1	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_nam	*(*(char))
[	O
markv2	*(int)
[	O
v1	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_len	*(int)
[	O
markv2	*(int)
[	O
v1	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
outlist	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
vars2	*(char)
&&	O
nvar2	int
>	O
0	int
)	O
varcat	(*(char),*(char))->(void)
(	O
outlist	*(char)
,	O
vars2	*(char)
)	O
;	O
outlist2	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
vars2	*(char)
&&	O
nvar2	int
>	O
0	int
)	O
varcat	(*(char),*(char))->(void)
(	O
outlist2	*(char)
,	O
vars2	*(char)
)	O
;	O
dap_ono	int
=	O
2	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
=	O
0	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_ovar	int
=	O
0	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_out	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_ovar	int
++	O
]	O
=	O
dap_vd	(array(char),int)->(int)
(	O
"_type_ 8"	*(char)
,	O
0	int
)	O
;	O
for	O
(	O
v2	int
=	O
0	int
;	O
v2	int
<	O
nvar2	int
;	O
v2	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
]	O
,	O
"merge: dap_obs[2].do_nam[dap_obs[2].do_nvar]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_nam	*(*(char))
[	O
varv2	*(int)
[	O
v2	int
]	O
]	O
)	O
+	O
1	int
,	O
"merge: dap_obs[1].do_nam[varv2[v2]]"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_nam	*(*(char))
[	O
varv2	*(int)
[	O
v2	int
]	O
]	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_len	*(int)
[	O
varv2	*(int)
[	O
v2	int
]	O
]	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
++	O
;	O
}	O
outlist1	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
vars1	*(char)
&&	O
nvar1	int
>	O
0	int
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
" "	*(char)
)	O
;	O
varcat	(*(char),*(char))->(void)
(	O
outlist	*(char)
,	O
vars1	*(char)
)	O
;	O
varcat	(*(char),*(char))->(void)
(	O
outlist1	*(char)
,	O
vars1	*(char)
)	O
;	O
}	O
for	O
(	O
v1	int
=	O
0	int
;	O
v1	int
<	O
nvar1	int
;	O
v1	int
++	O
)	O
{	O
for	O
(	O
v2	int
=	O
0	int
;	O
v2	int
<	O
nvar2	int
;	O
v2	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv1	*(int)
[	O
v1	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_nam	*(*(char))
[	O
varv2	*(int)
[	O
v2	int
]	O
]	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
v2	int
<	O
nvar2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(merge) variable appears in lists for both %s and %s: %s\n"	*(char)
,	O
fname1	*(char)
,	O
fname2	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv1	*(int)
[	O
v1	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
]	O
,	O
"merge: dap_obs[2].do_nam[dap_obs[2].do_nvar]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv1	*(int)
[	O
v1	int
]	O
]	O
)	O
+	O
1	int
,	O
"merge: dap_obs[0].do_nam[varv1[v1]]"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nam	*(*(char))
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv1	*(int)
[	O
v1	int
]	O
]	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_len	*(int)
[	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv1	*(int)
[	O
v1	int
]	O
]	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_nvar	int
++	O
;	O
}	O
}	O
outset	(array(char),array(char))->(void)
(	O
outname	*(char)
,	O
outlist	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_str	*(*(char))
[	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
]	O
,	O
"OBS"	*(char)
)	O
;	O
expand	(*(char),*(int),int)->(int)
(	O
outlist1	*(char)
,	O
ovarv1	*(int)
,	O
dap_maxvar	int
)	O
;	O
expand	(*(char),*(int),int)->(int)
(	O
outlist2	*(char)
,	O
ovarv2	*(int)
,	O
dap_maxvar	int
)	O
;	O
dap_ono	int
=	O
0	int
;	O
goon1	int
=	O
step	()->(int)
(	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
dap_ono	int
=	O
1	int
;	O
if	O
(	O
step	()->(int)
(	O
)	O
)	O
{	O
while	O
(	O
goon1	int
)	O
{	O
isdiff	int
=	O
0	int
;	O
if	O
(	O
nmark	int
)	O
{	O
for	O
(	O
v1	int
=	O
0	int
;	O
v1	int
<	O
nmark	int
;	O
v1	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
markv1	*(int)
[	O
v1	int
]	O
]	O
==	O
DBL	O
)	O
{	O
ddiff	double
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
markv1	*(int)
[	O
v1	int
]	O
]	O
-	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_dbl	*(double)
[	O
markv2	*(int)
[	O
v1	int
]	O
]	O
;	O
if	O
(	O
ddiff	double
<	O
0.0	int
)	O
isdiff	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
ddiff	double
>	O
0.0	int
)	O
isdiff	int
=	O
1	int
;	O
else	O
isdiff	int
=	O
0	int
;	O
if	O
(	O
isdiff	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
markv1	*(int)
[	O
v1	int
]	O
]	O
==	O
INT	int
)	O
{	O
isdiff	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
markv1	*(int)
[	O
v1	int
]	O
]	O
-	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_int	*(int)
[	O
markv2	*(int)
[	O
v1	int
]	O
]	O
;	O
if	O
(	O
isdiff	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
(	O
isdiff	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
markv1	*(int)
[	O
v1	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_str	*(*(char))
[	O
markv2	*(int)
[	O
v1	int
]	O
]	O
)	O
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
isdiff	int
<	O
0	int
)	O
{	O
dap_ono	int
=	O
0	int
;	O
goon1	int
=	O
step	()->(int)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
isdiff	int
>	O
0	int
)	O
break	O
;	O
else	O
{	O
for	O
(	O
v1	int
=	O
0	int
;	O
v1	int
<	O
nvar1	int
;	O
v1	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv1	*(int)
[	O
v1	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_dbl	*(double)
[	O
ovarv1	*(int)
[	O
v1	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv1	*(int)
[	O
v1	int
]	O
]	O
;	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv1	*(int)
[	O
v1	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_int	*(int)
[	O
ovarv1	*(int)
[	O
v1	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
varv1	*(int)
[	O
v1	int
]	O
]	O
;	O
else	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_str	*(*(char))
[	O
ovarv1	*(int)
[	O
v1	int
]	O
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_str	*(*(char))
[	O
ovarv1	*(int)
[	O
v1	int
]	O
]	O
,	O
"merge: dap_obs[2].do_str[ovarv1[v1]]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_str	*(*(char))
[	O
ovarv1	*(int)
[	O
v1	int
]	O
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
varv1	*(int)
[	O
v1	int
]	O
]	O
)	O
+	O
1	int
,	O
"merge: dap_obs[0].do_str[ovarv1[v1]]"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_str	*(*(char))
[	O
ovarv1	*(int)
[	O
v1	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
varv1	*(int)
[	O
v1	int
]	O
]	O
)	O
;	O
}	O
}	O
for	O
(	O
v2	int
=	O
0	int
;	O
v2	int
<	O
nvar2	int
;	O
v2	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_len	*(int)
[	O
varv2	*(int)
[	O
v2	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_dbl	*(double)
[	O
ovarv2	*(int)
[	O
v2	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_dbl	*(double)
[	O
varv2	*(int)
[	O
v2	int
]	O
]	O
;	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_len	*(int)
[	O
varv2	*(int)
[	O
v2	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_int	*(int)
[	O
ovarv2	*(int)
[	O
v2	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_int	*(int)
[	O
varv2	*(int)
[	O
v2	int
]	O
]	O
;	O
else	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_str	*(*(char))
[	O
ovarv2	*(int)
[	O
v2	int
]	O
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_str	*(*(char))
[	O
ovarv2	*(int)
[	O
v2	int
]	O
]	O
,	O
"merge: dap_obs[2].do_str[ovarv2[v2]]"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_str	*(*(char))
[	O
ovarv2	*(int)
[	O
v2	int
]	O
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_str	*(*(char))
[	O
varv2	*(int)
[	O
v2	int
]	O
]	O
)	O
+	O
1	int
,	O
"merge: dap_obs[1].do_str[ovarv2[v2]]"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
2	int
]	O
.	O
do_str	*(*(char))
[	O
ovarv2	*(int)
[	O
v2	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
1	int
]	O
.	O
do_str	*(*(char))
[	O
varv2	*(int)
[	O
v2	int
]	O
]	O
)	O
;	O
}	O
}	O
dap_ono	int
=	O
2	int
;	O
output	()->(void)
(	O
)	O
;	O
dap_ono	int
=	O
0	int
;	O
goon1	int
=	O
step	()->(int)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
nmark	int
)	O
break	O
;	O
}	O
}	O
else	O
break	O
;	O
}	O
dap_ono	int
=	O
0	int
;	O
if	O
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
{	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
;	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
1	int
]	O
)	O
{	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
1	int
]	O
)	O
;	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
1	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
)	O
;	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
)	O
NULL	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
outlist	*(char)
,	O
"merge: outlist"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
outlist1	*(char)
,	O
"merge: outlist1"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
outlist2	*(char)
,	O
"merge: outlist2"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
ovarv1	*(int)
,	O
"merge: ovarv1"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
ovarv2	*(int)
,	O
"merge: ovarv2"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
markv1	*(int)
,	O
"merge: markv1"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
markv2	*(int)
,	O
"merge: markv2"	*(char)
)	O
;	O
if	O
(	O
vars1null	int
)	O
dap_free	(*(void),*(char))->(void)
(	O
vars1	*(char)
,	O
"merge: vars1"	*(char)
)	O
;	O
if	O
(	O
vars2null	int
)	O
dap_free	(*(void),*(char))->(void)
(	O
vars2	*(char)
,	O
"merge: vars2"	*(char)
)	O
;	O
if	O
(	O
exclude1	int
<	O
0	int
)	O
{	O
dap_free	(*(void),*(char))->(void)
(	O
vars1a	*(char)
,	O
"merge: vars1a"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv1a	*(int)
,	O
"merge: varv1a"	*(char)
)	O
;	O
}	O
else	O
dap_free	(*(void),*(char))->(void)
(	O
varv1	*(int)
,	O
"merge: varv1"	*(char)
)	O
;	O
if	O
(	O
exclude2	int
<	O
0	int
)	O
{	O
dap_free	(*(void),*(char))->(void)
(	O
vars2a	*(char)
,	O
"merge: vars2a"	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv2a	*(int)
,	O
"merge: varv2a"	*(char)
)	O
;	O
}	O
else	O
dap_free	(*(void),*(char))->(void)
(	O
varv2	*(int)
,	O
"merge: varv2"	*(char)
)	O
;	O
}	O
void	O
title	(*(char))->(void)
(	O
char	O
*	O
text	*(char)
)	O
{	O
dap_title	*(char)
=	O
text	*(char)
;	O
}	O
void	O
dap_head	(array(int),int)->(void)
(	O
int	O
markv	array(int)
[	O
]	O
,	O
int	O
nmark	int
)	O
{	O
time_t	long
t	int
;	O
int	O
m	*(char)
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n================================="	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\nDap %3d. "	*(char)
,	O
pageno	int
++	O
)	O
;	O
time	(*(long))->(long)
(	O
&	O
t	int
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ctime	(*(long))->(*(char))
(	O
&	O
t	int
)	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
dap_title	*(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dap_title	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
nmark	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\nFor: "	*(char)
)	O
;	O
for	O
(	O
m	*(char)
=	O
0	int
;	O
m	*(char)
<	O
nmark	int
;	O
m	*(char)
++	O
)	O
{	O
switch	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
markv	array(int)
[	O
m	*(char)
]	O
]	O
)	O
{	O
case	O
DBL	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s = %g"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
markv	array(int)
[	O
m	*(char)
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
markv	array(int)
[	O
m	*(char)
]	O
]	O
)	O
;	O
break	O
;	O
case	O
INT	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s = %d"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
markv	array(int)
[	O
m	*(char)
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
markv	array(int)
[	O
m	*(char)
]	O
]	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s = %s"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
markv	array(int)
[	O
m	*(char)
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
markv	array(int)
[	O
m	*(char)
]	O
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
m	*(char)
<	O
nmark	int
-	O
1	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
", "	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
typedef	O
struct	O
CharList	struct
CharList	struct
;	O
struct	O
CharList	struct
{	O
char	O
*	O
word	*(char)
;	O
CharList	struct
*	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
;	O
typedef	O
struct	O
AttributeList	struct
AttributeList	struct
;	O
struct	O
AttributeList	struct
{	O
char	O
*	O
word	*(char)
;	O
int	O
size	int
;	O
int	O
type	int
;	O
AttributeList	struct
*	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
;	O
CharList	struct
extractWords	(*(char),long,*(char))->(struct(*(char),*(struct(*(char),*(struct`)))))
(	O
char	O
*	O
buffer	*(char)
,	O
long	O
size	int
,	O
char	O
*	O
delimiter	*(char)
)	O
{	O
char	O
*	O
bufferWord	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
)	O
*	O
size	int
+	O
1	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
bufferWord	*(char)
,	O
'\0'	O
,	O
size	int
+	O
1	int
)	O
;	O
CharList	struct
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
.	O
word	*(char)
=	O
NULL	O
;	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
.	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
CharList	struct
*	O
current	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
&	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
long	O
i	int
=	O
0l	int
;	O
long	O
sSize	long
=	O
0l	int
;	O
long	O
sIndex	long
=	O
0l	int
;	O
for	O
(	O
i	int
=	O
0l	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
buffer	*(char)
[	O
i	int
]	O
==	O
'\r'	O
||	O
buffer	*(char)
[	O
i	int
]	O
==	O
'\t'	O
)	O
continue	O
;	O
if	O
(	O
buffer	*(char)
[	O
i	int
]	O
==	O
delimiter	*(char)
[	O
0	int
]	O
)	O
{	O
current	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
word	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
)	O
*	O
sIndex	long
+	O
5	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
current	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
word	*(char)
,	O
bufferWord	*(char)
)	O
;	O
current	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
CharList	struct
)	O
)	O
;	O
current	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
current	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
sSize	long
=	O
sIndex	long
;	O
sIndex	long
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
bufferWord	*(char)
,	O
'\0'	O
,	O
size	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
bufferWord	*(char)
[	O
sIndex	long
]	O
=	O
buffer	*(char)
[	O
i	int
]	O
;	O
sIndex	long
++	O
;	O
}	O
}	O
if	O
(	O
sIndex	long
>	O
0	int
)	O
{	O
current	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
word	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
(	O
sizeof	O
(	O
char	O
)	O
*	O
strlen	(*(char))->(long)
(	O
bufferWord	*(char)
)	O
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
current	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
word	*(char)
,	O
bufferWord	*(char)
)	O
;	O
current	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
}	O
free	(*(void))->(void)
(	O
bufferWord	*(char)
)	O
;	O
return	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
}	O
void	O
cleanAttributeList	(*(struct(*(char),int,int,*(struct(*`,int,int,*`)))))->(void)
(	O
AttributeList	struct
*	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
)	O
{	O
AttributeList	struct
*	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
do	O
{	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
AttributeList	struct
*	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
AttributeList	struct
*	O
prev2	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
do	O
{	O
prev2	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
;	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
;	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
while	O
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
!=	O
NULL	O
)	O
;	O
if	O
(	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
!=	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
)	O
{	O
free	(*(void))->(void)
(	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
)	O
;	O
}	O
prev2	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
}	O
while	O
(	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
!=	O
NULL	O
)	O
;	O
}	O
void	O
cleanCharList	(*(struct(*(char),*(struct(*`,*`)))))->(void)
(	O
CharList	struct
*	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
)	O
{	O
CharList	struct
*	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
do	O
{	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
CharList	struct
*	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
CharList	struct
*	O
prev2	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
do	O
{	O
prev2	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
;	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
;	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
while	O
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
!=	O
NULL	O
)	O
;	O
if	O
(	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
!=	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
)	O
{	O
free	(*(void))->(void)
(	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
)	O
;	O
}	O
prev2	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
}	O
while	O
(	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
!=	O
NULL	O
)	O
;	O
}	O
int	O
import	(*(char),*(char),*(char),*(char),int,int)->(int)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
fileToLoad	*(char)
,	O
char	O
*	O
format	array(char)
,	O
char	O
*	O
delimiter	*(char)
,	O
int	O
replace	int
,	O
int	O
getnames	int
)	O
{	O
infile	(array(char),array(char))->(void)
(	O
fileToLoad	*(char)
,	O
delimiter	*(char)
)	O
;	O
FILE	struct
*	O
pFile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
long	O
lSize	long
;	O
char	O
*	O
buffer	*(char)
;	O
char	O
*	O
bufferline	*(char)
;	O
size_t	long
result	long
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"CSV"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"DLM"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"csv"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"dlm"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"TAB"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"tab"	*(char)
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Format not supported :%s\n"	*(char)
,	O
format	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
strlen	(*(char))->(long)
(	O
delimiter	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"CSV"	*(char)
)	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"csv"	*(char)
)	O
)	O
delimiter	*(char)
=	O
","	*(char)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"DLM"	*(char)
)	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"dlm"	*(char)
)	O
)	O
delimiter	*(char)
=	O
" "	*(char)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"TAB"	*(char)
)	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
format	array(char)
,	O
"tab"	*(char)
)	O
)	O
delimiter	*(char)
=	O
"\t"	*(char)
;	O
}	O
pFile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fileToLoad	*(char)
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
pFile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
"File loading error :%s\n"	*(char)
,	O
fileToLoad	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
pFile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
,	O
SEEK_END	int
)	O
;	O
lSize	long
=	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
pFile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
rewind	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
pFile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
buffer	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
)	O
*	O
lSize	long
)	O
;	O
if	O
(	O
buffer	*(char)
==	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Memory error \n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
bufferline	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
)	O
*	O
lSize	long
)	O
;	O
if	O
(	O
bufferline	*(char)
==	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
"2nd Memory error \n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
result	long
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buffer	*(char)
,	O
1	int
,	O
lSize	long
,	O
pFile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
result	long
!=	O
lSize	long
)	O
{	O
printf	(*(char))->(int)
(	O
"Reading error \n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
3	int
)	O
;	O
}	O
long	O
sIndex	long
=	O
0l	int
;	O
long	O
sSize	long
=	O
0l	int
;	O
long	O
i	int
=	O
0l	int
;	O
AttributeList	struct
listatt	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`)))))
;	O
listatt	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`)))))
.	O
word	*(char)
=	O
NULL	O
;	O
listatt	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`)))))
.	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
int	O
lineCnt	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0l	int
;	O
i	int
<	O
lSize	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
buffer	*(char)
[	O
i	int
]	O
==	O
'\n'	O
)	O
{	O
CharList	struct
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
=	O
extractWords	(*(char),long,*(char))->(struct(*(char),*(struct(*(char),*(struct`)))))
(	O
bufferline	*(char)
,	O
sIndex	long
,	O
delimiter	*(char)
)	O
;	O
CharList	struct
*	O
actual	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
&	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
int	O
counter	int
=	O
0	int
;	O
do	O
{	O
char	O
*	O
word	*(char)
=	O
actual	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
word	*(char)
;	O
int	O
sizeStr	int
=	O
strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
AttributeList	struct
*	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
&	O
listatt	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`)))))
;	O
AttributeList	struct
*	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
;	O
if	O
(	O
lineCnt	int
==	O
0	int
)	O
{	O
if	O
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
getnames	int
)	O
{	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
)	O
*	O
strlen	(*(char))->(long)
(	O
word	*(char)
)	O
+	O
5	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
,	O
word	*(char)
)	O
;	O
}	O
else	O
{	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
)	O
*	O
10	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
,	O
"X%d"	*(char)
,	O
counter	int
)	O
;	O
}	O
}	O
else	O
{	O
do	O
{	O
char	O
*	O
wordatt	*(char)
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
wordatt	*(char)
,	O
word	*(char)
)	O
==	O
0	int
)	O
{	O
break	O
;	O
}	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
;	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
while	O
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
!=	O
NULL	O
)	O
;	O
if	O
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
==	O
NULL	O
)	O
{	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
(	O
AttributeList	struct
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
AttributeList	struct
)	O
)	O
;	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
word	*(char)
=	O
NULL	O
;	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
if	O
(	O
getnames	int
)	O
{	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
)	O
*	O
strlen	(*(char))->(long)
(	O
word	*(char)
)	O
+	O
5	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
,	O
word	*(char)
)	O
;	O
}	O
else	O
{	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
)	O
*	O
10	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
,	O
"X%d"	*(char)
,	O
counter	int
)	O
;	O
}	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
}	O
}	O
}	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
&	O
listatt	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`)))))
;	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
;	O
if	O
(	O
(	O
getnames	int
&&	O
lineCnt	int
>	O
0	int
)	O
||	O
!	O
getnames	int
)	O
{	O
int	O
counterbis	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
counter	int
==	O
counterbis	int
)	O
break	O
;	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
counterbis	int
++	O
;	O
}	O
while	O
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
!=	O
NULL	O
)	O
;	O
if	O
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
sizeStr	int
>	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
size	int
)	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
size	int
=	O
sizeStr	int
;	O
if	O
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
size	int
>	O
1000	int
)	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
size	int
=	O
1000	int
;	O
float	O
f	*(()->(double))
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
word	*(char)
,	O
"%f"	*(char)
,	O
&	O
f	*(()->(double))
)	O
!=	O
0	int
)	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
type	int
=	O
DOUBLER	int
;	O
else	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
type	int
=	O
STRINGER	int
;	O
}	O
}	O
actual	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
actual	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
counter	int
++	O
;	O
}	O
while	O
(	O
actual	*(struct(*(char),*(struct(*(char),*(struct`)))))
!=	O
NULL	O
)	O
;	O
sSize	long
=	O
sIndex	long
;	O
sIndex	long
=	O
0	int
;	O
lineCnt	int
++	O
;	O
cleanCharList	(*(struct(*(char),*(struct(*`,*`)))))->(void)
(	O
&	O
list	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
)	O
;	O
}	O
else	O
{	O
bufferline	*(char)
[	O
sIndex	long
]	O
=	O
buffer	*(char)
[	O
i	int
]	O
;	O
sIndex	long
++	O
;	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pFile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
buffer	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
bufferline	*(char)
)	O
;	O
AttributeList	struct
*	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
&	O
listatt	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`)))))
;	O
int	O
countcol	int
=	O
0	int
;	O
do	O
{	O
char	O
*	O
wordatt	*(char)
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
word	*(char)
;	O
if	O
(	O
wordatt	*(char)
!=	O
NULL	O
)	O
{	O
int	O
sierr	int
=	O
strlen	(*(char))->(long)
(	O
wordatt	*(char)
)	O
+	O
6	int
;	O
char	O
*	O
bufferer	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
)	O
*	O
sierr	int
)	O
;	O
if	O
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
type	int
==	O
DOUBLER	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
bufferer	*(char)
,	O
"%s -1"	*(char)
,	O
wordatt	*(char)
)	O
;	O
dap_vd	(array(char),int)->(int)
(	O
bufferer	*(char)
,	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
int	O
size	int
=	O
1000	int
;	O
if	O
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
size	int
<	O
1000	int
)	O
size	int
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
size	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
bufferer	*(char)
,	O
"%s %d"	*(char)
,	O
wordatt	*(char)
,	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
size	int
)	O
;	O
dap_vd	(array(char),int)->(int)
(	O
bufferer	*(char)
,	O
size	int
)	O
;	O
}	O
}	O
countcol	int
++	O
;	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
=	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
while	O
(	O
actualatt	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`)))))
!=	O
NULL	O
)	O
;	O
outset	(array(char),array(char))->(void)
(	O
fname	array(char)
,	O
""	*(char)
)	O
;	O
skip	(int)->(void)
(	O
2	int
)	O
;	O
while	O
(	O
step	()->(int)
(	O
)	O
)	O
output	()->(void)
(	O
)	O
;	O
cleanAttributeList	(*(struct(*(char),int,int,*(struct(*`,int,int,*`)))))->(void)
(	O
&	O
listatt	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`)))))
)	O
;	O
return	O
0	int
;	O
}	O
