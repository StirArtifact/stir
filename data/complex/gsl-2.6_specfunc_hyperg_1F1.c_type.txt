static	O
int	O
hyperg_1F1_asymp_negx	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
gsl_sf_result	struct(double,double)
lg_b	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
lg_bma	struct(double,double)
;	O
double	O
sgn_b	double
;	O
double	O
sgn_bma	double
;	O
int	O
stat_b	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
b	double
,	O
&	O
lg_b	struct(double,double)
,	O
&	O
sgn_b	double
)	O
;	O
int	O
stat_bma	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
b	double
-	O
a	double
,	O
&	O
lg_bma	struct(double,double)
,	O
&	O
sgn_bma	double
)	O
;	O
if	O
(	O
stat_b	int
==	O
GSL_SUCCESS	int
&&	O
stat_bma	int
==	O
GSL_SUCCESS	int
)	O
{	O
gsl_sf_result	struct(double,double)
F	struct(double,double)
;	O
int	O
stat_F	int
=	O
gsl_sf_hyperg_2F0_series_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
a	double
,	O
1.0	int
+	O
a	double
-	O
b	double
,	O
-	O
1.0	int
/	O
x	double
,	O
-	O
1	int
,	O
&	O
F	struct(double,double)
)	O
;	O
if	O
(	O
F	struct(double,double)
.	O
val	double
!=	O
0	int
)	O
{	O
double	O
ln_term_val	double
=	O
a	double
*	O
log	(double)->(double)
(	O
-	O
x	double
)	O
;	O
double	O
ln_term_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
+	O
fabs	(double)->(double)
(	O
ln_term_val	double
)	O
)	O
;	O
double	O
ln_pre_val	double
=	O
lg_b	struct(double,double)
.	O
val	double
-	O
lg_bma	struct(double,double)
.	O
val	double
-	O
ln_term_val	double
;	O
double	O
ln_pre_err	double
=	O
lg_b	struct(double,double)
.	O
err	double
+	O
lg_bma	struct(double,double)
.	O
err	double
+	O
ln_term_err	double
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
ln_pre_val	double
,	O
ln_pre_err	double
,	O
sgn_bma	double
*	O
sgn_b	double
*	O
F	struct(double,double)
.	O
val	double
,	O
F	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_F	int
)	O
;	O
}	O
else	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
stat_F	int
;	O
}	O
}	O
else	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
static	O
int	O
hyperg_1F1_asymp_posx	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
gsl_sf_result	struct(double,double)
lg_b	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
lg_a	struct(double,double)
;	O
double	O
sgn_b	double
;	O
double	O
sgn_a	double
;	O
int	O
stat_b	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
b	double
,	O
&	O
lg_b	struct(double,double)
,	O
&	O
sgn_b	double
)	O
;	O
int	O
stat_a	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
a	double
,	O
&	O
lg_a	struct(double,double)
,	O
&	O
sgn_a	double
)	O
;	O
if	O
(	O
stat_a	int
==	O
GSL_SUCCESS	int
&&	O
stat_b	int
==	O
GSL_SUCCESS	int
)	O
{	O
gsl_sf_result	struct(double,double)
F	struct(double,double)
;	O
int	O
stat_F	int
=	O
gsl_sf_hyperg_2F0_series_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
b	double
-	O
a	double
,	O
1.0	int
-	O
a	double
,	O
1.0	int
/	O
x	double
,	O
-	O
1	int
,	O
&	O
F	struct(double,double)
)	O
;	O
if	O
(	O
stat_F	int
==	O
GSL_SUCCESS	int
&&	O
F	struct(double,double)
.	O
val	double
!=	O
0	int
)	O
{	O
double	O
lnx	double
=	O
log	(double)->(double)
(	O
x	double
)	O
;	O
double	O
ln_term_val	double
=	O
(	O
a	double
-	O
b	double
)	O
*	O
lnx	double
;	O
double	O
ln_term_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
+	O
fabs	(double)->(double)
(	O
b	double
)	O
)	O
*	O
fabs	(double)->(double)
(	O
lnx	double
)	O
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
a	double
-	O
b	double
)	O
;	O
double	O
ln_pre_val	double
=	O
lg_b	struct(double,double)
.	O
val	double
-	O
lg_a	struct(double,double)
.	O
val	double
+	O
ln_term_val	double
+	O
x	double
;	O
double	O
ln_pre_err	double
=	O
lg_b	struct(double,double)
.	O
err	double
+	O
lg_a	struct(double,double)
.	O
err	double
+	O
ln_term_err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
ln_pre_val	double
,	O
ln_pre_err	double
,	O
sgn_a	double
*	O
sgn_b	double
*	O
F	struct(double,double)
.	O
val	double
,	O
F	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_F	int
)	O
;	O
}	O
else	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
stat_F	int
;	O
}	O
}	O
else	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
static	O
int	O
hyperg_1F1_largebx	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
y	double
=	O
x	double
/	O
b	double
;	O
double	O
f	*(double)
=	O
exp	(double)->(double)
(	O
-	O
a	double
*	O
log1p	(double)->(double)
(	O
-	O
y	double
)	O
)	O
;	O
double	O
t1	double
=	O
-	O
(	O
(	O
a	double
*	O
(	O
a	double
+	O
1.0	int
)	O
)	O
/	O
(	O
2	int
*	O
b	double
)	O
)	O
*	O
pow	(double,double)->(double)
(	O
(	O
y	double
/	O
(	O
1.0	int
-	O
y	double
)	O
)	O
,	O
2.0	int
)	O
;	O
double	O
t2	double
=	O
(	O
1	int
/	O
(	O
24	int
*	O
b	double
*	O
b	double
)	O
)	O
*	O
(	O
(	O
a	double
*	O
(	O
a	double
+	O
1	int
)	O
*	O
y	double
*	O
y	double
)	O
/	O
pow	(double,double)->(double)
(	O
1	int
-	O
y	double
,	O
4	int
)	O
)	O
*	O
(	O
12	int
+	O
8	int
*	O
(	O
2	int
*	O
a	double
+	O
1	int
)	O
*	O
y	double
+	O
(	O
3	int
*	O
a	double
*	O
a	double
-	O
a	double
-	O
2	int
)	O
*	O
y	double
*	O
y	double
)	O
;	O
double	O
t3	double
=	O
(	O
-	O
1	int
/	O
(	O
48	int
*	O
b	double
*	O
b	double
*	O
b	double
*	O
pow	(double,double)->(double)
(	O
1	int
-	O
y	double
,	O
6	int
)	O
)	O
)	O
*	O
a	double
*	O
(	O
(	O
a	double
+	O
1	int
)	O
*	O
(	O
(	O
y	double
*	O
(	O
(	O
a	double
+	O
1	int
)	O
*	O
(	O
a	double
*	O
(	O
y	double
*	O
(	O
y	double
*	O
(	O
(	O
y	double
*	O
(	O
a	double
-	O
2	int
)	O
+	O
16	int
)	O
*	O
(	O
a	double
-	O
1	int
)	O
)	O
+	O
72	int
)	O
)	O
+	O
96	int
)	O
)	O
+	O
24	int
)	O
*	O
pow	(double,double)->(double)
(	O
y	double
,	O
2	int
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
f	*(double)
*	O
(	O
1	int
+	O
t1	double
+	O
t2	double
+	O
t3	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2	int
*	O
fabs	(double)->(double)
(	O
f	*(double)
*	O
t3	double
)	O
+	O
2	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
hyperg_1F1_large2bm4a	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
eta	double
=	O
2.0	int
*	O
b	double
-	O
4.0	int
*	O
a	double
;	O
double	O
cos2th	double
=	O
x	double
/	O
eta	double
;	O
double	O
sin2th	double
=	O
1.0	int
-	O
cos2th	double
;	O
double	O
th	double
=	O
acos	(double)->(double)
(	O
sqrt	(double)->(double)
(	O
cos2th	double
)	O
)	O
;	O
double	O
pre_h	double
=	O
0.25	int
*	O
M_PI	int
*	O
M_PI	int
*	O
eta	double
*	O
eta	double
*	O
cos2th	double
*	O
sin2th	double
;	O
gsl_sf_result	struct(double,double)
lg_b	struct(double,double)
;	O
int	O
stat_lg	int
=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
b	double
,	O
&	O
lg_b	struct(double,double)
)	O
;	O
double	O
t1	double
=	O
0.5	int
*	O
(	O
1.0	int
-	O
b	double
)	O
*	O
log	(double)->(double)
(	O
0.25	int
*	O
x	double
*	O
eta	double
)	O
;	O
double	O
t2	double
=	O
0.25	int
*	O
log	(double)->(double)
(	O
pre_h	double
)	O
;	O
double	O
lnpre_val	double
=	O
lg_b	struct(double,double)
.	O
val	double
+	O
0.5	int
*	O
x	double
+	O
t1	double
-	O
t2	double
;	O
double	O
lnpre_err	double
=	O
lg_b	struct(double,double)
.	O
err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
0.5	int
*	O
x	double
)	O
+	O
fabs	(double)->(double)
(	O
t1	double
)	O
+	O
fabs	(double)->(double)
(	O
t2	double
)	O
)	O
;	O
double	O
s1	double
=	O
sin	(double)->(double)
(	O
a	double
*	O
M_PI	int
)	O
;	O
double	O
s2	double
=	O
sin	(double)->(double)
(	O
0.25	int
*	O
eta	double
*	O
(	O
2.0	int
*	O
th	double
-	O
sin	(double)->(double)
(	O
2.0	int
*	O
th	double
)	O
)	O
+	O
0.25	int
*	O
M_PI	int
)	O
;	O
double	O
ser_val	double
=	O
s1	double
+	O
s2	double
;	O
double	O
ser_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
s1	double
)	O
+	O
fabs	(double)->(double)
(	O
s2	double
)	O
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
lnpre_val	double
,	O
lnpre_err	double
,	O
ser_val	double
,	O
ser_err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_lg	int
)	O
;	O
}	O
static	O
int	O
hyperg_1F1_luke	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
c	double
,	O
const	O
double	O
xin	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
RECUR_BIG	double
=	O
1.0e+50	int
;	O
const	O
int	O
nmax	int
=	O
5000	int
;	O
int	O
n	int
=	O
3	int
;	O
const	O
double	O
x	double
=	O
-	O
xin	double
;	O
const	O
double	O
x3	double
=	O
x	double
*	O
x	double
*	O
x	double
;	O
const	O
double	O
t0	double
=	O
a	double
/	O
c	double
;	O
const	O
double	O
t1	double
=	O
(	O
a	double
+	O
1.0	int
)	O
/	O
(	O
2.0	int
*	O
c	double
)	O
;	O
const	O
double	O
t2	double
=	O
(	O
a	double
+	O
2.0	int
)	O
/	O
(	O
2.0	int
*	O
(	O
c	double
+	O
1.0	int
)	O
)	O
;	O
double	O
F	struct(double,double)
=	O
1.0	int
;	O
double	O
prec	double
;	O
double	O
Bnm3	double
=	O
1.0	int
;	O
double	O
Bnm2	double
=	O
1.0	int
+	O
t1	double
*	O
x	double
;	O
double	O
Bnm1	double
=	O
1.0	int
+	O
t2	double
*	O
x	double
*	O
(	O
1.0	int
+	O
t1	double
/	O
3.0	int
*	O
x	double
)	O
;	O
double	O
Anm3	double
=	O
1.0	int
;	O
double	O
Anm2	double
=	O
Bnm2	double
-	O
t0	double
*	O
x	double
;	O
double	O
Anm1	double
=	O
Bnm1	double
-	O
t0	double
*	O
(	O
1.0	int
+	O
t2	double
*	O
x	double
)	O
*	O
x	double
+	O
t0	double
*	O
t1	double
*	O
(	O
c	double
/	O
(	O
c	double
+	O
1.0	int
)	O
)	O
*	O
x	double
*	O
x	double
;	O
while	O
(	O
1	int
)	O
{	O
double	O
npam1	double
=	O
n	int
+	O
a	double
-	O
1	int
;	O
double	O
npcm1	double
=	O
n	int
+	O
c	double
-	O
1	int
;	O
double	O
npam2	double
=	O
n	int
+	O
a	double
-	O
2	int
;	O
double	O
npcm2	double
=	O
n	int
+	O
c	double
-	O
2	int
;	O
double	O
tnm1	double
=	O
2	int
*	O
n	int
-	O
1	int
;	O
double	O
tnm3	double
=	O
2	int
*	O
n	int
-	O
3	int
;	O
double	O
tnm5	double
=	O
2	int
*	O
n	int
-	O
5	int
;	O
double	O
F1	double
=	O
(	O
n	int
-	O
a	double
-	O
2	int
)	O
/	O
(	O
2	int
*	O
tnm3	double
*	O
npcm1	double
)	O
;	O
double	O
F2	double
=	O
(	O
n	int
+	O
a	double
)	O
*	O
npam1	double
/	O
(	O
4	int
*	O
tnm1	double
*	O
tnm3	double
*	O
npcm2	double
*	O
npcm1	double
)	O
;	O
double	O
F3	double
=	O
-	O
npam2	double
*	O
npam1	double
*	O
(	O
n	int
-	O
a	double
-	O
2	int
)	O
/	O
(	O
8	int
*	O
tnm3	double
*	O
tnm3	double
*	O
tnm5	double
*	O
(	O
n	int
+	O
c	double
-	O
3	int
)	O
*	O
npcm2	double
*	O
npcm1	double
)	O
;	O
double	O
E	double
=	O
-	O
npam1	double
*	O
(	O
n	int
-	O
c	double
-	O
1	int
)	O
/	O
(	O
2	int
*	O
tnm3	double
*	O
npcm2	double
*	O
npcm1	double
)	O
;	O
double	O
An	double
=	O
(	O
1.0	int
+	O
F1	double
*	O
x	double
)	O
*	O
Anm1	double
+	O
(	O
E	double
+	O
F2	double
*	O
x	double
)	O
*	O
x	double
*	O
Anm2	double
+	O
F3	double
*	O
x3	double
*	O
Anm3	double
;	O
double	O
Bn	double
=	O
(	O
1.0	int
+	O
F1	double
*	O
x	double
)	O
*	O
Bnm1	double
+	O
(	O
E	double
+	O
F2	double
*	O
x	double
)	O
*	O
x	double
*	O
Bnm2	double
+	O
F3	double
*	O
x3	double
*	O
Bnm3	double
;	O
double	O
r	*(struct(double,double))
=	O
An	double
/	O
Bn	double
;	O
prec	double
=	O
fabs	(double)->(double)
(	O
(	O
F	struct(double,double)
-	O
r	*(struct(double,double))
)	O
/	O
F	struct(double,double)
)	O
;	O
F	struct(double,double)
=	O
r	*(struct(double,double))
;	O
if	O
(	O
prec	double
<	O
GSL_DBL_EPSILON	int
||	O
n	int
>	O
nmax	int
)	O
break	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
An	double
)	O
>	O
RECUR_BIG	double
||	O
fabs	(double)->(double)
(	O
Bn	double
)	O
>	O
RECUR_BIG	double
)	O
{	O
An	double
/=	O
RECUR_BIG	double
;	O
Bn	double
/=	O
RECUR_BIG	double
;	O
Anm1	double
/=	O
RECUR_BIG	double
;	O
Bnm1	double
/=	O
RECUR_BIG	double
;	O
Anm2	double
/=	O
RECUR_BIG	double
;	O
Bnm2	double
/=	O
RECUR_BIG	double
;	O
Anm3	double
/=	O
RECUR_BIG	double
;	O
Bnm3	double
/=	O
RECUR_BIG	double
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
An	double
)	O
<	O
1.0	int
/	O
RECUR_BIG	double
||	O
fabs	(double)->(double)
(	O
Bn	double
)	O
<	O
1.0	int
/	O
RECUR_BIG	double
)	O
{	O
An	double
*=	O
RECUR_BIG	double
;	O
Bn	double
*=	O
RECUR_BIG	double
;	O
Anm1	double
*=	O
RECUR_BIG	double
;	O
Bnm1	double
*=	O
RECUR_BIG	double
;	O
Anm2	double
*=	O
RECUR_BIG	double
;	O
Bnm2	double
*=	O
RECUR_BIG	double
;	O
Anm3	double
*=	O
RECUR_BIG	double
;	O
Bnm3	double
*=	O
RECUR_BIG	double
;	O
}	O
n	int
++	O
;	O
Bnm3	double
=	O
Bnm2	double
;	O
Bnm2	double
=	O
Bnm1	double
;	O
Bnm1	double
=	O
Bn	double
;	O
Anm3	double
=	O
Anm2	double
;	O
Anm2	double
=	O
Anm1	double
;	O
Anm1	double
=	O
An	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
F	struct(double,double)
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
fabs	(double)->(double)
(	O
F	struct(double,double)
*	O
prec	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
n	int
-	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
F	struct(double,double)
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
hyperg_1F1_1_series	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
sum_val	double
=	O
1.0	int
;	O
double	O
sum_err	double
=	O
0.0	int
;	O
double	O
term	double
=	O
1.0	int
;	O
double	O
n	int
=	O
1.0	int
;	O
while	O
(	O
fabs	(double)->(double)
(	O
term	double
/	O
sum_val	double
)	O
>	O
0.25	int
*	O
GSL_DBL_EPSILON	int
)	O
{	O
term	double
*=	O
x	double
/	O
(	O
b	double
+	O
n	int
-	O
1	int
)	O
;	O
sum_val	double
+=	O
term	double
;	O
sum_err	double
+=	O
8.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
term	double
)	O
+	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
sum_val	double
)	O
;	O
n	int
+=	O
1.0	int
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
sum_val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
sum_err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
fabs	(double)->(double)
(	O
term	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
hyperg_1F1_1_int	(int,double,*(struct(double,double)))->(int)
(	O
const	O
int	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
b	double
<	O
1	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
==	O
1	int
)	O
{	O
return	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
==	O
2	int
)	O
{	O
return	O
gsl_sf_exprel_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
==	O
3	int
)	O
{	O
return	O
gsl_sf_exprel_2_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
return	O
gsl_sf_exprel_n_e	(int,double,*(struct(double,double)))->(int)
(	O
b	double
-	O
1	int
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
static	O
int	O
hyperg_1F1_1	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
ax	double
=	O
fabs	(double)->(double)
(	O
x	double
)	O
;	O
double	O
ib	double
=	O
floor	(double)->(double)
(	O
b	double
+	O
0.1	int
)	O
;	O
if	O
(	O
b	double
<	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
==	O
1.0	int
)	O
{	O
return	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
>=	O
1.4	int
*	O
ax	double
)	O
{	O
return	O
hyperg_1F1_1_series	(double,double,*(struct(double,double)))->(int)
(	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
b	double
-	O
ib	double
)	O
<	O
_1F1_INT_THRESHOLD	O
&&	O
ib	double
<	O
INT_MAX	O
)	O
{	O
return	O
hyperg_1F1_1_int	(int,double,*(struct(double,double)))->(int)
(	O
(	O
int	O
)	O
ib	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
0.0	int
)	O
{	O
if	O
(	O
x	double
>	O
100.0	int
&&	O
b	double
<	O
0.75	int
*	O
x	double
)	O
{	O
return	O
hyperg_1F1_asymp_posx	(double,double,double,*(struct(double,double)))->(int)
(	O
1.0	int
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
<	O
1.0e+05	int
)	O
{	O
const	O
double	O
off	double
=	O
ceil	(double)->(double)
(	O
1.4	int
*	O
x	double
-	O
b	double
)	O
+	O
1.0	int
;	O
double	O
bp	double
=	O
b	double
+	O
off	double
;	O
gsl_sf_result	struct(double,double)
M	struct(double,double)
;	O
int	O
stat_s	int
=	O
hyperg_1F1_1_series	(double,double,*(struct(double,double)))->(int)
(	O
bp	double
,	O
x	double
,	O
&	O
M	struct(double,double)
)	O
;	O
const	O
double	O
err_rat	double
=	O
M	struct(double,double)
.	O
err	double
/	O
fabs	(double)->(double)
(	O
M	struct(double,double)
.	O
val	double
)	O
;	O
while	O
(	O
bp	double
>	O
b	double
+	O
0.1	int
)	O
{	O
bp	double
-=	O
1.0	int
;	O
M	struct(double,double)
.	O
val	double
=	O
1.0	int
+	O
x	double
/	O
bp	double
*	O
M	struct(double,double)
.	O
val	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
M	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
err_rat	double
*	O
fabs	(double)->(double)
(	O
M	struct(double,double)
.	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
off	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
M	struct(double,double)
.	O
val	double
)	O
;	O
return	O
stat_s	int
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
<	O
fabs	(double)->(double)
(	O
b	double
)	O
&&	O
fabs	(double)->(double)
(	O
x	double
)	O
<	O
sqrt	(double)->(double)
(	O
fabs	(double)->(double)
(	O
b	double
)	O
)	O
*	O
fabs	(double)->(double)
(	O
b	double
-	O
x	double
)	O
)	O
{	O
return	O
hyperg_1F1_largebx	(double,double,double,*(struct(double,double)))->(int)
(	O
1.0	int
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
>	O
fabs	(double)->(double)
(	O
b	double
)	O
)	O
{	O
return	O
hyperg_1F1_1_series	(double,double,*(struct(double,double)))->(int)
(	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
return	O
hyperg_1F1_large2bm4a	(double,double,double,*(struct(double,double)))->(int)
(	O
1.0	int
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
ax	double
<	O
10.0	int
&&	O
b	double
<	O
10.0	int
)	O
{	O
return	O
hyperg_1F1_1_series	(double,double,*(struct(double,double)))->(int)
(	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
ax	double
>=	O
100.0	int
&&	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
2.0	int
-	O
b	double
)	O
,	O
1.0	int
)	O
<	O
0.99	int
*	O
ax	double
)	O
{	O
return	O
hyperg_1F1_asymp_negx	(double,double,double,*(struct(double,double)))->(int)
(	O
1.0	int
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
return	O
hyperg_1F1_luke	(double,double,double,*(struct(double,double)))->(int)
(	O
1.0	int
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
}	O
static	O
int	O
hyperg_1F1_renorm_b0	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
eta	double
=	O
a	double
*	O
x	double
;	O
if	O
(	O
eta	double
>	O
0.0	int
)	O
{	O
double	O
root_eta	double
=	O
sqrt	(double)->(double)
(	O
eta	double
)	O
;	O
gsl_sf_result	struct(double,double)
I1_scaled	struct(double,double)
;	O
int	O
stat_I	int
=	O
gsl_sf_bessel_I1_scaled_e	(double,*(struct(double,double)))->(int)
(	O
2.0	int
*	O
root_eta	double
,	O
&	O
I1_scaled	struct(double,double)
)	O
;	O
if	O
(	O
I1_scaled	struct(double,double)
.	O
val	double
<=	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_I	int
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
{	O
const	O
double	O
corr1	double
=	O
(	O
2.0	int
/	O
3.0	int
)	O
*	O
a	double
*	O
pow	(double,double)->(double)
(	O
x	double
/	O
(	O
4.0	int
*	O
a	double
)	O
,	O
1.5	int
)	O
*	O
gsl_sf_bessel_In_scaled	(int,double)->(double)
(	O
2	int
,	O
2.0	int
*	O
root_eta	double
)	O
;	O
const	O
double	O
lnr_val	double
=	O
0.5	int
*	O
x	double
+	O
0.5	int
*	O
log	(double)->(double)
(	O
eta	double
)	O
+	O
fabs	(double)->(double)
(	O
2.0	int
*	O
root_eta	double
)	O
+	O
log	(double)->(double)
(	O
I1_scaled	struct(double,double)
.	O
val	double
+	O
corr1	double
)	O
;	O
const	O
double	O
lnr_err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
1.5	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
+	O
1.0	int
)	O
+	O
fabs	(double)->(double)
(	O
(	O
I1_scaled	struct(double,double)
.	O
err	double
+	O
corr1	double
)	O
/	O
I1_scaled	struct(double,double)
.	O
val	double
)	O
;	O
return	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
lnr_val	double
,	O
lnr_err	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
eta	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
root_eta	double
=	O
sqrt	(double)->(double)
(	O
-	O
eta	double
)	O
;	O
gsl_sf_result	struct(double,double)
J1	struct(double,double)
;	O
int	O
stat_J	int
=	O
gsl_sf_bessel_J1_e	(double,*(struct(double,double)))->(int)
(	O
2.0	int
*	O
root_eta	double
,	O
&	O
J1	struct(double,double)
)	O
;	O
if	O
(	O
J1	struct(double,double)
.	O
val	double
<=	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_J	int
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
{	O
const	O
double	O
t1	double
=	O
0.5	int
*	O
x	double
;	O
const	O
double	O
t2	double
=	O
0.5	int
*	O
log	(double)->(double)
(	O
-	O
eta	double
)	O
;	O
const	O
double	O
t3	double
=	O
fabs	(double)->(double)
(	O
x	double
)	O
;	O
const	O
double	O
t4	double
=	O
log	(double)->(double)
(	O
J1	struct(double,double)
.	O
val	double
)	O
;	O
const	O
double	O
lnr_val	double
=	O
t1	double
+	O
t2	double
+	O
t3	double
+	O
t4	double
;	O
const	O
double	O
lnr_err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
1.5	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
+	O
1.0	int
)	O
+	O
fabs	(double)->(double)
(	O
J1	struct(double,double)
.	O
err	double
/	O
J1	struct(double,double)
.	O
val	double
)	O
;	O
gsl_sf_result	struct(double,double)
ex	struct(double,double)
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
lnr_val	double
,	O
lnr_err	double
,	O
&	O
ex	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
ex	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
ex	struct(double,double)
.	O
err	double
;	O
return	O
stat_e	int
;	O
}	O
}	O
}	O
static	O
int	O
hyperg_1F1_CF1_p_ser	(double,double,double,*(double))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
a	double
==	O
0.0	int
)	O
{	O
*	O
result	*(struct(double,double))
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
int	O
maxiter	int
=	O
5000	int
;	O
double	O
sum	double
=	O
1.0	int
;	O
double	O
pk	double
=	O
1.0	int
;	O
double	O
rhok	double
=	O
0.0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
maxiter	int
;	O
k	int
++	O
)	O
{	O
double	O
ak	double
=	O
(	O
a	double
+	O
k	int
)	O
*	O
x	double
/	O
(	O
(	O
b	double
-	O
x	double
+	O
k	int
-	O
1.0	int
)	O
*	O
(	O
b	double
-	O
x	double
+	O
k	int
)	O
)	O
;	O
rhok	double
=	O
-	O
ak	double
*	O
(	O
1.0	int
+	O
rhok	double
)	O
/	O
(	O
1.0	int
+	O
ak	double
*	O
(	O
1.0	int
+	O
rhok	double
)	O
)	O
;	O
pk	double
*=	O
rhok	double
;	O
sum	double
+=	O
pk	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
pk	double
/	O
sum	double
)	O
<	O
2.0	int
*	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
*	O
result	*(struct(double,double))
=	O
a	double
/	O
(	O
b	double
-	O
x	double
)	O
*	O
sum	double
;	O
if	O
(	O
k	int
==	O
maxiter	int
)	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
hyperg_1F1_small_a_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
bma	double
=	O
b	double
-	O
a	double
;	O
const	O
double	O
oma	double
=	O
1.0	int
-	O
a	double
;	O
const	O
double	O
ap1mb	double
=	O
1.0	int
+	O
a	double
-	O
b	double
;	O
const	O
double	O
abs_bma	double
=	O
fabs	(double)->(double)
(	O
bma	double
)	O
;	O
const	O
double	O
abs_oma	double
=	O
fabs	(double)->(double)
(	O
oma	double
)	O
;	O
const	O
double	O
abs_ap1mb	double
=	O
fabs	(double)->(double)
(	O
ap1mb	double
)	O
;	O
const	O
double	O
ax	double
=	O
fabs	(double)->(double)
(	O
x	double
)	O
;	O
if	O
(	O
a	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
a	double
==	O
1.0	int
&&	O
b	double
>=	O
1.0	int
)	O
{	O
return	O
hyperg_1F1_1	(double,double,*(struct(double,double)))->(int)
(	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
a	double
==	O
-	O
1.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
+	O
a	double
/	O
b	double
*	O
x	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
1.0	int
+	O
fabs	(double)->(double)
(	O
a	double
/	O
b	double
*	O
x	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
b	double
>=	O
1.4	int
*	O
ax	double
)	O
{	O
return	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
0.0	int
)	O
{	O
if	O
(	O
x	double
>	O
100.0	int
&&	O
abs_bma	double
*	O
abs_oma	double
<	O
0.5	int
*	O
x	double
)	O
{	O
return	O
hyperg_1F1_asymp_posx	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
<	O
5.0e+06	int
)	O
{	O
const	O
double	O
b_del	double
=	O
ceil	(double)->(double)
(	O
1.4	int
*	O
x	double
-	O
b	double
)	O
+	O
1.0	int
;	O
double	O
bp	double
=	O
b	double
+	O
b_del	double
;	O
gsl_sf_result	struct(double,double)
r_Mbp1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
r_Mb	struct(double,double)
;	O
double	O
Mbp1	double
;	O
double	O
Mb	double
;	O
double	O
Mbm1	double
;	O
int	O
stat_0	int
=	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
bp	double
+	O
1.0	int
,	O
x	double
,	O
&	O
r_Mbp1	struct(double,double)
)	O
;	O
int	O
stat_1	int
=	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
bp	double
,	O
x	double
,	O
&	O
r_Mb	struct(double,double)
)	O
;	O
const	O
double	O
err_rat	double
=	O
fabs	(double)->(double)
(	O
r_Mbp1	struct(double,double)
.	O
err	double
/	O
r_Mbp1	struct(double,double)
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
r_Mb	struct(double,double)
.	O
err	double
/	O
r_Mb	struct(double,double)
.	O
val	double
)	O
;	O
Mbp1	double
=	O
r_Mbp1	struct(double,double)
.	O
val	double
;	O
Mb	double
=	O
r_Mb	struct(double,double)
.	O
val	double
;	O
while	O
(	O
bp	double
>	O
b	double
+	O
0.1	int
)	O
{	O
Mbm1	double
=	O
(	O
(	O
x	double
+	O
bp	double
-	O
1.0	int
)	O
*	O
Mb	double
-	O
x	double
*	O
(	O
bp	double
-	O
a	double
)	O
/	O
bp	double
*	O
Mbp1	double
)	O
/	O
(	O
bp	double
-	O
1.0	int
)	O
;	O
bp	double
-=	O
1.0	int
;	O
Mbp1	double
=	O
Mb	double
;	O
Mb	double
=	O
Mbm1	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
Mb	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
err_rat	double
*	O
(	O
fabs	(double)->(double)
(	O
b_del	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Mb	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Mb	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_0	int
,	O
stat_1	int
)	O
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
<	O
fabs	(double)->(double)
(	O
b	double
)	O
&&	O
fabs	(double)->(double)
(	O
a	double
*	O
x	double
)	O
<	O
sqrt	(double)->(double)
(	O
fabs	(double)->(double)
(	O
b	double
)	O
)	O
*	O
fabs	(double)->(double)
(	O
b	double
-	O
x	double
)	O
)	O
{	O
return	O
hyperg_1F1_largebx	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
return	O
hyperg_1F1_large2bm4a	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
ax	double
<	O
10.0	int
&&	O
b	double
<	O
10.0	int
)	O
{	O
return	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
ax	double
>=	O
100.0	int
&&	O
GSL_MAX	O
(	O
abs_ap1mb	double
,	O
1.0	int
)	O
<	O
0.99	int
*	O
ax	double
)	O
{	O
return	O
hyperg_1F1_asymp_negx	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
return	O
hyperg_1F1_luke	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
}	O
static	O
int	O
hyperg_1F1_beps_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
eps	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
b	double
>	O
fabs	(double)->(double)
(	O
x	double
)	O
&&	O
fabs	(double)->(double)
(	O
eps	double
)	O
<	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
double	O
a	double
=	O
b	double
+	O
eps	double
;	O
gsl_sf_result	struct(double,double)
exab	struct(double,double)
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
a	double
*	O
x	double
/	O
b	double
,	O
&	O
exab	struct(double,double)
)	O
;	O
double	O
v2	double
=	O
a	double
/	O
(	O
2.0	int
*	O
b	double
*	O
b	double
*	O
(	O
b	double
+	O
1.0	int
)	O
)	O
;	O
double	O
v3	double
=	O
a	double
*	O
(	O
b	double
-	O
2.0	int
*	O
a	double
)	O
/	O
(	O
3.0	int
*	O
b	double
*	O
b	double
*	O
b	double
*	O
(	O
b	double
+	O
1.0	int
)	O
*	O
(	O
b	double
+	O
2.0	int
)	O
)	O
;	O
double	O
v	*(double)
=	O
v2	double
+	O
v3	double
*	O
x	double
;	O
double	O
f	*(double)
=	O
(	O
1.0	int
-	O
eps	double
*	O
x	double
*	O
x	double
*	O
v	*(double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
exab	struct(double,double)
.	O
val	double
*	O
f	*(double)
;	O
result	*(struct(double,double))
->	O
err	double
=	O
exab	struct(double,double)
.	O
err	double
*	O
fabs	(double)->(double)
(	O
f	*(double)
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
fabs	(double)->(double)
(	O
exab	struct(double,double)
.	O
val	double
)	O
*	O
GSL_DBL_EPSILON	int
*	O
(	O
1.0	int
+	O
fabs	(double)->(double)
(	O
eps	double
*	O
x	double
*	O
x	double
*	O
v	*(double)
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
stat_e	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
Kummer_1F1	struct(double,double)
;	O
int	O
stat_K	int
=	O
hyperg_1F1_small_a_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
-	O
eps	double
,	O
b	double
,	O
-	O
x	double
,	O
&	O
Kummer_1F1	struct(double,double)
)	O
;	O
if	O
(	O
Kummer_1F1	struct(double,double)
.	O
val	double
!=	O
0.0	int
)	O
{	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
x	double
,	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
,	O
Kummer_1F1	struct(double,double)
.	O
val	double
,	O
Kummer_1F1	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_K	int
)	O
;	O
}	O
else	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
stat_K	int
;	O
}	O
}	O
}	O
static	O
int	O
hyperg_1F1_beq2a_pos	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
I	struct(double,double)
;	O
int	O
stat_I	int
=	O
gsl_sf_bessel_Inu_scaled_e	(double,double,*(struct(double,double)))->(int)
(	O
a	double
-	O
0.5	int
,	O
0.5	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
,	O
&	O
I	struct(double,double)
)	O
;	O
gsl_sf_result	struct(double,double)
lg	struct(double,double)
;	O
int	O
stat_g	int
=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
a	double
+	O
0.5	int
,	O
&	O
lg	struct(double,double)
)	O
;	O
double	O
ln_term	double
=	O
(	O
0.5	int
-	O
a	double
)	O
*	O
log	(double)->(double)
(	O
0.25	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
;	O
double	O
lnpre_val	double
=	O
lg	struct(double,double)
.	O
val	double
+	O
GSL_MAX_DBL	(double,double)->(double)
(	O
x	double
,	O
0.0	int
)	O
+	O
ln_term	double
;	O
double	O
lnpre_err	double
=	O
lg	struct(double,double)
.	O
err	double
+	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
ln_term	double
)	O
+	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
lnpre_val	double
,	O
lnpre_err	double
,	O
I	struct(double,double)
.	O
val	double
,	O
I	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_g	int
,	O
stat_I	int
)	O
;	O
}	O
}	O
static	O
int	O
hyperg_1F1_ab_posint	(int,int,double,*(struct(double,double)))->(int)
(	O
const	O
int	O
a	double
,	O
const	O
int	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
ax	double
=	O
fabs	(double)->(double)
(	O
x	double
)	O
;	O
if	O
(	O
a	double
==	O
b	double
)	O
{	O
return	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
a	double
==	O
1	int
)	O
{	O
return	O
gsl_sf_exprel_n_e	(int,double,*(struct(double,double)))->(int)
(	O
b	double
-	O
1	int
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
==	O
a	double
+	O
1	int
)	O
{	O
gsl_sf_result	struct(double,double)
K	struct(double,double)
;	O
int	O
stat_K	int
=	O
gsl_sf_exprel_n_e	(int,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
-	O
x	double
,	O
&	O
K	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
x	double
,	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
,	O
K	struct(double,double)
.	O
val	double
,	O
K	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_K	int
)	O
;	O
}	O
else	O
if	O
(	O
a	double
==	O
b	double
+	O
1	int
)	O
{	O
gsl_sf_result	struct(double,double)
ex	struct(double,double)
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
ex	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
ex	struct(double,double)
.	O
val	double
*	O
(	O
1.0	int
+	O
x	double
/	O
b	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
ex	struct(double,double)
.	O
err	double
*	O
(	O
1.0	int
+	O
x	double
/	O
b	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
ex	struct(double,double)
.	O
val	double
*	O
GSL_DBL_EPSILON	int
*	O
(	O
1.0	int
+	O
fabs	(double)->(double)
(	O
x	double
/	O
b	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
stat_e	int
;	O
}	O
else	O
if	O
(	O
a	double
==	O
b	double
+	O
2	int
)	O
{	O
gsl_sf_result	struct(double,double)
ex	struct(double,double)
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
ex	struct(double,double)
)	O
;	O
double	O
poly	double
=	O
(	O
1.0	int
+	O
x	double
/	O
b	double
*	O
(	O
2.0	int
+	O
x	double
/	O
(	O
b	double
+	O
1.0	int
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
ex	struct(double,double)
.	O
val	double
*	O
poly	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
ex	struct(double,double)
.	O
err	double
*	O
fabs	(double)->(double)
(	O
poly	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
ex	struct(double,double)
.	O
val	double
*	O
GSL_DBL_EPSILON	int
*	O
(	O
1.0	int
+	O
fabs	(double)->(double)
(	O
x	double
/	O
b	double
)	O
*	O
(	O
2.0	int
+	O
fabs	(double)->(double)
(	O
x	double
/	O
(	O
b	double
+	O
1.0	int
)	O
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
stat_e	int
;	O
}	O
else	O
if	O
(	O
b	double
==	O
2	int
*	O
a	double
)	O
{	O
return	O
hyperg_1F1_beq2a_pos	(double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
(	O
b	double
<	O
10	int
&&	O
a	double
<	O
10	int
&&	O
ax	double
<	O
5.0	int
)	O
||	O
(	O
b	double
>	O
a	double
*	O
ax	double
)	O
||	O
(	O
b	double
>	O
a	double
&&	O
ax	double
<	O
5.0	int
)	O
)	O
{	O
return	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
>	O
a	double
&&	O
b	double
>=	O
2	int
*	O
a	double
+	O
x	double
)	O
{	O
double	O
rap	double
;	O
int	O
stat_CF1	int
=	O
hyperg_1F1_CF1_p_ser	(double,double,double,*(double))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
rap	double
)	O
;	O
double	O
ra	double
=	O
1.0	int
+	O
x	double
/	O
a	double
*	O
rap	double
;	O
double	O
Ma	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Map1	double
=	O
ra	double
*	O
Ma	double
;	O
double	O
Mnp1	double
=	O
Map1	double
;	O
double	O
Mn	double
=	O
Ma	double
;	O
double	O
Mnm1	double
;	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
a	double
;	O
n	int
>	O
0	int
;	O
n	int
--	O
)	O
{	O
Mnm1	double
=	O
(	O
n	int
*	O
Mnp1	double
-	O
(	O
2	int
*	O
n	int
-	O
b	double
+	O
x	double
)	O
*	O
Mn	double
)	O
/	O
(	O
b	double
-	O
n	int
)	O
;	O
Mnp1	double
=	O
Mn	double
;	O
Mn	double
=	O
Mnm1	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
Ma	double
/	O
Mn	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Ma	double
/	O
Mn	double
)	O
;	O
return	O
stat_CF1	int
;	O
}	O
else	O
if	O
(	O
b	double
>	O
a	double
&&	O
b	double
<	O
2	int
*	O
a	double
+	O
x	double
&&	O
b	double
>	O
x	double
)	O
{	O
double	O
rap	double
;	O
int	O
stat_CF1	int
=	O
hyperg_1F1_CF1_p_ser	(double,double,double,*(double))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
rap	double
)	O
;	O
double	O
ra	double
=	O
1.0	int
+	O
x	double
/	O
a	double
*	O
rap	double
;	O
gsl_sf_result	struct(double,double)
ex	struct(double,double)
;	O
int	O
stat_ex	int
;	O
double	O
Ma	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Map1	double
=	O
ra	double
*	O
Ma	double
;	O
double	O
Mnm1	double
=	O
Ma	double
;	O
double	O
Mn	double
=	O
Map1	double
;	O
double	O
Mnp1	double
;	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
a	double
+	O
1	int
;	O
n	int
<	O
b	double
;	O
n	int
++	O
)	O
{	O
Mnp1	double
=	O
(	O
(	O
b	double
-	O
n	int
)	O
*	O
Mnm1	double
+	O
(	O
2	int
*	O
n	int
-	O
b	double
+	O
x	double
)	O
*	O
Mn	double
)	O
/	O
n	int
;	O
Mnm1	double
=	O
Mn	double
;	O
Mn	double
=	O
Mnp1	double
;	O
}	O
stat_ex	int
=	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
ex	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
ex	struct(double,double)
.	O
val	double
*	O
Ma	double
/	O
Mn	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
ex	struct(double,double)
.	O
err	double
*	O
fabs	(double)->(double)
(	O
Ma	double
/	O
Mn	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
b	double
-	O
a	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_ex	int
,	O
stat_CF1	int
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>=	O
0.0	int
)	O
{	O
if	O
(	O
b	double
<	O
a	double
)	O
{	O
if	O
(	O
x	double
+	O
log	(double)->(double)
(	O
fabs	(double)->(double)
(	O
x	double
/	O
b	double
)	O
)	O
<	O
GSL_LOG_DBL_MAX	int
-	O
2.0	int
)	O
{	O
double	O
ex	struct(double,double)
=	O
exp	(double)->(double)
(	O
x	double
)	O
;	O
int	O
n	int
;	O
double	O
Mnm1	double
=	O
ex	struct(double,double)
;	O
double	O
Mn	double
=	O
ex	struct(double,double)
*	O
(	O
1.0	int
+	O
x	double
/	O
b	double
)	O
;	O
double	O
Mnp1	double
;	O
for	O
(	O
n	int
=	O
b	double
+	O
1	int
;	O
n	int
<	O
a	double
;	O
n	int
++	O
)	O
{	O
Mnp1	double
=	O
(	O
(	O
b	double
-	O
n	int
)	O
*	O
Mnm1	double
+	O
(	O
2	int
*	O
n	int
-	O
b	double
+	O
x	double
)	O
*	O
Mn	double
)	O
/	O
n	int
;	O
Mnm1	double
=	O
Mn	double
;	O
Mn	double
=	O
Mnp1	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
Mn	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
(	O
x	double
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Mn	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
fabs	(double)->(double)
(	O
a	double
-	O
b	double
)	O
+	O
1.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
r_Mn	struct(double,double)
;	O
double	O
Mnm1	double
=	O
1.0	int
;	O
double	O
Mn	double
;	O
double	O
Mnp1	double
;	O
int	O
n	int
;	O
gsl_sf_exprel_n_e	(int,double,*(struct(double,double)))->(int)
(	O
b	double
-	O
1	int
,	O
x	double
,	O
&	O
r_Mn	struct(double,double)
)	O
;	O
Mn	double
=	O
r_Mn	struct(double,double)
.	O
val	double
;	O
for	O
(	O
n	int
=	O
1	int
;	O
n	int
<	O
a	double
;	O
n	int
++	O
)	O
{	O
Mnp1	double
=	O
(	O
(	O
b	double
-	O
n	int
)	O
*	O
Mnm1	double
+	O
(	O
2	int
*	O
n	int
-	O
b	double
+	O
x	double
)	O
*	O
Mn	double
)	O
/	O
n	int
;	O
Mnm1	double
=	O
Mn	double
;	O
Mn	double
=	O
Mnp1	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
Mn	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
Mn	double
)	O
*	O
(	O
1.0	int
+	O
fabs	(double)->(double)
(	O
a	double
)	O
)	O
*	O
fabs	(double)->(double)
(	O
r_Mn	struct(double,double)
.	O
err	double
/	O
r_Mn	struct(double,double)
.	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Mn	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
a	double
<=	O
0.5	int
*	O
(	O
b	double
-	O
x	double
)	O
||	O
a	double
>=	O
-	O
x	double
)	O
{	O
double	O
ex	struct(double,double)
=	O
exp	(double)->(double)
(	O
x	double
)	O
;	O
double	O
Manp1	double
=	O
ex	struct(double,double)
;	O
double	O
Man	double
=	O
ex	struct(double,double)
*	O
(	O
1.0	int
+	O
x	double
/	O
(	O
a	double
-	O
1.0	int
)	O
)	O
;	O
double	O
Manm1	double
;	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
a	double
-	O
1	int
;	O
n	int
>	O
b	double
;	O
n	int
--	O
)	O
{	O
Manm1	double
=	O
(	O
-	O
n	int
*	O
(	O
1	int
-	O
n	int
-	O
x	double
)	O
*	O
Man	double
-	O
x	double
*	O
(	O
n	int
-	O
a	double
)	O
*	O
Manp1	double
)	O
/	O
(	O
n	int
*	O
(	O
n	int
-	O
1.0	int
)	O
)	O
;	O
Manp1	double
=	O
Man	double
;	O
Man	double
=	O
Manm1	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
Man	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Man	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
fabs	(double)->(double)
(	O
b	double
-	O
a	double
)	O
+	O
1.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
a0	int
=	O
(	O
int	O
)	O
ceil	(double)->(double)
(	O
0.5	int
*	O
(	O
b	double
-	O
x	double
)	O
)	O
;	O
double	O
Ma0b	double
;	O
double	O
Ma0bp1	double
;	O
double	O
Ma0p1b	double
;	O
double	O
Mnm1	double
;	O
double	O
Mn	double
;	O
double	O
Mnp1	double
;	O
int	O
n	int
;	O
{	O
double	O
ex	struct(double,double)
=	O
exp	(double)->(double)
(	O
x	double
)	O
;	O
double	O
Ma0np1	double
=	O
ex	struct(double,double)
;	O
double	O
Ma0n	double
=	O
ex	struct(double,double)
*	O
(	O
1.0	int
+	O
x	double
/	O
(	O
a0	int
-	O
1.0	int
)	O
)	O
;	O
double	O
Ma0nm1	double
;	O
for	O
(	O
n	int
=	O
a0	int
-	O
1	int
;	O
n	int
>	O
b	double
;	O
n	int
--	O
)	O
{	O
Ma0nm1	double
=	O
(	O
-	O
n	int
*	O
(	O
1	int
-	O
n	int
-	O
x	double
)	O
*	O
Ma0n	double
-	O
x	double
*	O
(	O
n	int
-	O
a0	int
)	O
*	O
Ma0np1	double
)	O
/	O
(	O
n	int
*	O
(	O
n	int
-	O
1.0	int
)	O
)	O
;	O
Ma0np1	double
=	O
Ma0n	double
;	O
Ma0n	double
=	O
Ma0nm1	double
;	O
}	O
Ma0bp1	double
=	O
Ma0np1	double
;	O
Ma0b	double
=	O
Ma0n	double
;	O
Ma0p1b	double
=	O
(	O
b	double
*	O
(	O
a0	int
+	O
x	double
)	O
*	O
Ma0b	double
+	O
x	double
*	O
(	O
a0	int
-	O
b	double
)	O
*	O
Ma0bp1	double
)	O
/	O
(	O
a0	int
*	O
b	double
)	O
;	O
}	O
if	O
(	O
a0	int
>=	O
a	double
)	O
{	O
Mn	double
=	O
Ma0b	double
;	O
}	O
else	O
if	O
(	O
a0	int
+	O
1	int
>=	O
a	double
)	O
{	O
Mn	double
=	O
Ma0p1b	double
;	O
}	O
else	O
{	O
Mnm1	double
=	O
Ma0b	double
;	O
Mn	double
=	O
Ma0p1b	double
;	O
for	O
(	O
n	int
=	O
a0	int
+	O
1	int
;	O
n	int
<	O
a	double
;	O
n	int
++	O
)	O
{	O
Mnp1	double
=	O
(	O
(	O
b	double
-	O
n	int
)	O
*	O
Mnm1	double
+	O
(	O
2	int
*	O
n	int
-	O
b	double
+	O
x	double
)	O
*	O
Mn	double
)	O
/	O
n	int
;	O
Mnm1	double
=	O
Mn	double
;	O
Mn	double
=	O
Mnp1	double
;	O
}	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
Mn	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Mn	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
fabs	(double)->(double)
(	O
b	double
-	O
a	double
)	O
+	O
1.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
}	O
static	O
int	O
hyperg_1F1_a_negint_poly	(int,double,double,*(struct(double,double)))->(int)
(	O
const	O
int	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
a	double
==	O
0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
1.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
N	int
=	O
-	O
a	double
;	O
double	O
poly	double
=	O
1.0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
N	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
double	O
t	double
=	O
(	O
a	double
+	O
k	int
)	O
/	O
(	O
b	double
+	O
k	int
)	O
*	O
(	O
x	double
/	O
(	O
k	int
+	O
1	int
)	O
)	O
;	O
double	O
r	*(struct(double,double))
=	O
t	double
+	O
1.0	int
/	O
poly	double
;	O
if	O
(	O
r	*(struct(double,double))
>	O
0.9	int
*	O
GSL_DBL_MAX	int
/	O
poly	double
)	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
poly	double
*=	O
r	*(struct(double,double))
;	O
}	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
poly	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
(	O
sqrt	(double)->(double)
(	O
N	int
)	O
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
poly	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
hyperg_1F1_a_negint_lag	(int,double,double,*(struct(double,double)))->(int)
(	O
const	O
int	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
int	O
n	int
=	O
-	O
a	double
;	O
gsl_sf_result	struct(double,double)
lag	struct(double,double)
;	O
const	O
int	O
stat_l	int
=	O
gsl_sf_laguerre_n_e	(int,double,double,*(struct(double,double)))->(int)
(	O
n	int
,	O
b	double
-	O
1.0	int
,	O
x	double
,	O
&	O
lag	struct(double,double)
)	O
;	O
if	O
(	O
b	double
<	O
0.0	int
)	O
{	O
gsl_sf_result	struct(double,double)
lnfact	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
lng1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
lng2	struct(double,double)
;	O
double	O
s1	double
,	O
s2	double
;	O
const	O
int	O
stat_f	int
=	O
gsl_sf_lnfact_e	(int,*(struct(double,double)))->(int)
(	O
n	int
,	O
&	O
lnfact	struct(double,double)
)	O
;	O
const	O
int	O
stat_g1	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
b	double
+	O
n	int
,	O
&	O
lng1	struct(double,double)
,	O
&	O
s1	double
)	O
;	O
const	O
int	O
stat_g2	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
b	double
,	O
&	O
lng2	struct(double,double)
,	O
&	O
s2	double
)	O
;	O
const	O
double	O
lnpre_val	double
=	O
lnfact	struct(double,double)
.	O
val	double
-	O
(	O
lng1	struct(double,double)
.	O
val	double
-	O
lng2	struct(double,double)
.	O
val	double
)	O
;	O
const	O
double	O
lnpre_err	double
=	O
lnfact	struct(double,double)
.	O
err	double
+	O
lng1	struct(double,double)
.	O
err	double
+	O
lng2	struct(double,double)
.	O
err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
lnpre_val	double
)	O
;	O
const	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
lnpre_val	double
,	O
lnpre_err	double
,	O
s1	double
*	O
s2	double
*	O
lag	struct(double,double)
.	O
val	double
,	O
lag	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_5	O
(	O
stat_e	int
,	O
stat_l	int
,	O
stat_g1	int
,	O
stat_g2	int
,	O
stat_f	int
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
lnbeta	struct(double,double)
;	O
gsl_sf_lnbeta_e	(double,double,*(struct(double,double)))->(int)
(	O
b	double
,	O
n	int
,	O
&	O
lnbeta	struct(double,double)
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
lnbeta	struct(double,double)
.	O
val	double
)	O
<	O
0.1	int
)	O
{	O
const	O
double	O
ln_term_val	double
=	O
log	(double)->(double)
(	O
1.25	int
*	O
n	int
)	O
;	O
const	O
double	O
ln_term_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
ln_term_val	double
;	O
gsl_sf_result	struct(double,double)
beta	struct(double,double)
;	O
int	O
stat_b	int
=	O
gsl_sf_beta_e	(double,double,*(struct(double,double)))->(int)
(	O
b	double
,	O
n	int
,	O
&	O
beta	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
ln_term_val	double
,	O
ln_term_err	double
,	O
lag	struct(double,double)
.	O
val	double
,	O
lag	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
result	*(struct(double,double))
->	O
val	double
*=	O
beta	struct(double,double)
.	O
val	double
/	O
1.25	int
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
beta	struct(double,double)
.	O
val	double
/	O
1.25	int
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_l	int
,	O
stat_b	int
)	O
;	O
}	O
else	O
{	O
const	O
double	O
ln_n	double
=	O
log	(double)->(double)
(	O
n	int
)	O
;	O
const	O
double	O
ln_term_val	double
=	O
lnbeta	struct(double,double)
.	O
val	double
+	O
ln_n	double
;	O
const	O
double	O
ln_term_err	double
=	O
lnbeta	struct(double,double)
.	O
err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
ln_n	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
ln_term_val	double
,	O
ln_term_err	double
,	O
lag	struct(double,double)
.	O
val	double
,	O
lag	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_l	int
)	O
;	O
}	O
}	O
}	O
static	O
int	O
hyperg_1F1_ab_negint	(int,int,double,*(struct(double,double)))->(int)
(	O
const	O
int	O
a	double
,	O
const	O
int	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
>	O
0.0	int
)	O
{	O
return	O
hyperg_1F1_a_negint_poly	(int,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
K	struct(double,double)
;	O
int	O
stat_K	int
=	O
hyperg_1F1_a_negint_poly	(int,double,double,*(struct(double,double)))->(int)
(	O
b	double
-	O
a	double
,	O
b	double
,	O
-	O
x	double
,	O
&	O
K	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
x	double
,	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
,	O
K	struct(double,double)
.	O
val	double
,	O
K	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_K	int
)	O
;	O
}	O
}	O
static	O
int	O
hyperg_1F1_U	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
bp	double
=	O
2.0	int
-	O
b	double
;	O
const	O
double	O
ap	double
=	O
a	double
-	O
b	double
+	O
1.0	int
;	O
gsl_sf_result	struct(double,double)
lg_ap	struct(double,double)
,	O
lg_bp	struct(double,double)
;	O
double	O
sg_ap	double
;	O
int	O
stat_lg0	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
ap	double
,	O
&	O
lg_ap	struct(double,double)
,	O
&	O
sg_ap	double
)	O
;	O
int	O
stat_lg1	int
=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
bp	double
,	O
&	O
lg_bp	struct(double,double)
)	O
;	O
int	O
stat_lg2	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_lg0	int
,	O
stat_lg1	int
)	O
;	O
double	O
t1	double
=	O
(	O
bp	double
-	O
1.0	int
)	O
*	O
log	(double)->(double)
(	O
x	double
)	O
;	O
double	O
lnpre_val	double
=	O
lg_ap	struct(double,double)
.	O
val	double
-	O
lg_bp	struct(double,double)
.	O
val	double
+	O
t1	double
;	O
double	O
lnpre_err	double
=	O
lg_ap	struct(double,double)
.	O
err	double
+	O
lg_bp	struct(double,double)
.	O
err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
t1	double
)	O
;	O
gsl_sf_result	struct(double,double)
lg_2mbp	struct(double,double)
,	O
lg_1papmbp	struct(double,double)
;	O
double	O
sg_2mbp	double
,	O
sg_1papmbp	double
;	O
int	O
stat_lg3	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
2.0	int
-	O
bp	double
,	O
&	O
lg_2mbp	struct(double,double)
,	O
&	O
sg_2mbp	double
)	O
;	O
int	O
stat_lg4	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
1.0	int
+	O
ap	double
-	O
bp	double
,	O
&	O
lg_1papmbp	struct(double,double)
,	O
&	O
sg_1papmbp	double
)	O
;	O
int	O
stat_lg5	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_lg3	int
,	O
stat_lg4	int
)	O
;	O
double	O
lnc1_val	double
=	O
lg_2mbp	struct(double,double)
.	O
val	double
-	O
lg_1papmbp	struct(double,double)
.	O
val	double
;	O
double	O
lnc1_err	double
=	O
lg_2mbp	struct(double,double)
.	O
err	double
+	O
lg_1papmbp	struct(double,double)
.	O
err	double
+	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
lg_2mbp	struct(double,double)
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
lg_1papmbp	struct(double,double)
.	O
val	double
)	O
)	O
;	O
gsl_sf_result	struct(double,double)
M	struct(double,double)
;	O
gsl_sf_result_e10	struct(double,double,int)
U	struct(double,double,int)
;	O
int	O
stat_F	int
=	O
gsl_sf_hyperg_1F1_e	(double,double,double,*(struct(double,double)))->(int)
(	O
ap	double
,	O
bp	double
,	O
x	double
,	O
&	O
M	struct(double,double)
)	O
;	O
int	O
stat_U	int
=	O
gsl_sf_hyperg_U_e10_e	(double,double,double,*(struct(double,double,int)))->(int)
(	O
ap	double
,	O
bp	double
,	O
x	double
,	O
&	O
U	struct(double,double,int)
)	O
;	O
int	O
stat_FU	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_F	int
,	O
stat_U	int
)	O
;	O
gsl_sf_result_e10	struct(double,double,int)
term_M	struct(double,double,int)
;	O
int	O
stat_e0	int
=	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
lnc1_val	double
,	O
lnc1_err	double
,	O
sg_2mbp	double
*	O
sg_1papmbp	double
*	O
M	struct(double,double)
.	O
val	double
,	O
M	struct(double,double)
.	O
err	double
,	O
&	O
term_M	struct(double,double,int)
)	O
;	O
const	O
double	O
ombp	double
=	O
1.0	int
-	O
bp	double
;	O
const	O
double	O
Uee_val	double
=	O
U	struct(double,double,int)
.	O
e10	int
*	O
M_LN10	int
;	O
const	O
double	O
Uee_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Uee_val	double
)	O
;	O
const	O
double	O
Mee_val	double
=	O
term_M	struct(double,double,int)
.	O
e10	int
*	O
M_LN10	int
;	O
const	O
double	O
Mee_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Mee_val	double
)	O
;	O
int	O
stat_e1	int
;	O
if	O
(	O
Uee_val	double
>	O
Mee_val	double
)	O
{	O
const	O
double	O
factorM_val	double
=	O
exp	(double)->(double)
(	O
Mee_val	double
-	O
Uee_val	double
)	O
;	O
const	O
double	O
factorM_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
Mee_val	double
-	O
Uee_val	double
)	O
+	O
1.0	int
)	O
*	O
factorM_val	double
;	O
const	O
double	O
inner_val	double
=	O
term_M	struct(double,double,int)
.	O
val	double
*	O
factorM_val	double
-	O
ombp	double
*	O
U	struct(double,double,int)
.	O
val	double
;	O
const	O
double	O
inner_err	double
=	O
term_M	struct(double,double,int)
.	O
err	double
*	O
factorM_val	double
+	O
fabs	(double)->(double)
(	O
ombp	double
)	O
*	O
U	struct(double,double,int)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
term_M	struct(double,double,int)
.	O
val	double
)	O
*	O
factorM_err	double
+	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
term_M	struct(double,double,int)
.	O
val	double
*	O
factorM_val	double
)	O
+	O
fabs	(double)->(double)
(	O
ombp	double
*	O
U	struct(double,double,int)
.	O
val	double
)	O
)	O
;	O
stat_e1	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
lnpre_val	double
+	O
Uee_val	double
,	O
lnpre_err	double
+	O
Uee_err	double
,	O
sg_ap	double
*	O
inner_val	double
,	O
inner_err	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
const	O
double	O
factorU_val	double
=	O
exp	(double)->(double)
(	O
Uee_val	double
-	O
Mee_val	double
)	O
;	O
const	O
double	O
factorU_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
Mee_val	double
-	O
Uee_val	double
)	O
+	O
1.0	int
)	O
*	O
factorU_val	double
;	O
const	O
double	O
inner_val	double
=	O
term_M	struct(double,double,int)
.	O
val	double
-	O
ombp	double
*	O
factorU_val	double
*	O
U	struct(double,double,int)
.	O
val	double
;	O
const	O
double	O
inner_err	double
=	O
term_M	struct(double,double,int)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
ombp	double
*	O
factorU_val	double
*	O
U	struct(double,double,int)
.	O
err	double
)	O
+	O
fabs	(double)->(double)
(	O
ombp	double
*	O
factorU_err	double
*	O
U	struct(double,double,int)
.	O
val	double
)	O
+	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
term_M	struct(double,double,int)
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
ombp	double
*	O
factorU_val	double
*	O
U	struct(double,double,int)
.	O
val	double
)	O
)	O
;	O
stat_e1	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
lnpre_val	double
+	O
Mee_val	double
,	O
lnpre_err	double
+	O
Mee_err	double
,	O
sg_ap	double
*	O
inner_val	double
,	O
inner_err	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
return	O
GSL_ERROR_SELECT_5	O
(	O
stat_e1	int
,	O
stat_e0	int
,	O
stat_FU	int
,	O
stat_lg5	int
,	O
stat_lg2	int
)	O
;	O
}	O
static	O
int	O
hyperg_1F1_ab_pos	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
ax	double
=	O
fabs	(double)->(double)
(	O
x	double
)	O
;	O
if	O
(	O
(	O
b	double
<	O
10.0	int
&&	O
a	double
<	O
10.0	int
&&	O
ax	double
<	O
5.0	int
)	O
||	O
(	O
b	double
>	O
a	double
*	O
ax	double
)	O
||	O
(	O
b	double
>	O
a	double
&&	O
ax	double
<	O
5.0	int
)	O
)	O
{	O
return	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
-	O
100.0	int
&&	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
a	double
)	O
,	O
1.0	int
)	O
*	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
1.0	int
+	O
a	double
-	O
b	double
)	O
,	O
1.0	int
)	O
<	O
0.7	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
{	O
return	O
hyperg_1F1_asymp_negx	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
100.0	int
&&	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
b	double
-	O
a	double
)	O
,	O
1.0	int
)	O
*	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
1.0	int
-	O
a	double
)	O
,	O
1.0	int
)	O
<	O
0.7	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
{	O
return	O
hyperg_1F1_asymp_posx	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
b	double
-	O
a	double
)	O
<=	O
1.0	int
)	O
{	O
return	O
hyperg_1F1_beps_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
-	O
b	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
>	O
a	double
&&	O
b	double
>=	O
2	int
*	O
a	double
+	O
x	double
)	O
{	O
double	O
rap	double
;	O
int	O
stat_CF1	int
=	O
hyperg_1F1_CF1_p_ser	(double,double,double,*(double))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
rap	double
)	O
;	O
double	O
ra	double
=	O
1.0	int
+	O
x	double
/	O
a	double
*	O
rap	double
;	O
double	O
Ma	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Map1	double
=	O
ra	double
*	O
Ma	double
;	O
double	O
Mnp1	double
=	O
Map1	double
;	O
double	O
Mn	double
=	O
Ma	double
;	O
double	O
Mnm1	double
;	O
gsl_sf_result	struct(double,double)
Mn_true	struct(double,double)
;	O
int	O
stat_Mt	int
;	O
double	O
n	int
;	O
for	O
(	O
n	int
=	O
a	double
;	O
n	int
>	O
0.5	int
;	O
n	int
-=	O
1.0	int
)	O
{	O
Mnm1	double
=	O
(	O
n	int
*	O
Mnp1	double
-	O
(	O
2.0	int
*	O
n	int
-	O
b	double
+	O
x	double
)	O
*	O
Mn	double
)	O
/	O
(	O
b	double
-	O
n	int
)	O
;	O
Mnp1	double
=	O
Mn	double
;	O
Mn	double
=	O
Mnm1	double
;	O
}	O
stat_Mt	int
=	O
hyperg_1F1_small_a_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
n	int
,	O
b	double
,	O
x	double
,	O
&	O
Mn_true	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
Ma	double
/	O
Mn	double
)	O
*	O
Mn_true	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
Ma	double
/	O
Mn	double
)	O
*	O
Mn_true	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_Mt	int
,	O
stat_CF1	int
)	O
;	O
}	O
else	O
if	O
(	O
b	double
>	O
a	double
&&	O
b	double
<	O
2	int
*	O
a	double
+	O
x	double
&&	O
b	double
>	O
x	double
)	O
{	O
gsl_sf_result	struct(double,double)
Mn_true	struct(double,double)
;	O
int	O
stat_Mt	int
;	O
double	O
rap	double
;	O
int	O
stat_CF1	int
=	O
hyperg_1F1_CF1_p_ser	(double,double,double,*(double))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
rap	double
)	O
;	O
double	O
ra	double
=	O
1.0	int
+	O
x	double
/	O
a	double
*	O
rap	double
;	O
double	O
Ma	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Mnm1	double
=	O
Ma	double
;	O
double	O
Mn	double
=	O
ra	double
*	O
Mnm1	double
;	O
double	O
Mnp1	double
;	O
double	O
n	int
;	O
for	O
(	O
n	int
=	O
a	double
+	O
1.0	int
;	O
n	int
<	O
b	double
-	O
0.5	int
;	O
n	int
+=	O
1.0	int
)	O
{	O
Mnp1	double
=	O
(	O
(	O
b	double
-	O
n	int
)	O
*	O
Mnm1	double
+	O
(	O
2	int
*	O
n	int
-	O
b	double
+	O
x	double
)	O
*	O
Mn	double
)	O
/	O
n	int
;	O
Mnm1	double
=	O
Mn	double
;	O
Mn	double
=	O
Mnp1	double
;	O
}	O
stat_Mt	int
=	O
hyperg_1F1_beps_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
n	int
-	O
b	double
,	O
b	double
,	O
x	double
,	O
&	O
Mn_true	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
Ma	double
/	O
Mn	double
*	O
Mn_true	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
Ma	double
/	O
Mn	double
)	O
*	O
Mn_true	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
b	double
-	O
a	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_Mt	int
,	O
stat_CF1	int
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>=	O
0.0	int
)	O
{	O
if	O
(	O
b	double
<	O
a	double
)	O
{	O
double	O
N	int
=	O
floor	(double)->(double)
(	O
a	double
-	O
b	double
)	O
;	O
double	O
eps	double
=	O
a	double
-	O
b	double
-	O
N	int
;	O
gsl_sf_result	struct(double,double)
r_M0	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
r_M1	struct(double,double)
;	O
int	O
stat_0	int
=	O
hyperg_1F1_beps_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
eps	double
-	O
1.0	int
,	O
b	double
,	O
x	double
,	O
&	O
r_M0	struct(double,double)
)	O
;	O
int	O
stat_1	int
=	O
hyperg_1F1_beps_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
eps	double
,	O
b	double
,	O
x	double
,	O
&	O
r_M1	struct(double,double)
)	O
;	O
double	O
M0	double
=	O
r_M0	struct(double,double)
.	O
val	double
;	O
double	O
M1	double
=	O
r_M1	struct(double,double)
.	O
val	double
;	O
double	O
Mam1	double
=	O
M0	double
;	O
double	O
Ma	double
=	O
M1	double
;	O
double	O
Map1	double
;	O
double	O
ap	double
;	O
double	O
start_pair	double
=	O
fabs	(double)->(double)
(	O
M0	double
)	O
+	O
fabs	(double)->(double)
(	O
M1	double
)	O
;	O
double	O
minim_pair	double
=	O
GSL_DBL_MAX	int
;	O
double	O
pair_ratio	double
;	O
double	O
rat_0	double
=	O
fabs	(double)->(double)
(	O
r_M0	struct(double,double)
.	O
err	double
/	O
r_M0	struct(double,double)
.	O
val	double
)	O
;	O
double	O
rat_1	double
=	O
fabs	(double)->(double)
(	O
r_M1	struct(double,double)
.	O
err	double
/	O
r_M1	struct(double,double)
.	O
val	double
)	O
;	O
for	O
(	O
ap	double
=	O
b	double
+	O
eps	double
;	O
ap	double
<	O
a	double
-	O
0.1	int
;	O
ap	double
+=	O
1.0	int
)	O
{	O
Map1	double
=	O
(	O
(	O
b	double
-	O
ap	double
)	O
*	O
Mam1	double
+	O
(	O
2.0	int
*	O
ap	double
-	O
b	double
+	O
x	double
)	O
*	O
Ma	double
)	O
/	O
ap	double
;	O
Mam1	double
=	O
Ma	double
;	O
Ma	double
=	O
Map1	double
;	O
minim_pair	double
=	O
GSL_MIN_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
Mam1	double
)	O
+	O
fabs	(double)->(double)
(	O
Ma	double
)	O
,	O
minim_pair	double
)	O
;	O
}	O
pair_ratio	double
=	O
start_pair	double
/	O
minim_pair	double
;	O
result	*(struct(double,double))
->	O
val	double
=	O
Ma	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
(	O
rat_0	double
+	O
rat_1	double
+	O
GSL_DBL_EPSILON	int
)	O
*	O
(	O
fabs	(double)->(double)
(	O
b	double
-	O
a	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Ma	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
(	O
rat_0	double
+	O
rat_1	double
)	O
*	O
pair_ratio	double
*	O
pair_ratio	double
*	O
fabs	(double)->(double)
(	O
Ma	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Ma	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_0	int
,	O
stat_1	int
)	O
;	O
}	O
else	O
{	O
double	O
eps	double
=	O
a	double
-	O
floor	(double)->(double)
(	O
a	double
)	O
;	O
gsl_sf_result	struct(double,double)
r_Mnm1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
r_Mn	struct(double,double)
;	O
int	O
stat_0	int
=	O
hyperg_1F1_small_a_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
eps	double
,	O
b	double
,	O
x	double
,	O
&	O
r_Mnm1	struct(double,double)
)	O
;	O
int	O
stat_1	int
=	O
hyperg_1F1_small_a_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
eps	double
+	O
1.0	int
,	O
b	double
,	O
x	double
,	O
&	O
r_Mn	struct(double,double)
)	O
;	O
double	O
Mnm1	double
=	O
r_Mnm1	struct(double,double)
.	O
val	double
;	O
double	O
Mn	double
=	O
r_Mn	struct(double,double)
.	O
val	double
;	O
double	O
Mnp1	double
;	O
double	O
n	int
;	O
double	O
start_pair	double
=	O
fabs	(double)->(double)
(	O
Mn	double
)	O
+	O
fabs	(double)->(double)
(	O
Mnm1	double
)	O
;	O
double	O
minim_pair	double
=	O
GSL_DBL_MAX	int
;	O
double	O
pair_ratio	double
;	O
double	O
rat_0	double
=	O
fabs	(double)->(double)
(	O
r_Mnm1	struct(double,double)
.	O
err	double
/	O
r_Mnm1	struct(double,double)
.	O
val	double
)	O
;	O
double	O
rat_1	double
=	O
fabs	(double)->(double)
(	O
r_Mn	struct(double,double)
.	O
err	double
/	O
r_Mn	struct(double,double)
.	O
val	double
)	O
;	O
for	O
(	O
n	int
=	O
eps	double
+	O
1.0	int
;	O
n	int
<	O
a	double
-	O
0.1	int
;	O
n	int
++	O
)	O
{	O
Mnp1	double
=	O
(	O
(	O
b	double
-	O
n	int
)	O
*	O
Mnm1	double
+	O
(	O
2	int
*	O
n	int
-	O
b	double
+	O
x	double
)	O
*	O
Mn	double
)	O
/	O
n	int
;	O
Mnm1	double
=	O
Mn	double
;	O
Mn	double
=	O
Mnp1	double
;	O
minim_pair	double
=	O
GSL_MIN_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
Mn	double
)	O
+	O
fabs	(double)->(double)
(	O
Mnm1	double
)	O
,	O
minim_pair	double
)	O
;	O
}	O
pair_ratio	double
=	O
start_pair	double
/	O
minim_pair	double
;	O
result	*(struct(double,double))
->	O
val	double
=	O
Mn	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
(	O
rat_0	double
+	O
rat_1	double
+	O
GSL_DBL_EPSILON	int
)	O
*	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Mn	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
(	O
rat_0	double
+	O
rat_1	double
)	O
*	O
pair_ratio	double
*	O
pair_ratio	double
*	O
fabs	(double)->(double)
(	O
Mn	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Mn	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_0	int
,	O
stat_1	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
a	double
<=	O
0.5	int
*	O
(	O
b	double
-	O
x	double
)	O
||	O
a	double
>=	O
-	O
x	double
)	O
{	O
double	O
N	int
=	O
floor	(double)->(double)
(	O
a	double
-	O
b	double
)	O
;	O
double	O
eps	double
=	O
1.0	int
+	O
N	int
-	O
a	double
+	O
b	double
;	O
gsl_sf_result	struct(double,double)
r_Manp1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
r_Man	struct(double,double)
;	O
int	O
stat_0	int
=	O
hyperg_1F1_beps_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
-	O
eps	double
,	O
a	double
+	O
eps	double
,	O
x	double
,	O
&	O
r_Manp1	struct(double,double)
)	O
;	O
int	O
stat_1	int
=	O
hyperg_1F1_beps_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
1.0	int
-	O
eps	double
,	O
a	double
+	O
eps	double
-	O
1.0	int
,	O
x	double
,	O
&	O
r_Man	struct(double,double)
)	O
;	O
double	O
Manp1	double
=	O
r_Manp1	struct(double,double)
.	O
val	double
;	O
double	O
Man	double
=	O
r_Man	struct(double,double)
.	O
val	double
;	O
double	O
Manm1	double
;	O
double	O
n	int
;	O
double	O
start_pair	double
=	O
fabs	(double)->(double)
(	O
Manp1	double
)	O
+	O
fabs	(double)->(double)
(	O
Man	double
)	O
;	O
double	O
minim_pair	double
=	O
GSL_DBL_MAX	int
;	O
double	O
pair_ratio	double
;	O
double	O
rat_0	double
=	O
fabs	(double)->(double)
(	O
r_Manp1	struct(double,double)
.	O
err	double
/	O
r_Manp1	struct(double,double)
.	O
val	double
)	O
;	O
double	O
rat_1	double
=	O
fabs	(double)->(double)
(	O
r_Man	struct(double,double)
.	O
err	double
/	O
r_Man	struct(double,double)
.	O
val	double
)	O
;	O
for	O
(	O
n	int
=	O
a	double
+	O
eps	double
-	O
1.0	int
;	O
n	int
>	O
b	double
+	O
0.1	int
;	O
n	int
-=	O
1.0	int
)	O
{	O
Manm1	double
=	O
(	O
-	O
n	int
*	O
(	O
1	int
-	O
n	int
-	O
x	double
)	O
*	O
Man	double
-	O
x	double
*	O
(	O
n	int
-	O
a	double
)	O
*	O
Manp1	double
)	O
/	O
(	O
n	int
*	O
(	O
n	int
-	O
1.0	int
)	O
)	O
;	O
Manp1	double
=	O
Man	double
;	O
Man	double
=	O
Manm1	double
;	O
minim_pair	double
=	O
GSL_MIN_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
Manp1	double
)	O
+	O
fabs	(double)->(double)
(	O
Man	double
)	O
,	O
minim_pair	double
)	O
;	O
}	O
pair_ratio	double
=	O
start_pair	double
/	O
minim_pair	double
;	O
result	*(struct(double,double))
->	O
val	double
=	O
Man	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
(	O
rat_0	double
+	O
rat_1	double
+	O
GSL_DBL_EPSILON	int
)	O
*	O
(	O
fabs	(double)->(double)
(	O
b	double
-	O
a	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Man	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
pair_ratio	double
*	O
pair_ratio	double
+	O
1.0	int
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_0	int
,	O
stat_1	int
)	O
;	O
}	O
else	O
{	O
double	O
epsa	double
=	O
a	double
-	O
floor	(double)->(double)
(	O
a	double
)	O
;	O
double	O
a0	int
=	O
floor	(double)->(double)
(	O
0.5	int
*	O
(	O
b	double
-	O
x	double
)	O
)	O
+	O
epsa	double
;	O
double	O
N	int
=	O
floor	(double)->(double)
(	O
a0	int
-	O
b	double
)	O
;	O
double	O
epsb	double
=	O
1.0	int
+	O
N	int
-	O
a0	int
+	O
b	double
;	O
double	O
Ma0b	double
;	O
double	O
Ma0bp1	double
;	O
double	O
Ma0p1b	double
;	O
int	O
stat_a0	int
;	O
double	O
Mnm1	double
;	O
double	O
Mn	double
;	O
double	O
Mnp1	double
;	O
double	O
n	int
;	O
double	O
err_rat	double
;	O
{	O
gsl_sf_result	struct(double,double)
r_Ma0np1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
r_Ma0n	struct(double,double)
;	O
int	O
stat_0	int
=	O
hyperg_1F1_beps_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
-	O
epsb	double
,	O
a0	int
+	O
epsb	double
,	O
x	double
,	O
&	O
r_Ma0np1	struct(double,double)
)	O
;	O
int	O
stat_1	int
=	O
hyperg_1F1_beps_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
1.0	int
-	O
epsb	double
,	O
a0	int
+	O
epsb	double
-	O
1.0	int
,	O
x	double
,	O
&	O
r_Ma0n	struct(double,double)
)	O
;	O
double	O
Ma0np1	double
=	O
r_Ma0np1	struct(double,double)
.	O
val	double
;	O
double	O
Ma0n	double
=	O
r_Ma0n	struct(double,double)
.	O
val	double
;	O
double	O
Ma0nm1	double
;	O
err_rat	double
=	O
fabs	(double)->(double)
(	O
r_Ma0np1	struct(double,double)
.	O
err	double
/	O
r_Ma0np1	struct(double,double)
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
r_Ma0n	struct(double,double)
.	O
err	double
/	O
r_Ma0n	struct(double,double)
.	O
val	double
)	O
;	O
for	O
(	O
n	int
=	O
a0	int
+	O
epsb	double
-	O
1.0	int
;	O
n	int
>	O
b	double
+	O
0.1	int
;	O
n	int
-=	O
1.0	int
)	O
{	O
Ma0nm1	double
=	O
(	O
-	O
n	int
*	O
(	O
1	int
-	O
n	int
-	O
x	double
)	O
*	O
Ma0n	double
-	O
x	double
*	O
(	O
n	int
-	O
a0	int
)	O
*	O
Ma0np1	double
)	O
/	O
(	O
n	int
*	O
(	O
n	int
-	O
1.0	int
)	O
)	O
;	O
Ma0np1	double
=	O
Ma0n	double
;	O
Ma0n	double
=	O
Ma0nm1	double
;	O
}	O
Ma0bp1	double
=	O
Ma0np1	double
;	O
Ma0b	double
=	O
Ma0n	double
;	O
Ma0p1b	double
=	O
(	O
b	double
*	O
(	O
a0	int
+	O
x	double
)	O
*	O
Ma0b	double
+	O
x	double
*	O
(	O
a0	int
-	O
b	double
)	O
*	O
Ma0bp1	double
)	O
/	O
(	O
a0	int
*	O
b	double
)	O
;	O
stat_a0	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_0	int
,	O
stat_1	int
)	O
;	O
}	O
if	O
(	O
a0	int
>=	O
a	double
-	O
0.1	int
)	O
{	O
Mn	double
=	O
Ma0b	double
;	O
}	O
else	O
if	O
(	O
a0	int
+	O
1	int
>=	O
a	double
-	O
0.1	int
)	O
{	O
Mn	double
=	O
Ma0p1b	double
;	O
}	O
else	O
{	O
Mnm1	double
=	O
Ma0b	double
;	O
Mn	double
=	O
Ma0p1b	double
;	O
for	O
(	O
n	int
=	O
a0	int
+	O
1.0	int
;	O
n	int
<	O
a	double
-	O
0.1	int
;	O
n	int
+=	O
1.0	int
)	O
{	O
Mnp1	double
=	O
(	O
(	O
b	double
-	O
n	int
)	O
*	O
Mnm1	double
+	O
(	O
2	int
*	O
n	int
-	O
b	double
+	O
x	double
)	O
*	O
Mn	double
)	O
/	O
n	int
;	O
Mnm1	double
=	O
Mn	double
;	O
Mn	double
=	O
Mnp1	double
;	O
}	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
Mn	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
(	O
err_rat	double
+	O
GSL_DBL_EPSILON	int
)	O
*	O
(	O
fabs	(double)->(double)
(	O
b	double
-	O
a	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
Mn	double
)	O
;	O
return	O
stat_a0	int
;	O
}	O
}	O
}	O
static	O
int	O
hyperg_1F1_ab_neg	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
bma	double
=	O
b	double
-	O
a	double
;	O
const	O
double	O
abs_x	double
=	O
fabs	(double)->(double)
(	O
x	double
)	O
;	O
const	O
double	O
abs_a	double
=	O
fabs	(double)->(double)
(	O
a	double
)	O
;	O
const	O
double	O
abs_b	double
=	O
fabs	(double)->(double)
(	O
b	double
)	O
;	O
const	O
double	O
size_a	double
=	O
GSL_MAX	O
(	O
abs_a	double
,	O
1.0	int
)	O
;	O
const	O
double	O
size_b	double
=	O
GSL_MAX	O
(	O
abs_b	double
,	O
1.0	int
)	O
;	O
const	O
int	O
bma_integer	int
=	O
(	O
bma	double
-	O
floor	(double)->(double)
(	O
bma	double
+	O
0.5	int
)	O
<	O
_1F1_INT_THRESHOLD	O
)	O
;	O
if	O
(	O
(	O
abs_a	double
<	O
10.0	int
&&	O
abs_b	double
<	O
10.0	int
&&	O
abs_x	double
<	O
5.0	int
)	O
||	O
(	O
b	double
>	O
0.8	int
*	O
GSL_MAX	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
,	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
)	O
{	O
return	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
0.0	int
&&	O
size_b	double
>	O
size_a	double
&&	O
size_a	double
*	O
log	(double)->(double)
(	O
M_E	int
*	O
x	double
/	O
size_b	double
)	O
<	O
GSL_LOG_DBL_EPSILON	O
+	O
7.0	int
)	O
{	O
return	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
(	O
abs_x	double
<	O
5.0	int
&&	O
fabs	(double)->(double)
(	O
bma	double
)	O
<	O
10.0	int
&&	O
abs_b	double
<	O
10.0	int
)	O
||	O
(	O
b	double
>	O
0.8	int
*	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
bma	double
)	O
,	O
1.0	int
)	O
*	O
abs_x	double
)	O
)	O
{	O
gsl_sf_result	struct(double,double)
Kummer_1F1	struct(double,double)
;	O
int	O
stat_K	int
=	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
bma	double
,	O
b	double
,	O
-	O
x	double
,	O
&	O
Kummer_1F1	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
x	double
,	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
,	O
Kummer_1F1	struct(double,double)
.	O
val	double
,	O
Kummer_1F1	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_K	int
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
-	O
30.0	int
&&	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
a	double
)	O
,	O
1.0	int
)	O
*	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
1.0	int
+	O
a	double
-	O
b	double
)	O
,	O
1.0	int
)	O
<	O
0.99	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
{	O
return	O
hyperg_1F1_asymp_negx	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
100.0	int
&&	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
bma	double
)	O
,	O
1.0	int
)	O
*	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
1.0	int
-	O
a	double
)	O
,	O
1.0	int
)	O
<	O
0.99	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
{	O
return	O
hyperg_1F1_asymp_posx	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
0.0	int
&&	O
!	O
(	O
bma_integer	int
&&	O
bma	double
>	O
0.0	int
)	O
)	O
{	O
return	O
hyperg_1F1_U	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
int	O
status	int
=	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
b	double
-	O
a	double
,	O
b	double
,	O
-	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
double	O
K_factor	double
=	O
exp	(double)->(double)
(	O
x	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
*=	O
K_factor	double
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
K_factor	double
;	O
return	O
status	int
;	O
}	O
else	O
{	O
int	O
status	int
=	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
status	int
;	O
}	O
}	O
}	O
int	O
gsl_sf_hyperg_1F1_int_e	(int,int,double,*(struct(double,double)))->(int)
(	O
const	O
int	O
a	double
,	O
const	O
int	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
a	double
==	O
b	double
)	O
{	O
return	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
==	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
a	double
==	O
0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
b	double
<	O
0	int
&&	O
(	O
a	double
<	O
b	double
||	O
a	double
>	O
0	int
)	O
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
100.0	int
&&	O
GSL_MAX_DBL	(double,double)->(double)
(	O
1.0	int
,	O
fabs	(double)->(double)
(	O
b	double
-	O
a	double
)	O
)	O
*	O
GSL_MAX_DBL	(double,double)->(double)
(	O
1.0	int
,	O
fabs	(double)->(double)
(	O
1	int
-	O
a	double
)	O
)	O
<	O
0.5	int
*	O
x	double
)	O
{	O
return	O
hyperg_1F1_asymp_posx	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
-	O
100.0	int
&&	O
GSL_MAX_DBL	(double,double)->(double)
(	O
1.0	int
,	O
fabs	(double)->(double)
(	O
a	double
)	O
)	O
*	O
GSL_MAX_DBL	(double,double)->(double)
(	O
1.0	int
,	O
fabs	(double)->(double)
(	O
1	int
+	O
a	double
-	O
b	double
)	O
)	O
<	O
0.5	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
{	O
return	O
hyperg_1F1_asymp_negx	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
a	double
<	O
0	int
&&	O
b	double
<	O
0	int
)	O
{	O
return	O
hyperg_1F1_ab_negint	(int,int,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
a	double
<	O
0	int
&&	O
b	double
>	O
0	int
)	O
{	O
gsl_sf_result	struct(double,double)
Kummer_1F1	struct(double,double)
;	O
int	O
stat_K	int
=	O
hyperg_1F1_ab_posint	(int,int,double,*(struct(double,double)))->(int)
(	O
b	double
-	O
a	double
,	O
b	double
,	O
-	O
x	double
,	O
&	O
Kummer_1F1	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
x	double
,	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
,	O
Kummer_1F1	struct(double,double)
.	O
val	double
,	O
Kummer_1F1	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_K	int
)	O
;	O
}	O
else	O
{	O
return	O
hyperg_1F1_ab_posint	(int,int,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_hyperg_1F1_e	(double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
bma	double
=	O
b	double
-	O
a	double
;	O
const	O
double	O
rinta	double
=	O
floor	(double)->(double)
(	O
a	double
+	O
0.5	int
)	O
;	O
const	O
double	O
rintb	double
=	O
floor	(double)->(double)
(	O
b	double
+	O
0.5	int
)	O
;	O
const	O
double	O
rintbma	double
=	O
floor	(double)->(double)
(	O
bma	double
+	O
0.5	int
)	O
;	O
const	O
int	O
a_integer	int
=	O
(	O
fabs	(double)->(double)
(	O
a	double
-	O
rinta	double
)	O
<	O
_1F1_INT_THRESHOLD	O
&&	O
rinta	double
>	O
INT_MIN	O
&&	O
rinta	double
<	O
INT_MAX	O
)	O
;	O
const	O
int	O
b_integer	int
=	O
(	O
fabs	(double)->(double)
(	O
b	double
-	O
rintb	double
)	O
<	O
_1F1_INT_THRESHOLD	O
&&	O
rintb	double
>	O
INT_MIN	O
&&	O
rintb	double
<	O
INT_MAX	O
)	O
;	O
const	O
int	O
bma_integer	int
=	O
(	O
fabs	(double)->(double)
(	O
bma	double
-	O
rintbma	double
)	O
<	O
_1F1_INT_THRESHOLD	O
&&	O
rintbma	double
>	O
INT_MIN	O
&&	O
rintbma	double
<	O
INT_MAX	O
)	O
;	O
const	O
int	O
b_neg_integer	int
=	O
(	O
b	double
<	O
-	O
0.1	int
&&	O
b_integer	int
)	O
;	O
const	O
int	O
a_neg_integer	int
=	O
(	O
a	double
<	O
-	O
0.1	int
&&	O
a_integer	int
)	O
;	O
const	O
int	O
bma_neg_integer	int
=	O
(	O
bma	double
<	O
-	O
0.1	int
&&	O
bma_integer	int
)	O
;	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
b	double
==	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
a	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
a	double
==	O
b	double
)	O
{	O
return	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
b	double
)	O
<	O
_1F1_INT_THRESHOLD	O
&&	O
fabs	(double)->(double)
(	O
a	double
)	O
<	O
_1F1_INT_THRESHOLD	O
)	O
{	O
gsl_sf_result	struct(double,double)
exm1	struct(double,double)
;	O
int	O
stat_e	int
=	O
gsl_sf_expm1_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
exm1	struct(double,double)
)	O
;	O
double	O
sa	double
=	O
(	O
a	double
>	O
0.0	int
?	O
1.0	int
:	O
-	O
1.0	int
)	O
;	O
double	O
sb	double
=	O
(	O
b	double
>	O
0.0	int
?	O
1.0	int
:	O
-	O
1.0	int
)	O
;	O
double	O
lnab	double
=	O
log	(double)->(double)
(	O
fabs	(double)->(double)
(	O
a	double
/	O
b	double
)	O
)	O
;	O
gsl_sf_result	struct(double,double)
hx	struct(double,double)
;	O
int	O
stat_hx	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
lnab	double
,	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
lnab	double
)	O
,	O
sa	double
*	O
sb	double
*	O
exm1	struct(double,double)
.	O
val	double
,	O
exm1	struct(double,double)
.	O
err	double
,	O
&	O
hx	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
hx	struct(double,double)
.	O
val	double
==	O
GSL_DBL_MAX	int
?	O
hx	struct(double,double)
.	O
val	double
:	O
1.0	int
+	O
hx	struct(double,double)
.	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
hx	struct(double,double)
.	O
err	double
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_hx	int
,	O
stat_e	int
)	O
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
b	double
)	O
<	O
_1F1_INT_THRESHOLD	O
&&	O
fabs	(double)->(double)
(	O
x	double
*	O
a	double
)	O
<	O
1	int
)	O
{	O
const	O
double	O
m_arg	double
=	O
1.0	int
/	O
(	O
0.5	int
*	O
b	double
)	O
;	O
gsl_sf_result	struct(double,double)
F_renorm	struct(double,double)
;	O
int	O
stat_F	int
=	O
hyperg_1F1_renorm_b0	(double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
x	double
,	O
&	O
F_renorm	struct(double,double)
)	O
;	O
int	O
stat_m	int
=	O
gsl_sf_multiply_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
m_arg	double
,	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
m_arg	double
,	O
0.5	int
*	O
F_renorm	struct(double,double)
.	O
val	double
,	O
0.5	int
*	O
F_renorm	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_m	int
,	O
stat_F	int
)	O
;	O
}	O
else	O
if	O
(	O
a_integer	int
&&	O
b_integer	int
)	O
{	O
return	O
gsl_sf_hyperg_1F1_int_e	(int,int,double,*(struct(double,double)))->(int)
(	O
(	O
int	O
)	O
rinta	double
,	O
(	O
int	O
)	O
rintb	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b_neg_integer	int
&&	O
!	O
(	O
a_neg_integer	int
&&	O
a	double
>	O
b	double
)	O
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
a_neg_integer	int
)	O
{	O
return	O
hyperg_1F1_a_negint_lag	(int,double,double,*(struct(double,double)))->(int)
(	O
(	O
int	O
)	O
rinta	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
b	double
>	O
0.0	int
)	O
{	O
if	O
(	O
-	O
1.0	int
<=	O
a	double
&&	O
a	double
<=	O
1.0	int
)	O
{	O
return	O
hyperg_1F1_small_a_bgt0	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
bma_neg_integer	int
)	O
{	O
gsl_sf_result	struct(double,double)
Kummer_1F1	struct(double,double)
;	O
int	O
stat_K	int
=	O
hyperg_1F1_a_negint_lag	(int,double,double,*(struct(double,double)))->(int)
(	O
(	O
int	O
)	O
rintbma	double
,	O
b	double
,	O
-	O
x	double
,	O
&	O
Kummer_1F1	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
x	double
,	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
,	O
Kummer_1F1	struct(double,double)
.	O
val	double
,	O
Kummer_1F1	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_K	int
)	O
;	O
}	O
else	O
if	O
(	O
a	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
x	double
)	O
<	O
2	int
*	O
GSL_LOG_DBL_MAX	int
)	O
{	O
gsl_sf_result	struct(double,double)
Kummer_1F1	struct(double,double)
;	O
int	O
stat_K	int
=	O
hyperg_1F1_ab_pos	(double,double,double,*(struct(double,double)))->(int)
(	O
b	double
-	O
a	double
,	O
b	double
,	O
-	O
x	double
,	O
&	O
Kummer_1F1	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
x	double
,	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
,	O
Kummer_1F1	struct(double,double)
.	O
val	double
,	O
Kummer_1F1	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_K	int
)	O
;	O
}	O
else	O
if	O
(	O
a	double
>	O
0	int
)	O
{	O
return	O
hyperg_1F1_ab_pos	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
return	O
gsl_sf_hyperg_1F1_series_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
bma_neg_integer	int
&&	O
x	double
<	O
0.0	int
)	O
{	O
gsl_sf_result	struct(double,double)
K	struct(double,double)
;	O
int	O
stat_K	int
;	O
int	O
stat_e	int
;	O
if	O
(	O
a	double
<	O
0.0	int
)	O
{	O
stat_K	int
=	O
hyperg_1F1_a_negint_poly	(int,double,double,*(struct(double,double)))->(int)
(	O
(	O
int	O
)	O
rintbma	double
,	O
b	double
,	O
-	O
x	double
,	O
&	O
K	struct(double,double)
)	O
;	O
}	O
else	O
{	O
stat_K	int
=	O
hyperg_1F1_a_negint_lag	(int,double,double,*(struct(double,double)))->(int)
(	O
(	O
int	O
)	O
rintbma	double
,	O
b	double
,	O
-	O
x	double
,	O
&	O
K	struct(double,double)
)	O
;	O
}	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
x	double
,	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
,	O
K	struct(double,double)
.	O
val	double
,	O
K	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_K	int
)	O
;	O
}	O
else	O
if	O
(	O
a	double
>	O
0.0	int
)	O
{	O
gsl_sf_result	struct(double,double)
K	struct(double,double)
;	O
int	O
stat_K	int
=	O
hyperg_1F1_ab_neg	(double,double,double,*(struct(double,double)))->(int)
(	O
b	double
-	O
a	double
,	O
b	double
,	O
-	O
x	double
,	O
&	O
K	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
x	double
,	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
,	O
K	struct(double,double)
.	O
val	double
,	O
K	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_K	int
)	O
;	O
}	O
else	O
{	O
return	O
hyperg_1F1_ab_neg	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
}	O
double	O
gsl_sf_hyperg_1F1_int	(int,int,double)->(double)
(	O
const	O
int	O
m	int
,	O
const	O
int	O
n	int
,	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hyperg_1F1_int_e	(int,int,double,*(struct(double,double)))->(int)
(	O
m	int
,	O
n	int
,	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_hyperg_1F1	(double,double,double)->(double)
(	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hyperg_1F1_e	(double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
