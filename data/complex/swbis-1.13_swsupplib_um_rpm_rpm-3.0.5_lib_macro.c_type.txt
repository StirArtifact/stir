static	O
int	O
_debug	int
=	O
0	int
;	O
struct	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
rpmGlobalMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
;	O
struct	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
rpmCLIMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
;	O
typedef	O
struct	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
{	O
const	O
char	O
*	O
s	*(char)
;	O
char	O
*	O
t	*(char)
;	O
size_t	long
nb	long
;	O
int	O
depth	int
;	O
int	O
macro_trace	int
;	O
int	O
expand_trace	int
;	O
void	O
*	O
spec	*(void)
;	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
;	O
}	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
;	O
static	O
int	O
expandMacro	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))))->(int)
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
)	O
;	O
int	O
max_macro_depth	int
=	O
MAX_MACRO_DEPTH	int
;	O
int	O
print_macro_trace	int
=	O
0	int
;	O
int	O
print_expand_trace	int
=	O
0	int
;	O
static	O
int	O
compareMacroName	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
ap	*(void)
,	O
const	O
void	O
*	O
bp	*(void)
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
ame	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
*	O
(	O
(	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
)	O
ap	*(void)
)	O
;	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
bme	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
*	O
(	O
(	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
)	O
bp	*(void)
)	O
;	O
if	O
(	O
ame	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
==	O
NULL	O
&&	O
bme	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
ame	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
==	O
NULL	O
)	O
return	O
1	int
;	O
if	O
(	O
bme	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
ame	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
,	O
bme	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
)	O
;	O
}	O
static	O
void	O
expandMacroTable	(*(struct(*(*(struct`)),int,int)))->(void)
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
)	O
{	O
if	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
==	O
NULL	O
)	O
{	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macrosAllocated	int
=	O
MACRO_CHUNK_SIZE	int
;	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
(	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
)	O
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macrosAllocated	int
)	O
;	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
=	O
0	int
;	O
}	O
else	O
{	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macrosAllocated	int
+=	O
MACRO_CHUNK_SIZE	int
;	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
(	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
,	O
sizeof	O
(	O
*	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
)	O
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macrosAllocated	int
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
[	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
]	O
,	O
0	int
,	O
MACRO_CHUNK_SIZE	int
*	O
sizeof	O
(	O
*	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
)	O
)	O
;	O
}	O
static	O
void	O
sortMacroTable	(*(struct(*(*(struct`)),int,int)))->(void)
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
)	O
{	O
int	O
i	int
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
,	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
,	O
sizeof	O
(	O
*	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
)	O
,	O
compareMacroName	(*(void),*(void))->(int)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
[	O
i	int
]	O
!=	O
NULL	O
)	O
continue	O
;	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
=	O
i	int
;	O
break	O
;	O
}	O
}	O
void	O
rpmDumpMacroTable	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
FILE	struct
*	O
fp	*(void)
)	O
{	O
int	O
i	int
;	O
int	O
nempty	int
=	O
0	int
;	O
int	O
nactive	int
=	O
0	int
;	O
if	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
==	O
NULL	O
)	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
=	O
&	O
rpmGlobalMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
;	O
if	O
(	O
fp	*(void)
==	O
NULL	O
)	O
fp	*(void)
=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(void)
,	O
"========================\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
;	O
i	int
++	O
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
;	O
if	O
(	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
[	O
i	int
]	O
)	O
==	O
NULL	O
)	O
{	O
nempty	int
++	O
;	O
continue	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(void)
,	O
"%3d%c %s"	*(char)
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
level	int
,	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
used	int
>	O
0	int
?	O
'='	O
:	O
':'	O
)	O
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
)	O
;	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
opts	*(char)
&&	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
opts	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(void)
,	O
"(%s)"	*(char)
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
opts	*(char)
)	O
;	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
&&	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(void)
,	O
"\t%s"	*(char)
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(void)
,	O
"\n"	*(char)
)	O
;	O
nactive	int
++	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(void)
,	O
_	O
(	O
"======================== active %d empty %d\n"	*(char)
)	O
,	O
nactive	int
,	O
nempty	int
)	O
;	O
}	O
static	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
findEntry	(*(struct(*(*(struct`)),int,int)),*(char),long)->(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))))
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
namelen	long
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
keybuf	struct(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
,	O
*	O
key	*(*(char))
,	O
*	O
*	O
ret	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
;	O
char	O
namebuf	array(char)
[	O
1024	int
]	O
;	O
if	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
==	O
NULL	O
)	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
=	O
&	O
rpmGlobalMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
;	O
if	O
(	O
!	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
)	O
return	O
NULL	O
;	O
if	O
(	O
namelen	long
>	O
0	int
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
namebuf	array(char)
,	O
name	*(char)
,	O
namelen	long
)	O
;	O
namebuf	array(char)
[	O
namelen	long
]	O
=	O
'\0'	O
;	O
name	*(char)
=	O
namebuf	array(char)
;	O
}	O
key	*(*(char))
=	O
&	O
keybuf	struct(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
;	O
memset	(*(void),int,long)->(*(void))
(	O
key	*(*(char))
,	O
0	int
,	O
sizeof	O
(	O
*	O
key	*(*(char))
)	O
)	O
;	O
key	*(*(char))
->	O
name	*(char)
=	O
(	O
char	O
*	O
)	O
name	*(char)
;	O
ret	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
(	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
)	O
bsearch	(*(void),*(void),long,long,*((*(void),*(void))->(int)))->(*(void))
(	O
&	O
key	*(*(char))
,	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
,	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
,	O
sizeof	O
(	O
*	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
)	O
,	O
compareMacroName	(*(void),*(void))->(int)
)	O
;	O
return	O
ret	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
;	O
}	O
static	O
char	O
*	O
rdcl	(*(char),long,*(struct),int)->(*(char))
(	O
char	O
*	O
buf	*(char)
,	O
size_t	long
size	long
,	O
FD_t	*(struct)
fd	*(struct)
,	O
int	O
escapes	int
)	O
{	O
char	O
*	O
q	*(char)
=	O
buf	*(char)
;	O
size_t	long
nb	long
=	O
0	int
;	O
size_t	long
nread	long
=	O
0	int
;	O
*	O
q	*(char)
=	O
'\0'	O
;	O
do	O
{	O
if	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
q	*(char)
,	O
size	long
,	O
(	O
FILE	struct
*	O
)	O
fdGetFp	(*(struct))->(*(void))
(	O
fd	*(struct)
)	O
)	O
==	O
NULL	O
)	O
break	O
;	O
nb	long
=	O
strlen	(*(char))->(long)
(	O
q	*(char)
)	O
;	O
nread	long
+=	O
nb	long
;	O
for	O
(	O
q	*(char)
+=	O
nb	long
-	O
1	int
;	O
nb	long
>	O
0	int
&&	O
iseol	O
(	O
*	O
q	*(char)
)	O
;	O
q	*(char)
--	O
)	O
nb	long
--	O
;	O
if	O
(	O
!	O
(	O
nb	long
>	O
0	int
&&	O
*	O
q	*(char)
==	O
'\\'	O
)	O
)	O
{	O
*	O
(	O
++	O
q	*(char)
)	O
=	O
'\0'	O
;	O
break	O
;	O
}	O
if	O
(	O
escapes	int
)	O
{	O
q	*(char)
++	O
;	O
nb	long
++	O
;	O
}	O
size	long
-=	O
nb	long
;	O
if	O
(	O
*	O
q	*(char)
==	O
'\r'	O
)	O
*	O
q	*(char)
=	O
'\n'	O
;	O
*	O
(	O
++	O
q	*(char)
)	O
=	O
'\0'	O
;	O
}	O
while	O
(	O
size	long
>	O
0	int
)	O
;	O
return	O
(	O
nread	long
>	O
0	int
?	O
buf	*(char)
:	O
NULL	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
matchchar	(*(char),char,char)->(*(char))
(	O
const	O
char	O
*	O
p	*(void)
,	O
char	O
pl	char
,	O
char	O
pr	char
)	O
{	O
int	O
lvl	int
=	O
0	int
;	O
char	O
c	int
;	O
while	O
(	O
(	O
c	int
=	O
*	O
p	*(void)
++	O
)	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
p	*(void)
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
pr	char
)	O
{	O
if	O
(	O
--	O
lvl	int
<=	O
0	int
)	O
return	O
--	O
p	*(void)
;	O
}	O
else	O
if	O
(	O
c	int
==	O
pl	char
)	O
lvl	int
++	O
;	O
}	O
return	O
(	O
const	O
char	O
*	O
)	O
NULL	O
;	O
}	O
static	O
void	O
printMacro	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),*(char))->(void)
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
se	*(char)
)	O
{	O
const	O
char	O
*	O
senl	*(char)
;	O
const	O
char	O
*	O
ellipsis	*(char)
;	O
int	O
choplen	int
;	O
if	O
(	O
s	*(char)
>=	O
se	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%3d>%*s(empty)"	*(char)
)	O
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
,	O
(	O
2	int
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
+	O
1	int
)	O
,	O
""	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
s	*(char)
[	O
-	O
1	int
]	O
==	O
'{'	O
)	O
s	*(char)
--	O
;	O
for	O
(	O
senl	*(char)
=	O
se	*(char)
;	O
*	O
senl	*(char)
&&	O
!	O
iseol	O
(	O
*	O
senl	*(char)
)	O
;	O
senl	*(char)
++	O
)	O
;	O
choplen	int
=	O
61	int
-	O
(	O
2	int
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
if	O
(	O
(	O
senl	*(char)
-	O
s	*(char)
)	O
>	O
choplen	int
)	O
{	O
senl	*(char)
=	O
s	*(char)
+	O
choplen	int
;	O
ellipsis	*(char)
=	O
"..."	*(char)
;	O
}	O
else	O
ellipsis	*(char)
=	O
""	*(char)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%3d>%*s%%%.*s^"	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
,	O
(	O
2	int
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
+	O
1	int
)	O
,	O
""	*(char)
,	O
(	O
int	O
)	O
(	O
se	*(char)
-	O
s	*(char)
)	O
,	O
s	*(char)
)	O
;	O
if	O
(	O
se	*(char)
[	O
1	int
]	O
!=	O
'\0'	O
&&	O
(	O
senl	*(char)
-	O
(	O
se	*(char)
+	O
1	int
)	O
)	O
>	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%-.*s%s"	*(char)
,	O
(	O
int	O
)	O
(	O
senl	*(char)
-	O
(	O
se	*(char)
+	O
1	int
)	O
)	O
,	O
se	*(char)
+	O
1	int
,	O
ellipsis	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
printExpansion	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),*(char))->(void)
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
const	O
char	O
*	O
t	*(char)
,	O
const	O
char	O
*	O
te	*(char)
)	O
{	O
const	O
char	O
*	O
ellipsis	*(char)
;	O
int	O
choplen	int
;	O
if	O
(	O
!	O
(	O
te	*(char)
>	O
t	*(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%3d<%*s(empty)\n"	*(char)
)	O
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
,	O
(	O
2	int
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
+	O
1	int
)	O
,	O
""	*(char)
)	O
;	O
return	O
;	O
}	O
while	O
(	O
te	*(char)
>	O
t	*(char)
&&	O
iseol	O
(	O
te	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
te	*(char)
--	O
;	O
ellipsis	*(char)
=	O
""	*(char)
;	O
if	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
>	O
0	int
)	O
{	O
const	O
char	O
*	O
tenl	*(char)
;	O
while	O
(	O
(	O
tenl	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
t	*(char)
,	O
'\n'	O
)	O
)	O
&&	O
tenl	*(char)
<	O
te	*(char)
)	O
t	*(char)
=	O
++	O
tenl	*(char)
;	O
choplen	int
=	O
61	int
-	O
(	O
2	int
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
if	O
(	O
(	O
te	*(char)
-	O
t	*(char)
)	O
>	O
choplen	int
)	O
{	O
te	*(char)
=	O
t	*(char)
+	O
choplen	int
;	O
ellipsis	*(char)
=	O
"..."	*(char)
;	O
}	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%3d<%*s"	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
,	O
(	O
2	int
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
+	O
1	int
)	O
,	O
""	*(char)
)	O
;	O
if	O
(	O
te	*(char)
>	O
t	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%.*s%s"	*(char)
,	O
(	O
int	O
)	O
(	O
te	*(char)
-	O
t	*(char)
)	O
,	O
t	*(char)
,	O
ellipsis	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
int	O
expandT	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
const	O
char	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
size_t	long
flen	long
)	O
{	O
char	O
*	O
sbuf	*(char)
;	O
const	O
char	O
*	O
s	*(char)
=	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
s	*(char)
;	O
int	O
rc	int
;	O
sbuf	*(char)
=	O
alloca	(long)->(*(void))
(	O
flen	long
+	O
1	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
sbuf	*(char)
,	O
0	int
,	O
(	O
flen	long
+	O
1	int
)	O
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
sbuf	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
flen	long
)	O
;	O
sbuf	*(char)
[	O
flen	long
]	O
=	O
'\0'	O
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
s	*(char)
=	O
sbuf	*(char)
;	O
rc	int
=	O
expandMacro	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))))->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
)	O
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
s	*(char)
=	O
s	*(char)
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
expandU	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
char	O
*	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
,	O
size_t	long
ulen	long
)	O
{	O
const	O
char	O
*	O
s	*(char)
=	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
s	*(char)
;	O
char	O
*	O
t	*(char)
=	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
t	*(char)
;	O
size_t	long
nb	long
=	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
nb	long
;	O
char	O
*	O
tbuf	*(char)
;	O
int	O
rc	int
;	O
tbuf	*(char)
=	O
alloca	(long)->(*(void))
(	O
ulen	long
+	O
1	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
tbuf	*(char)
,	O
0	int
,	O
(	O
ulen	long
+	O
1	int
)	O
)	O
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
s	*(char)
=	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
t	*(char)
=	O
tbuf	*(char)
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
nb	long
=	O
ulen	long
;	O
rc	int
=	O
expandMacro	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))))->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
)	O
;	O
tbuf	*(char)
[	O
ulen	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
ulen	long
>	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
nb	long
)	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
,	O
tbuf	*(char)
,	O
(	O
ulen	long
-	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
nb	long
+	O
1	int
)	O
)	O
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
s	*(char)
=	O
s	*(char)
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
t	*(char)
=	O
t	*(char)
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
nb	long
=	O
nb	long
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
doShellEscape	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
const	O
char	O
*	O
cmd	*(char)
,	O
size_t	long
clen	long
)	O
{	O
char	O
pcmd	array(char)
[	O
BUFSIZ	int
]	O
;	O
FILE	struct
*	O
shf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
rc	int
;	O
int	O
c	int
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
pcmd	array(char)
,	O
cmd	*(char)
,	O
clen	long
)	O
;	O
pcmd	array(char)
[	O
clen	long
]	O
=	O
'\0'	O
;	O
rc	int
=	O
expandU	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
pcmd	array(char)
,	O
sizeof	O
(	O
pcmd	array(char)
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
(	O
shf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pcmd	array(char)
,	O
"r"	*(char)
)	O
)	O
==	O
NULL	O
)	O
return	O
1	int
;	O
while	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
nb	long
>	O
0	int
&&	O
(	O
c	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
shf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
SAVECHAR	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
c	int
)	O
;	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
shf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
iseol	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
t	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
{	O
*	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
t	*(char)
--	O
)	O
=	O
'\0'	O
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
nb	long
++	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
doDefine	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),int,int)->(*(char))
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
const	O
char	O
*	O
se	*(char)
,	O
int	O
level	int
,	O
int	O
expandbody	int
)	O
{	O
const	O
char	O
*	O
s	*(char)
=	O
se	*(char)
;	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
,	O
*	O
n	*(char)
=	O
buf	*(char)
,	O
*	O
ne	*(char)
=	O
n	*(char)
;	O
char	O
*	O
o	*(char)
=	O
NULL	O
,	O
*	O
oe	*(char)
;	O
char	O
*	O
b	*(char)
,	O
*	O
be	*(char)
;	O
int	O
c	int
;	O
int	O
oc	int
=	O
')'	O
;	O
COPYNAME	O
(	O
ne	*(char)
,	O
s	*(char)
,	O
c	int
)	O
;	O
oe	*(char)
=	O
ne	*(char)
+	O
1	int
;	O
if	O
(	O
*	O
s	*(char)
==	O
'('	O
)	O
{	O
s	*(char)
++	O
;	O
o	*(char)
=	O
oe	*(char)
;	O
COPYOPTS	O
(	O
oe	*(char)
,	O
s	*(char)
,	O
oc	int
)	O
;	O
s	*(char)
++	O
;	O
}	O
b	*(char)
=	O
be	*(char)
=	O
oe	*(char)
+	O
1	int
;	O
SKIPBLANK	O
(	O
s	*(char)
,	O
c	int
)	O
;	O
if	O
(	O
c	int
==	O
'{'	O
)	O
{	O
if	O
(	O
(	O
se	*(char)
=	O
matchchar	(*(char),char,char)->(*(char))
(	O
s	*(char)
,	O
c	int
,	O
'}'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s has unterminated body"	*(char)
)	O
,	O
n	*(char)
)	O
;	O
se	*(char)
=	O
s	*(char)
;	O
return	O
se	*(char)
;	O
}	O
s	*(char)
++	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
b	*(char)
,	O
s	*(char)
,	O
(	O
se	*(char)
-	O
s	*(char)
)	O
)	O
;	O
b	*(char)
[	O
se	*(char)
-	O
s	*(char)
]	O
=	O
'\0'	O
;	O
be	*(char)
+=	O
strlen	(*(char))->(long)
(	O
b	*(char)
)	O
;	O
se	*(char)
++	O
;	O
s	*(char)
=	O
se	*(char)
;	O
}	O
else	O
{	O
COPYBODY	O
(	O
be	*(char)
,	O
s	*(char)
,	O
c	int
)	O
;	O
while	O
(	O
--	O
be	*(char)
>=	O
b	*(char)
&&	O
(	O
c	int
=	O
*	O
be	*(char)
)	O
&&	O
(	O
isblank	(int)->(int)
(	O
c	int
)	O
||	O
iseol	O
(	O
c	int
)	O
)	O
)	O
;	O
*	O
(	O
++	O
be	*(char)
)	O
=	O
'\0'	O
;	O
}	O
while	O
(	O
iseol	O
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
se	*(char)
=	O
s	*(char)
;	O
if	O
(	O
!	O
(	O
(	O
c	int
=	O
*	O
n	*(char)
)	O
&&	O
(	O
isalpha	(int)->(int)
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
)	O
&&	O
(	O
ne	*(char)
-	O
n	*(char)
)	O
>	O
2	int
)	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s has illegal name (%%define)"	*(char)
)	O
,	O
n	*(char)
)	O
;	O
return	O
se	*(char)
;	O
}	O
if	O
(	O
o	*(char)
&&	O
oc	int
!=	O
')'	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s has unterminated opts"	*(char)
)	O
,	O
n	*(char)
)	O
;	O
return	O
se	*(char)
;	O
}	O
if	O
(	O
(	O
be	*(char)
-	O
b	*(char)
)	O
<	O
1	int
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s has empty body"	*(char)
)	O
,	O
n	*(char)
)	O
;	O
return	O
se	*(char)
;	O
}	O
if	O
(	O
expandbody	int
&&	O
expandU	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
b	*(char)
,	O
(	O
&	O
buf	*(char)
[	O
sizeof	O
(	O
buf	*(char)
)	O
]	O
-	O
b	*(char)
)	O
)	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s failed to expand"	*(char)
)	O
,	O
n	*(char)
)	O
;	O
return	O
se	*(char)
;	O
}	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
n	*(char)
,	O
o	*(char)
,	O
b	*(char)
,	O
(	O
level	int
-	O
1	int
)	O
)	O
;	O
return	O
se	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
doUndefine	(*(struct(*(*(struct`)),int,int)),*(char))->(*(char))
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
const	O
char	O
*	O
se	*(char)
)	O
{	O
const	O
char	O
*	O
s	*(char)
=	O
se	*(char)
;	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
,	O
*	O
n	*(char)
=	O
buf	*(char)
,	O
*	O
ne	*(char)
=	O
n	*(char)
;	O
int	O
c	int
;	O
COPYNAME	O
(	O
ne	*(char)
,	O
s	*(char)
,	O
c	int
)	O
;	O
while	O
(	O
iseol	O
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
se	*(char)
=	O
s	*(char)
;	O
if	O
(	O
!	O
(	O
(	O
c	int
=	O
*	O
n	*(char)
)	O
&&	O
(	O
isalpha	(int)->(int)
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
)	O
&&	O
(	O
ne	*(char)
-	O
n	*(char)
)	O
>	O
2	int
)	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s has illegal name (%%undefine)"	*(char)
)	O
,	O
n	*(char)
)	O
;	O
return	O
se	*(char)
;	O
}	O
delMacro	(*(struct(*(*(struct`)),int,int)),*(char))->(void)
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
n	*(char)
)	O
;	O
return	O
se	*(char)
;	O
}	O
static	O
void	O
pushMacro	(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),*(char),*(char),*(char),int)->(void)
(	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
,	O
const	O
char	O
*	O
n	*(char)
,	O
const	O
char	O
*	O
o	*(char)
,	O
const	O
char	O
*	O
b	*(char)
,	O
int	O
level	int
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
prev	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
(	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
?	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
:	O
NULL	O
)	O
;	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
(	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
)	O
)	O
;	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
prev	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
prev	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
;	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
=	O
(	O
prev	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
?	O
prev	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
:	O
xstrdup	(*(char))->(*(char))
(	O
n	*(char)
)	O
)	O
;	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
opts	*(char)
=	O
(	O
o	*(char)
?	O
xstrdup	(*(char))->(*(char))
(	O
o	*(char)
)	O
:	O
NULL	O
)	O
;	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
b	*(char)
?	O
b	*(char)
:	O
""	*(char)
)	O
;	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
used	int
=	O
0	int
;	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
level	int
=	O
level	int
;	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
;	O
}	O
static	O
void	O
popMacro	(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))))->(void)
(	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
(	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
?	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
:	O
NULL	O
)	O
;	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
)	O
{	O
if	O
(	O
(	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
prev	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
)	O
==	O
NULL	O
)	O
FREE	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
)	O
;	O
FREE	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
opts	*(char)
)	O
;	O
FREE	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
)	O
;	O
FREE	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
)	O
;	O
}	O
}	O
static	O
void	O
freeArgs	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))))->(void)
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
)	O
{	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
=	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
;	O
int	O
ndeleted	int
=	O
0	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
;	O
i	int
++	O
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
,	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
;	O
int	O
skiptest	int
=	O
0	int
;	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
&	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
[	O
i	int
]	O
;	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
;	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
level	int
<	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
continue	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
)	O
==	O
1	int
&&	O
strchr	(*(char),int)->(*(char))
(	O
"#*0"	*(char)
,	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
)	O
)	O
{	O
if	O
(	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
==	O
'*'	O
&&	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
used	int
>	O
0	int
)	O
skiptest	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
skiptest	int
&&	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
used	int
<=	O
0	int
)	O
{	O
}	O
popMacro	(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))))->(void)
(	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
;	O
if	O
(	O
!	O
(	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
&&	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
)	O
ndeleted	int
++	O
;	O
}	O
if	O
(	O
ndeleted	int
)	O
sortMacroTable	(*(struct(*(*(struct`)),int,int)))->(void)
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
)	O
;	O
}	O
static	O
const	O
char	O
*	O
grabArgs	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)),*(char),char)->(*(char))
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
const	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
,	O
const	O
char	O
*	O
se	*(char)
,	O
char	O
lastc	char
)	O
{	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
,	O
*	O
b	*(char)
,	O
*	O
be	*(char)
;	O
char	O
aname	array(char)
[	O
16	int
]	O
;	O
const	O
char	O
*	O
opts	*(char)
,	O
*	O
o	*(char)
;	O
int	O
argc	int
=	O
0	int
;	O
const	O
char	O
*	O
*	O
argv	*(*(char))
;	O
int	O
c	int
;	O
b	*(char)
=	O
be	*(char)
=	O
rpm_stpcpy	()->(int)
(	O
buf	*(char)
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
)	O
;	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
"0"	*(char)
,	O
NULL	O
,	O
buf	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
argc	int
=	O
1	int
;	O
*	O
be	*(char)
++	O
=	O
' '	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
se	*(char)
++	O
)	O
!=	O
'\0'	O
&&	O
c	int
!=	O
lastc	char
)	O
{	O
if	O
(	O
!	O
isblank	(int)->(int)
(	O
c	int
)	O
)	O
{	O
*	O
be	*(char)
++	O
=	O
c	int
;	O
continue	O
;	O
}	O
if	O
(	O
be	*(char)
[	O
-	O
1	int
]	O
==	O
' '	O
)	O
continue	O
;	O
*	O
be	*(char)
++	O
=	O
' '	O
;	O
argc	int
++	O
;	O
}	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
se	*(char)
--	O
;	O
if	O
(	O
be	*(char)
[	O
-	O
1	int
]	O
!=	O
' '	O
)	O
argc	int
++	O
,	O
be	*(char)
++	O
;	O
be	*(char)
[	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
b	*(char)
==	O
' '	O
)	O
b	*(char)
++	O
;	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
"**"	*(char)
,	O
NULL	O
,	O
b	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
argv	*(*(char))
=	O
(	O
const	O
char	O
*	O
*	O
)	O
alloca	(long)->(*(void))
(	O
(	O
argc	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
be	*(char)
[	O
-	O
1	int
]	O
=	O
' '	O
;	O
b	*(char)
=	O
buf	*(char)
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
argc	int
;	O
c	int
++	O
)	O
{	O
argv	*(*(char))
[	O
c	int
]	O
=	O
b	*(char)
;	O
b	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
b	*(char)
,	O
' '	O
)	O
;	O
*	O
b	*(char)
++	O
=	O
'\0'	O
;	O
}	O
argv	*(*(char))
[	O
argc	int
]	O
=	O
NULL	O
;	O
opts	*(char)
=	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
opts	*(char)
;	O
while	O
(	O
(	O
c	int
=	O
getopt	(int,*(*(char)),*(char))->(int)
(	O
argc	int
,	O
(	O
char	O
*	O
*	O
)	O
argv	*(*(char))
,	O
opts	*(char)
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
c	int
==	O
'?'	O
||	O
(	O
o	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
opts	*(char)
,	O
c	int
)	O
)	O
==	O
NULL	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Unknown option %c in %s(%s)"	*(char)
)	O
,	O
c	int
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
,	O
opts	*(char)
)	O
;	O
return	O
se	*(char)
;	O
}	O
*	O
be	*(char)
++	O
=	O
'-'	O
;	O
*	O
be	*(char)
++	O
=	O
c	int
;	O
if	O
(	O
o	*(char)
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
*	O
be	*(char)
++	O
=	O
' '	O
;	O
be	*(char)
=	O
rpm_stpcpy	()->(int)
(	O
be	*(char)
,	O
optarg	*(char)
)	O
;	O
}	O
*	O
be	*(char)
++	O
=	O
'\0'	O
;	O
aname	array(char)
[	O
0	int
]	O
=	O
'-'	O
;	O
aname	array(char)
[	O
1	int
]	O
=	O
c	int
;	O
aname	array(char)
[	O
2	int
]	O
=	O
'\0'	O
;	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
aname	array(char)
,	O
NULL	O
,	O
b	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
if	O
(	O
o	*(char)
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
aname	array(char)
[	O
0	int
]	O
=	O
'-'	O
;	O
aname	array(char)
[	O
1	int
]	O
=	O
c	int
;	O
aname	array(char)
[	O
2	int
]	O
=	O
'*'	O
;	O
aname	array(char)
[	O
3	int
]	O
=	O
'\0'	O
;	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
aname	array(char)
,	O
NULL	O
,	O
optarg	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
}	O
be	*(char)
=	O
b	*(char)
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
aname	array(char)
,	O
"%d"	*(char)
,	O
(	O
argc	int
-	O
optind	int
)	O
)	O
;	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
"#"	*(char)
,	O
NULL	O
,	O
aname	array(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
*	O
be	*(char)
=	O
'\0'	O
;	O
for	O
(	O
c	int
=	O
optind	int
;	O
c	int
<	O
argc	int
;	O
c	int
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
aname	array(char)
,	O
"%d"	*(char)
,	O
(	O
c	int
-	O
optind	int
+	O
1	int
)	O
)	O
;	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
aname	array(char)
,	O
NULL	O
,	O
argv	*(*(char))
[	O
c	int
]	O
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
*	O
be	*(char)
++	O
=	O
' '	O
;	O
be	*(char)
=	O
rpm_stpcpy	()->(int)
(	O
be	*(char)
,	O
argv	*(*(char))
[	O
c	int
]	O
)	O
;	O
}	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
"*"	*(char)
,	O
NULL	O
,	O
b	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
return	O
se	*(char)
;	O
}	O
static	O
void	O
doOutput	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),int,*(char),long)->(void)
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
int	O
waserror	int
,	O
const	O
char	O
*	O
msg	*(char)
,	O
size_t	long
msglen	long
)	O
{	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
buf	*(char)
,	O
msg	*(char)
,	O
msglen	long
)	O
;	O
buf	*(char)
[	O
msglen	long
]	O
=	O
'\0'	O
;	O
expandU	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
if	O
(	O
waserror	int
)	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
"%s"	*(char)
,	O
buf	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
buf	*(char)
)	O
;	O
}	O
static	O
void	O
doFoo	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),int,*(char),long,*(char),long)->(void)
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
int	O
negate	int
,	O
const	O
char	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
size_t	long
fn	long
,	O
const	O
char	O
*	O
g	*(char)
,	O
size_t	long
glen	long
)	O
{	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
,	O
*	O
b	*(char)
=	O
NULL	O
,	O
*	O
be	*(char)
;	O
int	O
c	int
;	O
buf	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
g	*(char)
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
buf	*(char)
,	O
g	*(char)
,	O
glen	long
)	O
;	O
buf	*(char)
[	O
glen	long
]	O
=	O
'\0'	O
;	O
expandU	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"basename"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
if	O
(	O
(	O
b	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
buf	*(char)
,	O
'/'	O
)	O
)	O
==	O
NULL	O
)	O
b	*(char)
=	O
buf	*(char)
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"suffix"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
if	O
(	O
(	O
b	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
buf	*(char)
,	O
'.'	O
)	O
)	O
!=	O
NULL	O
)	O
b	*(char)
++	O
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"expand"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
b	*(char)
=	O
buf	*(char)
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"verbose"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
if	O
(	O
negate	int
)	O
b	*(char)
=	O
(	O
rpmIsVerbose	()->(int)
(	O
)	O
?	O
NULL	O
:	O
buf	*(char)
)	O
;	O
else	O
b	*(char)
=	O
(	O
rpmIsVerbose	()->(int)
(	O
)	O
?	O
buf	*(char)
:	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"url2path"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"u2p"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
(	O
void	O
)	O
urlPath	(*(char),*(*(char)))->(int)
(	O
buf	*(char)
,	O
(	O
const	O
char	O
*	O
*	O
)	O
&	O
b	*(char)
)	O
;	O
if	O
(	O
*	O
b	*(char)
==	O
'\0'	O
)	O
b	*(char)
=	O
"/"	*(char)
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"uncompress"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
int	O
compressed	*(int)
=	O
1	int
;	O
for	O
(	O
b	*(char)
=	O
buf	*(char)
;	O
(	O
c	int
=	O
*	O
b	*(char)
)	O
&&	O
isblank	(int)->(int)
(	O
c	int
)	O
;	O
)	O
b	*(char)
++	O
;	O
for	O
(	O
be	*(char)
=	O
b	*(char)
;	O
(	O
c	int
=	O
*	O
be	*(char)
)	O
&&	O
!	O
isblank	(int)->(int)
(	O
c	int
)	O
;	O
)	O
be	*(char)
++	O
;	O
*	O
be	*(char)
++	O
=	O
'\0'	O
;	O
isCompressed	(*(char),*(int))->(int)
(	O
b	*(char)
,	O
&	O
compressed	*(int)
)	O
;	O
switch	O
(	O
compressed	*(int)
)	O
{	O
default	O
:	O
case	O
0	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
be	*(char)
,	O
"%%_cat %s"	*(char)
,	O
b	*(char)
)	O
;	O
break	O
;	O
case	O
1	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
be	*(char)
,	O
"%%_gzip -dc %s"	*(char)
,	O
b	*(char)
)	O
;	O
break	O
;	O
case	O
2	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
be	*(char)
,	O
"%%_bzip2 %s"	*(char)
,	O
b	*(char)
)	O
;	O
break	O
;	O
}	O
b	*(char)
=	O
be	*(char)
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"S"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
for	O
(	O
b	*(char)
=	O
buf	*(char)
;	O
(	O
c	int
=	O
*	O
b	*(char)
)	O
&&	O
isdigit	(int)->(int)
(	O
c	int
)	O
;	O
)	O
b	*(char)
++	O
;	O
if	O
(	O
!	O
c	int
)	O
{	O
b	*(char)
++	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
b	*(char)
,	O
"%%SOURCE%s"	*(char)
,	O
buf	*(char)
)	O
;	O
}	O
else	O
b	*(char)
=	O
buf	*(char)
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"P"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
for	O
(	O
b	*(char)
=	O
buf	*(char)
;	O
(	O
c	int
=	O
*	O
b	*(char)
)	O
&&	O
isdigit	(int)->(int)
(	O
c	int
)	O
;	O
)	O
b	*(char)
++	O
;	O
if	O
(	O
!	O
c	int
)	O
{	O
b	*(char)
++	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
b	*(char)
,	O
"%%PATCH%s"	*(char)
,	O
buf	*(char)
)	O
;	O
}	O
else	O
b	*(char)
=	O
buf	*(char)
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"F"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
b	*(char)
=	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
+	O
1	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
b	*(char)
,	O
"file%s.file"	*(char)
,	O
buf	*(char)
)	O
;	O
}	O
if	O
(	O
b	*(char)
)	O
{	O
expandT	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
b	*(char)
,	O
strlen	(*(char))->(long)
(	O
b	*(char)
)	O
)	O
;	O
}	O
}	O
static	O
int	O
expandMacro	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))))->(int)
(	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
;	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
;	O
const	O
char	O
*	O
s	*(char)
=	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
s	*(char)
,	O
*	O
se	*(char)
;	O
const	O
char	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
*	O
fe	*(char)
;	O
const	O
char	O
*	O
g	*(char)
,	O
*	O
ge	*(char)
;	O
size_t	long
fn	long
,	O
gn	long
;	O
char	O
*	O
t	*(char)
=	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
t	*(char)
;	O
int	O
c	int
;	O
int	O
rc	int
=	O
0	int
;	O
int	O
negate	int
;	O
char	O
grab	char
;	O
int	O
chkexist	int
;	O
if	O
(	O
++	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
>	O
max_macro_depth	int
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Recursion depth(%d) greater than max(%d)"	*(char)
)	O
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
,	O
max_macro_depth	int
)	O
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
--	O
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
expand_trace	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
while	O
(	O
rc	int
==	O
0	int
&&	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
nb	long
>	O
0	int
&&	O
(	O
c	int
=	O
*	O
s	*(char)
)	O
!=	O
'\0'	O
)	O
{	O
s	*(char)
++	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'%'	O
:	O
if	O
(	O
*	O
s	*(char)
!=	O
'%'	O
)	O
break	O
;	O
s	*(char)
++	O
;	O
default	O
:	O
SAVECHAR	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
c	int
)	O
;	O
continue	O
;	O
break	O
;	O
}	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fe	*(char)
=	O
NULL	O
;	O
g	*(char)
=	O
ge	*(char)
=	O
NULL	O
;	O
if	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
>	O
1	int
)	O
t	*(char)
=	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
t	*(char)
;	O
negate	int
=	O
0	int
;	O
grab	char
=	O
'\0'	O
;	O
chkexist	int
=	O
0	int
;	O
switch	O
(	O
(	O
c	int
=	O
*	O
s	*(char)
)	O
)	O
{	O
default	O
:	O
while	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"!?"	*(char)
,	O
*	O
s	*(char)
)	O
!=	O
NULL	O
)	O
{	O
switch	O
(	O
*	O
s	*(char)
++	O
)	O
{	O
case	O
'!'	O
:	O
negate	int
=	O
(	O
++	O
negate	int
%	O
2	int
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
chkexist	int
++	O
;	O
break	O
;	O
}	O
}	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
se	*(char)
=	O
s	*(char)
;	O
if	O
(	O
*	O
se	*(char)
==	O
'-'	O
)	O
se	*(char)
++	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
se	*(char)
)	O
&&	O
(	O
isalnum	(int)->(int)
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
)	O
)	O
se	*(char)
++	O
;	O
switch	O
(	O
*	O
se	*(char)
)	O
{	O
case	O
'*'	O
:	O
se	*(char)
++	O
;	O
if	O
(	O
*	O
se	*(char)
==	O
'*'	O
)	O
se	*(char)
++	O
;	O
break	O
;	O
case	O
'#'	O
:	O
se	*(char)
++	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
fe	*(char)
=	O
se	*(char)
;	O
if	O
(	O
(	O
c	int
=	O
*	O
fe	*(char)
)	O
&&	O
isblank	(int)->(int)
(	O
c	int
)	O
)	O
grab	char
=	O
'\n'	O
;	O
break	O
;	O
case	O
'('	O
:	O
if	O
(	O
(	O
se	*(char)
=	O
matchchar	(*(char),char,char)->(*(char))
(	O
s	*(char)
,	O
c	int
,	O
')'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Unterminated %c: %s"	*(char)
)	O
,	O
c	int
,	O
s	*(char)
)	O
;	O
rc	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
macro_trace	int
)	O
printMacro	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),*(char))->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
s	*(char)
,	O
se	*(char)
+	O
1	int
)	O
;	O
s	*(char)
++	O
;	O
rc	int
=	O
doShellEscape	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
s	*(char)
,	O
(	O
se	*(char)
-	O
s	*(char)
)	O
)	O
;	O
se	*(char)
++	O
;	O
s	*(char)
=	O
se	*(char)
;	O
continue	O
;	O
break	O
;	O
case	O
'{'	O
:	O
if	O
(	O
(	O
se	*(char)
=	O
matchchar	(*(char),char,char)->(*(char))
(	O
s	*(char)
,	O
c	int
,	O
'}'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Unterminated %c: %s"	*(char)
)	O
,	O
c	int
,	O
s	*(char)
)	O
;	O
rc	int
=	O
1	int
;	O
continue	O
;	O
}	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
s	*(char)
+	O
1	int
;	O
se	*(char)
++	O
;	O
while	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"!?"	*(char)
,	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
NULL	O
)	O
{	O
switch	O
(	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
++	O
)	O
{	O
case	O
'!'	O
:	O
negate	int
=	O
(	O
++	O
negate	int
%	O
2	int
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
chkexist	int
++	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
fe	*(char)
=	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
(	O
c	int
=	O
*	O
fe	*(char)
)	O
&&	O
!	O
strchr	(*(char),int)->(*(char))
(	O
" :}"	*(char)
,	O
c	int
)	O
;	O
)	O
fe	*(char)
++	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
':'	O
:	O
g	*(char)
=	O
fe	*(char)
+	O
1	int
;	O
ge	*(char)
=	O
se	*(char)
-	O
1	int
;	O
break	O
;	O
case	O
' '	O
:	O
grab	char
=	O
se	*(char)
[	O
-	O
1	int
]	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
fn	long
=	O
(	O
fe	*(char)
-	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
gn	long
=	O
(	O
ge	*(char)
-	O
g	*(char)
)	O
;	O
if	O
(	O
fn	long
<=	O
0	int
)	O
{	O
c	int
=	O
'%'	O
;	O
SAVECHAR	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
c	int
)	O
;	O
s	*(char)
=	O
se	*(char)
;	O
continue	O
;	O
}	O
if	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
macro_trace	int
)	O
printMacro	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),*(char))->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
s	*(char)
,	O
se	*(char)
)	O
;	O
if	O
(	O
STREQ	O
(	O
"global"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
s	*(char)
=	O
doDefine	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),int,int)->(*(char))
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
se	*(char)
,	O
RMIL_GLOBAL	int
,	O
1	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"define"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
s	*(char)
=	O
doDefine	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),int,int)->(*(char))
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
se	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"undefine"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
s	*(char)
=	O
doUndefine	(*(struct(*(*(struct`)),int,int)),*(char))->(*(char))
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
se	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"echo"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"warn"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"error"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
int	O
waserror	int
=	O
0	int
;	O
if	O
(	O
STREQ	O
(	O
"error"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
waserror	int
=	O
1	int
;	O
if	O
(	O
g	*(char)
<	O
ge	*(char)
)	O
doOutput	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),int,*(char),long)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
waserror	int
,	O
g	*(char)
,	O
gn	long
)	O
;	O
else	O
doOutput	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),int,*(char),long)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
waserror	int
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
;	O
s	*(char)
=	O
se	*(char)
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"trace"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
expand_trace	int
=	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
macro_trace	int
=	O
(	O
negate	int
?	O
0	int
:	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
if	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
==	O
1	int
)	O
{	O
print_macro_trace	int
=	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
macro_trace	int
;	O
print_expand_trace	int
=	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
expand_trace	int
;	O
}	O
s	*(char)
=	O
se	*(char)
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"dump"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
rpmDumpMacroTable	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
NULL	O
)	O
;	O
while	O
(	O
iseol	O
(	O
*	O
se	*(char)
)	O
)	O
se	*(char)
++	O
;	O
s	*(char)
=	O
se	*(char)
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"basename"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"suffix"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"expand"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"verbose"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"uncompress"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"url2path"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"u2p"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"S"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"P"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"F"	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
)	O
{	O
doFoo	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),int,*(char),long,*(char),long)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
negate	int
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
,	O
g	*(char)
,	O
gn	long
)	O
;	O
s	*(char)
=	O
se	*(char)
;	O
continue	O
;	O
}	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
findEntry	(*(struct(*(*(struct`)),int,int)),*(char),long)->(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))))
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fn	long
)	O
;	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
(	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
?	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
:	O
NULL	O
)	O
;	O
if	O
(	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
'-'	O
)	O
{	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
)	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
used	int
++	O
;	O
if	O
(	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
==	O
NULL	O
&&	O
!	O
negate	int
)	O
||	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
!=	O
NULL	O
&&	O
negate	int
)	O
)	O
{	O
s	*(char)
=	O
se	*(char)
;	O
continue	O
;	O
}	O
if	O
(	O
g	*(char)
&&	O
g	*(char)
<	O
ge	*(char)
)	O
{	O
rc	int
=	O
expandT	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
g	*(char)
,	O
gn	long
)	O
;	O
}	O
else	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
&&	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
)	O
{	O
rc	int
=	O
expandT	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
,	O
strlen	(*(char))->(long)
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
)	O
)	O
;	O
}	O
s	*(char)
=	O
se	*(char)
;	O
continue	O
;	O
}	O
if	O
(	O
chkexist	int
)	O
{	O
if	O
(	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
==	O
NULL	O
&&	O
!	O
negate	int
)	O
||	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
!=	O
NULL	O
&&	O
negate	int
)	O
)	O
{	O
s	*(char)
=	O
se	*(char)
;	O
continue	O
;	O
}	O
if	O
(	O
g	*(char)
&&	O
g	*(char)
<	O
ge	*(char)
)	O
{	O
rc	int
=	O
expandT	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
g	*(char)
,	O
gn	long
)	O
;	O
}	O
else	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
&&	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
&&	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
)	O
{	O
rc	int
=	O
expandT	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),long)->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
,	O
strlen	(*(char))->(long)
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
)	O
)	O
;	O
}	O
s	*(char)
=	O
se	*(char)
;	O
continue	O
;	O
}	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
==	O
NULL	O
)	O
{	O
c	int
=	O
'%'	O
;	O
SAVECHAR	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
c	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
&&	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
opts	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
grab	char
)	O
{	O
se	*(char)
=	O
grabArgs	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)),*(char),char)->(*(char))
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
,	O
fe	*(char)
,	O
grab	char
)	O
;	O
}	O
else	O
{	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
"**"	*(char)
,	O
NULL	O
,	O
""	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
"*"	*(char)
,	O
NULL	O
,	O
""	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
"#"	*(char)
,	O
NULL	O
,	O
"0"	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
"0"	*(char)
,	O
NULL	O
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
)	O
;	O
}	O
}	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
&&	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
)	O
{	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
s	*(char)
=	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
;	O
rc	int
=	O
expandMacro	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))))->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
used	int
++	O
;	O
}	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
opts	*(char)
!=	O
NULL	O
)	O
freeArgs	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))))->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
)	O
;	O
s	*(char)
=	O
se	*(char)
;	O
}	O
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
t	*(char)
=	O
'\0'	O
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
s	*(char)
=	O
s	*(char)
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
--	O
;	O
if	O
(	O
rc	int
!=	O
0	int
||	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
expand_trace	int
)	O
printExpansion	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),*(char))->(void)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
t	*(char)
,	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
t	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
const	O
char	O
*	O
getMacroBody	(*(struct(*(*(struct`)),int,int)),*(char))->(*(char))
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
findEntry	(*(struct(*(*(struct`)),int,int)),*(char),long)->(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))))
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
name	*(char)
,	O
0	int
)	O
;	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
(	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
?	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
:	O
NULL	O
)	O
;	O
return	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
?	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
:	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
int	O
expandMacros	(*(void),*(struct(*(*(struct`)),int,int)),*(char),long)->(int)
(	O
void	O
*	O
spec	*(void)
,	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
char	O
*	O
s	*(char)
,	O
size_t	long
slen	long
)	O
{	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
macrobuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct`)),int,int)))
,	O
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
=	O
&	O
macrobuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct`)),int,int)))
;	O
char	O
*	O
tbuf	*(char)
;	O
int	O
rc	int
;	O
if	O
(	O
s	*(char)
==	O
NULL	O
||	O
slen	long
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
==	O
NULL	O
)	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
=	O
&	O
rpmGlobalMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
;	O
tbuf	*(char)
=	O
alloca	(long)->(*(void))
(	O
slen	long
+	O
1	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
tbuf	*(char)
,	O
0	int
,	O
(	O
slen	long
+	O
1	int
)	O
)	O
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
s	*(char)
=	O
s	*(char)
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
t	*(char)
=	O
tbuf	*(char)
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
nb	long
=	O
slen	long
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
depth	int
=	O
0	int
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
macro_trace	int
=	O
print_macro_trace	int
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
expand_trace	int
=	O
print_expand_trace	int
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
spec	*(void)
=	O
spec	*(void)
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
=	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
;	O
rc	int
=	O
expandMacro	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))))->(int)
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
)	O
;	O
if	O
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
nb	long
<=	O
0	int
)	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Target buffer overflow"	*(char)
)	O
)	O
;	O
tbuf	*(char)
[	O
slen	long
]	O
=	O
'\0'	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
s	*(char)
,	O
tbuf	*(char)
,	O
(	O
slen	long
-	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
nb	long
+	O
1	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
const	O
char	O
*	O
n	*(char)
,	O
const	O
char	O
*	O
o	*(char)
,	O
const	O
char	O
*	O
b	*(char)
,	O
int	O
level	int
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
;	O
if	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
==	O
NULL	O
)	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
=	O
&	O
rpmGlobalMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
;	O
if	O
(	O
(	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
findEntry	(*(struct(*(*(struct`)),int,int)),*(char),long)->(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))))
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
n	*(char)
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
==	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macrosAllocated	int
)	O
expandMacroTable	(*(struct(*(*(struct`)),int,int)))->(void)
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
)	O
;	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
+	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
++	O
;	O
}	O
pushMacro	(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),*(char),*(char),*(char),int)->(void)
(	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
,	O
n	*(char)
,	O
o	*(char)
,	O
b	*(char)
,	O
level	int
)	O
;	O
if	O
(	O
(	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
->	O
prev	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
==	O
NULL	O
)	O
sortMacroTable	(*(struct(*(*(struct`)),int,int)))->(void)
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
)	O
;	O
}	O
void	O
delMacro	(*(struct(*(*(struct`)),int,int)),*(char))->(void)
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
const	O
char	O
*	O
n	*(char)
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
;	O
if	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
==	O
NULL	O
)	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
=	O
&	O
rpmGlobalMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
;	O
if	O
(	O
(	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
findEntry	(*(struct(*(*(struct`)),int,int)),*(char),long)->(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))))
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
n	*(char)
,	O
0	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
popMacro	(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))))->(void)
(	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
;	O
if	O
(	O
!	O
(	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
&&	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
)	O
sortMacroTable	(*(struct(*(*(struct`)),int,int)))->(void)
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
)	O
;	O
}	O
}	O
int	O
rpmDefineMacro	(*(struct(*(*(struct`)),int,int)),*(char),int)->(int)
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
const	O
char	O
*	O
macro	*(char)
,	O
int	O
level	int
)	O
{	O
MacroBuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int)))
macrobuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct`)),int,int)))
,	O
*	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
=	O
&	O
macrobuf	struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*(struct`)),int,int)))
;	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
->	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
=	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
?	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
:	O
&	O
rpmGlobalMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
)	O
;	O
(	O
void	O
)	O
doDefine	(*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*`,int,int)))),*(char),int,int)->(*(char))
(	O
mb	*(struct(*(char),*(char),long,int,int,int,*(void),*(struct(*(*`),int,int))))
,	O
macro	*(char)
,	O
level	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
rpmLoadMacros	(*(struct(*(*(struct`)),int,int)),int)->(void)
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
int	O
level	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
==	O
NULL	O
||	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
==	O
&	O
rpmGlobalMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
;	O
i	int
++	O
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
,	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
;	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
=	O
&	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
[	O
i	int
]	O
;	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
*	O
mep	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
;	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
==	O
NULL	O
)	O
continue	O
;	O
addMacro	(*(struct(*(*(struct`)),int,int)),*(char),*(char),*(char),int)->(void)
(	O
NULL	O
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
opts	*(char)
,	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
,	O
(	O
level	int
-	O
1	int
)	O
)	O
;	O
}	O
}	O
void	O
rpmInitMacros	(*(struct(*(*(struct`)),int,int)),*(char))->(void)
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
const	O
char	O
*	O
macrofiles	*(char)
)	O
{	O
char	O
*	O
m	*(char)
,	O
*	O
mfile	*(char)
,	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
;	O
if	O
(	O
macrofiles	*(char)
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
==	O
NULL	O
)	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
=	O
&	O
rpmGlobalMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
;	O
for	O
(	O
mfile	*(char)
=	O
m	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
macrofiles	*(char)
)	O
;	O
*	O
mfile	*(char)
;	O
mfile	*(char)
=	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
)	O
{	O
FD_t	*(struct)
fd	*(struct)
;	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
;	O
for	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
mfile	*(char)
;	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
strchr	(*(char),int)->(*(char))
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
,	O
':'	O
)	O
)	O
!=	O
NULL	O
;	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
++	O
)	O
{	O
if	O
(	O
!	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
[	O
1	int
]	O
==	O
'/'	O
&&	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
[	O
2	int
]	O
==	O
'/'	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
&&	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
==	O
':'	O
)	O
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
++	O
=	O
'\0'	O
;	O
else	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
mfile	*(char)
+	O
strlen	(*(char))->(long)
(	O
mfile	*(char)
)	O
;	O
buf	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
mfile	*(char)
[	O
0	int
]	O
==	O
'~'	O
&&	O
mfile	*(char)
[	O
1	int
]	O
==	O
'/'	O
)	O
{	O
char	O
*	O
home	*(char)
;	O
if	O
(	O
(	O
home	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
mfile	*(char)
+=	O
2	int
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
buf	*(char)
,	O
home	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(char)
,	O
"/"	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
-	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
)	O
;	O
}	O
}	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(char)
,	O
mfile	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
-	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
)	O
;	O
buf	*(char)
[	O
sizeof	O
(	O
buf	*(char)
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
fd	*(struct)
=	O
Fopen	(*(char),*(char))->(*(struct))
(	O
buf	*(char)
,	O
"r.fpio"	*(char)
)	O
;	O
if	O
(	O
fd	*(struct)
==	O
NULL	O
||	O
Ferror	(*(struct))->(int)
(	O
fd	*(struct)
)	O
)	O
{	O
if	O
(	O
fd	*(struct)
)	O
Fclose	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
continue	O
;	O
}	O
max_macro_depth	int
=	O
16	int
;	O
while	O
(	O
rdcl	(*(char),long,*(struct),int)->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
fd	*(struct)
,	O
1	int
)	O
!=	O
NULL	O
)	O
{	O
char	O
c	int
,	O
*	O
n	*(char)
;	O
n	*(char)
=	O
buf	*(char)
;	O
SKIPBLANK	O
(	O
n	*(char)
,	O
c	int
)	O
;	O
if	O
(	O
c	int
!=	O
'%'	O
)	O
continue	O
;	O
n	*(char)
++	O
;	O
(	O
void	O
)	O
rpmDefineMacro	(*(struct(*(*(struct`)),int,int)),*(char),int)->(int)
(	O
NULL	O
,	O
n	*(char)
,	O
RMIL_MACROFILES	O
)	O
;	O
}	O
Fclose	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
}	O
if	O
(	O
m	*(char)
)	O
free	(*(void))->(void)
(	O
m	*(char)
)	O
;	O
rpmLoadMacros	(*(struct(*(*(struct`)),int,int)),int)->(void)
(	O
&	O
rpmCLIMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
,	O
RMIL_CMDLINE	O
)	O
;	O
}	O
void	O
rpmFreeMacros	(*(struct(*(*(struct`)),int,int)))->(void)
(	O
MacroContext	struct(*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int))),int,int)
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
)	O
{	O
int	O
i	int
;	O
if	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
==	O
NULL	O
)	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
=	O
&	O
rpmGlobalMacroContext	struct(*(*(struct(*(struct`),*(char),*(char),*(char),int,int))),int,int)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
firstFree	int
;	O
i	int
++	O
)	O
{	O
MacroEntry	struct(*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int)
*	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
;	O
while	O
(	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
=	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
[	O
i	int
]	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
[	O
i	int
]	O
=	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
prev	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
)	O
==	O
NULL	O
)	O
FREE	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
name	*(char)
)	O
;	O
FREE	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
opts	*(char)
)	O
;	O
FREE	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
->	O
body	*(char)
)	O
;	O
FREE	O
(	O
me	*(struct(*(struct(*(struct`),*(char),*(char),*(char),int,int)),*(char),*(char),*(char),int,int))
)	O
;	O
}	O
}	O
FREE	O
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
->	O
macroTable	*(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),*(char),int,int)))
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
,	O
0	int
,	O
sizeof	O
(	O
*	O
mc	*(struct(*(*(struct(*`,*`,*`,*`,int,int))),int,int))
)	O
)	O
;	O
}	O
int	O
isCompressed	(*(char),*(int))->(int)
(	O
const	O
char	O
*	O
file	*(char)
,	O
int	O
*	O
compressed	*(int)
)	O
{	O
FD_t	*(struct)
fd	*(struct)
;	O
ssize_t	long
nb	long
;	O
int	O
rc	int
=	O
-	O
1	int
;	O
unsigned	O
char	O
magic	array(char)
[	O
4	int
]	O
;	O
*	O
compressed	*(int)
=	O
COMPRESSED_NOT	int
;	O
fd	*(struct)
=	O
Fopen	(*(char),*(char))->(*(struct))
(	O
file	*(char)
,	O
"r.ufdio"	*(char)
)	O
;	O
if	O
(	O
fd	*(struct)
==	O
NULL	O
||	O
Ferror	(*(struct))->(int)
(	O
fd	*(struct)
)	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"File %s: %s"	*(char)
)	O
,	O
file	*(char)
,	O
Fstrerror	(*(struct))->(*(char))
(	O
fd	*(struct)
)	O
)	O
;	O
if	O
(	O
fd	*(struct)
)	O
Fclose	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
nb	long
=	O
Fread	(*(void),long,long,*(struct))->(long)
(	O
magic	array(char)
,	O
sizeof	O
(	O
char	O
)	O
,	O
sizeof	O
(	O
magic	array(char)
)	O
,	O
fd	*(struct)
)	O
;	O
if	O
(	O
nb	long
<	O
0	int
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"File %s: %s"	*(char)
)	O
,	O
file	*(char)
,	O
Fstrerror	(*(struct))->(*(char))
(	O
fd	*(struct)
)	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
nb	long
<	O
sizeof	O
(	O
magic	array(char)
)	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"File %s is smaller than %d bytes"	*(char)
)	O
,	O
file	*(char)
,	O
sizeof	O
(	O
magic	array(char)
)	O
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
Fclose	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
if	O
(	O
rc	int
>=	O
0	int
)	O
return	O
rc	int
;	O
rc	int
=	O
0	int
;	O
if	O
(	O
(	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
0037	int
)	O
&&	O
(	O
magic	array(char)
[	O
1	int
]	O
==	O
0213	int
)	O
)	O
||	O
(	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
0037	int
)	O
&&	O
(	O
magic	array(char)
[	O
1	int
]	O
==	O
0236	int
)	O
)	O
||	O
(	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
0037	int
)	O
&&	O
(	O
magic	array(char)
[	O
1	int
]	O
==	O
0036	int
)	O
)	O
||	O
(	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
0037	int
)	O
&&	O
(	O
magic	array(char)
[	O
1	int
]	O
==	O
0240	int
)	O
)	O
||	O
(	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
0037	int
)	O
&&	O
(	O
magic	array(char)
[	O
1	int
]	O
==	O
0235	int
)	O
)	O
||	O
(	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
0120	int
)	O
&&	O
(	O
magic	array(char)
[	O
1	int
]	O
==	O
0113	int
)	O
&&	O
(	O
magic	array(char)
[	O
2	int
]	O
==	O
0003	int
)	O
&&	O
(	O
magic	array(char)
[	O
3	int
]	O
==	O
0004	int
)	O
)	O
)	O
{	O
*	O
compressed	*(int)
=	O
COMPRESSED_OTHER	int
;	O
}	O
else	O
if	O
(	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
'B'	O
)	O
&&	O
(	O
magic	array(char)
[	O
1	int
]	O
==	O
'Z'	O
)	O
)	O
{	O
*	O
compressed	*(int)
=	O
COMPRESSED_BZIP2	int
;	O
}	O
return	O
rc	int
;	O
}	O
char	O
*	O
rpmExpand	(*(char))->(*(char))
(	O
const	O
char	O
*	O
arg	*(char)
,	O
...	O
)	O
{	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
,	O
*	O
p	*(void)
,	O
*	O
pe	*(char)
;	O
const	O
char	O
*	O
s	*(char)
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	*(void)
;	O
if	O
(	O
arg	*(char)
==	O
NULL	O
)	O
return	O
xstrdup	(*(char))->(*(char))
(	O
""	*(char)
)	O
;	O
p	*(void)
=	O
buf	*(char)
;	O
pe	*(char)
=	O
rpm_stpcpy	()->(int)
(	O
p	*(void)
,	O
arg	*(char)
)	O
;	O
va_start	O
(	O
ap	*(void)
,	O
arg	*(char)
)	O
;	O
while	O
(	O
(	O
s	*(char)
=	O
va_arg	O
(	O
ap	*(void)
,	O
const	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
pe	*(char)
=	O
rpm_stpcpy	()->(int)
(	O
pe	*(char)
,	O
s	*(char)
)	O
;	O
va_end	O
(	O
ap	*(void)
)	O
;	O
expandMacros	(*(void),*(struct(*(*(struct`)),int,int)),*(char),long)->(int)
(	O
NULL	O
,	O
NULL	O
,	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
return	O
xstrdup	(*(char))->(*(char))
(	O
buf	*(char)
)	O
;	O
}	O
int	O
rpmExpandNumeric	(*(char))->(int)
(	O
const	O
char	O
*	O
arg	*(char)
)	O
{	O
const	O
char	O
*	O
val	array(int)
;	O
int	O
rc	int
;	O
if	O
(	O
arg	*(char)
==	O
NULL	O
)	O
return	O
0	int
;	O
val	array(int)
=	O
rpmExpand	(*(char))->(*(char))
(	O
arg	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
val	array(int)
&&	O
*	O
val	array(int)
!=	O
'%'	O
)	O
)	O
rc	int
=	O
0	int
;	O
else	O
if	O
(	O
*	O
val	array(int)
==	O
'Y'	O
||	O
*	O
val	array(int)
==	O
'y'	O
)	O
rc	int
=	O
1	int
;	O
else	O
if	O
(	O
*	O
val	array(int)
==	O
'N'	O
||	O
*	O
val	array(int)
==	O
'n'	O
)	O
rc	int
=	O
0	int
;	O
else	O
{	O
char	O
*	O
end	*(char)
;	O
rc	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
val	array(int)
,	O
&	O
end	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
end	*(char)
&&	O
*	O
end	*(char)
==	O
'\0'	O
)	O
)	O
rc	int
=	O
0	int
;	O
}	O
xfree	O
(	O
val	array(int)
)	O
;	O
return	O
rc	int
;	O
}	O
char	O
*	O
rpmCleanPath	(*(char))->(*(char))
(	O
char	O
*	O
path	*(char)
)	O
{	O
const	O
char	O
*	O
s	*(char)
;	O
char	O
*	O
se	*(char)
,	O
*	O
t	*(char)
,	O
*	O
te	*(char)
;	O
s	*(char)
=	O
t	*(char)
=	O
te	*(char)
=	O
path	*(char)
;	O
while	O
(	O
*	O
s	*(char)
)	O
{	O
switch	O
(	O
*	O
s	*(char)
)	O
{	O
case	O
':'	O
:	O
if	O
(	O
s	*(char)
[	O
1	int
]	O
==	O
'/'	O
&&	O
s	*(char)
[	O
2	int
]	O
==	O
'/'	O
)	O
{	O
*	O
t	*(char)
++	O
=	O
*	O
s	*(char)
++	O
;	O
*	O
t	*(char)
++	O
=	O
*	O
s	*(char)
++	O
;	O
}	O
break	O
;	O
case	O
'/'	O
:	O
for	O
(	O
se	*(char)
=	O
te	*(char)
+	O
1	int
;	O
se	*(char)
<	O
t	*(char)
&&	O
*	O
se	*(char)
!=	O
'/'	O
;	O
se	*(char)
++	O
)	O
;	O
if	O
(	O
se	*(char)
<	O
t	*(char)
&&	O
*	O
se	*(char)
==	O
'/'	O
)	O
{	O
te	*(char)
=	O
se	*(char)
;	O
}	O
while	O
(	O
s	*(char)
[	O
1	int
]	O
==	O
'/'	O
)	O
s	*(char)
++	O
;	O
while	O
(	O
t	*(char)
>	O
path	*(char)
&&	O
t	*(char)
[	O
-	O
1	int
]	O
==	O
'/'	O
)	O
t	*(char)
--	O
;	O
break	O
;	O
case	O
'.'	O
:	O
if	O
(	O
t	*(char)
==	O
path	*(char)
&&	O
s	*(char)
[	O
1	int
]	O
==	O
'.'	O
)	O
{	O
*	O
t	*(char)
++	O
=	O
*	O
s	*(char)
++	O
;	O
break	O
;	O
}	O
if	O
(	O
t	*(char)
==	O
path	*(char)
&&	O
s	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
break	O
;	O
}	O
if	O
(	O
(	O
t	*(char)
==	O
path	*(char)
||	O
t	*(char)
[	O
-	O
1	int
]	O
==	O
'/'	O
)	O
&&	O
(	O
s	*(char)
[	O
1	int
]	O
==	O
'/'	O
||	O
s	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
)	O
{	O
s	*(char)
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
t	*(char)
>	O
path	*(char)
&&	O
t	*(char)
[	O
-	O
1	int
]	O
==	O
'/'	O
&&	O
s	*(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
(	O
s	*(char)
[	O
2	int
]	O
==	O
'/'	O
||	O
s	*(char)
[	O
2	int
]	O
==	O
'\0'	O
)	O
)	O
{	O
t	*(char)
=	O
te	*(char)
;	O
if	O
(	O
te	*(char)
>	O
path	*(char)
)	O
for	O
(	O
--	O
te	*(char)
;	O
te	*(char)
>	O
path	*(char)
&&	O
*	O
te	*(char)
!=	O
'/'	O
;	O
te	*(char)
--	O
)	O
;	O
s	*(char)
++	O
;	O
s	*(char)
++	O
;	O
continue	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
*	O
t	*(char)
++	O
=	O
*	O
s	*(char)
++	O
;	O
}	O
if	O
(	O
t	*(char)
>	O
&	O
path	*(char)
[	O
1	int
]	O
&&	O
t	*(char)
[	O
-	O
1	int
]	O
==	O
'/'	O
)	O
t	*(char)
--	O
;	O
*	O
t	*(char)
=	O
'\0'	O
;	O
return	O
path	*(char)
;	O
}	O
const	O
char	O
*	O
rpmGetPath	(*(char))->(*(char))
(	O
const	O
char	O
*	O
path	*(char)
,	O
...	O
)	O
{	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
;	O
const	O
char	O
*	O
s	*(char)
;	O
char	O
*	O
t	*(char)
,	O
*	O
te	*(char)
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	*(void)
;	O
if	O
(	O
path	*(char)
==	O
NULL	O
)	O
return	O
xstrdup	(*(char))->(*(char))
(	O
""	*(char)
)	O
;	O
t	*(char)
=	O
buf	*(char)
;	O
te	*(char)
=	O
rpm_stpcpy	()->(int)
(	O
t	*(char)
,	O
path	*(char)
)	O
;	O
*	O
te	*(char)
=	O
'\0'	O
;	O
va_start	O
(	O
ap	*(void)
,	O
path	*(char)
)	O
;	O
while	O
(	O
(	O
s	*(char)
=	O
va_arg	O
(	O
ap	*(void)
,	O
const	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
te	*(char)
=	O
rpm_stpcpy	()->(int)
(	O
te	*(char)
,	O
s	*(char)
)	O
;	O
*	O
te	*(char)
=	O
'\0'	O
;	O
}	O
va_end	O
(	O
ap	*(void)
)	O
;	O
expandMacros	(*(void),*(struct(*(*(struct`)),int,int)),*(char),long)->(int)
(	O
NULL	O
,	O
NULL	O
,	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
return	O
xstrdup	(*(char))->(*(char))
(	O
rpmCleanPath	(*(char))->(*(char))
(	O
buf	*(char)
)	O
)	O
;	O
}	O
const	O
char	O
*	O
rpmGenPath	(*(char),*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
urlroot	*(char)
,	O
const	O
char	O
*	O
urlmdir	*(char)
,	O
const	O
char	O
*	O
urlfile	*(char)
)	O
{	O
const	O
char	O
*	O
xroot	*(char)
=	O
rpmGetPath	(*(char))->(*(char))
(	O
urlroot	*(char)
,	O
NULL	O
)	O
,	O
*	O
root	*(char)
=	O
xroot	*(char)
;	O
const	O
char	O
*	O
xmdir	*(char)
=	O
rpmGetPath	(*(char))->(*(char))
(	O
urlmdir	*(char)
,	O
NULL	O
)	O
,	O
*	O
mdir	*(char)
=	O
xmdir	*(char)
;	O
const	O
char	O
*	O
xfile	*(char)
=	O
rpmGetPath	(*(char))->(*(char))
(	O
urlfile	*(char)
,	O
NULL	O
)	O
,	O
*	O
file	*(char)
=	O
xfile	*(char)
;	O
const	O
char	O
*	O
result	*(int)
;	O
const	O
char	O
*	O
url	*(char)
=	O
NULL	O
;	O
int	O
nurl	int
=	O
0	int
;	O
int	O
ut	int
;	O
if	O
(	O
_debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** RGP xroot %s xmdir %s xfile %s\n"	*(char)
,	O
xroot	*(char)
,	O
xmdir	*(char)
,	O
xfile	*(char)
)	O
;	O
ut	int
=	O
urlPath	(*(char),*(*(char)))->(int)
(	O
xroot	*(char)
,	O
&	O
root	*(char)
)	O
;	O
if	O
(	O
url	*(char)
==	O
NULL	O
&&	O
ut	int
>	O
URL_IS_DASH	int
)	O
{	O
url	*(char)
=	O
xroot	*(char)
;	O
nurl	int
=	O
root	*(char)
-	O
xroot	*(char)
;	O
if	O
(	O
_debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** RGP ut %d root %s nurl %d\n"	*(char)
,	O
ut	int
,	O
root	*(char)
,	O
nurl	int
)	O
;	O
}	O
if	O
(	O
root	*(char)
==	O
NULL	O
||	O
*	O
root	*(char)
==	O
'\0'	O
)	O
root	*(char)
=	O
"/"	*(char)
;	O
ut	int
=	O
urlPath	(*(char),*(*(char)))->(int)
(	O
xmdir	*(char)
,	O
&	O
mdir	*(char)
)	O
;	O
if	O
(	O
url	*(char)
==	O
NULL	O
&&	O
ut	int
>	O
URL_IS_DASH	int
)	O
{	O
url	*(char)
=	O
xmdir	*(char)
;	O
nurl	int
=	O
mdir	*(char)
-	O
xmdir	*(char)
;	O
if	O
(	O
_debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** RGP ut %d mdir %s nurl %d\n"	*(char)
,	O
ut	int
,	O
mdir	*(char)
,	O
nurl	int
)	O
;	O
}	O
if	O
(	O
mdir	*(char)
==	O
NULL	O
||	O
*	O
mdir	*(char)
==	O
'\0'	O
)	O
mdir	*(char)
=	O
"/"	*(char)
;	O
ut	int
=	O
urlPath	(*(char),*(*(char)))->(int)
(	O
xfile	*(char)
,	O
&	O
file	*(char)
)	O
;	O
if	O
(	O
url	*(char)
==	O
NULL	O
&&	O
ut	int
>	O
URL_IS_DASH	int
)	O
{	O
url	*(char)
=	O
xfile	*(char)
;	O
nurl	int
=	O
file	*(char)
-	O
xfile	*(char)
;	O
if	O
(	O
_debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** RGP ut %d file %s nurl %d\n"	*(char)
,	O
ut	int
,	O
file	*(char)
,	O
nurl	int
)	O
;	O
}	O
if	O
(	O
url	*(char)
&&	O
nurl	int
>	O
0	int
)	O
{	O
char	O
*	O
t	*(char)
=	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
alloca	(long)->(*(void))
(	O
nurl	int
+	O
1	int
)	O
,	O
url	*(char)
,	O
nurl	int
)	O
;	O
t	*(char)
[	O
nurl	int
]	O
=	O
'\0'	O
;	O
url	*(char)
=	O
t	*(char)
;	O
}	O
else	O
url	*(char)
=	O
""	*(char)
;	O
result	*(int)
=	O
rpmGetPath	(*(char))->(*(char))
(	O
url	*(char)
,	O
root	*(char)
,	O
"/"	*(char)
,	O
mdir	*(char)
,	O
"/"	*(char)
,	O
file	*(char)
,	O
NULL	O
)	O
;	O
xfree	O
(	O
xroot	*(char)
)	O
;	O
xfree	O
(	O
xmdir	*(char)
)	O
;	O
xfree	O
(	O
xfile	*(char)
)	O
;	O
if	O
(	O
_debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** RGP result %s\n"	*(char)
,	O
result	*(int)
)	O
;	O
return	O
result	*(int)
;	O
}	O
