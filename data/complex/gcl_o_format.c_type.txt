static	O
int	O
fmt_thousand	(int,int,int,int,int)->(int)
(	O
int	O
,	O
int	O
,	O
bool	int
,	O
bool	int
,	O
int	O
)	O
;	O
static	O
void	O
fmt_exponent1	(int)->(void)
(	O
int	O
)	O
;	O
static	O
void	O
fmt_write_numeral	(int,int)->(void)
(	O
int	O
,	O
int	O
)	O
;	O
static	O
void	O
fmt_write_ordinal	(int,int)->(void)
(	O
int	O
,	O
int	O
)	O
;	O
static	O
int	O
fmt_nonillion	(int,int,int,int,int)->(int)
(	O
int	O
,	O
int	O
,	O
bool	int
,	O
bool	int
,	O
int	O
)	O
;	O
static	O
void	O
fmt_roman	(int,int,int,int,int)->(void)
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
;	O
static	O
void	O
fmt_integer	()->(void)
(	O
object	O
,	O
bool	int
,	O
bool	int
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
;	O
static	O
void	O
fmt_semicolon	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_up_and_out	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_justification	(int,int)->(void)
(	O
volatile	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_iteration	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_conditional	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_case	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_indirection	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_asterisk	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_tabulate	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_newline	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_tilde	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_bar	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_ampersand	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_percent	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_dollars_float	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_general_float	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_exponential_float	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_fix_float	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_character	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_plural	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_radix	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_hexadecimal	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_octal	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_binary	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_error	(*(char))->(void)
(	O
char	O
*	O
)	O
;	O
static	O
void	O
fmt_ascii	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_S_expression	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
static	O
void	O
fmt_decimal	()->(void)
(	O
bool	int
,	O
bool	int
)	O
;	O
object	O
sSAindent_formatted_outputA	int
;	O
typedef	O
struct	O
{	O
int	O
fmt_param_type	int
;	O
int	O
fmt_param_value	int
;	O
}	O
format_parameter	struct(int,int)
;	O
format_parameter	struct(int,int)
fmt_param	array(struct(int,int))
[	O
100	int
]	O
;	O
VOL	O
format_parameter	struct(int,int)
*	O
fmt_paramp	O
;	O
object	O
fmt_temporary_stream	int
;	O
object	O
fmt_temporary_string	int
;	O
int	O
fmt_nparam	int
;	O
enum	O
fmt_types	enum(int,int,int)
{	O
fmt_null	int
,	O
fmt_int	int
,	O
fmt_char	int
}	O
;	O
char	O
*	O
fmt_big_numeral	array(*(char))
[	O
]	O
=	O
{	O
"thousand"	*(char)
,	O
"million"	*(char)
,	O
"billion"	*(char)
,	O
"trillion"	*(char)
,	O
"quadrillion"	*(char)
,	O
"quintillion"	*(char)
,	O
"sextillion"	*(char)
,	O
"septillion"	*(char)
,	O
"octillion"	*(char)
}	O
;	O
char	O
*	O
fmt_numeral	array(*(char))
[	O
]	O
=	O
{	O
"zero"	*(char)
,	O
"one"	*(char)
,	O
"two"	*(char)
,	O
"three"	*(char)
,	O
"four"	*(char)
,	O
"five"	*(char)
,	O
"six"	*(char)
,	O
"seven"	*(char)
,	O
"eight"	*(char)
,	O
"nine"	*(char)
,	O
"ten"	*(char)
,	O
"eleven"	*(char)
,	O
"twelve"	*(char)
,	O
"thirteen"	*(char)
,	O
"fourteen"	*(char)
,	O
"fifteen"	*(char)
,	O
"sixteen"	*(char)
,	O
"seventeen"	*(char)
,	O
"eighteen"	*(char)
,	O
"nineteen"	*(char)
,	O
"zero"	*(char)
,	O
"ten"	*(char)
,	O
"twenty"	*(char)
,	O
"thirty"	*(char)
,	O
"forty"	*(char)
,	O
"fifty"	*(char)
,	O
"sixty"	*(char)
,	O
"seventy"	*(char)
,	O
"eighty"	*(char)
,	O
"ninety"	*(char)
}	O
;	O
char	O
*	O
fmt_ordinal	array(*(char))
[	O
]	O
=	O
{	O
"zeroth"	*(char)
,	O
"first"	*(char)
,	O
"second"	*(char)
,	O
"third"	*(char)
,	O
"fourth"	*(char)
,	O
"fifth"	*(char)
,	O
"sixth"	*(char)
,	O
"seventh"	*(char)
,	O
"eighth"	*(char)
,	O
"ninth"	*(char)
,	O
"tenth"	*(char)
,	O
"eleventh"	*(char)
,	O
"twelfth"	*(char)
,	O
"thirteenth"	*(char)
,	O
"fourteenth"	*(char)
,	O
"fifteenth"	*(char)
,	O
"sixteenth"	*(char)
,	O
"seventeenth"	*(char)
,	O
"eighteenth"	*(char)
,	O
"nineteenth"	*(char)
,	O
"zeroth"	*(char)
,	O
"tenth"	*(char)
,	O
"twentieth"	*(char)
,	O
"thirtieth"	*(char)
,	O
"fortieth"	*(char)
,	O
"fiftieth"	*(char)
,	O
"sixtieth"	*(char)
,	O
"seventieth"	*(char)
,	O
"eightieth"	*(char)
,	O
"ninetieth"	*(char)
}	O
;	O
int	O
fmt_spare_spaces	int
;	O
int	O
fmt_line_length	int
;	O
static	O
int	O
fmt_tempstr	(int)->(int)
(	O
int	O
s	int
)	O
{	O
return	O
(	O
fmt_temporary_string	int
->	O
st	O
.	O
st_self	O
[	O
s	int
]	O
)	O
;	O
}	O
static	O
int	O
ctl_advance	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
ctl_index	O
>=	O
ctl_end	O
)	O
fmt_error	(*(char))->(void)
(	O
"unexpected end of control string"	*(char)
)	O
;	O
return	O
(	O
ctl_string	O
[	O
ctl_index	O
++	O
]	O
)	O
;	O
}	O
static	O
object	O
fmt_advance	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
fmt_index	O
>=	O
fmt_end	O
)	O
fmt_error	(*(char))->(void)
(	O
"arguments exhausted"	*(char)
)	O
;	O
return	O
(	O
fmt_base	O
[	O
fmt_index	O
++	O
]	O
)	O
;	O
}	O
static	O
void	O
format	(int,int,int)->(void)
(	O
object	O
fmt_stream0	int
,	O
int	O
ctl_origin0	int
,	O
int	O
ctl_end0	int
)	O
{	O
int	O
c	int
,	O
i	int
,	O
n	int
;	O
bool	int
colon	int
,	O
atsign	int
;	O
object	O
x	int
;	O
fmt_paramp	O
=	O
fmt_param	array(struct(int,int))
;	O
{	O
BEGIN_NO_INTERRUPT	O
;	O
fmt_stream	O
=	O
fmt_stream0	int
;	O
ctl_origin	O
=	O
ctl_origin0	int
;	O
ctl_index	O
=	O
0	int
;	O
ctl_end	O
=	O
ctl_end0	int
;	O
LOOP	O
:	O
if	O
(	O
ctl_index	O
>=	O
ctl_end	O
)	O
{	O
END_NO_INTERRUPT	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
)	O
!=	O
'~'	O
)	O
{	O
writec_stream	()->(int)
(	O
c	int
,	O
fmt_stream	O
)	O
;	O
goto	O
LOOP	O
;	O
}	O
n	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
)	O
{	O
case	O
','	O
:	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_type	int
=	O
fmt_null	int
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
DIGIT	O
:	O
i	int
=	O
0	int
;	O
do	O
{	O
i	int
=	O
i	int
*	O
10	int
+	O
(	O
c	int
-	O
'0'	O
)	O
;	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
;	O
}	O
while	O
(	O
isDigit	()->(int)
(	O
c	int
)	O
)	O
;	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_type	int
=	O
fmt_int	int
;	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_value	int
=	O
i	int
;	O
break	O
;	O
case	O
'+'	O
:	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
;	O
if	O
(	O
!	O
isDigit	()->(int)
(	O
c	int
)	O
)	O
fmt_error	(*(char))->(void)
(	O
"digit expected"	*(char)
)	O
;	O
goto	O
DIGIT	O
;	O
case	O
'-'	O
:	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
;	O
if	O
(	O
!	O
isDigit	()->(int)
(	O
c	int
)	O
)	O
fmt_error	(*(char))->(void)
(	O
"digit expected"	*(char)
)	O
;	O
i	int
=	O
0	int
;	O
do	O
{	O
i	int
=	O
i	int
*	O
10	int
+	O
(	O
c	int
-	O
'0'	O
)	O
;	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
;	O
}	O
while	O
(	O
isDigit	()->(int)
(	O
c	int
)	O
)	O
;	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_type	int
=	O
fmt_int	int
;	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_value	int
=	O
-	O
i	int
;	O
break	O
;	O
case	O
'\''	O
:	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_type	int
=	O
fmt_char	int
;	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_value	int
=	O
ctl_advance	()->(int)
(	O
)	O
;	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
case	O
'V'	O
:	O
x	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_fixnum	O
)	O
{	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_type	int
=	O
fmt_int	int
;	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_value	int
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
}	O
else	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_character	O
)	O
{	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_type	int
=	O
fmt_char	int
;	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_value	int
=	O
x	int
->	O
ch	O
.	O
ch_code	O
;	O
}	O
else	O
if	O
(	O
x	int
==	O
Cnil	O
)	O
{	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_type	int
=	O
fmt_null	int
;	O
}	O
else	O
fmt_error	(*(char))->(void)
(	O
"illegal V parameter"	*(char)
)	O
;	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
;	O
break	O
;	O
case	O
'#'	O
:	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_type	int
=	O
fmt_int	int
;	O
fmt_param	array(struct(int,int))
[	O
n	int
]	O
.	O
fmt_param_value	int
=	O
fmt_end	O
-	O
fmt_index	O
;	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
;	O
break	O
;	O
default	O
:	O
goto	O
DIRECTIVE	O
;	O
}	O
n	int
++	O
;	O
if	O
(	O
c	int
!=	O
','	O
)	O
break	O
;	O
}	O
DIRECTIVE	O
:	O
colon	int
=	O
atsign	int
=	O
FALSE	O
;	O
if	O
(	O
c	int
==	O
':'	O
)	O
{	O
colon	int
=	O
TRUE	O
;	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
;	O
}	O
if	O
(	O
c	int
==	O
'@'	O
)	O
{	O
atsign	int
=	O
TRUE	O
;	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
;	O
}	O
fmt_nparam	int
=	O
n	int
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'a'	O
:	O
case	O
'A'	O
:	O
fmt_ascii	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
case	O
'S'	O
:	O
fmt_S_expression	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'D'	O
:	O
fmt_decimal	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
case	O
'B'	O
:	O
fmt_binary	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
case	O
'O'	O
:	O
fmt_octal	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
fmt_hexadecimal	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
case	O
'R'	O
:	O
fmt_radix	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
case	O
'P'	O
:	O
fmt_plural	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
case	O
'C'	O
:	O
fmt_character	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'F'	O
:	O
fmt_fix_float	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
fmt_exponential_float	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
case	O
'G'	O
:	O
fmt_general_float	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'$'	O
:	O
fmt_dollars_float	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'%'	O
:	O
fmt_percent	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'&'	O
:	O
fmt_ampersand	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'|'	O
:	O
fmt_bar	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'~'	O
:	O
fmt_tilde	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
fmt_newline	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
case	O
'T'	O
:	O
fmt_tabulate	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
fmt_asterisk	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
fmt_indirection	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'('	O
:	O
fmt_case	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'['	O
:	O
fmt_conditional	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'{'	O
:	O
fmt_iteration	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'<'	O
:	O
fmt_justification	(int,int)->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
'^'	O
:	O
fmt_up_and_out	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
case	O
';'	O
:	O
fmt_semicolon	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
break	O
;	O
default	O
:	O
{	O
object	O
user_fmt	O
=	O
getf	O
(	O
sSAindent_formatted_outputA	int
->	O
s	int
.	O
s_plist	O
,	O
make_fixnum	()->(int)
(	O
c	int
)	O
,	O
Cnil	O
)	O
;	O
if	O
(	O
user_fmt	O
!=	O
Cnil	O
)	O
{	O
object	O
*	O
oldbase	O
=	O
vs_base	O
;	O
object	O
*	O
oldtop	O
=	O
vs_top	O
;	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
fmt_advance	()->(int)
(	O
)	O
)	O
;	O
vs_push	()->(int)
(	O
fmt_stream	O
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
colon	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
atsign	int
)	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
user_fmt	O
)	O
==	O
t_symbol	O
)	O
user_fmt	O
=	O
symbol_function	()->(int)
(	O
user_fmt	O
)	O
;	O
funcall	()->(int)
(	O
user_fmt	O
)	O
;	O
vs_base	O
=	O
oldbase	O
;	O
vs_top	O
=	O
oldtop	O
;	O
break	O
;	O
}	O
}	O
fmt_error	(*(char))->(void)
(	O
"illegal directive"	*(char)
)	O
;	O
}	O
goto	O
LOOP	O
;	O
}	O
}	O
static	O
int	O
fmt_skip	()->(int)
(	O
void	O
)	O
{	O
int	O
c	int
,	O
level	int
=	O
0	int
;	O
LOOP	O
:	O
if	O
(	O
ctl_advance	()->(int)
(	O
)	O
!=	O
'~'	O
)	O
goto	O
LOOP	O
;	O
for	O
(	O
;	O
;	O
)	O
switch	O
(	O
c	int
=	O
ctl_advance	()->(int)
(	O
)	O
)	O
{	O
case	O
'\''	O
:	O
ctl_advance	()->(int)
(	O
)	O
;	O
case	O
','	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
case	O
'+'	O
:	O
case	O
'-'	O
:	O
case	O
'v'	O
:	O
case	O
'V'	O
:	O
case	O
'#'	O
:	O
case	O
':'	O
:	O
case	O
'@'	O
:	O
continue	O
;	O
default	O
:	O
goto	O
DIRECTIVE	O
;	O
}	O
DIRECTIVE	O
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'('	O
:	O
case	O
'['	O
:	O
case	O
'<'	O
:	O
case	O
'{'	O
:	O
level	int
++	O
;	O
break	O
;	O
case	O
')'	O
:	O
case	O
']'	O
:	O
case	O
'>'	O
:	O
case	O
'}'	O
:	O
if	O
(	O
level	int
==	O
0	int
)	O
return	O
(	O
ctl_index	O
)	O
;	O
else	O
--	O
level	int
;	O
break	O
;	O
case	O
';'	O
:	O
if	O
(	O
level	int
==	O
0	int
)	O
return	O
(	O
ctl_index	O
)	O
;	O
break	O
;	O
}	O
goto	O
LOOP	O
;	O
}	O
static	O
void	O
fmt_max_param	(int)->(void)
(	O
int	O
n	int
)	O
{	O
if	O
(	O
fmt_nparam	int
>	O
n	int
)	O
fmt_error	(*(char))->(void)
(	O
"too many parameters"	*(char)
)	O
;	O
}	O
static	O
void	O
fmt_not_colon	(int)->(void)
(	O
bool	int
colon	int
)	O
{	O
if	O
(	O
colon	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal :"	*(char)
)	O
;	O
}	O
static	O
void	O
fmt_not_atsign	(int)->(void)
(	O
bool	int
atsign	int
)	O
{	O
if	O
(	O
atsign	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal @"	*(char)
)	O
;	O
}	O
static	O
void	O
fmt_not_colon_atsign	(int,int)->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
if	O
(	O
colon	int
&&	O
atsign	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal :@"	*(char)
)	O
;	O
}	O
static	O
void	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
int	O
i	int
,	O
int	O
*	O
p	*(int)
,	O
int	O
t	int
,	O
int	O
v	int
)	O
{	O
if	O
(	O
i	int
>=	O
fmt_nparam	int
||	O
FMT_PARAM	O
[	O
i	int
]	O
.	O
fmt_param_type	int
==	O
fmt_null	int
)	O
*	O
p	*(int)
=	O
v	int
;	O
else	O
if	O
(	O
FMT_PARAM	O
[	O
i	int
]	O
.	O
fmt_param_type	int
!=	O
t	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal parameter type"	*(char)
)	O
;	O
else	O
*	O
p	*(int)
=	O
FMT_PARAM	O
[	O
i	int
]	O
.	O
fmt_param_value	int
;	O
}	O
static	O
void	O
fmt_ascii	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
mincol	int
=	O
0	int
,	O
colinc	int
=	O
0	int
,	O
minpad	int
=	O
0	int
,	O
padchar	int
=	O
0	int
;	O
object	O
x	int
;	O
int	O
l	int
,	O
i	int
;	O
fmt_max_param	(int)->(void)
(	O
4	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
mincol	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
colinc	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
minpad	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
3	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
=	O
0	int
;	O
STREAM_FILE_COLUMN	()->(int)
(	O
fmt_temporary_stream	int
)	O
=	O
file_column	()->(int)
(	O
fmt_stream	O
)	O
;	O
x	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
if	O
(	O
colon	int
&&	O
x	int
==	O
Cnil	O
)	O
writestr_stream	()->(int)
(	O
"()"	*(char)
,	O
fmt_temporary_stream	int
)	O
;	O
else	O
if	O
(	O
mincol	int
==	O
0	int
&&	O
minpad	int
==	O
0	int
)	O
{	O
princ	()->(int)
(	O
x	int
,	O
fmt_stream	O
)	O
;	O
return	O
;	O
}	O
else	O
princ	()->(int)
(	O
x	int
,	O
fmt_temporary_stream	int
)	O
;	O
l	int
=	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
;	O
for	O
(	O
i	int
=	O
minpad	int
;	O
l	int
+	O
i	int
<	O
mincol	int
;	O
i	int
+=	O
colinc	int
)	O
;	O
if	O
(	O
!	O
atsign	int
)	O
{	O
write_string	()->(int)
(	O
fmt_temporary_string	int
,	O
fmt_stream	O
)	O
;	O
while	O
(	O
i	int
--	O
>	O
0	int
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
{	O
while	O
(	O
i	int
--	O
>	O
0	int
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
write_string	()->(int)
(	O
fmt_temporary_string	int
,	O
fmt_stream	O
)	O
;	O
}	O
}	O
static	O
void	O
fmt_S_expression	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
mincol	int
=	O
0	int
,	O
colinc	int
=	O
0	int
,	O
minpad	int
=	O
0	int
,	O
padchar	int
=	O
0	int
;	O
object	O
x	int
;	O
int	O
l	int
,	O
i	int
;	O
fmt_max_param	(int)->(void)
(	O
4	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
mincol	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
colinc	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
minpad	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
3	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
=	O
0	int
;	O
STREAM_FILE_COLUMN	()->(int)
(	O
fmt_temporary_stream	int
)	O
=	O
file_column	()->(int)
(	O
fmt_stream	O
)	O
;	O
x	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
if	O
(	O
colon	int
&&	O
x	int
==	O
Cnil	O
)	O
writestr_stream	()->(int)
(	O
"()"	*(char)
,	O
fmt_temporary_stream	int
)	O
;	O
else	O
if	O
(	O
mincol	int
==	O
0	int
&&	O
minpad	int
==	O
0	int
)	O
{	O
prin1	()->(int)
(	O
x	int
,	O
fmt_stream	O
)	O
;	O
return	O
;	O
}	O
else	O
prin1	()->(int)
(	O
x	int
,	O
fmt_temporary_stream	int
)	O
;	O
l	int
=	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
;	O
for	O
(	O
i	int
=	O
minpad	int
;	O
l	int
+	O
i	int
<	O
mincol	int
;	O
i	int
+=	O
colinc	int
)	O
;	O
if	O
(	O
!	O
atsign	int
)	O
{	O
write_string	()->(int)
(	O
fmt_temporary_string	int
,	O
fmt_stream	O
)	O
;	O
while	O
(	O
i	int
--	O
>	O
0	int
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
{	O
while	O
(	O
i	int
--	O
>	O
0	int
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
write_string	()->(int)
(	O
fmt_temporary_string	int
,	O
fmt_stream	O
)	O
;	O
}	O
}	O
static	O
void	O
fmt_decimal	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
mincol	int
=	O
0	int
,	O
padchar	int
=	O
0	int
,	O
commachar	int
=	O
0	int
;	O
fmt_max_param	(int)->(void)
(	O
3	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
mincol	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
commachar	int
,	O
fmt_char	int
,	O
','	O
)	O
;	O
fmt_integer	()->(void)
(	O
fmt_advance	()->(int)
(	O
)	O
,	O
colon	int
,	O
atsign	int
,	O
10	int
,	O
mincol	int
,	O
padchar	int
,	O
commachar	int
)	O
;	O
}	O
static	O
void	O
fmt_binary	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
mincol	int
=	O
0	int
,	O
padchar	int
=	O
0	int
,	O
commachar	int
=	O
0	int
;	O
fmt_max_param	(int)->(void)
(	O
3	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
mincol	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
commachar	int
,	O
fmt_char	int
,	O
','	O
)	O
;	O
fmt_integer	()->(void)
(	O
fmt_advance	()->(int)
(	O
)	O
,	O
colon	int
,	O
atsign	int
,	O
2	int
,	O
mincol	int
,	O
padchar	int
,	O
commachar	int
)	O
;	O
}	O
static	O
void	O
fmt_octal	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
mincol	int
=	O
0	int
,	O
padchar	int
=	O
0	int
,	O
commachar	int
=	O
0	int
;	O
fmt_max_param	(int)->(void)
(	O
3	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
mincol	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
commachar	int
,	O
fmt_char	int
,	O
','	O
)	O
;	O
fmt_integer	()->(void)
(	O
fmt_advance	()->(int)
(	O
)	O
,	O
colon	int
,	O
atsign	int
,	O
8	int
,	O
mincol	int
,	O
padchar	int
,	O
commachar	int
)	O
;	O
}	O
static	O
void	O
fmt_hexadecimal	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
mincol	int
=	O
0	int
,	O
padchar	int
=	O
0	int
,	O
commachar	int
=	O
0	int
;	O
fmt_max_param	(int)->(void)
(	O
3	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
mincol	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
commachar	int
,	O
fmt_char	int
,	O
','	O
)	O
;	O
fmt_integer	()->(void)
(	O
fmt_advance	()->(int)
(	O
)	O
,	O
colon	int
,	O
atsign	int
,	O
16	int
,	O
mincol	int
,	O
padchar	int
,	O
commachar	int
)	O
;	O
}	O
static	O
void	O
fmt_radix	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
radix	int
=	O
0	int
,	O
mincol	int
=	O
0	int
,	O
padchar	int
=	O
0	int
,	O
commachar	int
=	O
0	int
;	O
object	O
x	int
;	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
int	O
s	int
,	O
t	int
;	O
bool	int
b	int
;	O
extern	O
void	O
(	O
*	O
write_ch_fun	*((int)->(void))
)	O
(	O
int	O
)	O
,	O
writec_PRINTstream	(int)->(void)
(	O
int	O
)	O
;	O
if	O
(	O
fmt_nparam	int
==	O
0	int
)	O
{	O
x	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
check_type_integer	()->(int)
(	O
&	O
x	int
)	O
;	O
if	O
(	O
atsign	int
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_fixnum	O
)	O
i	int
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
else	O
i	int
=	O
-	O
1	int
;	O
if	O
(	O
(	O
!	O
colon	int
&&	O
(	O
i	int
<=	O
0	int
||	O
i	int
>=	O
4000	int
)	O
)	O
||	O
(	O
colon	int
&&	O
(	O
i	int
<=	O
0	int
||	O
i	int
>=	O
5000	int
)	O
)	O
)	O
{	O
fmt_integer	()->(void)
(	O
x	int
,	O
FALSE	O
,	O
FALSE	O
,	O
10	int
,	O
0	int
,	O
' '	O
,	O
','	O
)	O
;	O
return	O
;	O
}	O
fmt_roman	(int,int,int,int,int)->(void)
(	O
i	int
/	O
1000	int
,	O
'M'	O
,	O
'*'	O
,	O
'*'	O
,	O
colon	int
)	O
;	O
fmt_roman	(int,int,int,int,int)->(void)
(	O
i	int
%	O
1000	int
/	O
100	int
,	O
'C'	O
,	O
'D'	O
,	O
'M'	O
,	O
colon	int
)	O
;	O
fmt_roman	(int,int,int,int,int)->(void)
(	O
i	int
%	O
100	int
/	O
10	int
,	O
'X'	O
,	O
'L'	O
,	O
'C'	O
,	O
colon	int
)	O
;	O
fmt_roman	(int,int,int,int,int)->(void)
(	O
i	int
%	O
10	int
,	O
'I'	O
,	O
'V'	O
,	O
'X'	O
,	O
colon	int
)	O
;	O
return	O
;	O
}	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
=	O
0	int
;	O
STREAM_FILE_COLUMN	()->(int)
(	O
fmt_temporary_stream	int
)	O
=	O
file_column	()->(int)
(	O
fmt_stream	O
)	O
;	O
PRINTstream	O
=	O
fmt_temporary_stream	int
;	O
PRINTradix	O
=	O
FALSE	O
;	O
PRINTbase	O
=	O
10	int
;	O
write_ch_fun	*((int)->(void))
=	O
writec_PRINTstream	(int)->(void)
;	O
write_object	()->(int)
(	O
x	int
,	O
0	int
)	O
;	O
s	int
=	O
0	int
;	O
i	int
=	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
;	O
if	O
(	O
i	int
==	O
1	int
&&	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
==	O
'0'	O
)	O
{	O
writestr_stream	()->(int)
(	O
"zero"	*(char)
,	O
fmt_stream	O
)	O
;	O
if	O
(	O
colon	int
)	O
writestr_stream	()->(int)
(	O
"th"	*(char)
,	O
fmt_stream	O
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
==	O
'-'	O
)	O
{	O
writestr_stream	()->(int)
(	O
"minus "	*(char)
,	O
fmt_stream	O
)	O
;	O
--	O
i	int
;	O
s	int
++	O
;	O
}	O
t	int
=	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
;	O
for	O
(	O
;	O
;	O
)	O
if	O
(	O
fmt_tempstr	(int)->(int)
(	O
--	O
t	int
)	O
!=	O
'0'	O
)	O
break	O
;	O
for	O
(	O
b	int
=	O
FALSE	O
;	O
i	int
>	O
0	int
;	O
i	int
-=	O
j	int
)	O
{	O
b	int
=	O
fmt_nonillion	(int,int,int,int,int)->(int)
(	O
s	int
,	O
j	int
=	O
(	O
i	int
+	O
29	int
)	O
%	O
30	int
+	O
1	int
,	O
b	int
,	O
i	int
<=	O
30	int
&&	O
colon	int
,	O
t	int
)	O
;	O
s	int
+=	O
j	int
;	O
if	O
(	O
b	int
&&	O
i	int
>	O
30	int
)	O
{	O
for	O
(	O
k	int
=	O
(	O
i	int
-	O
1	int
)	O
/	O
30	int
;	O
k	int
>	O
0	int
;	O
--	O
k	int
)	O
writestr_stream	()->(int)
(	O
" nonillion"	*(char)
,	O
fmt_stream	O
)	O
;	O
if	O
(	O
colon	int
&&	O
s	int
>	O
t	int
)	O
writestr_stream	()->(int)
(	O
"th"	*(char)
,	O
fmt_stream	O
)	O
;	O
}	O
}	O
return	O
;	O
}	O
fmt_max_param	(int)->(void)
(	O
4	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
radix	int
,	O
fmt_int	int
,	O
10	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
mincol	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
3	int
,	O
&	O
commachar	int
,	O
fmt_char	int
,	O
','	O
)	O
;	O
x	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
check_type_integer	()->(int)
(	O
&	O
x	int
)	O
;	O
if	O
(	O
radix	int
<	O
0	int
||	O
radix	int
>	O
36	int
)	O
{	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
radix	int
)	O
)	O
;	O
FEerror	()->(int)
(	O
"~D is illegal as a radix."	*(char)
,	O
1	int
,	O
vs_head	O
)	O
;	O
}	O
fmt_integer	()->(void)
(	O
x	int
,	O
colon	int
,	O
atsign	int
,	O
radix	int
,	O
mincol	int
,	O
padchar	int
,	O
commachar	int
)	O
;	O
}	O
static	O
void	O
fmt_integer	()->(void)
(	O
object	O
x	int
,	O
bool	int
colon	int
,	O
bool	int
atsign	int
,	O
int	O
radix	int
,	O
int	O
mincol	int
,	O
int	O
padchar	int
,	O
int	O
commachar	int
)	O
{	O
int	O
l	int
,	O
l1	int
;	O
int	O
s	int
;	O
extern	O
void	O
(	O
*	O
write_ch_fun	*((int)->(void))
)	O
(	O
int	O
)	O
,	O
writec_PRINTstream	(int)->(void)
(	O
int	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_fixnum	O
&&	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_bignum	O
)	O
{	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
=	O
0	int
;	O
STREAM_FILE_COLUMN	()->(int)
(	O
fmt_temporary_stream	int
)	O
=	O
file_column	()->(int)
(	O
fmt_stream	O
)	O
;	O
{	O
SETUP_PRINT_DEFAULT	()->(int)
(	O
x	int
)	O
;	O
PRINTstream	O
=	O
fmt_temporary_stream	int
;	O
PRINTescape	O
=	O
FALSE	O
;	O
PRINTbase	O
=	O
radix	int
;	O
write_ch_fun	*((int)->(void))
=	O
writec_PRINTstream	(int)->(void)
;	O
write_object	()->(int)
(	O
x	int
,	O
0	int
)	O
;	O
CLEANUP_PRINT_DEFAULT	O
;	O
}	O
l	int
=	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
;	O
mincol	int
-=	O
l	int
;	O
while	O
(	O
mincol	int
--	O
>	O
0	int
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
l	int
>	O
0	int
;	O
--	O
l	int
,	O
s	int
++	O
)	O
writec_stream	()->(int)
(	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
,	O
fmt_stream	O
)	O
;	O
return	O
;	O
}	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
=	O
0	int
;	O
STREAM_FILE_COLUMN	()->(int)
(	O
fmt_temporary_stream	int
)	O
=	O
file_column	()->(int)
(	O
fmt_stream	O
)	O
;	O
PRINTstream	O
=	O
fmt_temporary_stream	int
;	O
PRINTradix	O
=	O
FALSE	O
;	O
PRINTbase	O
=	O
radix	int
;	O
write_ch_fun	*((int)->(void))
=	O
writec_PRINTstream	(int)->(void)
;	O
write_object	()->(int)
(	O
x	int
,	O
0	int
)	O
;	O
l	int
=	O
l1	int
=	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
;	O
s	int
=	O
0	int
;	O
if	O
(	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
==	O
'-'	O
)	O
--	O
l1	int
;	O
mincol	int
-=	O
l	int
;	O
if	O
(	O
colon	int
)	O
mincol	int
-=	O
(	O
l1	int
-	O
1	int
)	O
/	O
3	int
;	O
if	O
(	O
atsign	int
&&	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
!=	O
'-'	O
)	O
--	O
mincol	int
;	O
while	O
(	O
mincol	int
--	O
>	O
0	int
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
if	O
(	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
==	O
'-'	O
)	O
{	O
s	int
++	O
;	O
writec_stream	()->(int)
(	O
'-'	O
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
if	O
(	O
atsign	int
)	O
writec_stream	()->(int)
(	O
'+'	O
,	O
fmt_stream	O
)	O
;	O
while	O
(	O
l1	int
--	O
>	O
0	int
)	O
{	O
writec_stream	()->(int)
(	O
fmt_tempstr	(int)->(int)
(	O
s	int
++	O
)	O
,	O
fmt_stream	O
)	O
;	O
if	O
(	O
colon	int
&&	O
l1	int
>	O
0	int
&&	O
l1	int
%	O
3	int
==	O
0	int
)	O
writec_stream	()->(int)
(	O
commachar	int
,	O
fmt_stream	O
)	O
;	O
}	O
}	O
static	O
int	O
fmt_nonillion	(int,int,int,int,int)->(int)
(	O
int	O
s	int
,	O
int	O
i	int
,	O
bool	int
b	int
,	O
bool	int
o	int
,	O
int	O
t	int
)	O
{	O
int	O
j	int
;	O
for	O
(	O
;	O
i	int
>	O
3	int
;	O
i	int
-=	O
j	int
)	O
{	O
b	int
=	O
fmt_thousand	(int,int,int,int,int)->(int)
(	O
s	int
,	O
j	int
=	O
(	O
i	int
+	O
2	int
)	O
%	O
3	int
+	O
1	int
,	O
b	int
,	O
FALSE	O
,	O
t	int
)	O
;	O
if	O
(	O
j	int
!=	O
3	int
||	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
!=	O
'0'	O
||	O
fmt_tempstr	(int)->(int)
(	O
s	int
+	O
1	int
)	O
!=	O
'0'	O
||	O
fmt_tempstr	(int)->(int)
(	O
s	int
+	O
2	int
)	O
!=	O
'0'	O
)	O
{	O
writec_stream	()->(int)
(	O
' '	O
,	O
fmt_stream	O
)	O
;	O
writestr_stream	()->(int)
(	O
fmt_big_numeral	array(*(char))
[	O
(	O
i	int
-	O
1	int
)	O
/	O
3	int
-	O
1	int
]	O
,	O
fmt_stream	O
)	O
;	O
s	int
+=	O
j	int
;	O
if	O
(	O
o	int
&&	O
s	int
>	O
t	int
)	O
writestr_stream	()->(int)
(	O
"th"	*(char)
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
s	int
+=	O
j	int
;	O
}	O
return	O
(	O
fmt_thousand	(int,int,int,int,int)->(int)
(	O
s	int
,	O
i	int
,	O
b	int
,	O
o	int
,	O
t	int
)	O
)	O
;	O
}	O
static	O
int	O
fmt_thousand	(int,int,int,int,int)->(int)
(	O
int	O
s	int
,	O
int	O
i	int
,	O
bool	int
b	int
,	O
bool	int
o	int
,	O
int	O
t	int
)	O
{	O
if	O
(	O
i	int
==	O
3	int
&&	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
>	O
'0'	O
)	O
{	O
if	O
(	O
b	int
)	O
writec_stream	()->(int)
(	O
' '	O
,	O
fmt_stream	O
)	O
;	O
fmt_write_numeral	(int,int)->(void)
(	O
s	int
,	O
0	int
)	O
;	O
writestr_stream	()->(int)
(	O
" hundred"	*(char)
,	O
fmt_stream	O
)	O
;	O
--	O
i	int
;	O
s	int
++	O
;	O
b	int
=	O
TRUE	O
;	O
if	O
(	O
o	int
&&	O
s	int
>	O
t	int
)	O
writestr_stream	()->(int)
(	O
"th"	*(char)
,	O
fmt_stream	O
)	O
;	O
}	O
if	O
(	O
i	int
==	O
3	int
)	O
{	O
--	O
i	int
;	O
s	int
++	O
;	O
}	O
if	O
(	O
i	int
==	O
2	int
&&	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
>	O
'0'	O
)	O
{	O
if	O
(	O
b	int
)	O
writec_stream	()->(int)
(	O
' '	O
,	O
fmt_stream	O
)	O
;	O
if	O
(	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
==	O
'1'	O
)	O
{	O
if	O
(	O
o	int
&&	O
s	int
+	O
2	int
>	O
t	int
)	O
fmt_write_ordinal	(int,int)->(void)
(	O
++	O
s	int
,	O
10	int
)	O
;	O
else	O
fmt_write_numeral	(int,int)->(void)
(	O
++	O
s	int
,	O
10	int
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
o	int
&&	O
s	int
+	O
1	int
>	O
t	int
)	O
fmt_write_ordinal	(int,int)->(void)
(	O
s	int
,	O
20	int
)	O
;	O
else	O
fmt_write_numeral	(int,int)->(void)
(	O
s	int
,	O
20	int
)	O
;	O
s	int
++	O
;	O
if	O
(	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
>	O
'0'	O
)	O
{	O
writec_stream	()->(int)
(	O
'-'	O
,	O
fmt_stream	O
)	O
;	O
if	O
(	O
o	int
&&	O
s	int
+	O
1	int
>	O
t	int
)	O
fmt_write_ordinal	(int,int)->(void)
(	O
s	int
,	O
0	int
)	O
;	O
else	O
fmt_write_numeral	(int,int)->(void)
(	O
s	int
,	O
0	int
)	O
;	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
}	O
if	O
(	O
i	int
==	O
2	int
)	O
s	int
++	O
;	O
if	O
(	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
>	O
'0'	O
)	O
{	O
if	O
(	O
b	int
)	O
writec_stream	()->(int)
(	O
' '	O
,	O
fmt_stream	O
)	O
;	O
if	O
(	O
o	int
&&	O
s	int
+	O
1	int
>	O
t	int
)	O
fmt_write_ordinal	(int,int)->(void)
(	O
s	int
,	O
0	int
)	O
;	O
else	O
fmt_write_numeral	(int,int)->(void)
(	O
s	int
,	O
0	int
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
return	O
(	O
b	int
)	O
;	O
}	O
static	O
void	O
fmt_write_numeral	(int,int)->(void)
(	O
int	O
s	int
,	O
int	O
i	int
)	O
{	O
writestr_stream	()->(int)
(	O
fmt_numeral	array(*(char))
[	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
-	O
'0'	O
+	O
i	int
]	O
,	O
fmt_stream	O
)	O
;	O
}	O
static	O
void	O
fmt_write_ordinal	(int,int)->(void)
(	O
int	O
s	int
,	O
int	O
i	int
)	O
{	O
writestr_stream	()->(int)
(	O
fmt_ordinal	array(*(char))
[	O
fmt_tempstr	(int)->(int)
(	O
s	int
)	O
-	O
'0'	O
+	O
i	int
]	O
,	O
fmt_stream	O
)	O
;	O
}	O
static	O
void	O
fmt_roman	(int,int,int,int,int)->(void)
(	O
int	O
i	int
,	O
int	O
one	int
,	O
int	O
five	int
,	O
int	O
ten	int
,	O
int	O
colon	int
)	O
{	O
int	O
j	int
;	O
if	O
(	O
i	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
(	O
!	O
colon	int
&&	O
i	int
<	O
4	int
)	O
||	O
(	O
colon	int
&&	O
i	int
<	O
5	int
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
)	O
writec_stream	()->(int)
(	O
one	int
,	O
fmt_stream	O
)	O
;	O
else	O
if	O
(	O
!	O
colon	int
&&	O
i	int
==	O
4	int
)	O
{	O
writec_stream	()->(int)
(	O
one	int
,	O
fmt_stream	O
)	O
;	O
writec_stream	()->(int)
(	O
five	int
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
!	O
colon	int
&&	O
i	int
<	O
9	int
)	O
||	O
colon	int
)	O
{	O
writec_stream	()->(int)
(	O
five	int
,	O
fmt_stream	O
)	O
;	O
for	O
(	O
j	int
=	O
5	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
)	O
writec_stream	()->(int)
(	O
one	int
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
colon	int
&&	O
i	int
==	O
9	int
)	O
{	O
writec_stream	()->(int)
(	O
one	int
,	O
fmt_stream	O
)	O
;	O
writec_stream	()->(int)
(	O
ten	int
,	O
fmt_stream	O
)	O
;	O
}	O
}	O
static	O
void	O
fmt_plural	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
fmt_max_param	(int)->(void)
(	O
0	int
)	O
;	O
if	O
(	O
colon	int
)	O
{	O
if	O
(	O
fmt_index	O
==	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"can't back up"	*(char)
)	O
;	O
--	O
fmt_index	O
;	O
}	O
if	O
(	O
eql	()->(int)
(	O
fmt_advance	()->(int)
(	O
)	O
,	O
make_fixnum	()->(int)
(	O
1	int
)	O
)	O
)	O
if	O
(	O
atsign	int
)	O
writec_stream	()->(int)
(	O
'y'	O
,	O
fmt_stream	O
)	O
;	O
else	O
;	O
else	O
if	O
(	O
atsign	int
)	O
writestr_stream	()->(int)
(	O
"ies"	*(char)
,	O
fmt_stream	O
)	O
;	O
else	O
writec_stream	()->(int)
(	O
's'	O
,	O
fmt_stream	O
)	O
;	O
}	O
static	O
void	O
fmt_character	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
object	O
x	int
;	O
int	O
i	int
;	O
fmt_max_param	(int)->(void)
(	O
0	int
)	O
;	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
=	O
0	int
;	O
STREAM_FILE_COLUMN	()->(int)
(	O
fmt_temporary_stream	int
)	O
=	O
0	int
;	O
x	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
check_type_character	()->(int)
(	O
&	O
x	int
)	O
;	O
prin1	()->(int)
(	O
x	int
,	O
fmt_temporary_stream	int
)	O
;	O
if	O
(	O
!	O
colon	int
&&	O
atsign	int
)	O
i	int
=	O
0	int
;	O
else	O
i	int
=	O
2	int
;	O
for	O
(	O
;	O
i	int
<	O
fmt_temporary_string	int
->	O
st	O
.	O
st_fillp	O
;	O
i	int
++	O
)	O
writec_stream	()->(int)
(	O
fmt_tempstr	(int)->(int)
(	O
i	int
)	O
,	O
fmt_stream	O
)	O
;	O
}	O
static	O
void	O
fmt_fix_float	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
w	int
=	O
0	int
,	O
d	int
=	O
0	int
,	O
k	int
=	O
0	int
,	O
overflowchar	int
=	O
0	int
,	O
padchar	int
=	O
0	int
;	O
double	O
f	double
;	O
int	O
sign	int
;	O
char	O
*	O
buff	*(char)
,	O
*	O
b	int
,	O
*	O
buff1	*(char)
;	O
int	O
exp	int
;	O
int	O
i	int
,	O
j	int
;	O
object	O
x	int
;	O
int	O
n	int
,	O
m	int
;	O
vs_mark	O
;	O
massert	()->(int)
(	O
buff	*(char)
=	O
alloca	O
(	O
256	int
)	O
)	O
;	O
massert	()->(int)
(	O
buff1	*(char)
=	O
alloca	O
(	O
256	int
)	O
)	O
;	O
b	int
=	O
buff1	*(char)
+	O
1	int
;	O
fmt_not_colon	(int)->(void)
(	O
colon	int
)	O
;	O
fmt_max_param	(int)->(void)
(	O
5	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
w	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
w	int
<	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal width"	*(char)
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
w	int
,	O
fmt_int	int
,	O
-	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
d	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal number of digits"	*(char)
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
d	int
,	O
fmt_int	int
,	O
-	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
k	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
3	int
,	O
&	O
overflowchar	int
,	O
fmt_char	int
,	O
-	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
4	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
x	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_fixnum	O
||	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_bignum	O
||	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_ratio	O
)	O
{	O
x	int
=	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
number_to_double	()->(int)
(	O
x	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_complex	O
)	O
{	O
if	O
(	O
w	int
<	O
0	int
)	O
prin1	()->(int)
(	O
x	int
,	O
fmt_stream	O
)	O
;	O
else	O
{	O
fmt_nparam	int
=	O
1	int
;	O
--	O
fmt_index	O
;	O
fmt_decimal	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
}	O
vs_reset	O
;	O
return	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_longfloat	O
)	O
n	int
=	O
17	int
;	O
else	O
n	int
=	O
8	int
;	O
f	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
edit_double	()->(int)
(	O
n	int
,	O
f	double
,	O
&	O
sign	int
,	O
buff	*(char)
,	O
&	O
exp	int
)	O
;	O
if	O
(	O
exp	int
+	O
k	int
>	O
100	int
||	O
exp	int
+	O
k	int
<	O
-	O
100	int
||	O
d	int
>	O
100	int
)	O
{	O
prin1	()->(int)
(	O
x	int
,	O
fmt_stream	O
)	O
;	O
vs_reset	O
;	O
return	O
;	O
}	O
if	O
(	O
d	int
>=	O
0	int
)	O
m	int
=	O
d	int
+	O
exp	int
+	O
k	int
+	O
1	int
;	O
else	O
if	O
(	O
w	int
>=	O
0	int
)	O
{	O
if	O
(	O
exp	int
+	O
k	int
>=	O
0	int
)	O
m	int
=	O
w	int
-	O
1	int
;	O
else	O
m	int
=	O
w	int
+	O
exp	int
+	O
k	int
-	O
2	int
;	O
if	O
(	O
sign	int
<	O
0	int
||	O
atsign	int
)	O
--	O
m	int
;	O
if	O
(	O
m	int
==	O
0	int
)	O
m	int
=	O
1	int
;	O
}	O
else	O
m	int
=	O
n	int
;	O
if	O
(	O
m	int
<=	O
0	int
)	O
{	O
if	O
(	O
m	int
==	O
0	int
&&	O
buff	*(char)
[	O
0	int
]	O
>=	O
'5'	O
)	O
{	O
exp	int
++	O
;	O
n	int
=	O
m	int
=	O
1	int
;	O
buff	*(char)
[	O
0	int
]	O
=	O
'1'	O
;	O
}	O
else	O
n	int
=	O
m	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
m	int
<	O
n	int
)	O
{	O
n	int
=	O
m	int
;	O
edit_double	()->(int)
(	O
n	int
,	O
f	double
,	O
&	O
sign	int
,	O
buff	*(char)
,	O
&	O
exp	int
)	O
;	O
}	O
while	O
(	O
n	int
>=	O
0	int
)	O
if	O
(	O
buff	*(char)
[	O
n	int
-	O
1	int
]	O
==	O
'0'	O
)	O
--	O
n	int
;	O
else	O
break	O
;	O
exp	int
+=	O
k	int
;	O
j	int
=	O
0	int
;	O
if	O
(	O
exp	int
>=	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
exp	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
i	int
<	O
n	int
?	O
buff	*(char)
[	O
i	int
]	O
:	O
'0'	O
;	O
b	int
[	O
j	int
++	O
]	O
=	O
'.'	O
;	O
if	O
(	O
d	int
>=	O
0	int
)	O
for	O
(	O
m	int
=	O
i	int
+	O
d	int
;	O
i	int
<	O
m	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
i	int
<	O
n	int
?	O
buff	*(char)
[	O
i	int
]	O
:	O
'0'	O
;	O
else	O
for	O
(	O
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
buff	*(char)
[	O
i	int
]	O
;	O
}	O
else	O
{	O
b	int
[	O
j	int
++	O
]	O
=	O
'.'	O
;	O
if	O
(	O
d	int
>=	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
-	O
exp	int
)	O
-	O
1	int
&&	O
i	int
<	O
d	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
'0'	O
;	O
for	O
(	O
m	int
=	O
d	int
-	O
i	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
m	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
i	int
<	O
n	int
?	O
buff	*(char)
[	O
i	int
]	O
:	O
'0'	O
;	O
}	O
else	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
-	O
exp	int
)	O
-	O
1	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
'0'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
buff	*(char)
[	O
i	int
]	O
;	O
}	O
}	O
b	int
[	O
j	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
w	int
>=	O
0	int
)	O
{	O
if	O
(	O
sign	int
<	O
0	int
||	O
atsign	int
)	O
--	O
w	int
;	O
if	O
(	O
j	int
>	O
w	int
&&	O
overflowchar	int
>=	O
0	int
)	O
goto	O
OVER	O
;	O
if	O
(	O
j	int
<	O
w	int
&&	O
b	int
[	O
j	int
-	O
1	int
]	O
==	O
'.'	O
&&	O
d	int
)	O
{	O
b	int
[	O
j	int
++	O
]	O
=	O
'0'	O
;	O
b	int
[	O
j	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
j	int
<	O
w	int
&&	O
b	int
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
*	O
--	O
b	int
=	O
'0'	O
;	O
j	int
++	O
;	O
}	O
for	O
(	O
i	int
=	O
j	int
;	O
i	int
<	O
w	int
;	O
i	int
++	O
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
b	int
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
*	O
--	O
b	int
=	O
'0'	O
;	O
j	int
++	O
;	O
}	O
if	O
(	O
d	int
<	O
0	int
&&	O
b	int
[	O
j	int
-	O
1	int
]	O
==	O
'.'	O
)	O
{	O
b	int
[	O
j	int
++	O
]	O
=	O
'0'	O
;	O
b	int
[	O
j	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
if	O
(	O
sign	int
<	O
0	int
)	O
writec_stream	()->(int)
(	O
'-'	O
,	O
fmt_stream	O
)	O
;	O
else	O
if	O
(	O
atsign	int
)	O
writec_stream	()->(int)
(	O
'+'	O
,	O
fmt_stream	O
)	O
;	O
writestr_stream	()->(int)
(	O
b	int
,	O
fmt_stream	O
)	O
;	O
vs_reset	O
;	O
return	O
;	O
OVER	O
:	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
w	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
w	int
;	O
i	int
++	O
)	O
writec_stream	()->(int)
(	O
overflowchar	int
,	O
fmt_stream	O
)	O
;	O
vs_reset	O
;	O
return	O
;	O
}	O
static	O
int	O
fmt_exponent_length	(int)->(int)
(	O
int	O
e	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
e	int
==	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
e	int
<	O
0	int
)	O
e	int
=	O
-	O
e	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
e	int
>	O
0	int
;	O
i	int
++	O
,	O
e	int
/=	O
10	int
)	O
;	O
return	O
(	O
i	int
)	O
;	O
}	O
static	O
void	O
fmt_exponent	(int)->(void)
(	O
int	O
e	int
)	O
{	O
if	O
(	O
e	int
==	O
0	int
)	O
{	O
writec_stream	()->(int)
(	O
'0'	O
,	O
fmt_stream	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
e	int
<	O
0	int
)	O
e	int
=	O
-	O
e	int
;	O
fmt_exponent1	(int)->(void)
(	O
e	int
)	O
;	O
}	O
static	O
void	O
fmt_exponent1	(int)->(void)
(	O
int	O
e	int
)	O
{	O
if	O
(	O
e	int
==	O
0	int
)	O
return	O
;	O
fmt_exponent1	(int)->(void)
(	O
e	int
/	O
10	int
)	O
;	O
writec_stream	()->(int)
(	O
'0'	O
+	O
e	int
%	O
10	int
,	O
fmt_stream	O
)	O
;	O
}	O
static	O
void	O
fmt_exponential_float	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
w	int
=	O
0	int
,	O
d	int
=	O
0	int
,	O
e	int
=	O
0	int
,	O
k	int
=	O
0	int
,	O
overflowchar	int
=	O
0	int
,	O
padchar	int
=	O
0	int
,	O
exponentchar	int
=	O
0	int
;	O
double	O
f	double
;	O
int	O
sign	int
;	O
char	O
buff	*(char)
[	O
256	int
]	O
,	O
*	O
b	int
,	O
buff1	*(char)
[	O
256	int
]	O
;	O
int	O
exp	int
;	O
int	O
i	int
,	O
j	int
;	O
object	O
x	int
,	O
y	O
;	O
int	O
n	int
,	O
m	int
;	O
enum	O
type	O
t	int
;	O
vs_mark	O
;	O
b	int
=	O
buff1	*(char)
+	O
1	int
;	O
fmt_not_colon	(int)->(void)
(	O
colon	int
)	O
;	O
fmt_max_param	(int)->(void)
(	O
7	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
w	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
w	int
<	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal width"	*(char)
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
w	int
,	O
fmt_int	int
,	O
-	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
d	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal number of digits"	*(char)
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
d	int
,	O
fmt_int	int
,	O
-	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
e	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
e	int
<	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal number of digits in exponent"	*(char)
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
e	int
,	O
fmt_int	int
,	O
-	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
3	int
,	O
&	O
k	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
4	int
,	O
&	O
overflowchar	int
,	O
fmt_char	int
,	O
-	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
5	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
6	int
,	O
&	O
exponentchar	int
,	O
fmt_char	int
,	O
-	O
1	int
)	O
;	O
x	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_fixnum	O
||	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_bignum	O
||	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_ratio	O
)	O
{	O
x	int
=	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
number_to_double	()->(int)
(	O
x	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_complex	O
)	O
{	O
if	O
(	O
w	int
<	O
0	int
)	O
prin1	()->(int)
(	O
x	int
,	O
fmt_stream	O
)	O
;	O
else	O
{	O
fmt_nparam	int
=	O
1	int
;	O
--	O
fmt_index	O
;	O
fmt_decimal	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
}	O
vs_reset	O
;	O
return	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_longfloat	O
)	O
n	int
=	O
17	int
;	O
else	O
n	int
=	O
8	int
;	O
f	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
edit_double	()->(int)
(	O
n	int
,	O
f	double
,	O
&	O
sign	int
,	O
buff	*(char)
,	O
&	O
exp	int
)	O
;	O
if	O
(	O
d	int
>=	O
0	int
)	O
{	O
if	O
(	O
k	int
>	O
0	int
)	O
{	O
if	O
(	O
!	O
(	O
k	int
<	O
d	int
+	O
2	int
)	O
)	O
fmt_error	(*(char))->(void)
(	O
"illegal scale factor"	*(char)
)	O
;	O
m	int
=	O
d	int
+	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
k	int
>	O
-	O
d	int
)	O
)	O
fmt_error	(*(char))->(void)
(	O
"illegal scale factor"	*(char)
)	O
;	O
m	int
=	O
d	int
+	O
k	int
;	O
}	O
}	O
else	O
if	O
(	O
w	int
>=	O
0	int
)	O
{	O
if	O
(	O
k	int
>	O
0	int
)	O
m	int
=	O
w	int
-	O
1	int
;	O
else	O
m	int
=	O
w	int
+	O
k	int
-	O
1	int
;	O
if	O
(	O
sign	int
<	O
0	int
||	O
atsign	int
)	O
--	O
m	int
;	O
if	O
(	O
e	int
>=	O
0	int
)	O
m	int
-=	O
e	int
+	O
2	int
;	O
else	O
m	int
-=	O
fmt_exponent_length	(int)->(int)
(	O
e	int
-	O
k	int
+	O
1	int
)	O
+	O
2	int
;	O
}	O
else	O
m	int
=	O
n	int
;	O
if	O
(	O
m	int
<=	O
0	int
)	O
{	O
if	O
(	O
m	int
==	O
0	int
&&	O
buff	*(char)
[	O
0	int
]	O
>=	O
'5'	O
)	O
{	O
exp	int
++	O
;	O
n	int
=	O
m	int
=	O
1	int
;	O
buff	*(char)
[	O
0	int
]	O
=	O
'1'	O
;	O
}	O
else	O
n	int
=	O
m	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
m	int
<	O
n	int
)	O
{	O
n	int
=	O
m	int
;	O
edit_double	()->(int)
(	O
n	int
,	O
f	double
,	O
&	O
sign	int
,	O
buff	*(char)
,	O
&	O
exp	int
)	O
;	O
}	O
while	O
(	O
n	int
>=	O
0	int
)	O
if	O
(	O
buff	*(char)
[	O
n	int
-	O
1	int
]	O
==	O
'0'	O
)	O
--	O
n	int
;	O
else	O
break	O
;	O
exp	int
=	O
exp	int
-	O
k	int
+	O
1	int
;	O
j	int
=	O
0	int
;	O
if	O
(	O
k	int
>	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
k	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
i	int
<	O
n	int
?	O
buff	*(char)
[	O
i	int
]	O
:	O
'0'	O
;	O
b	int
[	O
j	int
++	O
]	O
=	O
'.'	O
;	O
if	O
(	O
d	int
>=	O
0	int
)	O
for	O
(	O
m	int
=	O
i	int
+	O
(	O
d	int
-	O
k	int
+	O
1	int
)	O
;	O
i	int
<	O
m	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
i	int
<	O
n	int
?	O
buff	*(char)
[	O
i	int
]	O
:	O
'0'	O
;	O
else	O
for	O
(	O
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
buff	*(char)
[	O
i	int
]	O
;	O
}	O
else	O
{	O
b	int
[	O
j	int
++	O
]	O
=	O
'.'	O
;	O
if	O
(	O
d	int
>=	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
-	O
k	int
&&	O
i	int
<	O
d	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
'0'	O
;	O
for	O
(	O
m	int
=	O
d	int
-	O
i	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
m	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
i	int
<	O
n	int
?	O
buff	*(char)
[	O
i	int
]	O
:	O
'0'	O
;	O
}	O
else	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
-	O
k	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
'0'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
b	int
[	O
j	int
++	O
]	O
=	O
buff	*(char)
[	O
i	int
]	O
;	O
}	O
}	O
b	int
[	O
j	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
w	int
>=	O
0	int
)	O
{	O
if	O
(	O
sign	int
<	O
0	int
||	O
atsign	int
)	O
--	O
w	int
;	O
i	int
=	O
fmt_exponent_length	(int)->(int)
(	O
exp	int
)	O
;	O
if	O
(	O
e	int
>=	O
0	int
)	O
{	O
if	O
(	O
i	int
>	O
e	int
)	O
{	O
if	O
(	O
overflowchar	int
>=	O
0	int
)	O
goto	O
OVER	O
;	O
else	O
e	int
=	O
i	int
;	O
}	O
w	int
-=	O
e	int
+	O
2	int
;	O
}	O
else	O
w	int
-=	O
i	int
+	O
2	int
;	O
if	O
(	O
j	int
>	O
w	int
&&	O
overflowchar	int
>=	O
0	int
)	O
goto	O
OVER	O
;	O
if	O
(	O
j	int
<	O
w	int
&&	O
b	int
[	O
j	int
-	O
1	int
]	O
==	O
'.'	O
)	O
{	O
b	int
[	O
j	int
++	O
]	O
=	O
'0'	O
;	O
b	int
[	O
j	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
j	int
<	O
w	int
&&	O
b	int
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
*	O
--	O
b	int
=	O
'0'	O
;	O
j	int
++	O
;	O
}	O
for	O
(	O
i	int
=	O
j	int
;	O
i	int
<	O
w	int
;	O
i	int
++	O
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
b	int
[	O
j	int
-	O
1	int
]	O
==	O
'.'	O
)	O
{	O
b	int
[	O
j	int
++	O
]	O
=	O
'0'	O
;	O
b	int
[	O
j	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
d	int
<	O
0	int
&&	O
b	int
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
*	O
--	O
b	int
=	O
'0'	O
;	O
j	int
++	O
;	O
}	O
}	O
if	O
(	O
sign	int
<	O
0	int
)	O
writec_stream	()->(int)
(	O
'-'	O
,	O
fmt_stream	O
)	O
;	O
else	O
if	O
(	O
atsign	int
)	O
writec_stream	()->(int)
(	O
'+'	O
,	O
fmt_stream	O
)	O
;	O
writestr_stream	()->(int)
(	O
b	int
,	O
fmt_stream	O
)	O
;	O
y	O
=	O
symbol_value	()->(int)
(	O
sLAread_default_float_formatA	O
)	O
;	O
if	O
(	O
exponentchar	int
<	O
0	int
)	O
{	O
if	O
(	O
y	O
==	O
sLlong_float	O
||	O
y	O
==	O
sLdouble_float	O
||	O
y	O
==	O
sLsingle_float	O
)	O
t	int
=	O
t_longfloat	O
;	O
else	O
t	int
=	O
t_shortfloat	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t	int
)	O
exponentchar	int
=	O
'E'	O
;	O
else	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_shortfloat	O
)	O
exponentchar	int
=	O
'S'	O
;	O
else	O
exponentchar	int
=	O
'L'	O
;	O
}	O
writec_stream	()->(int)
(	O
exponentchar	int
,	O
fmt_stream	O
)	O
;	O
if	O
(	O
exp	int
<	O
0	int
)	O
writec_stream	()->(int)
(	O
'-'	O
,	O
fmt_stream	O
)	O
;	O
else	O
writec_stream	()->(int)
(	O
'+'	O
,	O
fmt_stream	O
)	O
;	O
if	O
(	O
e	int
>=	O
0	int
)	O
for	O
(	O
i	int
=	O
e	int
-	O
fmt_exponent_length	(int)->(int)
(	O
exp	int
)	O
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
writec_stream	()->(int)
(	O
'0'	O
,	O
fmt_stream	O
)	O
;	O
fmt_exponent	(int)->(void)
(	O
exp	int
)	O
;	O
vs_reset	O
;	O
return	O
;	O
OVER	O
:	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
w	int
,	O
fmt_int	int
,	O
-	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
w	int
;	O
i	int
++	O
)	O
writec_stream	()->(int)
(	O
overflowchar	int
,	O
fmt_stream	O
)	O
;	O
vs_reset	O
;	O
return	O
;	O
}	O
static	O
void	O
fmt_general_float	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
w	int
=	O
0	int
,	O
d	int
=	O
0	int
,	O
e	int
=	O
0	int
,	O
k	int
,	O
overflowchar	int
,	O
padchar	int
=	O
0	int
,	O
exponentchar	int
;	O
int	O
sign	int
,	O
exp	int
;	O
char	O
buff	*(char)
[	O
256	int
]	O
;	O
object	O
x	int
;	O
int	O
n	int
,	O
ee	int
,	O
ww	int
,	O
q	int
,	O
dd	int
;	O
vs_mark	O
;	O
fmt_not_colon	(int)->(void)
(	O
colon	int
)	O
;	O
fmt_max_param	(int)->(void)
(	O
7	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
w	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
w	int
<	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal width"	*(char)
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
w	int
,	O
fmt_int	int
,	O
-	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
d	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal number of digits"	*(char)
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
d	int
,	O
fmt_int	int
,	O
-	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
e	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
e	int
<	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal number of digits in exponent"	*(char)
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
e	int
,	O
fmt_int	int
,	O
-	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
3	int
,	O
&	O
k	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
4	int
,	O
&	O
overflowchar	int
,	O
fmt_char	int
,	O
-	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
5	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
6	int
,	O
&	O
exponentchar	int
,	O
fmt_char	int
,	O
-	O
1	int
)	O
;	O
x	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_complex	O
)	O
{	O
if	O
(	O
w	int
<	O
0	int
)	O
prin1	()->(int)
(	O
x	int
,	O
fmt_stream	O
)	O
;	O
else	O
{	O
fmt_nparam	int
=	O
1	int
;	O
--	O
fmt_index	O
;	O
fmt_decimal	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
}	O
vs_reset	O
;	O
return	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_longfloat	O
)	O
q	int
=	O
17	int
;	O
else	O
q	int
=	O
8	int
;	O
edit_double	()->(int)
(	O
q	int
,	O
number_to_double	()->(int)
(	O
x	int
)	O
,	O
&	O
sign	int
,	O
buff	*(char)
,	O
&	O
exp	int
)	O
;	O
n	int
=	O
exp	int
+	O
1	int
;	O
while	O
(	O
q	int
>	O
0	int
)	O
if	O
(	O
buff	*(char)
[	O
q	int
-	O
1	int
]	O
==	O
'0'	O
)	O
--	O
q	int
;	O
else	O
break	O
;	O
if	O
(	O
e	int
>=	O
0	int
)	O
ee	int
=	O
e	int
+	O
2	int
;	O
else	O
ee	int
=	O
4	int
;	O
ww	int
=	O
w	int
-	O
ee	int
;	O
if	O
(	O
d	int
<	O
0	int
)	O
{	O
d	int
=	O
n	int
<	O
7	int
?	O
n	int
:	O
7	int
;	O
d	int
=	O
q	int
>	O
d	int
?	O
q	int
:	O
d	int
;	O
}	O
dd	int
=	O
d	int
-	O
n	int
;	O
if	O
(	O
0	int
<=	O
dd	int
&&	O
dd	int
<=	O
d	int
)	O
{	O
FMT_PARAM	O
[	O
0	int
]	O
.	O
fmt_param_value	int
=	O
ww	int
;	O
if	O
(	O
w	int
<	O
0	int
)	O
FMT_PARAM	O
[	O
0	int
]	O
.	O
fmt_param_type	int
=	O
fmt_null	int
;	O
FMT_PARAM	O
[	O
1	int
]	O
.	O
fmt_param_value	int
=	O
dd	int
;	O
FMT_PARAM	O
[	O
1	int
]	O
.	O
fmt_param_type	int
=	O
fmt_int	int
;	O
FMT_PARAM	O
[	O
2	int
]	O
.	O
fmt_param_type	int
=	O
fmt_null	int
;	O
if	O
(	O
fmt_nparam	int
>	O
4	int
)	O
{	O
FMT_PARAM	O
[	O
3	int
]	O
=	O
FMT_PARAM	O
[	O
4	int
]	O
;	O
}	O
else	O
FMT_PARAM	O
[	O
3	int
]	O
.	O
fmt_param_type	int
=	O
fmt_null	int
;	O
if	O
(	O
fmt_nparam	int
>	O
5	int
)	O
{	O
FMT_PARAM	O
[	O
4	int
]	O
=	O
FMT_PARAM	O
[	O
5	int
]	O
;	O
}	O
else	O
FMT_PARAM	O
[	O
4	int
]	O
.	O
fmt_param_type	int
=	O
fmt_null	int
;	O
fmt_nparam	int
=	O
5	int
;	O
--	O
fmt_index	O
;	O
fmt_fix_float	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
if	O
(	O
w	int
>=	O
0	int
)	O
while	O
(	O
ww	int
++	O
<	O
w	int
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
vs_reset	O
;	O
return	O
;	O
}	O
FMT_PARAM	O
[	O
1	int
]	O
.	O
fmt_param_value	int
=	O
d	int
;	O
FMT_PARAM	O
[	O
1	int
]	O
.	O
fmt_param_type	int
=	O
fmt_int	int
;	O
--	O
fmt_index	O
;	O
fmt_exponential_float	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
vs_reset	O
;	O
}	O
static	O
void	O
fmt_dollars_float	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
d	int
=	O
0	int
,	O
n	int
=	O
0	int
,	O
w	int
=	O
0	int
,	O
padchar	int
=	O
0	int
;	O
double	O
f	double
;	O
int	O
sign	int
;	O
char	O
buff	*(char)
[	O
256	int
]	O
;	O
int	O
exp	int
;	O
int	O
q	int
,	O
i	int
;	O
object	O
x	int
;	O
vs_mark	O
;	O
fmt_max_param	(int)->(void)
(	O
4	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
d	int
,	O
fmt_int	int
,	O
2	int
)	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal number of digits"	*(char)
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
n	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal number of digits"	*(char)
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
w	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
w	int
<	O
0	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal width"	*(char)
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
3	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
x	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_complex	O
)	O
{	O
if	O
(	O
w	int
<	O
0	int
)	O
prin1	()->(int)
(	O
x	int
,	O
fmt_stream	O
)	O
;	O
else	O
{	O
fmt_nparam	int
=	O
1	int
;	O
FMT_PARAM	O
[	O
0	int
]	O
=	O
FMT_PARAM	O
[	O
2	int
]	O
;	O
--	O
fmt_index	O
;	O
fmt_decimal	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
}	O
vs_reset	O
;	O
return	O
;	O
}	O
q	int
=	O
8	int
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_longfloat	O
)	O
q	int
=	O
17	int
;	O
f	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
edit_double	()->(int)
(	O
q	int
,	O
f	double
,	O
&	O
sign	int
,	O
buff	*(char)
,	O
&	O
exp	int
)	O
;	O
if	O
(	O
(	O
q	int
=	O
exp	int
+	O
d	int
+	O
1	int
)	O
>	O
0	int
)	O
edit_double	()->(int)
(	O
q	int
,	O
f	double
,	O
&	O
sign	int
,	O
buff	*(char)
,	O
&	O
exp	int
)	O
;	O
exp	int
++	O
;	O
if	O
(	O
w	int
>	O
100	int
||	O
exp	int
>	O
100	int
||	O
exp	int
<	O
-	O
100	int
)	O
{	O
fmt_nparam	int
=	O
6	int
;	O
FMT_PARAM	O
[	O
0	int
]	O
=	O
FMT_PARAM	O
[	O
2	int
]	O
;	O
FMT_PARAM	O
[	O
1	int
]	O
.	O
fmt_param_value	int
=	O
d	int
+	O
n	int
-	O
1	int
;	O
FMT_PARAM	O
[	O
1	int
]	O
.	O
fmt_param_type	int
=	O
fmt_int	int
;	O
FMT_PARAM	O
[	O
2	int
]	O
.	O
fmt_param_type	int
=	O
FMT_PARAM	O
[	O
3	int
]	O
.	O
fmt_param_type	int
=	O
FMT_PARAM	O
[	O
4	int
]	O
.	O
fmt_param_type	int
=	O
fmt_null	int
;	O
FMT_PARAM	O
[	O
5	int
]	O
=	O
FMT_PARAM	O
[	O
3	int
]	O
;	O
--	O
fmt_index	O
;	O
fmt_exponential_float	()->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
}	O
if	O
(	O
exp	int
>	O
n	int
)	O
n	int
=	O
exp	int
;	O
if	O
(	O
sign	int
<	O
0	int
||	O
atsign	int
)	O
--	O
w	int
;	O
if	O
(	O
colon	int
)	O
{	O
if	O
(	O
sign	int
<	O
0	int
)	O
writec_stream	()->(int)
(	O
'-'	O
,	O
fmt_stream	O
)	O
;	O
else	O
if	O
(	O
atsign	int
)	O
writec_stream	()->(int)
(	O
'+'	O
,	O
fmt_stream	O
)	O
;	O
while	O
(	O
--	O
w	int
>	O
n	int
+	O
d	int
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
{	O
while	O
(	O
--	O
w	int
>	O
n	int
+	O
d	int
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
if	O
(	O
sign	int
<	O
0	int
)	O
writec_stream	()->(int)
(	O
'-'	O
,	O
fmt_stream	O
)	O
;	O
else	O
if	O
(	O
atsign	int
)	O
writec_stream	()->(int)
(	O
'+'	O
,	O
fmt_stream	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
n	int
-	O
exp	int
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
writec_stream	()->(int)
(	O
'0'	O
,	O
fmt_stream	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
exp	int
;	O
i	int
++	O
)	O
writec_stream	()->(int)
(	O
(	O
i	int
<	O
q	int
?	O
buff	*(char)
[	O
i	int
]	O
:	O
'0'	O
)	O
,	O
fmt_stream	O
)	O
;	O
writec_stream	()->(int)
(	O
'.'	O
,	O
fmt_stream	O
)	O
;	O
for	O
(	O
d	int
+=	O
i	int
;	O
i	int
<	O
d	int
;	O
i	int
++	O
)	O
writec_stream	()->(int)
(	O
(	O
i	int
<	O
q	int
?	O
buff	*(char)
[	O
i	int
]	O
:	O
'0'	O
)	O
,	O
fmt_stream	O
)	O
;	O
vs_reset	O
;	O
}	O
static	O
void	O
fmt_percent	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
n	int
=	O
0	int
,	O
i	int
;	O
fmt_max_param	(int)->(void)
(	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
n	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
fmt_not_colon	(int)->(void)
(	O
colon	int
)	O
;	O
fmt_not_atsign	(int)->(void)
(	O
atsign	int
)	O
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
{	O
WRITEC_NEWLINE	O
(	O
fmt_stream	O
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
for	O
(	O
i	int
=	O
fmt_indents	O
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
writec_stream	()->(int)
(	O
' '	O
,	O
fmt_stream	O
)	O
;	O
}	O
}	O
static	O
void	O
fmt_ampersand	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
n	int
=	O
0	int
;	O
fmt_max_param	(int)->(void)
(	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
n	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
fmt_not_colon	(int)->(void)
(	O
colon	int
)	O
;	O
fmt_not_atsign	(int)->(void)
(	O
atsign	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
file_column	()->(int)
(	O
fmt_stream	O
)	O
!=	O
0	int
)	O
WRITEC_NEWLINE	O
(	O
fmt_stream	O
)	O
;	O
while	O
(	O
--	O
n	int
>	O
0	int
)	O
WRITEC_NEWLINE	O
(	O
fmt_stream	O
)	O
;	O
fmt_indents	O
=	O
0	int
;	O
}	O
static	O
void	O
fmt_bar	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
n	int
=	O
0	int
;	O
fmt_max_param	(int)->(void)
(	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
n	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
fmt_not_colon	(int)->(void)
(	O
colon	int
)	O
;	O
fmt_not_atsign	(int)->(void)
(	O
atsign	int
)	O
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
writec_stream	()->(int)
(	O
'\f'	O
,	O
fmt_stream	O
)	O
;	O
}	O
static	O
void	O
fmt_tilde	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
n	int
=	O
0	int
;	O
fmt_max_param	(int)->(void)
(	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
n	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
fmt_not_colon	(int)->(void)
(	O
colon	int
)	O
;	O
fmt_not_atsign	(int)->(void)
(	O
atsign	int
)	O
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
writec_stream	()->(int)
(	O
'~'	O
,	O
fmt_stream	O
)	O
;	O
}	O
static	O
void	O
fmt_newline	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
fmt_max_param	(int)->(void)
(	O
0	int
)	O
;	O
fmt_not_colon_atsign	(int,int)->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
if	O
(	O
atsign	int
)	O
WRITEC_NEWLINE	O
(	O
fmt_stream	O
)	O
;	O
while	O
(	O
ctl_index	O
<	O
ctl_end	O
&&	O
isspace	O
(	O
(	O
int	O
)	O
ctl_string	O
[	O
ctl_index	O
]	O
)	O
)	O
{	O
if	O
(	O
colon	int
)	O
writec_stream	()->(int)
(	O
ctl_string	O
[	O
ctl_index	O
]	O
,	O
fmt_stream	O
)	O
;	O
ctl_index	O
++	O
;	O
}	O
}	O
static	O
void	O
fmt_tabulate	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
colnum	int
=	O
0	int
,	O
colinc	int
=	O
0	int
;	O
int	O
c	int
,	O
i	int
;	O
fmt_max_param	(int)->(void)
(	O
2	int
)	O
;	O
fmt_not_colon	(int)->(void)
(	O
colon	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
colnum	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
colinc	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
if	O
(	O
!	O
atsign	int
)	O
{	O
c	int
=	O
file_column	()->(int)
(	O
fmt_stream	O
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
{	O
writestr_stream	()->(int)
(	O
"  "	*(char)
,	O
fmt_stream	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
c	int
>	O
colnum	int
&&	O
colinc	int
<=	O
0	int
)	O
return	O
;	O
while	O
(	O
c	int
>	O
colnum	int
)	O
colnum	int
+=	O
colinc	int
;	O
for	O
(	O
i	int
=	O
colnum	int
-	O
c	int
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
writec_stream	()->(int)
(	O
' '	O
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
colnum	int
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
writec_stream	()->(int)
(	O
' '	O
,	O
fmt_stream	O
)	O
;	O
c	int
=	O
file_column	()->(int)
(	O
fmt_stream	O
)	O
;	O
if	O
(	O
c	int
<	O
0	int
||	O
colinc	int
<=	O
0	int
)	O
return	O
;	O
colnum	int
=	O
0	int
;	O
while	O
(	O
c	int
>	O
colnum	int
)	O
colnum	int
+=	O
colinc	int
;	O
for	O
(	O
i	int
=	O
colnum	int
-	O
c	int
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
writec_stream	()->(int)
(	O
' '	O
,	O
fmt_stream	O
)	O
;	O
}	O
}	O
static	O
void	O
fmt_asterisk	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
n	int
=	O
0	int
;	O
fmt_max_param	(int)->(void)
(	O
1	int
)	O
;	O
fmt_not_colon_atsign	(int,int)->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
if	O
(	O
atsign	int
)	O
{	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
n	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
n	int
<	O
0	int
||	O
n	int
>=	O
fmt_end	O
)	O
fmt_error	(*(char))->(void)
(	O
"can't goto"	*(char)
)	O
;	O
fmt_index	O
=	O
n	int
;	O
}	O
else	O
if	O
(	O
colon	int
)	O
{	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
n	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
if	O
(	O
n	int
>	O
fmt_index	O
)	O
fmt_error	(*(char))->(void)
(	O
"can't back up"	*(char)
)	O
;	O
fmt_index	O
-=	O
n	int
;	O
}	O
else	O
{	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
n	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
fmt_advance	()->(int)
(	O
)	O
;	O
}	O
}	O
static	O
void	O
fmt_indirection	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
object	O
s	int
,	O
l	int
;	O
fmt_old	O
;	O
jmp_buf	O
fmt_jmp_buf0	O
;	O
int	O
up_colon	int
;	O
up_colon	int
=	O
(	O
long	O
)	O
&	O
old_fmt_paramp	O
;	O
fmt_max_param	(int)->(void)
(	O
0	int
)	O
;	O
fmt_not_colon	(int)->(void)
(	O
colon	int
)	O
;	O
s	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
s	int
)	O
!=	O
t_string	O
)	O
fmt_error	(*(char))->(void)
(	O
"control string expected"	*(char)
)	O
;	O
if	O
(	O
atsign	int
)	O
{	O
fmt_save	O
;	O
fmt_jmp_bufp	O
=	O
&	O
fmt_jmp_buf0	O
;	O
fmt_string	O
=	O
s	int
;	O
if	O
(	O
(	O
up_colon	int
=	O
setjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
)	O
)	O
)	O
{	O
if	O
(	O
--	O
up_colon	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal ~:^"	*(char)
)	O
;	O
}	O
else	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
0	int
,	O
s	int
->	O
st	O
.	O
st_fillp	O
)	O
;	O
fmt_restore1	O
;	O
}	O
else	O
{	O
l	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
fmt_save	O
;	O
fmt_base	O
=	O
vs_top	O
;	O
fmt_index	O
=	O
0	int
;	O
for	O
(	O
fmt_end	O
=	O
0	int
;	O
!	O
endp	()->(int)
(	O
l	int
)	O
;	O
fmt_end	O
++	O
,	O
l	int
=	O
l	int
->	O
c	int
.	O
c_cdr	O
)	O
vs_check_push	()->(int)
(	O
l	int
->	O
c	int
.	O
c_car	O
)	O
;	O
fmt_jmp_bufp	O
=	O
&	O
fmt_jmp_buf0	O
;	O
fmt_string	O
=	O
s	int
;	O
if	O
(	O
(	O
up_colon	int
=	O
setjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
)	O
)	O
)	O
{	O
if	O
(	O
--	O
up_colon	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal ~:^"	*(char)
)	O
;	O
}	O
else	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
0	int
,	O
s	int
->	O
st	O
.	O
st_fillp	O
)	O
;	O
vs_top	O
=	O
fmt_base	O
;	O
fmt_restore	O
;	O
}	O
}	O
static	O
void	O
fmt_case	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
VOL	O
object	O
x	int
;	O
VOL	O
int	O
i	int
,	O
j	int
;	O
fmt_old	O
;	O
jmp_buf	O
fmt_jmp_buf0	O
;	O
int	O
up_colon	int
;	O
bool	int
b	int
;	O
x	int
=	O
make_string_output_stream	()->(int)
(	O
64	int
)	O
;	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
i	int
=	O
ctl_index	O
;	O
j	int
=	O
fmt_skip	()->(int)
(	O
)	O
;	O
if	O
(	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
')'	O
||	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
'~'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~) expected"	*(char)
)	O
;	O
fmt_save	O
;	O
fmt_jmp_bufp	O
=	O
&	O
fmt_jmp_buf0	O
;	O
if	O
(	O
(	O
up_colon	int
=	O
setjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
)	O
)	O
)	O
;	O
else	O
format	(int,int,int)->(void)
(	O
x	int
,	O
ctl_origin	O
+	O
i	int
,	O
j	int
-	O
i	int
)	O
;	O
fmt_restore1	O
;	O
x	int
=	O
x	int
->	O
sm	O
.	O
sm_object0	O
;	O
if	O
(	O
!	O
colon	int
&&	O
!	O
atsign	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
x	int
->	O
st	O
.	O
st_fillp	O
;	O
i	int
++	O
)	O
{	O
j	int
=	O
x	int
->	O
st	O
.	O
st_self	O
[	O
i	int
]	O
;	O
if	O
(	O
isUpper	()->(int)
(	O
j	int
)	O
)	O
j	int
+=	O
'a'	O
-	O
'A'	O
;	O
writec_stream	()->(int)
(	O
j	int
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
if	O
(	O
colon	int
&&	O
!	O
atsign	int
)	O
for	O
(	O
b	int
=	O
TRUE	O
,	O
i	int
=	O
0	int
;	O
i	int
<	O
x	int
->	O
st	O
.	O
st_fillp	O
;	O
i	int
++	O
)	O
{	O
j	int
=	O
x	int
->	O
st	O
.	O
st_self	O
[	O
i	int
]	O
;	O
if	O
(	O
isLower	()->(int)
(	O
j	int
)	O
)	O
{	O
if	O
(	O
b	int
)	O
j	int
-=	O
'a'	O
-	O
'A'	O
;	O
b	int
=	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
isUpper	()->(int)
(	O
j	int
)	O
)	O
{	O
if	O
(	O
!	O
b	int
)	O
j	int
+=	O
'a'	O
-	O
'A'	O
;	O
b	int
=	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
!	O
isDigit	()->(int)
(	O
j	int
)	O
)	O
b	int
=	O
TRUE	O
;	O
writec_stream	()->(int)
(	O
j	int
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
colon	int
&&	O
atsign	int
)	O
for	O
(	O
b	int
=	O
TRUE	O
,	O
i	int
=	O
0	int
;	O
i	int
<	O
x	int
->	O
st	O
.	O
st_fillp	O
;	O
i	int
++	O
)	O
{	O
j	int
=	O
x	int
->	O
st	O
.	O
st_self	O
[	O
i	int
]	O
;	O
if	O
(	O
isLower	()->(int)
(	O
j	int
)	O
)	O
{	O
if	O
(	O
b	int
)	O
j	int
-=	O
'a'	O
-	O
'A'	O
;	O
b	int
=	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
isUpper	()->(int)
(	O
j	int
)	O
)	O
{	O
if	O
(	O
!	O
b	int
)	O
j	int
+=	O
'a'	O
-	O
'A'	O
;	O
b	int
=	O
FALSE	O
;	O
}	O
writec_stream	()->(int)
(	O
j	int
,	O
fmt_stream	O
)	O
;	O
}	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
x	int
->	O
st	O
.	O
st_fillp	O
;	O
i	int
++	O
)	O
{	O
j	int
=	O
x	int
->	O
st	O
.	O
st_self	O
[	O
i	int
]	O
;	O
if	O
(	O
isLower	()->(int)
(	O
j	int
)	O
)	O
j	int
-=	O
'a'	O
-	O
'A'	O
;	O
writec_stream	()->(int)
(	O
j	int
,	O
fmt_stream	O
)	O
;	O
}	O
vs_popp	O
;	O
if	O
(	O
up_colon	int
)	O
longjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
,	O
up_colon	int
)	O
;	O
}	O
static	O
void	O
fmt_conditional	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
object	O
x	int
;	O
int	O
n	int
=	O
0	int
;	O
bool	int
done	O
;	O
fmt_old	O
;	O
fmt_not_colon_atsign	(int,int)->(void)
(	O
colon	int
,	O
atsign	int
)	O
;	O
if	O
(	O
colon	int
)	O
{	O
fmt_max_param	(int)->(void)
(	O
0	int
)	O
;	O
i	int
=	O
ctl_index	O
;	O
j	int
=	O
fmt_skip	()->(int)
(	O
)	O
;	O
if	O
(	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
';'	O
||	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
'~'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~; expected"	*(char)
)	O
;	O
k	int
=	O
fmt_skip	()->(int)
(	O
)	O
;	O
if	O
(	O
ctl_string	O
[	O
--	O
k	int
]	O
!=	O
']'	O
||	O
ctl_string	O
[	O
--	O
k	int
]	O
!=	O
'~'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~] expected"	*(char)
)	O
;	O
if	O
(	O
fmt_advance	()->(int)
(	O
)	O
==	O
Cnil	O
)	O
{	O
fmt_save	O
;	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
ctl_origin	O
+	O
i	int
,	O
j	int
-	O
i	int
)	O
;	O
fmt_restore1	O
;	O
}	O
else	O
{	O
fmt_save	O
;	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
ctl_origin	O
+	O
j	int
+	O
2	int
,	O
k	int
-	O
(	O
j	int
+	O
2	int
)	O
)	O
;	O
fmt_restore1	O
;	O
}	O
}	O
else	O
if	O
(	O
atsign	int
)	O
{	O
i	int
=	O
ctl_index	O
;	O
j	int
=	O
fmt_skip	()->(int)
(	O
)	O
;	O
if	O
(	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
']'	O
||	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
'~'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~] expected"	*(char)
)	O
;	O
if	O
(	O
fmt_advance	()->(int)
(	O
)	O
==	O
Cnil	O
)	O
;	O
else	O
{	O
--	O
fmt_index	O
;	O
fmt_save	O
;	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
ctl_origin	O
+	O
i	int
,	O
j	int
-	O
i	int
)	O
;	O
fmt_restore1	O
;	O
}	O
}	O
else	O
{	O
fmt_max_param	(int)->(void)
(	O
1	int
)	O
;	O
if	O
(	O
fmt_nparam	int
==	O
0	int
)	O
{	O
x	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_fixnum	O
)	O
fmt_error	(*(char))->(void)
(	O
"illegal argument for conditional"	*(char)
)	O
;	O
n	int
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
}	O
else	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
n	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
i	int
=	O
ctl_index	O
;	O
for	O
(	O
done	O
=	O
FALSE	O
;	O
;	O
--	O
n	int
)	O
{	O
j	int
=	O
fmt_skip	()->(int)
(	O
)	O
;	O
for	O
(	O
k	int
=	O
j	int
;	O
ctl_string	O
[	O
--	O
k	int
]	O
!=	O
'~'	O
;	O
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
fmt_save	O
;	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
ctl_origin	O
+	O
i	int
,	O
k	int
-	O
i	int
)	O
;	O
fmt_restore1	O
;	O
done	O
=	O
TRUE	O
;	O
}	O
i	int
=	O
j	int
;	O
if	O
(	O
ctl_string	O
[	O
--	O
j	int
]	O
==	O
']'	O
)	O
{	O
if	O
(	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
'~'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~] expected"	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ctl_string	O
[	O
j	int
]	O
==	O
';'	O
)	O
{	O
if	O
(	O
ctl_string	O
[	O
--	O
j	int
]	O
==	O
'~'	O
)	O
continue	O
;	O
if	O
(	O
ctl_string	O
[	O
j	int
]	O
==	O
':'	O
)	O
goto	O
ELSE	O
;	O
}	O
fmt_error	(*(char))->(void)
(	O
"~; or ~] expected"	*(char)
)	O
;	O
}	O
ELSE	O
:	O
if	O
(	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
'~'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~:; expected"	*(char)
)	O
;	O
j	int
=	O
fmt_skip	()->(int)
(	O
)	O
;	O
if	O
(	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
']'	O
||	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
'~'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~] expected"	*(char)
)	O
;	O
if	O
(	O
!	O
done	O
)	O
{	O
fmt_save	O
;	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
ctl_origin	O
+	O
i	int
,	O
j	int
-	O
i	int
)	O
;	O
fmt_restore1	O
;	O
}	O
}	O
}	O
static	O
void	O
fmt_iteration	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
i	int
,	O
n	int
=	O
0	int
;	O
VOL	O
int	O
j	int
;	O
int	O
o	int
;	O
bool	int
colon_close	O
=	O
FALSE	O
;	O
object	O
l	int
;	O
VOL	O
object	O
l0	int
;	O
fmt_old	O
;	O
jmp_buf	O
fmt_jmp_buf0	O
;	O
int	O
up_colon	int
;	O
up_colon	int
=	O
(	O
long	O
)	O
&	O
old_fmt_paramp	O
;	O
fmt_max_param	(int)->(void)
(	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
n	int
,	O
fmt_int	int
,	O
1000000	int
)	O
;	O
i	int
=	O
ctl_index	O
;	O
j	int
=	O
fmt_skip	()->(int)
(	O
)	O
;	O
if	O
(	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
'}'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~} expected"	*(char)
)	O
;	O
if	O
(	O
ctl_string	O
[	O
--	O
j	int
]	O
==	O
':'	O
)	O
{	O
colon_close	O
=	O
TRUE	O
;	O
--	O
j	int
;	O
}	O
if	O
(	O
ctl_string	O
[	O
j	int
]	O
!=	O
'~'	O
)	O
fmt_error	(*(char))->(void)
(	O
"syntax error"	*(char)
)	O
;	O
o	int
=	O
ctl_origin	O
;	O
if	O
(	O
!	O
colon	int
&&	O
!	O
atsign	int
)	O
{	O
l	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
fmt_save	O
;	O
fmt_base	O
=	O
vs_top	O
;	O
fmt_index	O
=	O
0	int
;	O
for	O
(	O
fmt_end	O
=	O
0	int
;	O
!	O
endp	()->(int)
(	O
l	int
)	O
;	O
fmt_end	O
++	O
,	O
l	int
=	O
l	int
->	O
c	int
.	O
c_cdr	O
)	O
vs_check_push	()->(int)
(	O
l	int
->	O
c	int
.	O
c_car	O
)	O
;	O
fmt_jmp_bufp	O
=	O
&	O
fmt_jmp_buf0	O
;	O
if	O
(	O
colon_close	O
)	O
goto	O
L1	O
;	O
while	O
(	O
fmt_index	O
<	O
fmt_end	O
)	O
{	O
L1	O
:	O
if	O
(	O
n	int
--	O
<=	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
up_colon	int
=	O
setjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
)	O
)	O
)	O
{	O
if	O
(	O
--	O
up_colon	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal ~:^"	*(char)
)	O
;	O
break	O
;	O
}	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
o	int
+	O
i	int
,	O
j	int
-	O
i	int
)	O
;	O
}	O
vs_top	O
=	O
fmt_base	O
;	O
fmt_restore	O
;	O
}	O
else	O
if	O
(	O
colon	int
&&	O
!	O
atsign	int
)	O
{	O
l0	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
fmt_save	O
;	O
fmt_base	O
=	O
vs_top	O
;	O
fmt_jmp_bufp	O
=	O
&	O
fmt_jmp_buf0	O
;	O
if	O
(	O
colon_close	O
)	O
goto	O
L2	O
;	O
while	O
(	O
!	O
endp	()->(int)
(	O
l0	int
)	O
)	O
{	O
L2	O
:	O
if	O
(	O
n	int
--	O
<=	O
0	int
)	O
break	O
;	O
l	int
=	O
l0	int
->	O
c	int
.	O
c_car	O
;	O
l0	int
=	O
l0	int
->	O
c	int
.	O
c_cdr	O
;	O
fmt_index	O
=	O
0	int
;	O
for	O
(	O
fmt_end	O
=	O
0	int
;	O
!	O
endp	()->(int)
(	O
l	int
)	O
;	O
fmt_end	O
++	O
,	O
l	int
=	O
l	int
->	O
c	int
.	O
c_cdr	O
)	O
vs_check_push	()->(int)
(	O
l	int
->	O
c	int
.	O
c_car	O
)	O
;	O
if	O
(	O
(	O
up_colon	int
=	O
setjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
)	O
)	O
)	O
{	O
vs_top	O
=	O
fmt_base	O
;	O
if	O
(	O
--	O
up_colon	int
)	O
break	O
;	O
else	O
continue	O
;	O
}	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
o	int
+	O
i	int
,	O
j	int
-	O
i	int
)	O
;	O
vs_top	O
=	O
fmt_base	O
;	O
}	O
fmt_restore	O
;	O
}	O
else	O
if	O
(	O
!	O
colon	int
&&	O
atsign	int
)	O
{	O
fmt_save	O
;	O
fmt_jmp_bufp	O
=	O
&	O
fmt_jmp_buf0	O
;	O
if	O
(	O
colon_close	O
)	O
goto	O
L3	O
;	O
while	O
(	O
fmt_index	O
<	O
fmt_end	O
)	O
{	O
L3	O
:	O
if	O
(	O
n	int
--	O
<=	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
up_colon	int
=	O
setjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
)	O
)	O
)	O
{	O
if	O
(	O
--	O
up_colon	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal ~:^"	*(char)
)	O
;	O
break	O
;	O
}	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
o	int
+	O
i	int
,	O
j	int
-	O
i	int
)	O
;	O
}	O
fmt_restore1	O
;	O
}	O
else	O
if	O
(	O
colon	int
&&	O
atsign	int
)	O
{	O
if	O
(	O
colon_close	O
)	O
goto	O
L4	O
;	O
while	O
(	O
fmt_index	O
<	O
fmt_end	O
)	O
{	O
L4	O
:	O
if	O
(	O
n	int
--	O
<=	O
0	int
)	O
break	O
;	O
l	int
=	O
fmt_advance	()->(int)
(	O
)	O
;	O
fmt_save	O
;	O
fmt_base	O
=	O
vs_top	O
;	O
fmt_index	O
=	O
0	int
;	O
for	O
(	O
fmt_end	O
=	O
0	int
;	O
!	O
endp	()->(int)
(	O
l	int
)	O
;	O
fmt_end	O
++	O
,	O
l	int
=	O
l	int
->	O
c	int
.	O
c_cdr	O
)	O
vs_check_push	()->(int)
(	O
l	int
->	O
c	int
.	O
c_car	O
)	O
;	O
fmt_jmp_bufp	O
=	O
&	O
fmt_jmp_buf0	O
;	O
if	O
(	O
(	O
up_colon	int
=	O
setjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
)	O
)	O
)	O
{	O
vs_top	O
=	O
fmt_base	O
;	O
fmt_restore	O
;	O
if	O
(	O
--	O
up_colon	int
)	O
break	O
;	O
else	O
continue	O
;	O
}	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
o	int
+	O
i	int
,	O
j	int
-	O
i	int
)	O
;	O
vs_top	O
=	O
fmt_base	O
;	O
fmt_restore	O
;	O
}	O
}	O
}	O
static	O
void	O
fmt_justification	(int,int)->(void)
(	O
volatile	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
mincol	int
=	O
0	int
,	O
colinc	int
=	O
0	int
,	O
minpad	int
=	O
0	int
,	O
padchar	int
=	O
0	int
;	O
object	O
fields	O
[	O
FORMAT_DIRECTIVE_LIMIT	int
]	O
;	O
fmt_old	O
;	O
jmp_buf	O
fmt_jmp_buf0	O
;	O
VOL	O
int	O
i	int
,	O
j	int
,	O
n	int
,	O
j0	O
;	O
int	O
k	int
,	O
l	int
,	O
m	int
,	O
l0	int
;	O
int	O
up_colon	int
;	O
VOL	O
int	O
special	O
=	O
0	int
;	O
volatile	O
int	O
spare_spaces	int
=	O
0	int
,	O
line_length	int
=	O
0	int
;	O
vs_mark	O
;	O
up_colon	int
=	O
(	O
long	O
)	O
&	O
old_fmt_paramp	O
;	O
fmt_max_param	(int)->(void)
(	O
4	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
mincol	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
colinc	int
,	O
fmt_int	int
,	O
1	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
minpad	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
3	int
,	O
&	O
padchar	int
,	O
fmt_char	int
,	O
' '	O
)	O
;	O
n	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
n	int
>=	O
FORMAT_DIRECTIVE_LIMIT	int
)	O
fmt_error	(*(char))->(void)
(	O
"too many fields"	*(char)
)	O
;	O
i	int
=	O
ctl_index	O
;	O
j0	O
=	O
j	int
=	O
fmt_skip	()->(int)
(	O
)	O
;	O
while	O
(	O
ctl_string	O
[	O
--	O
j	int
]	O
!=	O
'~'	O
)	O
;	O
fields	O
[	O
n	int
]	O
=	O
make_string_output_stream	()->(int)
(	O
64	int
)	O
;	O
vs_push	()->(int)
(	O
fields	O
[	O
n	int
]	O
)	O
;	O
fmt_save	O
;	O
fmt_jmp_bufp	O
=	O
&	O
fmt_jmp_buf0	O
;	O
if	O
(	O
(	O
up_colon	int
=	O
setjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
)	O
)	O
)	O
{	O
--	O
n	int
;	O
if	O
(	O
--	O
up_colon	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal ~:^"	*(char)
)	O
;	O
fmt_restore1	O
;	O
while	O
(	O
ctl_string	O
[	O
--	O
j0	O
]	O
!=	O
'>'	O
)	O
j0	O
=	O
fmt_skip	()->(int)
(	O
)	O
;	O
if	O
(	O
ctl_string	O
[	O
--	O
j0	O
]	O
!=	O
'~'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~> expected"	*(char)
)	O
;	O
break	O
;	O
}	O
format	(int,int,int)->(void)
(	O
fields	O
[	O
n	int
++	O
]	O
,	O
ctl_origin	O
+	O
i	int
,	O
j	int
-	O
i	int
)	O
;	O
fmt_restore1	O
;	O
if	O
(	O
ctl_string	O
[	O
--	O
j0	O
]	O
==	O
'>'	O
)	O
{	O
if	O
(	O
ctl_string	O
[	O
--	O
j0	O
]	O
!=	O
'~'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~> expected"	*(char)
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
ctl_string	O
[	O
j0	O
]	O
!=	O
';'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~; expected"	*(char)
)	O
;	O
else	O
if	O
(	O
ctl_string	O
[	O
--	O
j0	O
]	O
==	O
':'	O
)	O
{	O
if	O
(	O
n	int
!=	O
1	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal ~:;"	*(char)
)	O
;	O
special	O
=	O
1	int
;	O
for	O
(	O
j	int
=	O
j0	O
;	O
ctl_string	O
[	O
j	int
]	O
!=	O
'~'	O
;	O
--	O
j	int
)	O
;	O
fmt_save	O
;	O
format	(int,int,int)->(void)
(	O
fmt_stream	O
,	O
ctl_origin	O
+	O
j	int
,	O
j0	O
-	O
j	int
+	O
2	int
)	O
;	O
fmt_restore1	O
;	O
spare_spaces	int
=	O
fmt_spare_spaces	int
;	O
line_length	int
=	O
fmt_line_length	int
;	O
}	O
else	O
if	O
(	O
ctl_string	O
[	O
j0	O
]	O
!=	O
'~'	O
)	O
fmt_error	(*(char))->(void)
(	O
"~; expected"	*(char)
)	O
;	O
}	O
for	O
(	O
i	int
=	O
special	O
,	O
l	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
l	int
+=	O
fields	O
[	O
i	int
]	O
->	O
sm	O
.	O
sm_object0	O
->	O
st	O
.	O
st_fillp	O
;	O
m	int
=	O
n	int
-	O
1	int
-	O
special	O
;	O
if	O
(	O
m	int
<=	O
0	int
&&	O
!	O
colon	int
&&	O
!	O
atsign	int
)	O
{	O
m	int
=	O
0	int
;	O
colon	int
=	O
TRUE	O
;	O
}	O
if	O
(	O
colon	int
)	O
m	int
++	O
;	O
if	O
(	O
atsign	int
)	O
m	int
++	O
;	O
l0	int
=	O
l	int
;	O
l	int
+=	O
minpad	int
*	O
m	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
mincol	int
+	O
k	int
*	O
colinc	int
<	O
l	int
;	O
k	int
++	O
)	O
;	O
l	int
=	O
mincol	int
+	O
k	int
*	O
colinc	int
;	O
if	O
(	O
special	O
!=	O
0	int
&&	O
file_column	()->(int)
(	O
fmt_stream	O
)	O
+	O
l	int
+	O
spare_spaces	int
>=	O
line_length	int
)	O
princ	()->(int)
(	O
fields	O
[	O
0	int
]	O
->	O
sm	O
.	O
sm_object0	O
,	O
fmt_stream	O
)	O
;	O
l	int
-=	O
l0	int
;	O
for	O
(	O
i	int
=	O
special	O
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
m	int
>	O
0	int
&&	O
(	O
i	int
>	O
0	int
||	O
colon	int
)	O
)	O
for	O
(	O
j	int
=	O
l	int
/	O
m	int
,	O
l	int
-=	O
j	int
,	O
--	O
m	int
;	O
j	int
>	O
0	int
;	O
--	O
j	int
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
princ	()->(int)
(	O
fields	O
[	O
i	int
]	O
->	O
sm	O
.	O
sm_object0	O
,	O
fmt_stream	O
)	O
;	O
}	O
if	O
(	O
atsign	int
)	O
for	O
(	O
j	int
=	O
l	int
;	O
j	int
>	O
0	int
;	O
--	O
j	int
)	O
writec_stream	()->(int)
(	O
padchar	int
,	O
fmt_stream	O
)	O
;	O
vs_reset	O
;	O
}	O
static	O
void	O
fmt_up_and_out	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
int	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
,	O
k	int
=	O
0	int
;	O
fmt_max_param	(int)->(void)
(	O
3	int
)	O
;	O
fmt_not_atsign	(int)->(void)
(	O
atsign	int
)	O
;	O
if	O
(	O
fmt_nparam	int
==	O
0	int
)	O
{	O
if	O
(	O
fmt_index	O
>=	O
fmt_end	O
)	O
longjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
,	O
++	O
colon	int
)	O
;	O
}	O
else	O
if	O
(	O
fmt_nparam	int
==	O
1	int
)	O
{	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
i	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
longjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
,	O
++	O
colon	int
)	O
;	O
}	O
else	O
if	O
(	O
fmt_nparam	int
==	O
2	int
)	O
{	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
i	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
j	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
i	int
==	O
j	int
)	O
longjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
,	O
++	O
colon	int
)	O
;	O
}	O
else	O
{	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
i	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
j	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
2	int
,	O
&	O
k	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
if	O
(	O
i	int
<=	O
j	int
&&	O
j	int
<=	O
k	int
)	O
longjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
,	O
++	O
colon	int
)	O
;	O
}	O
}	O
static	O
void	O
fmt_semicolon	()->(void)
(	O
bool	int
colon	int
,	O
bool	int
atsign	int
)	O
{	O
fmt_not_atsign	(int)->(void)
(	O
atsign	int
)	O
;	O
if	O
(	O
!	O
colon	int
)	O
fmt_error	(*(char))->(void)
(	O
"~:; expected"	*(char)
)	O
;	O
fmt_max_param	(int)->(void)
(	O
2	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
0	int
,	O
&	O
fmt_spare_spaces	int
,	O
fmt_int	int
,	O
0	int
)	O
;	O
fmt_set_param	(int,*(int),int,int)->(void)
(	O
1	int
,	O
&	O
fmt_line_length	int
,	O
fmt_int	int
,	O
72	int
)	O
;	O
}	O
DEFUNO_NEW	()->(int)
(	O
"FORMAT"	*(char)
,	O
object	O
,	O
fLformat	O
,	O
LISP	O
,	O
2	int
,	O
F_ARG_LIMIT	O
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lformat	O
,	O
(	O
object	O
strm	int
,	O
object	O
control	int
,	O
...	O
)	O
,	O
""	*(char)
)	O
{	O
va_list	O
ap	O
;	O
VOL	O
int	O
nargs	O
=	O
VFUN_NARGS	O
;	O
VOL	O
object	O
x	int
=	O
OBJNULL	O
;	O
jmp_buf	O
fmt_jmp_buf0	O
;	O
bool	int
colon	int
,	O
e	int
;	O
fmt_old	O
;	O
nargs	O
=	O
nargs	O
-	O
2	int
;	O
if	O
(	O
nargs	O
<	O
0	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
if	O
(	O
strm	int
==	O
Cnil	O
)	O
{	O
strm	int
=	O
make_string_output_stream	()->(int)
(	O
64	int
)	O
;	O
x	int
=	O
strm	int
->	O
sm	O
.	O
sm_object0	O
;	O
}	O
else	O
if	O
(	O
strm	int
==	O
Ct	O
)	O
strm	int
=	O
symbol_value	()->(int)
(	O
sLAstandard_outputA	O
)	O
;	O
else	O
if	O
(	O
type_of	()->(int)
(	O
strm	int
)	O
==	O
t_string	O
)	O
{	O
x	int
=	O
strm	int
;	O
if	O
(	O
!	O
x	int
->	O
st	O
.	O
st_hasfillp	O
)	O
FEerror	()->(int)
(	O
"The string ~S doesn't have a fill-pointer."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
strm	int
=	O
make_string_output_stream	()->(int)
(	O
0	int
)	O
;	O
strm	int
->	O
sm	O
.	O
sm_object0	O
=	O
x	int
;	O
}	O
else	O
check_type_stream	()->(int)
(	O
&	O
strm	int
)	O
;	O
check_type_string	()->(int)
(	O
&	O
control	int
)	O
;	O
fmt_save	O
;	O
frs_push	()->(int)
(	O
FRS_PROTECT	O
,	O
Cnil	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
e	int
=	O
TRUE	O
;	O
goto	O
L	O
;	O
}	O
va_start	O
(	O
ap	O
,	O
control	int
)	O
;	O
{	O
object	O
*	O
l	int
;	O
COERCE_VA_LIST	()->(int)
(	O
l	int
,	O
ap	O
,	O
nargs	O
)	O
;	O
fmt_base	O
=	O
l	int
;	O
fmt_index	O
=	O
0	int
;	O
fmt_end	O
=	O
nargs	O
;	O
fmt_jmp_bufp	O
=	O
&	O
fmt_jmp_buf0	O
;	O
if	O
(	O
symbol_value	()->(int)
(	O
sSAindent_formatted_outputA	int
)	O
!=	O
Cnil	O
)	O
fmt_indents	O
=	O
file_column	()->(int)
(	O
strm	int
)	O
;	O
else	O
fmt_indents	O
=	O
0	int
;	O
fmt_string	O
=	O
control	int
;	O
if	O
(	O
(	O
colon	int
=	O
setjmp	()->(int)
(	O
*	O
fmt_jmp_bufp	O
)	O
)	O
)	O
{	O
if	O
(	O
--	O
colon	int
)	O
fmt_error	(*(char))->(void)
(	O
"illegal ~:^"	*(char)
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
if	O
(	O
x	int
!=	O
OBJNULL	O
)	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
else	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
e	int
=	O
FALSE	O
;	O
goto	O
L	O
;	O
}	O
format	(int,int,int)->(void)
(	O
strm	int
,	O
0	int
,	O
control	int
->	O
st	O
.	O
st_fillp	O
)	O
;	O
flush_stream	()->(int)
(	O
strm	int
)	O
;	O
}	O
va_end	O
(	O
ap	O
)	O
;	O
e	int
=	O
FALSE	O
;	O
L	O
:	O
frs_pop	()->(int)
(	O
)	O
;	O
fmt_restore	O
;	O
if	O
(	O
e	int
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
unwind	()->(int)
(	O
nlj_fr	O
,	O
nlj_tag	O
)	O
;	O
}	O
RETURN1	()->(int)
(	O
x	int
==	O
0	int
?	O
Cnil	O
:	O
x	int
)	O
;	O
}	O
object	O
fLformat_1	(int,int,int)->(int)
(	O
object	O
strm	int
,	O
object	O
control	int
,	O
object	O
x	int
)	O
{	O
VFUN_NARGS	O
=	O
3	int
;	O
return	O
FFN	()->(int)
(	O
fLformat	O
)	O
(	O
strm	int
,	O
control	int
,	O
x	int
)	O
;	O
}	O
static	O
void	O
fmt_error	(*(char))->(void)
(	O
char	O
*	O
s	int
)	O
{	O
vs_push	()->(int)
(	O
make_simple_string	()->(int)
(	O
s	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
&	O
ctl_string	O
[	O
ctl_index	O
]	O
-	O
fmt_string	O
->	O
st	O
.	O
st_self	O
)	O
)	O
;	O
FEerror	()->(int)
(	O
"Format error: ~A.~%~V@TV~%\"~A\"~%"	*(char)
,	O
3	int
,	O
vs_top	O
[	O
-	O
2	int
]	O
,	O
vs_top	O
[	O
-	O
1	int
]	O
,	O
fmt_string	O
)	O
;	O
}	O
DEFVAR	()->(int)
(	O
"*INDENT-FORMATTED-OUTPUT*"	*(char)
,	O
sSAindent_formatted_outputA	int
,	O
SI	O
,	O
Cnil	O
,	O
""	*(char)
)	O
;	O
void	O
gcl_init_format	()->(void)
(	O
void	O
)	O
{	O
fmt_temporary_stream	int
=	O
make_string_output_stream	()->(int)
(	O
64	int
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
fmt_temporary_stream	int
)	O
;	O
fmt_temporary_string	int
=	O
fmt_temporary_stream	int
->	O
sm	O
.	O
sm_object0	O
;	O
}	O
