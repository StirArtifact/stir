int	O
use_file_to_check_type	int
=	O
1	int
;	O
static	O
char	O
*	O
data	*(void)
=	O
NULL	O
;	O
void	O
flush_extension_file	()->(void)
(	O
void	O
)	O
{	O
g_free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
data	*(void)
=	O
NULL	O
;	O
}	O
typedef	O
char	O
*	O
(	O
*	O
quote_func_t	*((*(char),int)->(*(char)))
)	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
quote_percent	int
)	O
;	O
static	O
void	O
exec_extension	(*(char),*(char),*(int),int)->(void)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
const	O
char	O
*	O
data	*(void)
,	O
int	O
*	O
move_dir	*(int)
,	O
int	O
start_line	long
)	O
{	O
char	O
*	O
file_name	*(char)
;	O
int	O
cmd_file_fd	int
;	O
FILE	struct
*	O
cmd_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
cmd	*(char)
=	O
NULL	O
;	O
int	O
expand_prefix_found	int
=	O
0	int
;	O
int	O
parameter_found	int
=	O
0	int
;	O
char	O
prompt	*(char)
[	O
80	int
]	O
;	O
int	O
run_view	int
=	O
0	int
;	O
int	O
def_hex_mode	int
=	O
default_hex_mode	int
,	O
changed_hex_mode	int
=	O
0	int
;	O
int	O
def_nroff_flag	int
=	O
default_nroff_flag	int
,	O
changed_nroff_flag	int
=	O
0	int
;	O
int	O
written_nonspace	int
=	O
0	int
;	O
int	O
is_cd	int
=	O
0	int
;	O
char	O
buffer	*(char)
[	O
1024	int
]	O
;	O
char	O
*	O
p	*(void)
=	O
0	int
;	O
char	O
*	O
localcopy	*(char)
=	O
NULL	O
;	O
int	O
do_local_copy	int
;	O
time_t	long
localmtime	long
=	O
0	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
mystat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
quote_func_t	*((*(char),int)->(*(char)))
quote_func	*((*(char),int)->(*(char)))
=	O
name_quote	(*(char),int)->(*(char))
;	O
g_return_if_fail	O
(	O
filename	*(char)
!=	O
NULL	O
)	O
;	O
g_return_if_fail	O
(	O
data	*(void)
!=	O
NULL	O
)	O
;	O
if	O
(	O
!	O
vfs_file_is_local	(*(char))->(int)
(	O
filename	*(char)
)	O
)	O
do_local_copy	int
=	O
1	int
;	O
else	O
do_local_copy	int
=	O
0	int
;	O
cmd_file_fd	int
=	O
mc_mkstemps	(*(*(char)),*(char),*(char))->(int)
(	O
&	O
file_name	*(char)
,	O
"mcext"	*(char)
,	O
SCRIPT_SUFFIX	*(char)
)	O
;	O
if	O
(	O
cmd_file_fd	int
==	O
-	O
1	int
)	O
{	O
message	*(char)
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot create temporary command file \n %s "	*(char)
)	O
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
;	O
}	O
cmd_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
cmd_file_fd	int
,	O
"w"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"#! /bin/sh\n"	*(char)
,	O
cmd_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
prompt	*(char)
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
;	O
*	O
data	*(void)
&&	O
*	O
data	*(void)
!=	O
'\n'	O
;	O
data	*(void)
++	O
)	O
{	O
if	O
(	O
parameter_found	int
)	O
{	O
if	O
(	O
*	O
data	*(void)
==	O
'}'	O
)	O
{	O
char	O
*	O
parameter	*(char)
;	O
parameter_found	int
=	O
0	int
;	O
parameter	*(char)
=	O
input_dialog	(*(char),*(char),*(char))->(*(char))
(	O
_	O
(	O
" Parameter "	*(char)
)	O
,	O
prompt	*(char)
,	O
""	*(char)
)	O
;	O
if	O
(	O
!	O
parameter	*(char)
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
cmd_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
unlink	(*(char))->(int)
(	O
file_name	*(char)
)	O
;	O
if	O
(	O
localcopy	*(char)
)	O
{	O
mc_ungetlocalcopy	(*(char),*(char),int)->(int)
(	O
filename	*(char)
,	O
localcopy	*(char)
,	O
0	int
)	O
;	O
g_free	(*(void))->(void)
(	O
localcopy	*(char)
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
file_name	*(char)
)	O
;	O
return	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
parameter	*(char)
,	O
cmd_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
written_nonspace	int
=	O
1	int
;	O
g_free	(*(void))->(void)
(	O
parameter	*(char)
)	O
;	O
}	O
else	O
{	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
prompt	*(char)
)	O
;	O
if	O
(	O
len	int
<	O
sizeof	O
(	O
prompt	*(char)
)	O
-	O
1	int
)	O
{	O
prompt	*(char)
[	O
len	int
]	O
=	O
*	O
data	*(void)
;	O
prompt	*(char)
[	O
len	int
+	O
1	int
]	O
=	O
0	int
;	O
}	O
}	O
}	O
else	O
if	O
(	O
expand_prefix_found	int
)	O
{	O
expand_prefix_found	int
=	O
0	int
;	O
if	O
(	O
*	O
data	*(void)
==	O
'{'	O
)	O
parameter_found	int
=	O
1	int
;	O
else	O
{	O
int	O
i	array(int)
=	O
check_format_view	(*(char))->(int)
(	O
data	*(void)
)	O
;	O
char	O
*	O
v	*(void)
;	O
if	O
(	O
i	array(int)
)	O
{	O
data	*(void)
+=	O
i	array(int)
-	O
1	int
;	O
run_view	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
i	array(int)
=	O
check_format_cd	(*(char))->(int)
(	O
data	*(void)
)	O
)	O
>	O
0	int
)	O
{	O
is_cd	int
=	O
1	int
;	O
quote_func	*((*(char),int)->(*(char)))
=	O
fake_name_quote	(*(char),int)->(*(char))
;	O
do_local_copy	int
=	O
0	int
;	O
p	*(void)
=	O
buffer	*(char)
;	O
data	*(void)
+=	O
i	array(int)
-	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
i	array(int)
=	O
check_format_var	(*(char),*(*(char)))->(int)
(	O
data	*(void)
,	O
&	O
v	*(void)
)	O
)	O
>	O
0	int
&&	O
v	*(void)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
v	*(void)
,	O
cmd_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
g_free	(*(void))->(void)
(	O
v	*(void)
)	O
;	O
data	*(void)
+=	O
i	array(int)
;	O
}	O
else	O
{	O
char	O
*	O
text	*(char)
;	O
if	O
(	O
*	O
data	*(void)
==	O
'f'	O
)	O
{	O
if	O
(	O
do_local_copy	int
)	O
{	O
localcopy	*(char)
=	O
mc_getlocalcopy	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
if	O
(	O
localcopy	*(char)
==	O
NULL	O
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
cmd_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
unlink	(*(char))->(int)
(	O
file_name	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
file_name	*(char)
)	O
;	O
return	O
;	O
}	O
mc_stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
localcopy	*(char)
,	O
&	O
mystat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
localmtime	long
=	O
mystat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
;	O
text	*(char)
=	O
(	O
*	O
quote_func	*((*(char),int)->(*(char)))
)	O
(	O
localcopy	*(char)
,	O
0	int
)	O
;	O
}	O
else	O
{	O
text	*(char)
=	O
(	O
*	O
quote_func	*((*(char),int)->(*(char)))
)	O
(	O
filename	*(char)
,	O
0	int
)	O
;	O
}	O
}	O
else	O
text	*(char)
=	O
expand_format	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),char,int)->(*(char))
(	O
NULL	O
,	O
*	O
data	*(void)
,	O
!	O
is_cd	int
)	O
;	O
if	O
(	O
!	O
is_cd	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
text	*(char)
,	O
cmd_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
text	*(char)
)	O
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
0	int
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
text	*(char)
)	O
;	O
written_nonspace	int
=	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
data	*(void)
==	O
'%'	O
)	O
expand_prefix_found	int
=	O
1	int
;	O
else	O
{	O
if	O
(	O
*	O
data	*(void)
!=	O
' '	O
&&	O
*	O
data	*(void)
!=	O
'\t'	O
)	O
written_nonspace	int
=	O
1	int
;	O
if	O
(	O
is_cd	int
)	O
*	O
(	O
p	*(void)
++	O
)	O
=	O
*	O
data	*(void)
;	O
else	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
*	O
data	*(void)
,	O
cmd_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
run_view	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
cmd_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n/bin/rm -f %s\n"	*(char)
,	O
file_name	*(char)
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
cmd_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
(	O
run_view	int
&&	O
!	O
written_nonspace	int
)	O
||	O
is_cd	int
)	O
{	O
unlink	(*(char))->(int)
(	O
file_name	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
file_name	*(char)
)	O
;	O
file_name	*(char)
=	O
NULL	O
;	O
}	O
else	O
{	O
chmod	(*(char),int)->(int)
(	O
file_name	*(char)
,	O
S_IRWXU	O
)	O
;	O
cmd	*(char)
=	O
g_strconcat	(*(char))->(*(char))
(	O
"/bin/sh "	*(char)
,	O
file_name	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
if	O
(	O
run_view	int
)	O
{	O
altered_hex_mode	int
=	O
0	int
;	O
altered_nroff_flag	int
=	O
0	int
;	O
if	O
(	O
def_hex_mode	int
!=	O
default_hex_mode	int
)	O
changed_hex_mode	int
=	O
1	int
;	O
if	O
(	O
def_nroff_flag	int
!=	O
default_nroff_flag	int
)	O
changed_nroff_flag	int
=	O
1	int
;	O
if	O
(	O
written_nonspace	int
)	O
{	O
mc_internal_viewer	(*(char),*(char),*(int),int)->(int)
(	O
cmd	*(char)
,	O
filename	*(char)
,	O
move_dir	*(int)
,	O
start_line	long
)	O
;	O
unlink	(*(char))->(int)
(	O
file_name	*(char)
)	O
;	O
}	O
else	O
{	O
mc_internal_viewer	(*(char),*(char),*(int),int)->(int)
(	O
NULL	O
,	O
filename	*(char)
,	O
move_dir	*(int)
,	O
start_line	long
)	O
;	O
}	O
if	O
(	O
changed_hex_mode	int
&&	O
!	O
altered_hex_mode	int
)	O
default_hex_mode	int
=	O
def_hex_mode	int
;	O
if	O
(	O
changed_nroff_flag	int
&&	O
!	O
altered_nroff_flag	int
)	O
default_nroff_flag	int
=	O
def_nroff_flag	int
;	O
repaint_screen	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
is_cd	int
)	O
{	O
char	O
*	O
q	*(char)
;	O
*	O
p	*(void)
=	O
0	int
;	O
p	*(void)
=	O
buffer	*(char)
;	O
q	*(char)
=	O
p	*(void)
+	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
-	O
1	int
;	O
while	O
(	O
q	*(char)
>=	O
p	*(void)
&&	O
(	O
*	O
q	*(char)
==	O
' '	O
||	O
*	O
q	*(char)
==	O
'\t'	O
)	O
)	O
q	*(char)
--	O
;	O
q	*(char)
[	O
1	int
]	O
=	O
0	int
;	O
do_cd	(*(char),enum(int,int))->(int)
(	O
p	*(void)
,	O
cd_parse_command	int
)	O
;	O
}	O
else	O
{	O
shell_execute	(*(char),int)->(void)
(	O
cmd	*(char)
,	O
EXECUTE_INTERNAL	O
)	O
;	O
if	O
(	O
console_flag	char
)	O
{	O
handle_console	(char)->(void)
(	O
CONSOLE_SAVE	int
)	O
;	O
if	O
(	O
output_lines	int
&&	O
keybar_visible	int
)	O
{	O
show_console_contents	(int,char,char)->(void)
(	O
output_start_y	int
,	O
LINES	O
-	O
keybar_visible	int
-	O
output_lines	int
-	O
1	int
,	O
LINES	O
-	O
keybar_visible	int
-	O
1	int
)	O
;	O
}	O
}	O
}	O
g_free	(*(void))->(void)
(	O
file_name	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
cmd	*(char)
)	O
;	O
if	O
(	O
localcopy	*(char)
)	O
{	O
mc_stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
localcopy	*(char)
,	O
&	O
mystat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
mc_ungetlocalcopy	(*(char),*(char),int)->(int)
(	O
filename	*(char)
,	O
localcopy	*(char)
,	O
localmtime	long
!=	O
mystat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
)	O
;	O
g_free	(*(void))->(void)
(	O
localcopy	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
get_file_type_local	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
char	O
*	O
buf	*(char)
,	O
int	O
buflen	int
)	O
{	O
int	O
read_bytes	int
=	O
0	int
;	O
char	O
*	O
tmp	*(char)
=	O
name_quote	(*(char),int)->(*(char))
(	O
filename	*(char)
,	O
0	int
)	O
;	O
char	O
*	O
command	*(char)
=	O
g_strconcat	(*(char))->(*(char))
(	O
FILE_CMD	*(char)
,	O
tmp	*(char)
,	O
" 2>/dev/null"	*(char)
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
FILE	struct
*	O
f	float
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
command	*(char)
,	O
"r"	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
command	*(char)
)	O
;	O
if	O
(	O
f	float
!=	O
NULL	O
)	O
{	O
read_bytes	int
=	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
buflen	int
,	O
f	float
)	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
read_bytes	int
==	O
0	int
)	O
buf	*(char)
[	O
0	int
]	O
=	O
0	int
;	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	float
)	O
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
return	O
(	O
read_bytes	int
>	O
0	int
)	O
;	O
}	O
static	O
int	O
regex_check_type	(*(char),*(char),*(int))->(int)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
const	O
char	O
*	O
ptr	*(*(void))
,	O
int	O
*	O
have_type	*(int)
)	O
{	O
int	O
found	int
=	O
0	int
;	O
static	O
char	O
content_string	array(char)
[	O
2048	int
]	O
;	O
static	O
int	O
content_shift	int
=	O
0	int
;	O
static	O
int	O
got_data	int
=	O
0	int
;	O
if	O
(	O
!	O
use_file_to_check_type	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
*	O
have_type	*(int)
)	O
{	O
char	O
*	O
realname	*(char)
;	O
char	O
*	O
localfile	*(char)
;	O
*	O
have_type	*(int)
=	O
1	int
;	O
localfile	*(char)
=	O
mc_getlocalcopy	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
if	O
(	O
!	O
localfile	*(char)
)	O
return	O
-	O
1	int
;	O
realname	*(char)
=	O
localfile	*(char)
;	O
got_data	int
=	O
get_file_type_local	(*(char),*(char),int)->(int)
(	O
localfile	*(char)
,	O
content_string	array(char)
,	O
sizeof	O
(	O
content_string	array(char)
)	O
)	O
;	O
mc_ungetlocalcopy	(*(char),*(char),int)->(int)
(	O
filename	*(char)
,	O
localfile	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
got_data	int
>	O
0	int
)	O
{	O
char	O
*	O
pp	*(*(void))
;	O
content_string	array(char)
[	O
sizeof	O
(	O
content_string	array(char)
)	O
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
(	O
pp	*(*(void))
=	O
strchr	(*(char),int)->(*(char))
(	O
content_string	array(char)
,	O
'\n'	O
)	O
)	O
!=	O
0	int
)	O
*	O
pp	*(*(void))
=	O
0	int
;	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
content_string	array(char)
,	O
realname	*(char)
,	O
strlen	(*(char))->(long)
(	O
realname	*(char)
)	O
)	O
)	O
{	O
content_shift	int
=	O
strlen	(*(char))->(long)
(	O
realname	*(char)
)	O
;	O
if	O
(	O
content_string	array(char)
[	O
content_shift	int
]	O
==	O
':'	O
)	O
{	O
for	O
(	O
content_shift	int
++	O
;	O
content_string	array(char)
[	O
content_shift	int
]	O
==	O
' '	O
||	O
content_string	array(char)
[	O
content_shift	int
]	O
==	O
'\t'	O
;	O
content_shift	int
++	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
content_string	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
}	O
g_free	(*(void))->(void)
(	O
realname	*(char)
)	O
;	O
}	O
if	O
(	O
got_data	int
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
content_string	array(char)
[	O
0	int
]	O
&&	O
regexp_match	(*(char),*(char),int)->(int)
(	O
ptr	*(*(void))
,	O
content_string	array(char)
+	O
content_shift	int
,	O
match_regex	int
)	O
)	O
{	O
found	int
=	O
1	int
;	O
}	O
return	O
found	int
;	O
}	O
int	O
regex_command	(*(char),*(char),*(int))->(int)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
const	O
char	O
*	O
action	int
,	O
int	O
*	O
move_dir	*(int)
)	O
{	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(char)
,	O
*	O
r	*(struct)
,	O
c	int
;	O
int	O
file_len	int
=	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
;	O
int	O
found	int
=	O
0	int
;	O
int	O
error_flag	int
=	O
0	int
;	O
int	O
ret	int
=	O
0	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
mystat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
view_at_line_number	int
;	O
char	O
*	O
include_target	*(char)
;	O
int	O
include_target_len	int
;	O
int	O
have_type	*(int)
=	O
0	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
action	int
,	O
"View:"	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
{	O
view_at_line_number	int
=	O
atoi	(*(char))->(int)
(	O
action	int
+	O
5	int
)	O
;	O
action	int
=	O
"View"	*(char)
;	O
}	O
else	O
{	O
view_at_line_number	int
=	O
0	int
;	O
}	O
if	O
(	O
data	*(void)
==	O
NULL	O
)	O
{	O
char	O
*	O
extension_file	*(char)
;	O
int	O
mc_user_ext	int
=	O
1	int
;	O
int	O
home_error	int
=	O
0	int
;	O
extension_file	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
home_dir	*(char)
,	O
MC_USER_EXT	*(char)
)	O
;	O
if	O
(	O
!	O
exist_file	(*(char))->(int)
(	O
extension_file	*(char)
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
extension_file	*(char)
)	O
;	O
check_stock_mc_ext	O
:	O
extension_file	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
mc_home	*(char)
,	O
MC_LIB_EXT	*(char)
)	O
;	O
mc_user_ext	int
=	O
0	int
;	O
}	O
data	*(void)
=	O
load_file	(*(char))->(*(char))
(	O
extension_file	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
extension_file	*(char)
)	O
;	O
if	O
(	O
data	*(void)
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
strstr	(*(char),*(char))->(*(char))
(	O
data	*(void)
,	O
"default/"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
strstr	(*(char),*(char))->(*(char))
(	O
data	*(void)
,	O
"regex/"	*(char)
)	O
&&	O
!	O
strstr	(*(char),*(char))->(*(char))
(	O
data	*(void)
,	O
"shell/"	*(char)
)	O
&&	O
!	O
strstr	(*(char),*(char))->(*(char))
(	O
data	*(void)
,	O
"type/"	*(char)
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
data	*(void)
=	O
NULL	O
;	O
if	O
(	O
mc_user_ext	int
)	O
{	O
home_error	int
=	O
1	int
;	O
goto	O
check_stock_mc_ext	O
;	O
}	O
else	O
{	O
char	O
*	O
title	*(char)
=	O
g_strdup_printf	(*(char))->(*(char))
(	O
_	O
(	O
" %s%s file error"	*(char)
)	O
,	O
mc_home	*(char)
,	O
MC_LIB_EXT	*(char)
)	O
;	O
message	*(char)
(	O
1	int
,	O
title	*(char)
,	O
_	O
(	O
"The format of the %smc.ext "	*(char)
"file has changed with version 3.0.  It seems that "	*(char)
"the installation failed.  Please fetch a fresh "	*(char)
"copy from the Midnight Commander package."	*(char)
)	O
,	O
mc_home	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
title	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
if	O
(	O
home_error	int
)	O
{	O
char	O
*	O
title	*(char)
=	O
g_strdup_printf	(*(char))->(*(char))
(	O
_	O
(	O
" ~/%s file error "	*(char)
)	O
,	O
MC_USER_EXT	*(char)
)	O
;	O
message	*(char)
(	O
1	int
,	O
title	*(char)
,	O
_	O
(	O
"The format of the ~/%s file has "	*(char)
"changed with version 3.0.  You may either want to copy "	*(char)
"it from %smc.ext or use that file as an example of how "	*(char)
"to write it."	*(char)
)	O
,	O
MC_USER_EXT	*(char)
,	O
mc_home	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
title	*(char)
)	O
;	O
}	O
}	O
mc_stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
filename	*(char)
,	O
&	O
mystat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
include_target	*(char)
=	O
NULL	O
;	O
include_target_len	int
=	O
0	int
;	O
for	O
(	O
p	*(void)
=	O
data	*(void)
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
{	O
for	O
(	O
q	*(char)
=	O
p	*(void)
;	O
*	O
q	*(char)
==	O
' '	O
||	O
*	O
q	*(char)
==	O
'\t'	O
;	O
q	*(char)
++	O
)	O
;	O
if	O
(	O
*	O
q	*(char)
==	O
'\n'	O
||	O
!	O
*	O
q	*(char)
)	O
p	*(void)
=	O
q	*(char)
;	O
if	O
(	O
*	O
p	*(void)
==	O
'#'	O
)	O
while	O
(	O
*	O
p	*(void)
&&	O
*	O
p	*(void)
!=	O
'\n'	O
)	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'\n'	O
)	O
continue	O
;	O
if	O
(	O
!	O
*	O
p	*(void)
)	O
break	O
;	O
if	O
(	O
p	*(void)
==	O
q	*(char)
)	O
{	O
found	int
=	O
0	int
;	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
'\n'	O
)	O
;	O
if	O
(	O
q	*(char)
==	O
NULL	O
)	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
0	int
)	O
;	O
c	int
=	O
*	O
q	*(char)
;	O
*	O
q	*(char)
=	O
0	int
;	O
if	O
(	O
include_target	*(char)
)	O
{	O
if	O
(	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
"include/"	*(char)
,	O
8	int
)	O
==	O
0	int
)	O
&&	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
+	O
8	int
,	O
include_target	*(char)
,	O
include_target_len	int
)	O
==	O
0	int
)	O
)	O
found	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
"regex/"	*(char)
,	O
6	int
)	O
)	O
{	O
p	*(void)
+=	O
6	int
;	O
if	O
(	O
regexp_match	(*(char),*(char),int)->(int)
(	O
p	*(void)
,	O
filename	*(char)
,	O
match_regex	int
)	O
)	O
found	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
"directory/"	*(char)
,	O
10	int
)	O
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
mystat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
&&	O
regexp_match	(*(char),*(char),int)->(int)
(	O
p	*(void)
+	O
10	int
,	O
filename	*(char)
,	O
match_regex	int
)	O
)	O
found	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
"shell/"	*(char)
,	O
6	int
)	O
)	O
{	O
p	*(void)
+=	O
6	int
;	O
if	O
(	O
*	O
p	*(void)
==	O
'.'	O
&&	O
file_len	int
>=	O
(	O
q	*(char)
-	O
p	*(void)
)	O
)	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
filename	*(char)
+	O
file_len	int
-	O
(	O
q	*(char)
-	O
p	*(void)
)	O
,	O
q	*(char)
-	O
p	*(void)
)	O
)	O
found	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
q	*(char)
-	O
p	*(void)
==	O
file_len	int
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
filename	*(char)
,	O
q	*(char)
-	O
p	*(void)
)	O
)	O
found	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
"type/"	*(char)
,	O
5	int
)	O
)	O
{	O
int	O
res	int
;	O
p	*(void)
+=	O
5	int
;	O
res	int
=	O
regex_check_type	(*(char),*(char),*(int))->(int)
(	O
filename	*(char)
,	O
p	*(void)
,	O
&	O
have_type	*(int)
)	O
;	O
if	O
(	O
res	int
==	O
1	int
)	O
found	int
=	O
1	int
;	O
if	O
(	O
res	int
==	O
-	O
1	int
)	O
error_flag	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
"default/"	*(char)
,	O
8	int
)	O
)	O
{	O
found	int
=	O
1	int
;	O
}	O
*	O
q	*(char)
=	O
c	int
;	O
p	*(void)
=	O
q	*(char)
;	O
if	O
(	O
!	O
*	O
p	*(void)
)	O
break	O
;	O
}	O
else	O
{	O
p	*(void)
=	O
q	*(char)
;	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
'\n'	O
)	O
;	O
if	O
(	O
q	*(char)
==	O
NULL	O
)	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
0	int
)	O
;	O
if	O
(	O
found	int
&&	O
!	O
error_flag	int
)	O
{	O
r	*(struct)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
'='	O
)	O
;	O
if	O
(	O
r	*(struct)
!=	O
NULL	O
)	O
{	O
c	int
=	O
*	O
r	*(struct)
;	O
*	O
r	*(struct)
=	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"Include"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
t	long
;	O
include_target	*(char)
=	O
p	*(void)
+	O
8	int
;	O
t	long
=	O
strchr	(*(char),int)->(*(char))
(	O
include_target	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
t	long
)	O
*	O
t	long
=	O
0	int
;	O
include_target_len	int
=	O
strlen	(*(char))->(long)
(	O
include_target	*(char)
)	O
;	O
if	O
(	O
t	long
)	O
*	O
t	long
=	O
'\n'	O
;	O
*	O
r	*(struct)
=	O
c	int
;	O
p	*(void)
=	O
q	*(char)
;	O
found	int
=	O
0	int
;	O
if	O
(	O
!	O
*	O
p	*(void)
)	O
break	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
action	int
,	O
p	*(void)
)	O
)	O
{	O
*	O
r	*(struct)
=	O
c	int
;	O
for	O
(	O
p	*(void)
=	O
r	*(struct)
+	O
1	int
;	O
*	O
p	*(void)
==	O
' '	O
||	O
*	O
p	*(void)
==	O
'\t'	O
;	O
p	*(void)
++	O
)	O
;	O
if	O
(	O
p	*(void)
<	O
q	*(char)
)	O
{	O
char	O
*	O
filename_copy	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
exec_extension	(*(char),*(char),*(int),int)->(void)
(	O
filename_copy	*(char)
,	O
r	*(struct)
+	O
1	int
,	O
move_dir	*(int)
,	O
view_at_line_number	int
)	O
;	O
g_free	(*(void))->(void)
(	O
filename_copy	*(char)
)	O
;	O
ret	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
else	O
*	O
r	*(struct)
=	O
c	int
;	O
}	O
}	O
p	*(void)
=	O
q	*(char)
;	O
if	O
(	O
!	O
*	O
p	*(void)
)	O
break	O
;	O
}	O
}	O
if	O
(	O
error_flag	int
)	O
return	O
-	O
1	int
;	O
return	O
ret	int
;	O
}	O
