error_t	O
pager_read_page	(*(struct),int,*(int),*(int))->(int)
(	O
struct	O
user_pager_info	O
*	O
upi	*(struct)
,	O
vm_offset_t	O
page	int
,	O
vm_address_t	O
*	O
buf	*(int)
,	O
int	O
*	O
writelock	*(int)
)	O
{	O
error_t	O
err	O
;	O
size_t	O
read	O
=	O
0	int
;	O
int	O
want	int
=	O
vm_page_size	O
;	O
struct	O
dev	*(struct)
*	O
dev	*(struct)
=	O
(	O
struct	O
dev	*(struct)
*	O
)	O
upi	*(struct)
;	O
struct	O
store	*(struct)
*	O
store	*(struct)
=	O
dev	*(struct)
->	O
store	*(struct)
;	O
if	O
(	O
page	int
+	O
want	int
>	O
store	*(struct)
->	O
size	*(int)
)	O
want	int
=	O
store	*(struct)
->	O
size	*(int)
-	O
page	int
;	O
err	O
=	O
dev_read	()->(int)
(	O
dev	*(struct)
,	O
page	int
,	O
want	int
,	O
(	O
void	O
*	O
*	O
)	O
buf	*(int)
,	O
&	O
read	O
)	O
;	O
if	O
(	O
!	O
err	O
&&	O
want	int
<	O
vm_page_size	O
)	O
memset	O
(	O
(	O
char	O
*	O
)	O
*	O
buf	*(int)
+	O
want	int
,	O
'\0'	O
,	O
vm_page_size	O
-	O
want	int
)	O
;	O
*	O
writelock	*(int)
=	O
(	O
store	*(struct)
->	O
flags	O
&	O
STORE_READONLY	O
)	O
;	O
if	O
(	O
err	O
||	O
read	O
<	O
want	int
)	O
return	O
EIO	O
;	O
else	O
return	O
0	int
;	O
}	O
error_t	O
pager_write_page	(*(struct),int,int)->(int)
(	O
struct	O
user_pager_info	O
*	O
upi	*(struct)
,	O
vm_offset_t	O
page	int
,	O
vm_address_t	O
buf	*(int)
)	O
{	O
struct	O
dev	*(struct)
*	O
dev	*(struct)
=	O
(	O
struct	O
dev	*(struct)
*	O
)	O
upi	*(struct)
;	O
struct	O
store	*(struct)
*	O
store	*(struct)
=	O
dev	*(struct)
->	O
store	*(struct)
;	O
if	O
(	O
store	*(struct)
->	O
flags	O
&	O
STORE_READONLY	O
)	O
return	O
EROFS	O
;	O
else	O
{	O
error_t	O
err	O
;	O
size_t	O
written	O
;	O
int	O
want	int
=	O
vm_page_size	O
;	O
if	O
(	O
page	int
+	O
want	int
>	O
store	*(struct)
->	O
size	*(int)
)	O
want	int
=	O
store	*(struct)
->	O
size	*(int)
-	O
page	int
;	O
err	O
=	O
dev_write	()->(int)
(	O
dev	*(struct)
,	O
page	int
,	O
(	O
char	O
*	O
)	O
buf	*(int)
,	O
want	int
,	O
&	O
written	O
)	O
;	O
munmap	()->(int)
(	O
(	O
caddr_t	O
)	O
buf	*(int)
,	O
vm_page_size	O
)	O
;	O
if	O
(	O
err	O
||	O
written	O
<	O
want	int
)	O
return	O
EIO	O
;	O
else	O
return	O
0	int
;	O
}	O
}	O
error_t	O
pager_unlock_page	(*(struct),int)->(int)
(	O
struct	O
user_pager_info	O
*	O
upi	*(struct)
,	O
vm_offset_t	O
address	int
)	O
{	O
struct	O
dev	*(struct)
*	O
dev	*(struct)
=	O
(	O
struct	O
dev	*(struct)
*	O
)	O
upi	*(struct)
;	O
if	O
(	O
dev	*(struct)
->	O
store	*(struct)
->	O
flags	O
&	O
STORE_READONLY	O
)	O
return	O
EROFS	O
;	O
else	O
return	O
0	int
;	O
}	O
void	O
pager_notify_evict	(*(struct),int)->(void)
(	O
struct	O
user_pager_info	O
*	O
pager	*(struct)
,	O
vm_offset_t	O
page	int
)	O
{	O
assert	()->(int)
(	O
!	O
"unrequested notification on eviction"	*(char)
)	O
;	O
}	O
error_t	O
pager_report_extent	(*(struct),*(int),*(int))->(int)
(	O
struct	O
user_pager_info	O
*	O
upi	*(struct)
,	O
vm_address_t	O
*	O
offset	*(int)
,	O
vm_size_t	O
*	O
size	*(int)
)	O
{	O
*	O
offset	*(int)
=	O
0	int
;	O
*	O
size	*(int)
=	O
(	O
(	O
struct	O
dev	*(struct)
*	O
)	O
upi	*(struct)
)	O
->	O
store	*(struct)
->	O
size	*(int)
;	O
return	O
0	int
;	O
}	O
void	O
pager_clear_user_data	(*(struct))->(void)
(	O
struct	O
user_pager_info	O
*	O
upi	*(struct)
)	O
{	O
struct	O
dev	*(struct)
*	O
dev	*(struct)
=	O
(	O
struct	O
dev	*(struct)
*	O
)	O
upi	*(struct)
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
dev	*(struct)
->	O
pager_lock	O
)	O
;	O
dev	*(struct)
->	O
pager	*(struct)
=	O
0	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
dev	*(struct)
->	O
pager_lock	O
)	O
;	O
}	O
static	O
struct	O
port_bucket	O
*	O
pager_port_bucket	*(struct)
=	O
0	int
;	O
static	O
struct	O
pager_requests	*(struct)
*	O
pager_requests	*(struct)
;	O
static	O
void	O
init_dev_paging	()->(void)
(	O
)	O
{	O
if	O
(	O
!	O
pager_port_bucket	*(struct)
)	O
{	O
static	O
pthread_mutex_t	O
pager_global_lock	int
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
pager_global_lock	int
)	O
;	O
if	O
(	O
pager_port_bucket	*(struct)
==	O
NULL	O
)	O
{	O
error_t	O
err	O
;	O
pager_port_bucket	*(struct)
=	O
ports_create_bucket	()->(int)
(	O
)	O
;	O
err	O
=	O
pager_start_workers	()->(int)
(	O
pager_port_bucket	*(struct)
,	O
&	O
pager_requests	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
{	O
errno	O
=	O
err	O
;	O
error	()->(int)
(	O
0	int
,	O
err	O
,	O
"pager_start_workers"	*(char)
)	O
;	O
}	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
pager_global_lock	int
)	O
;	O
}	O
}	O
void	O
pager_dropweak	(*(struct))->(void)
(	O
struct	O
user_pager_info	O
*	O
upi	*(struct)
__attribute__	O
(	O
(	O
unused	O
)	O
)	O
)	O
{	O
}	O
int	O
dev_stop_paging	(*(struct),int)->(int)
(	O
struct	O
dev	*(struct)
*	O
dev	*(struct)
,	O
int	O
nosync	int
)	O
{	O
size_t	O
num_pagers	O
=	O
(	O
pager_port_bucket	*(struct)
?	O
ports_count_bucket	()->(int)
(	O
pager_port_bucket	*(struct)
)	O
:	O
0	int
)	O
;	O
if	O
(	O
num_pagers	O
>	O
0	int
&&	O
!	O
nosync	int
)	O
{	O
error_t	O
block_cache	O
(	O
void	O
*	O
arg	O
)	O
{	O
struct	O
pager	*(struct)
*	O
p	O
=	O
arg	O
;	O
pager_change_attributes	O
(	O
p	O
,	O
0	int
,	O
MEMORY_OBJECT_COPY_DELAY	O
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
enable_cache	O
(	O
void	O
*	O
arg	O
)	O
{	O
struct	O
pager	*(struct)
*	O
p	O
=	O
arg	O
;	O
pager_change_attributes	O
(	O
p	O
,	O
1	int
,	O
MEMORY_OBJECT_COPY_DELAY	O
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
ports_bucket_iterate	()->(int)
(	O
pager_port_bucket	*(struct)
,	O
block_cache	O
)	O
;	O
sleep	()->(int)
(	O
1	int
)	O
;	O
num_pagers	O
=	O
ports_count_bucket	()->(int)
(	O
pager_port_bucket	*(struct)
)	O
;	O
if	O
(	O
num_pagers	O
>	O
0	int
)	O
ports_bucket_iterate	()->(int)
(	O
pager_port_bucket	*(struct)
,	O
enable_cache	O
)	O
;	O
}	O
return	O
num_pagers	O
==	O
0	int
;	O
}	O
error_t	O
dev_get_memory_object	(*(struct),int,*(int))->(int)
(	O
struct	O
dev	*(struct)
*	O
dev	*(struct)
,	O
vm_prot_t	O
prot	int
,	O
memory_object_t	O
*	O
memobj	*(int)
)	O
{	O
error_t	O
err	O
=	O
store_map	O
(	O
dev	*(struct)
->	O
store	*(struct)
,	O
prot	int
,	O
memobj	*(int)
)	O
;	O
if	O
(	O
err	O
==	O
EOPNOTSUPP	O
&&	O
!	O
dev	*(struct)
->	O
inhibit_cache	O
)	O
{	O
int	O
created	int
=	O
0	int
;	O
init_dev_paging	()->(void)
(	O
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
dev	*(struct)
->	O
pager_lock	O
)	O
;	O
if	O
(	O
dev	*(struct)
->	O
pager	*(struct)
==	O
NULL	O
)	O
{	O
dev	*(struct)
->	O
pager	*(struct)
=	O
pager_create	()->(int)
(	O
(	O
struct	O
user_pager_info	O
*	O
)	O
dev	*(struct)
,	O
pager_port_bucket	*(struct)
,	O
1	int
,	O
MEMORY_OBJECT_COPY_DELAY	O
,	O
0	int
)	O
;	O
if	O
(	O
dev	*(struct)
->	O
pager	*(struct)
==	O
NULL	O
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
dev	*(struct)
->	O
pager_lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
created	int
=	O
1	int
;	O
}	O
*	O
memobj	*(int)
=	O
pager_get_port	()->(int)
(	O
dev	*(struct)
->	O
pager	*(struct)
)	O
;	O
if	O
(	O
*	O
memobj	*(int)
==	O
MACH_PORT_NULL	O
)	O
{	O
dev	*(struct)
->	O
pager	*(struct)
=	O
0	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
dev	*(struct)
->	O
pager_lock	O
)	O
;	O
return	O
dev_get_memory_object	(*(struct),int,*(int))->(int)
(	O
dev	*(struct)
,	O
prot	int
,	O
memobj	*(int)
)	O
;	O
}	O
else	O
err	O
=	O
mach_port_insert_right	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
*	O
memobj	*(int)
,	O
*	O
memobj	*(int)
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
if	O
(	O
created	int
)	O
ports_port_deref	()->(int)
(	O
dev	*(struct)
->	O
pager	*(struct)
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
dev	*(struct)
->	O
pager_lock	O
)	O
;	O
}	O
return	O
err	O
;	O
}	O
