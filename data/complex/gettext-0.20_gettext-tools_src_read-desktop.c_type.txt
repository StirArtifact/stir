desktop_reader_ty	struct
*	O
desktop_reader_alloc	(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)))))->(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))))
(	O
desktop_reader_class_ty	struct
*	O
method_table	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
)	O
{	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
;	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
=	O
(	O
desktop_reader_ty	struct
*	O
)	O
xmalloc	(long)->(*(void))
(	O
method_table	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
size	long
)	O
;	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
->	O
methods	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
=	O
method_table	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
;	O
if	O
(	O
method_table	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
constructor	*((*(struct))->(void))
)	O
method_table	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
constructor	*((*(struct))->(void))
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
)	O
;	O
return	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
;	O
}	O
void	O
desktop_reader_free	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
)	O
{	O
if	O
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
->	O
methods	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
destructor	*((*(struct))->(void))
)	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
->	O
methods	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
destructor	*((*(struct))->(void))
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
)	O
;	O
free	(*(void))->(void)
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
)	O
;	O
}	O
void	O
desktop_reader_handle_group	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
(	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
const	O
char	O
*	O
group	*(char)
)	O
{	O
if	O
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
->	O
methods	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
handle_group	*((*(struct),*(char))->(void))
)	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
->	O
methods	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
handle_group	*((*(struct),*(char))->(void))
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
group	*(char)
)	O
;	O
}	O
void	O
desktop_reader_handle_pair	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(struct(*(char),long)),*(char),*(char),*(char))->(void)
(	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
lex_pos_ty	struct
*	O
key_pos	*(struct(*(char),long))
,	O
const	O
char	O
*	O
key	*(void)
,	O
const	O
char	O
*	O
locale	*(char)
,	O
const	O
char	O
*	O
value	*(char)
)	O
{	O
if	O
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
->	O
methods	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
handle_pair	*((*(struct),*(struct(*(char),long)),*(char),*(char),*(char))->(void))
)	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
->	O
methods	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
handle_pair	*((*(struct),*(struct(*(char),long)),*(char),*(char),*(char))->(void))
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
key_pos	*(struct(*(char),long))
,	O
key	*(void)
,	O
locale	*(char)
,	O
value	*(char)
)	O
;	O
}	O
void	O
desktop_reader_handle_comment	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
(	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
->	O
methods	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
handle_comment	*((*(struct),*(char))->(void))
)	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
->	O
methods	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
handle_comment	*((*(struct),*(char))->(void))
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
s	*(char)
)	O
;	O
}	O
void	O
desktop_reader_handle_blank	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
(	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
->	O
methods	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
handle_blank	*((*(struct),*(char))->(void))
)	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
->	O
methods	*(struct(long,*((*(struct`))->(void)),*((*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(struct`),*(char),*(char),*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char))->(void))))
->	O
handle_blank	*((*(struct),*(char))->(void))
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
s	*(char)
)	O
;	O
}	O
static	O
const	O
char	O
*	O
real_file_name	*(char)
;	O
extern	O
lex_pos_ty	struct
gram_pos	struct(*(char),long)
;	O
static	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
int	O
phase1_getc	()->(int)
(	O
)	O
{	O
int	O
c	int
;	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
const	O
char	O
*	O
errno_description	*(char)
=	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
;	O
po_xerror	*((int,*(struct),*(char),long,long,int,*(char))->(void))
(	O
PO_SEVERITY_FATAL_ERROR	int
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
xasprintf	(*(char))->(*(char))
(	O
"%s: %s"	*(char)
,	O
xasprintf	(*(char))->(*(char))
(	O
_	O
(	O
"error while reading \"%s\""	*(char)
)	O
,	O
real_file_name	*(char)
)	O
,	O
errno_description	*(char)
)	O
)	O
;	O
}	O
return	O
EOF	O
;	O
}	O
return	O
c	int
;	O
}	O
static	O
inline	O
void	O
phase1_ungetc	(int)->(void)
(	O
int	O
c	int
)	O
{	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
unsigned	O
char	O
phase2_pushback	array(char)
[	O
2	int
]	O
;	O
static	O
int	O
phase2_pushback_length	int
;	O
static	O
int	O
phase2_getc	()->(int)
(	O
)	O
{	O
int	O
c	int
;	O
if	O
(	O
phase2_pushback_length	int
)	O
c	int
=	O
phase2_pushback	array(char)
[	O
--	O
phase2_pushback_length	int
]	O
;	O
else	O
{	O
c	int
=	O
phase1_getc	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
{	O
int	O
c2	int
=	O
phase1_getc	()->(int)
(	O
)	O
;	O
if	O
(	O
c2	int
==	O
'\n'	O
)	O
c	int
=	O
c2	int
;	O
else	O
phase1_ungetc	(int)->(void)
(	O
c2	int
)	O
;	O
}	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
gram_pos	struct(*(char),long)
.	O
line_number	long
++	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
phase2_ungetc	(int)->(void)
(	O
int	O
c	int
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
--	O
gram_pos	struct(*(char),long)
.	O
line_number	long
;	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
phase2_pushback	array(char)
[	O
phase2_pushback_length	int
++	O
]	O
=	O
c	int
;	O
}	O
enum	O
token_type_ty	enum(int,int,int,int,int,int)
{	O
token_type_eof	int
,	O
token_type_group	int
,	O
token_type_pair	int
,	O
token_type_comment	int
,	O
token_type_blank	int
,	O
token_type_other	int
}	O
;	O
typedef	O
enum	O
token_type_ty	enum(int,int,int,int,int,int)
token_type_ty	enum(int,int,int,int,int,int)
;	O
typedef	O
struct	O
token_ty	struct
token_ty	struct
;	O
struct	O
token_ty	struct
{	O
token_type_ty	enum(int,int,int,int,int,int)
type	enum(int,int,int,int,int,int)
;	O
char	O
*	O
string	*(char)
;	O
const	O
char	O
*	O
value	*(char)
;	O
const	O
char	O
*	O
locale	*(char)
;	O
}	O
;	O
static	O
inline	O
void	O
free_token	(*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))))->(void)
(	O
token_ty	struct
*	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
)	O
{	O
if	O
(	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int)
==	O
token_type_group	int
||	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int)
==	O
token_type_pair	int
||	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int)
==	O
token_type_comment	int
||	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int)
==	O
token_type_blank	int
)	O
free	(*(void))->(void)
(	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
string	*(char)
)	O
;	O
}	O
static	O
void	O
desktop_lex	(*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))))->(void)
(	O
token_ty	struct
*	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
)	O
{	O
static	O
char	O
*	O
buffer	*(char)
;	O
static	O
size_t	long
bufmax	long
;	O
size_t	long
bufpos	long
;	O
bufpos	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
c	int
;	O
c	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
EOF	O
:	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int)
=	O
token_type_eof	int
;	O
return	O
;	O
case	O
'['	O
:	O
{	O
bool	bool
non_blank	bool
=	O
false	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
if	O
(	O
!	O
(	O
c_isascii	(int)->(bool)
(	O
c	int
)	O
&&	O
c	int
!=	O
'['	O
)	O
&&	O
!	O
c_iscntrl	(int)->(bool)
(	O
c	int
)	O
)	O
break	O
;	O
APPEND	O
(	O
c	int
)	O
;	O
continue	O
;	O
case	O
'\n'	O
:	O
po_xerror	*((int,*(struct),*(char),long,long,int,*(char))->(void))
(	O
PO_SEVERITY_WARNING	int
,	O
NULL	O
,	O
real_file_name	*(char)
,	O
gram_pos	struct(*(char),long)
.	O
line_number	long
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"unterminated group name"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
EOF	O
:	O
case	O
']'	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
while	O
(	O
c	int
!=	O
'\n'	O
&&	O
c	int
!=	O
EOF	O
)	O
{	O
c	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
break	O
;	O
if	O
(	O
!	O
c_isspace	(int)->(bool)
(	O
c	int
)	O
)	O
non_blank	bool
=	O
true	int
;	O
}	O
if	O
(	O
non_blank	bool
)	O
po_xerror	*((int,*(struct),*(char),long,long,int,*(char))->(void))
(	O
PO_SEVERITY_WARNING	int
,	O
NULL	O
,	O
real_file_name	*(char)
,	O
gram_pos	struct(*(char),long)
.	O
line_number	long
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"invalid non-blank character"	*(char)
)	O
)	O
;	O
APPEND	O
(	O
0	int
)	O
;	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int)
=	O
token_type_group	int
;	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
string	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
buffer	*(char)
)	O
;	O
return	O
;	O
}	O
case	O
'#'	O
:	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
APPEND	O
(	O
c	int
)	O
;	O
continue	O
;	O
case	O
EOF	O
:	O
case	O
'\n'	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
APPEND	O
(	O
0	int
)	O
;	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int)
=	O
token_type_comment	int
;	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
string	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
buffer	*(char)
)	O
;	O
return	O
;	O
}	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
case	O
'G'	O
:	O
case	O
'H'	O
:	O
case	O
'I'	O
:	O
case	O
'J'	O
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'M'	O
:	O
case	O
'N'	O
:	O
case	O
'O'	O
:	O
case	O
'P'	O
:	O
case	O
'Q'	O
:	O
case	O
'R'	O
:	O
case	O
'S'	O
:	O
case	O
'T'	O
:	O
case	O
'U'	O
:	O
case	O
'V'	O
:	O
case	O
'W'	O
:	O
case	O
'X'	O
:	O
case	O
'Y'	O
:	O
case	O
'Z'	O
:	O
case	O
'-'	O
:	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
case	O
'g'	O
:	O
case	O
'h'	O
:	O
case	O
'i'	O
:	O
case	O
'j'	O
:	O
case	O
'k'	O
:	O
case	O
'l'	O
:	O
case	O
'm'	O
:	O
case	O
'n'	O
:	O
case	O
'o'	O
:	O
case	O
'p'	O
:	O
case	O
'q'	O
:	O
case	O
'r'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
case	O
'v'	O
:	O
case	O
'w'	O
:	O
case	O
'x'	O
:	O
case	O
'y'	O
:	O
case	O
'z'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
{	O
size_t	long
locale_start	long
;	O
bool	bool
found_locale	bool
=	O
false	int
;	O
size_t	long
value_start	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
APPEND	O
(	O
c	int
)	O
;	O
c	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
case	O
'G'	O
:	O
case	O
'H'	O
:	O
case	O
'I'	O
:	O
case	O
'J'	O
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'M'	O
:	O
case	O
'N'	O
:	O
case	O
'O'	O
:	O
case	O
'P'	O
:	O
case	O
'Q'	O
:	O
case	O
'R'	O
:	O
case	O
'S'	O
:	O
case	O
'T'	O
:	O
case	O
'U'	O
:	O
case	O
'V'	O
:	O
case	O
'W'	O
:	O
case	O
'X'	O
:	O
case	O
'Y'	O
:	O
case	O
'Z'	O
:	O
case	O
'-'	O
:	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
case	O
'g'	O
:	O
case	O
'h'	O
:	O
case	O
'i'	O
:	O
case	O
'j'	O
:	O
case	O
'k'	O
:	O
case	O
'l'	O
:	O
case	O
'm'	O
:	O
case	O
'n'	O
:	O
case	O
'o'	O
:	O
case	O
'p'	O
:	O
case	O
'q'	O
:	O
case	O
'r'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
case	O
'v'	O
:	O
case	O
'w'	O
:	O
case	O
'x'	O
:	O
case	O
'y'	O
:	O
case	O
'z'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
continue	O
;	O
case	O
'['	O
:	O
APPEND	O
(	O
0	int
)	O
;	O
found_locale	bool
=	O
true	int
;	O
locale_start	long
=	O
bufpos	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
c2	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
switch	O
(	O
c2	int
)	O
{	O
default	O
:	O
APPEND	O
(	O
c2	int
)	O
;	O
continue	O
;	O
case	O
EOF	O
:	O
case	O
']'	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
phase2_ungetc	(int)->(void)
(	O
c	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
APPEND	O
(	O
0	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
if	O
(	O
c	int
==	O
' '	O
)	O
continue	O
;	O
phase2_ungetc	(int)->(void)
(	O
c	int
)	O
;	O
break	O
;	O
case	O
EOF	O
:	O
case	O
'\n'	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
c	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
!=	O
'='	O
)	O
{	O
po_xerror	*((int,*(struct),*(char),long,long,int,*(char))->(void))
(	O
PO_SEVERITY_WARNING	int
,	O
NULL	O
,	O
real_file_name	*(char)
,	O
gram_pos	struct(*(char),long)
.	O
line_number	long
,	O
0	int
,	O
false	int
,	O
xasprintf	(*(char))->(*(char))
(	O
_	O
(	O
"missing '=' after \"%s\""	*(char)
)	O
,	O
buffer	*(char)
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
||	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
}	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int)
=	O
token_type_other	int
;	O
return	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
if	O
(	O
c	int
==	O
' '	O
)	O
continue	O
;	O
phase2_ungetc	(int)->(void)
(	O
c	int
)	O
;	O
break	O
;	O
case	O
EOF	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
value_start	long
=	O
bufpos	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
||	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
APPEND	O
(	O
c	int
)	O
;	O
}	O
APPEND	O
(	O
0	int
)	O
;	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int)
=	O
token_type_pair	int
;	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
string	*(char)
=	O
xmemdup	(*(void),long)->(*(void))
(	O
buffer	*(char)
,	O
bufpos	long
)	O
;	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
locale	*(char)
=	O
found_locale	bool
?	O
&	O
buffer	*(char)
[	O
locale_start	long
]	O
:	O
NULL	O
;	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
value	*(char)
=	O
&	O
buffer	*(char)
[	O
value_start	long
]	O
;	O
return	O
;	O
}	O
default	O
:	O
{	O
bool	bool
non_blank	bool
=	O
false	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
EOF	O
)	O
break	O
;	O
if	O
(	O
!	O
c_isspace	(int)->(bool)
(	O
c	int
)	O
)	O
non_blank	bool
=	O
true	int
;	O
else	O
APPEND	O
(	O
c	int
)	O
;	O
c	int
=	O
phase2_getc	()->(int)
(	O
)	O
;	O
}	O
if	O
(	O
non_blank	bool
)	O
{	O
po_xerror	*((int,*(struct),*(char),long,long,int,*(char))->(void))
(	O
PO_SEVERITY_WARNING	int
,	O
NULL	O
,	O
real_file_name	*(char)
,	O
gram_pos	struct(*(char),long)
.	O
line_number	long
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"invalid non-blank line"	*(char)
)	O
)	O
;	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int)
=	O
token_type_other	int
;	O
return	O
;	O
}	O
APPEND	O
(	O
0	int
)	O
;	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int)
=	O
token_type_blank	int
;	O
tp	*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char)))
->	O
string	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
buffer	*(char)
)	O
;	O
return	O
;	O
}	O
}	O
}	O
}	O
void	O
desktop_parse	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char))->(void)
(	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
FILE	struct
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
const	O
char	O
*	O
real_filename	*(char)
,	O
const	O
char	O
*	O
logical_filename	*(char)
)	O
{	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
real_file_name	*(char)
=	O
real_filename	*(char)
;	O
gram_pos	struct(*(char),long)
.	O
file_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
logical_filename	*(char)
)	O
;	O
gram_pos	struct(*(char),long)
.	O
line_number	long
=	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
token_ty	struct
token	struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))
;	O
desktop_lex	(*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))))->(void)
(	O
&	O
token	struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))
)	O
;	O
switch	O
(	O
token	struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))
.	O
type	enum(int,int,int,int,int,int)
)	O
{	O
case	O
token_type_eof	int
:	O
goto	O
out	O
;	O
case	O
token_type_group	int
:	O
desktop_reader_handle_group	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
token	struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))
.	O
string	*(char)
)	O
;	O
break	O
;	O
case	O
token_type_comment	int
:	O
desktop_reader_handle_comment	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
token	struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))
.	O
string	*(char)
)	O
;	O
break	O
;	O
case	O
token_type_pair	int
:	O
desktop_reader_handle_pair	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(struct(*(char),long)),*(char),*(char),*(char))->(void)
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
&	O
gram_pos	struct(*(char),long)
,	O
token	struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))
.	O
string	*(char)
,	O
token	struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))
.	O
locale	*(char)
,	O
token	struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))
.	O
value	*(char)
)	O
;	O
break	O
;	O
case	O
token_type_blank	int
:	O
desktop_reader_handle_blank	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
token	struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))
.	O
string	*(char)
)	O
;	O
break	O
;	O
case	O
token_type_other	int
:	O
break	O
;	O
}	O
free_token	(*(struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))))->(void)
(	O
&	O
token	struct(enum(int,int,int,int,int,int),*(char),*(char),*(char))
)	O
;	O
}	O
out	O
:	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
real_file_name	*(char)
=	O
NULL	O
;	O
gram_pos	struct(*(char),long)
.	O
line_number	long
=	O
0	int
;	O
}	O
char	O
*	O
desktop_escape_string	(*(char),bool)->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
bool	bool
is_list	bool
)	O
{	O
char	O
*	O
buffer	*(char)
,	O
*	O
p	*(void)
;	O
p	*(void)
=	O
buffer	*(char)
=	O
XNMALLOC	O
(	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
*	O
2	int
+	O
1	int
,	O
char	O
)	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
' '	O
)	O
{	O
p	*(void)
=	O
stpcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
"\\s"	*(char)
)	O
;	O
s	*(char)
++	O
;	O
}	O
else	O
if	O
(	O
*	O
s	*(char)
==	O
'\t'	O
)	O
{	O
p	*(void)
=	O
stpcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
"\\t"	*(char)
)	O
;	O
s	*(char)
++	O
;	O
}	O
for	O
(	O
;	O
;	O
s	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
{	O
*	O
p	*(void)
=	O
'\0'	O
;	O
break	O
;	O
}	O
switch	O
(	O
*	O
s	*(char)
)	O
{	O
case	O
'\n'	O
:	O
p	*(void)
=	O
stpcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
"\\n"	*(char)
)	O
;	O
break	O
;	O
case	O
'\r'	O
:	O
p	*(void)
=	O
stpcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
"\\r"	*(char)
)	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
is_list	bool
&&	O
*	O
(	O
s	*(char)
+	O
1	int
)	O
==	O
';'	O
)	O
{	O
p	*(void)
=	O
stpcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
"\\;"	*(char)
)	O
;	O
s	*(char)
++	O
;	O
}	O
else	O
p	*(void)
=	O
stpcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
"\\\\"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
*	O
p	*(void)
++	O
=	O
*	O
s	*(char)
;	O
break	O
;	O
}	O
}	O
return	O
buffer	*(char)
;	O
}	O
char	O
*	O
desktop_unescape_string	(*(char),bool)->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
bool	bool
is_list	bool
)	O
{	O
char	O
*	O
buffer	*(char)
,	O
*	O
p	*(void)
;	O
p	*(void)
=	O
buffer	*(char)
=	O
XNMALLOC	O
(	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
+	O
1	int
,	O
char	O
)	O
;	O
for	O
(	O
;	O
;	O
s	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
{	O
*	O
p	*(void)
=	O
'\0'	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
s	*(char)
==	O
'\\'	O
)	O
{	O
s	*(char)
++	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
{	O
*	O
p	*(void)
=	O
'\0'	O
;	O
break	O
;	O
}	O
switch	O
(	O
*	O
s	*(char)
)	O
{	O
case	O
's'	O
:	O
*	O
p	*(void)
++	O
=	O
' '	O
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
p	*(void)
++	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
p	*(void)
++	O
=	O
'\t'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
p	*(void)
++	O
=	O
'\r'	O
;	O
break	O
;	O
case	O
';'	O
:	O
p	*(void)
=	O
stpcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
"\\;"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
*	O
p	*(void)
++	O
=	O
*	O
s	*(char)
;	O
break	O
;	O
}	O
}	O
else	O
*	O
p	*(void)
++	O
=	O
*	O
s	*(char)
;	O
}	O
return	O
buffer	*(char)
;	O
}	O
void	O
desktop_add_keyword	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(char),bool)->(void)
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
const	O
char	O
*	O
name	*(char)
,	O
bool	bool
is_list	bool
)	O
{	O
hash_insert_entry	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,*(void))->(*(void))
(	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
,	O
(	O
void	O
*	O
)	O
is_list	bool
)	O
;	O
}	O
void	O
desktop_add_default_keywords	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))->(void)
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
)	O
{	O
desktop_add_keyword	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(char),bool)->(void)
(	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
"Name"	*(char)
,	O
false	int
)	O
;	O
desktop_add_keyword	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(char),bool)->(void)
(	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
"GenericName"	*(char)
,	O
false	int
)	O
;	O
desktop_add_keyword	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(char),bool)->(void)
(	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
"Comment"	*(char)
,	O
false	int
)	O
;	O
desktop_add_keyword	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(char),bool)->(void)
(	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
"Icon"	*(char)
,	O
false	int
)	O
;	O
desktop_add_keyword	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(char),bool)->(void)
(	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
"Keywords"	*(char)
,	O
true	int
)	O
;	O
}	O
