void	O
mu_sieve_register_comparator	(*(struct),*(char),int,*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)))->(void)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
required	int
,	O
mu_sieve_comparator_t	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
is	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
,	O
mu_sieve_comparator_t	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
contains	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
,	O
mu_sieve_comparator_t	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
matches	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
,	O
mu_sieve_comparator_t	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
regex	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
,	O
mu_sieve_comparator_t	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
eq	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
)	O
{	O
mu_sieve_registry_t	struct(*(char),int,*(void),enum(int,int,int),union(struct(*((*`)->(int)),*(enum(int,int,int,int,int)),*(enum(int,int,int,int,int)),*(struct(*`,*`))),array(*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)))))
*	O
reg	long
=	O
mu_sieve_registry_add	(*(struct),*(char))->(*(struct(*(char),int,*(void),enum(int,int,int),union(struct(*`,*`,*`,*`),array(*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)))))))
(	O
mach	*(struct)
,	O
name	*(char)
)	O
;	O
reg	long
->	O
type	int
=	O
mu_sieve_record_comparator	int
;	O
reg	long
->	O
required	int
=	O
required	int
;	O
reg	long
->	O
name	*(char)
=	O
name	*(char)
;	O
reg	long
->	O
v	array(*(char))
.	O
comp	array(*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)))
[	O
MU_SIEVE_MATCH_IS	int
]	O
=	O
is	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
;	O
reg	long
->	O
v	array(*(char))
.	O
comp	array(*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)))
[	O
MU_SIEVE_MATCH_CONTAINS	int
]	O
=	O
contains	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
;	O
reg	long
->	O
v	array(*(char))
.	O
comp	array(*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)))
[	O
MU_SIEVE_MATCH_MATCHES	int
]	O
=	O
matches	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
;	O
reg	long
->	O
v	array(*(char))
.	O
comp	array(*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)))
[	O
MU_SIEVE_MATCH_REGEX	int
]	O
=	O
regex	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
;	O
reg	long
->	O
v	array(*(char))
.	O
comp	array(*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)))
[	O
MU_SIEVE_MATCH_EQ	int
]	O
=	O
eq	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
;	O
}	O
mu_sieve_comparator_t	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
mu_sieve_comparator_lookup	(*(struct),*(char),int)->(*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)))
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
matchtype	int
)	O
{	O
mu_sieve_registry_t	struct(*(char),int,*(void),enum(int,int,int),union(struct(*((*`)->(int)),*(enum(int,int,int,int,int)),*(enum(int,int,int,int,int)),*(struct(*`,*`))),array(*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)))))
*	O
reg	long
=	O
mu_sieve_registry_lookup	(*(struct),*(char),enum(int,int,int))->(*(struct(*(char),int,*(void),enum(int,int,int),union(struct(*`,*`,*`,*`),array(*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)))))))
(	O
mach	*(struct)
,	O
name	*(char)
,	O
mu_sieve_record_comparator	int
)	O
;	O
if	O
(	O
reg	long
&&	O
reg	long
->	O
v	array(*(char))
.	O
comp	array(*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)))
[	O
matchtype	int
]	O
)	O
return	O
reg	long
->	O
v	array(*(char))
.	O
comp	array(*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)))
[	O
matchtype	int
]	O
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
i_ascii_casemap_is	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
;	O
mu_sieve_comparator_t	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
mu_sieve_get_comparator	(*(struct))->(*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)))
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
if	O
(	O
!	O
mach	*(struct)
->	O
comparator	*((*(struct(struct(struct`,struct`),int,*(struct`),*(struct`),*(struct`),*(struct`),*(*`),long,long,*(struct`),long,long,*(struct`),long,long,long,*(union`),enum(int,int,int,int,int),long,long,*(struct`),*(char),*(struct`),long,long,*(struct`),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct`),*(struct`),long,*(struct`),int,int,int,struct(struct`,struct`),int,struct(struct`,struct`),*(struct`),*(struct`),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct`),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
)	O
return	O
i_ascii_casemap_is	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
;	O
return	O
mach	*(struct)
->	O
comparator	*((*(struct(struct(struct`,struct`),int,*(struct`),*(struct`),*(struct`),*(struct`),*(*`),long,long,*(struct`),long,long,*(struct`),long,long,long,*(union`),enum(int,int,int,int,int),long,long,*(struct`),*(char),*(struct`),long,long,*(struct`),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct`),*(struct`),long,*(struct`),int,int,int,struct(struct`,struct`),int,struct(struct`,struct`),*(struct`),*(struct`),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct`),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
;	O
}	O
static	O
void	O
compile_pattern	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),int)->(void)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
;	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
;	O
char	O
*	O
str	*(char)
;	O
str	*(char)
=	O
mu_sieve_string_get	(*(struct),*(struct(int,int,*(char),*(char),*(void))))->(*(char))
(	O
mach	*(struct)
,	O
pattern	*(void)
)	O
;	O
if	O
(	O
pattern	*(void)
->	O
rx	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
)	O
{	O
if	O
(	O
!	O
pattern	*(void)
->	O
changed	int
)	O
return	O
;	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
=	O
pattern	*(void)
->	O
rx	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
;	O
regfree	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(void)
(	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
)	O
;	O
}	O
else	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
=	O
mu_sieve_malloc	(*(struct),long)->(*(void))
(	O
mach	*(struct)
,	O
sizeof	O
(	O
*	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
)	O
)	O
;	O
rc	int
=	O
regcomp	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int)->(int)
(	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
str	*(char)
,	O
REG_EXTENDED	int
|	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
size_t	long
size	long
=	O
regerror	(int,*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),long)->(long)
(	O
rc	int
,	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
NULL	O
,	O
0	int
)	O
;	O
char	O
*	O
errbuf	array(struct(array(long),int,struct(array(long))))
=	O
malloc	(long)->(*(void))
(	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
errbuf	array(struct(array(long),int,struct(array(long))))
)	O
{	O
regerror	(int,*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),long)->(long)
(	O
rc	int
,	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
errbuf	array(struct(array(long),int,struct(array(long))))
,	O
size	long
)	O
;	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"regex error: %s"	*(char)
)	O
,	O
errbuf	array(struct(array(long),int,struct(array(long))))
)	O
;	O
free	(*(void))->(void)
(	O
errbuf	array(struct(array(long),int,struct(array(long))))
)	O
;	O
}	O
else	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"regex error"	*(char)
)	O
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
pattern	*(void)
->	O
rx	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
=	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
;	O
}	O
static	O
void	O
compile_wildcard	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),int)->(void)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
;	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
;	O
char	O
*	O
str	*(char)
;	O
str	*(char)
=	O
mu_sieve_string_get	(*(struct),*(struct(int,int,*(char),*(char),*(void))))->(*(char))
(	O
mach	*(struct)
,	O
pattern	*(void)
)	O
;	O
if	O
(	O
pattern	*(void)
->	O
rx	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
)	O
{	O
if	O
(	O
!	O
pattern	*(void)
->	O
changed	int
)	O
return	O
;	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
=	O
pattern	*(void)
->	O
rx	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
;	O
regfree	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(void)
(	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
)	O
;	O
}	O
else	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
=	O
mu_sieve_malloc	(*(struct),long)->(*(void))
(	O
mach	*(struct)
,	O
sizeof	O
(	O
*	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
)	O
)	O
;	O
if	O
(	O
mu_sieve_has_variables	(*(struct))->(int)
(	O
mach	*(struct)
)	O
)	O
flags	int
|=	O
MU_GLOBF_SUB	int
;	O
rc	int
=	O
mu_glob_compile	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int)->(int)
(	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
str	*(char)
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"can't compile pattern"	*(char)
)	O
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
pattern	*(void)
->	O
rx	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
=	O
preg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
;	O
}	O
static	O
int	O
comp_false	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
return	O
0	int
;	O
}	O
int	O
mu_sieve_match_part_checker	(*(struct))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
size_t	long
i	long
;	O
mu_sieve_value_t	struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long)))
*	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
=	O
NULL	O
;	O
mu_sieve_comparator_t	*((*(struct),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
compfun	*((*(struct(struct(struct`,struct`),int,*(struct`),*(struct`),*(struct`),*(struct`),*(*`),long,long,*(struct`),long,long,*(struct`),long,long,long,*(union`),enum(int,int,int,int,int),long,long,*(struct`),*(char),*(struct`),long,long,*(struct`),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct`),*(struct`),long,*(struct`),int,int,int,struct(struct`,struct`),int,struct(struct`,struct`),*(struct`),*(struct`),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct`),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
=	O
NULL	O
;	O
char	O
*	O
compname	*(char)
=	O
NULL	O
;	O
int	O
matchtype	int
;	O
if	O
(	O
mach	*(struct)
->	O
tagcount	long
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
mach	*(struct)
->	O
tagcount	long
;	O
i	long
++	O
)	O
{	O
mu_sieve_value_t	struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long)))
*	O
t	long
=	O
mu_sieve_get_tag_n	(*(struct),long)->(*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))))
(	O
mach	*(struct)
,	O
i	long
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
t	long
->	O
tag	*(char)
,	O
"is"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
t	long
->	O
tag	*(char)
,	O
"contains"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
t	long
->	O
tag	*(char)
,	O
"matches"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
t	long
->	O
tag	*(char)
,	O
"regex"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
t	long
->	O
tag	*(char)
,	O
"count"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
t	long
->	O
tag	*(char)
,	O
"value"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
t	long
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"match type specified twice in call to `%s'"	*(char)
)	O
,	O
mach	*(struct)
->	O
identifier	*(char)
)	O
;	O
mu_i_sv_error	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(void)
(	O
mach	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
else	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
=	O
t	long
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
t	long
->	O
tag	*(char)
,	O
"comparator"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
t	long
->	O
type	int
!=	O
SVT_STRING	int
)	O
abort	()->(void)
(	O
)	O
;	O
compname	*(char)
=	O
mu_sieve_string	struct(int,int,*(char),*(char),*(void))
(	O
mach	*(struct)
,	O
&	O
t	long
->	O
v	array(*(char))
.	O
list	*(struct)
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
||	O
strcmp	(*(char),*(char))->(int)
(	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
->	O
tag	*(char)
,	O
"is"	*(char)
)	O
==	O
0	int
)	O
matchtype	int
=	O
MU_SIEVE_MATCH_IS	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
->	O
tag	*(char)
,	O
"contains"	*(char)
)	O
==	O
0	int
)	O
matchtype	int
=	O
MU_SIEVE_MATCH_CONTAINS	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
->	O
tag	*(char)
,	O
"matches"	*(char)
)	O
==	O
0	int
)	O
matchtype	int
=	O
MU_SIEVE_MATCH_MATCHES	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
->	O
tag	*(char)
,	O
"regex"	*(char)
)	O
==	O
0	int
)	O
matchtype	int
=	O
MU_SIEVE_MATCH_REGEX	int
;	O
else	O
if	O
(	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
->	O
type	int
==	O
SVT_STRING	int
)	O
{	O
char	O
*	O
str	*(char)
=	O
mu_sieve_string	struct(int,int,*(char),*(char),*(void))
(	O
mach	*(struct)
,	O
&	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
->	O
v	array(*(char))
.	O
list	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
->	O
tag	*(char)
,	O
"count"	*(char)
)	O
==	O
0	int
)	O
{	O
mu_sieve_value_t	struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long)))
*	O
val	*(char)
;	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
argstr	*(struct(int,int,*(char),*(char),*(void)))
;	O
if	O
(	O
compname	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
compname	*(char)
,	O
"i;ascii-numeric"	*(char)
)	O
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"comparator %s is incompatible with "	*(char)
":count in call to `%s'"	*(char)
)	O
,	O
compname	*(char)
,	O
mach	*(struct)
->	O
identifier	*(char)
)	O
;	O
mu_i_sv_error	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(void)
(	O
mach	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
matchtype	int
=	O
MU_SIEVE_MATCH_LAST	int
;	O
compname	*(char)
=	O
"false"	*(char)
;	O
compfun	*((*(struct(struct(struct`,struct`),int,*(struct`),*(struct`),*(struct`),*(struct`),*(*`),long,long,*(struct`),long,long,*(struct`),long,long,long,*(union`),enum(int,int,int,int,int),long,long,*(struct`),*(char),*(struct`),long,long,*(struct`),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct`),*(struct`),long,*(struct`),int,int,int,struct(struct`,struct`),int,struct(struct`,struct`),*(struct`),*(struct`),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct`),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
=	O
comp_false	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
;	O
val	*(char)
=	O
mu_sieve_get_arg_untyped	(*(struct),long)->(*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))))
(	O
mach	*(struct)
,	O
1	int
)	O
;	O
switch	O
(	O
val	*(char)
->	O
type	int
)	O
{	O
case	O
SVT_STRING	int
:	O
break	O
;	O
case	O
SVT_STRING_LIST	int
:	O
if	O
(	O
val	*(char)
->	O
v	array(*(char))
.	O
list	*(struct)
.	O
count	long
==	O
1	int
)	O
break	O
;	O
default	O
:	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
val	*(char)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
":count requires second argument to be a list of one element"	*(char)
)	O
)	O
;	O
mu_i_sv_error	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(void)
(	O
mach	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
argstr	*(struct(int,int,*(char),*(char),*(void)))
=	O
mu_sieve_string_raw	(*(struct),*(struct(long,long)),long)->(*(struct(int,int,*(char),*(char),*(void))))
(	O
mach	*(struct)
,	O
&	O
val	*(char)
->	O
v	array(*(char))
.	O
list	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
argstr	*(struct(int,int,*(char),*(char),*(void)))
->	O
constant	long
)	O
{	O
char	O
*	O
p	*(char)
=	O
mu_str_skip_class	(*(char),int)->(*(char))
(	O
argstr	*(struct(int,int,*(char),*(char),*(void)))
->	O
orig	*(struct)
,	O
MU_CTYPE_DIGIT	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
val	*(char)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"second argument cannot be converted to number"	*(char)
)	O
)	O
;	O
mu_i_sv_error	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(void)
(	O
mach	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
else	O
matchtype	int
=	O
MU_SIEVE_MATCH_EQ	int
;	O
if	O
(	O
mu_sieve_str_to_relcmp	(*(char),*(*((int,int)->(int))),*(*((long,long)->(int))))->(int)
(	O
str	*(char)
,	O
NULL	O
,	O
NULL	O
)	O
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"invalid relational match `%s' in call to `%s'"	*(char)
)	O
,	O
str	*(char)
,	O
mach	*(struct)
->	O
identifier	*(char)
)	O
;	O
mu_i_sv_error	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(void)
(	O
mach	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s:%d: INTERNAL ERROR, please report"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
compfun	*((*(struct(struct(struct`,struct`),int,*(struct`),*(struct`),*(struct`),*(struct`),*(*`),long,long,*(struct`),long,long,*(struct`),long,long,long,*(union`),enum(int,int,int,int,int),long,long,*(struct`),*(char),*(struct`),long,long,*(struct`),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct`),*(struct`),long,*(struct`),int,int,int,struct(struct`,struct`),int,struct(struct`,struct`),*(struct`),*(struct`),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct`),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
)	O
{	O
if	O
(	O
!	O
compname	*(char)
)	O
compname	*(char)
=	O
"i;ascii-casemap"	*(char)
;	O
compfun	*((*(struct(struct(struct`,struct`),int,*(struct`),*(struct`),*(struct`),*(struct`),*(*`),long,long,*(struct`),long,long,*(struct`),long,long,long,*(union`),enum(int,int,int,int,int),long,long,*(struct`),*(char),*(struct`),long,long,*(struct`),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct`),*(struct`),long,*(struct`),int,int,int,struct(struct`,struct`),int,struct(struct`,struct`),*(struct`),*(struct`),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct`),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
=	O
mu_sieve_comparator_lookup	(*(struct),*(char),int)->(*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)))
(	O
mach	*(struct)
,	O
compname	*(char)
,	O
matchtype	int
)	O
;	O
if	O
(	O
!	O
compfun	*((*(struct(struct(struct`,struct`),int,*(struct`),*(struct`),*(struct`),*(struct`),*(*`),long,long,*(struct`),long,long,*(struct`),long,long,long,*(union`),enum(int,int,int,int,int),long,long,*(struct`),*(char),*(struct`),long,long,*(struct`),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct`),*(struct`),long,*(struct`),int,int,int,struct(struct`,struct`),int,struct(struct`,struct`),*(struct`),*(struct`),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct`),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
)	O
{	O
if	O
(	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
)	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"comparator `%s' is incompatible with match type `%s' in call to `%s'"	*(char)
)	O
,	O
compname	*(char)
,	O
match	*(struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long))))
->	O
tag	*(char)
,	O
mach	*(struct)
->	O
identifier	*(char)
)	O
;	O
else	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
mach	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"comparator `%s' is incompatible with match type `%s' in call to `%s'"	*(char)
)	O
,	O
compname	*(char)
,	O
"is"	*(char)
,	O
mach	*(struct)
->	O
identifier	*(char)
)	O
;	O
mu_i_sv_error	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(void)
(	O
mach	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
mach	*(struct)
->	O
comparator	*((*(struct(struct(struct`,struct`),int,*(struct`),*(struct`),*(struct`),*(struct`),*(*`),long,long,*(struct`),long,long,*(struct`),long,long,long,*(union`),enum(int,int,int,int,int),long,long,*(struct`),*(char),*(struct`),long,long,*(struct`),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct`),*(struct`),long,*(struct`),int,int,int,struct(struct`,struct`),int,struct(struct`,struct`),*(struct`),*(struct`),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct`),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
=	O
compfun	*((*(struct(struct(struct`,struct`),int,*(struct`),*(struct`),*(struct`),*(struct`),*(*`),long,long,*(struct`),long,long,*(struct`),long,long,long,*(union`),enum(int,int,int,int,int),long,long,*(struct`),*(char),*(struct`),long,long,*(struct`),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct`),*(struct`),long,*(struct`),int,int,int,struct(struct`,struct`),int,struct(struct`,struct`),*(struct`),*(struct`),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct`),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int))
;	O
return	O
0	int
;	O
}	O
static	O
int	O
regmatch	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
char	O
const	O
*	O
text	*(char)
)	O
{	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
reg	long
=	O
pattern	*(void)
->	O
rx	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
;	O
regmatch_t	struct(int,int)
*	O
match_buf	*(struct(int,int))
=	O
NULL	O
;	O
size_t	long
match_count	long
=	O
0	int
;	O
if	O
(	O
mu_sieve_has_variables	(*(struct))->(int)
(	O
mach	*(struct)
)	O
)	O
{	O
match_count	long
=	O
reg	long
->	O
re_nsub	long
+	O
1	int
;	O
while	O
(	O
mach	*(struct)
->	O
match_max	long
<	O
match_count	long
)	O
mu_i_sv_2nrealloc	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(*(void)),*(long),long)->(void)
(	O
mach	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
mach	*(struct)
->	O
match_buf	*(struct(int,int))
,	O
&	O
mach	*(struct)
->	O
match_max	long
,	O
sizeof	O
(	O
mach	*(struct)
->	O
match_buf	*(struct(int,int))
[	O
0	int
]	O
)	O
)	O
;	O
mach	*(struct)
->	O
match_count	long
=	O
match_count	long
;	O
mu_sieve_free	(*(struct),*(void))->(void)
(	O
mach	*(struct)
,	O
mach	*(struct)
->	O
match_string	*(char)
)	O
;	O
mach	*(struct)
->	O
match_string	*(char)
=	O
mu_sieve_strdup	(*(struct),*(char))->(*(char))
(	O
mach	*(struct)
,	O
text	*(char)
)	O
;	O
match_buf	*(struct(int,int))
=	O
mach	*(struct)
->	O
match_buf	*(struct(int,int))
;	O
}	O
return	O
regexec	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),long,array(struct(int,int)),int)->(int)
(	O
reg	long
,	O
text	*(char)
,	O
match_count	long
,	O
match_buf	*(struct(int,int))
,	O
0	int
)	O
==	O
0	int
;	O
}	O
static	O
int	O
i_octet_is	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
mu_sieve_string_get	(*(struct),*(struct(int,int,*(char),*(char),*(void))))->(*(char))
(	O
mach	*(struct)
,	O
pattern	*(void)
)	O
,	O
text	*(char)
)	O
==	O
0	int
;	O
}	O
static	O
int	O
i_octet_contains	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
return	O
strstr	(*(char),*(char))->(*(char))
(	O
text	*(char)
,	O
mu_sieve_string_get	(*(struct),*(struct(int,int,*(char),*(char),*(void))))->(*(char))
(	O
mach	*(struct)
,	O
pattern	*(void)
)	O
)	O
!=	O
NULL	O
;	O
}	O
static	O
int	O
i_octet_matches	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
compile_wildcard	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),int)->(void)
(	O
mach	*(struct)
,	O
pattern	*(void)
,	O
0	int
)	O
;	O
return	O
regmatch	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mach	*(struct)
,	O
pattern	*(void)
,	O
text	*(char)
)	O
;	O
}	O
static	O
int	O
i_octet_regex	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
compile_pattern	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),int)->(void)
(	O
mach	*(struct)
,	O
pattern	*(void)
,	O
0	int
)	O
;	O
return	O
regmatch	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mach	*(struct)
,	O
pattern	*(void)
,	O
text	*(char)
)	O
;	O
}	O
static	O
int	O
i_octet_eq	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
text	*(char)
,	O
mu_sieve_string_get	(*(struct),*(struct(int,int,*(char),*(char),*(void))))->(*(char))
(	O
mach	*(struct)
,	O
pattern	*(void)
)	O
)	O
;	O
}	O
static	O
int	O
i_ascii_casemap_is	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
return	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
mu_sieve_string_get	(*(struct),*(struct(int,int,*(char),*(char),*(void))))->(*(char))
(	O
mach	*(struct)
,	O
pattern	*(void)
)	O
,	O
text	*(char)
)	O
==	O
0	int
;	O
}	O
static	O
int	O
i_ascii_casemap_contains	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
return	O
mu_c_strcasestr	(*(char),*(char))->(*(char))
(	O
text	*(char)
,	O
mu_sieve_string_get	(*(struct),*(struct(int,int,*(char),*(char),*(void))))->(*(char))
(	O
mach	*(struct)
,	O
pattern	*(void)
)	O
)	O
!=	O
NULL	O
;	O
}	O
static	O
int	O
i_ascii_casemap_matches	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
compile_wildcard	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),int)->(void)
(	O
mach	*(struct)
,	O
pattern	*(void)
,	O
MU_GLOBF_ICASE	int
)	O
;	O
return	O
regmatch	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mach	*(struct)
,	O
pattern	*(void)
,	O
text	*(char)
)	O
;	O
}	O
static	O
int	O
i_ascii_casemap_regex	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
compile_pattern	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),int)->(void)
(	O
mach	*(struct)
,	O
pattern	*(void)
,	O
REG_ICASE	O
)	O
;	O
return	O
regmatch	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mach	*(struct)
,	O
pattern	*(void)
,	O
text	*(char)
)	O
;	O
}	O
static	O
int	O
i_ascii_casemap_eq	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
return	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
text	*(char)
,	O
mu_sieve_string_get	(*(struct),*(struct(int,int,*(char),*(char),*(void))))->(*(char))
(	O
mach	*(struct)
,	O
pattern	*(void)
)	O
)	O
;	O
}	O
static	O
int	O
i_ascii_numeric_is	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
char	O
*	O
str	*(char)
=	O
mu_sieve_string_get	(*(struct),*(struct(int,int,*(char),*(char),*(void))))->(*(char))
(	O
mach	*(struct)
,	O
pattern	*(void)
)	O
;	O
if	O
(	O
mu_isdigit	O
(	O
*	O
str	*(char)
)	O
)	O
{	O
if	O
(	O
mu_isdigit	O
(	O
*	O
text	*(char)
)	O
)	O
return	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
,	O
NULL	O
,	O
10	int
)	O
==	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
text	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
mu_isdigit	O
(	O
*	O
text	*(char)
)	O
)	O
return	O
0	int
;	O
else	O
return	O
1	int
;	O
}	O
static	O
int	O
i_ascii_numeric_eq	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_sieve_string_t	struct(int,int,*(char),*(char),*(void))
*	O
pattern	*(void)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
char	O
*	O
str	*(char)
=	O
mu_sieve_string_get	(*(struct),*(struct(int,int,*(char),*(char),*(void))))->(*(char))
(	O
mach	*(struct)
,	O
pattern	*(void)
)	O
;	O
if	O
(	O
mu_isdigit	O
(	O
*	O
str	*(char)
)	O
)	O
{	O
if	O
(	O
mu_isdigit	O
(	O
*	O
text	*(char)
)	O
)	O
{	O
size_t	long
a	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
size_t	long
b	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
text	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
b	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
>	O
a	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
return	O
1	int
;	O
else	O
if	O
(	O
b	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
<	O
a	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
else	O
return	O
1	int
;	O
}	O
else	O
return	O
1	int
;	O
}	O
void	O
mu_i_sv_register_standard_comparators	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(void)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_sieve_register_comparator	(*(struct),*(char),int,*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)))->(void)
(	O
mach	*(struct)
,	O
"i;octet"	*(char)
,	O
1	int
,	O
i_octet_is	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
,	O
i_octet_contains	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
,	O
i_octet_matches	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
,	O
i_octet_regex	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
,	O
i_octet_eq	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
)	O
;	O
mu_sieve_register_comparator	(*(struct),*(char),int,*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)))->(void)
(	O
mach	*(struct)
,	O
"i;ascii-casemap"	*(char)
,	O
1	int
,	O
i_ascii_casemap_is	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
,	O
i_ascii_casemap_contains	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
,	O
i_ascii_casemap_matches	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
,	O
i_ascii_casemap_regex	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
,	O
i_ascii_casemap_eq	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
)	O
;	O
mu_sieve_register_comparator	(*(struct),*(char),int,*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)),*((*(struct),*(struct(int,int,*`,*`,*`)),*(char))->(int)))->(void)
(	O
mach	*(struct)
,	O
"i;ascii-numeric"	*(char)
,	O
0	int
,	O
i_ascii_numeric_is	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
i_ascii_numeric_eq	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))),*(struct(int,int,*(char),*(char),*(void))),*(char))->(int)
)	O
;	O
}	O
