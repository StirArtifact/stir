static	O
inline	O
hurd_ihash_key_t	long
hash	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long)->(long)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_key_t	long
k	long
)	O
{	O
return	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
fct_hash	*((*(void))->(long))
?	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
fct_hash	*((*(void))->(long))
(	O
(	O
const	O
void	O
*	O
)	O
k	long
)	O
:	O
k	long
;	O
}	O
static	O
inline	O
int	O
compare	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,long)->(int)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_key_t	long
a	long
,	O
hurd_ihash_key_t	long
b	long
)	O
{	O
return	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
fct_cmp	*((*(void),*(void))->(int))
?	O
(	O
a	long
&&	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
fct_cmp	*((*(void),*(void))->(int))
(	O
(	O
const	O
void	O
*	O
)	O
a	long
,	O
(	O
const	O
void	O
*	O
)	O
b	long
)	O
)	O
:	O
a	long
==	O
b	long
;	O
}	O
static	O
inline	O
int	O
index_empty	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),int)->(int)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
unsigned	O
int	O
idx	int
)	O
{	O
return	O
!	O
hurd_ihash_value_valid	(*(void))->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
idx	int
]	O
.	O
value	*(void)
)	O
;	O
}	O
static	O
inline	O
int	O
index_valid	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),int,long)->(int)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
unsigned	O
int	O
idx	int
,	O
hurd_ihash_key_t	long
key	long
)	O
{	O
return	O
!	O
index_empty	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),int)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
idx	int
)	O
&&	O
compare	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
idx	int
]	O
.	O
key	long
,	O
key	long
)	O
;	O
}	O
static	O
inline	O
int	O
find_index	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long)->(int)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_key_t	long
key	long
)	O
{	O
unsigned	O
int	O
idx	int
;	O
unsigned	O
int	O
up_idx	int
;	O
unsigned	O
int	O
first_deleted	int
=	O
0	int
;	O
int	O
first_deleted_set	int
=	O
0	int
;	O
unsigned	O
int	O
mask	int
=	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
-	O
1	int
;	O
idx	int
=	O
hash	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long)->(long)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
key	long
)	O
&	O
mask	int
;	O
up_idx	int
=	O
idx	int
;	O
do	O
{	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
up_idx	int
]	O
.	O
value	*(void)
==	O
_HURD_IHASH_EMPTY	O
)	O
return	O
first_deleted_set	int
?	O
first_deleted	int
:	O
up_idx	int
;	O
if	O
(	O
compare	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
up_idx	int
]	O
.	O
key	long
,	O
key	long
)	O
)	O
return	O
up_idx	int
;	O
if	O
(	O
!	O
first_deleted_set	int
&&	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
up_idx	int
]	O
.	O
value	*(void)
==	O
_HURD_IHASH_DELETED	O
)	O
first_deleted	int
=	O
up_idx	int
,	O
first_deleted_set	int
=	O
1	int
;	O
up_idx	int
=	O
(	O
up_idx	int
+	O
1	int
)	O
&	O
mask	int
;	O
}	O
while	O
(	O
up_idx	int
!=	O
idx	int
)	O
;	O
return	O
first_deleted	int
;	O
}	O
static	O
inline	O
void	O
locp_remove	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),*(*(void)))->(void)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_locp_t	*(*(void))
locp	*(*(void))
)	O
{	O
struct	O
_hurd_ihash_item	struct(*(void),long)
*	O
item	*(void)
=	O
(	O
struct	O
_hurd_ihash_item	struct(*(void),long)
*	O
)	O
locp	*(*(void))
;	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup	*((*(void),*(void))->(void))
)	O
(	O
*	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup	*((*(void),*(void))->(void))
)	O
(	O
item	*(void)
->	O
value	*(void)
,	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup_data	*(void)
)	O
;	O
item	*(void)
->	O
value	*(void)
=	O
_HURD_IHASH_DELETED	O
;	O
item	*(void)
->	O
key	long
=	O
0	int
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
nr_items	long
--	O
;	O
}	O
void	O
hurd_ihash_init	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long)->(void)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
intptr_t	long
locp_offs	long
)	O
{	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
nr_items	long
=	O
0	int
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
=	O
0	int
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
locp_offset	long
=	O
locp_offs	long
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
max_load	int
=	O
HURD_IHASH_MAX_LOAD_DEFAULT	int
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup	*((*(void),*(void))->(void))
=	O
0	int
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
fct_hash	*((*(void))->(long))
=	O
NULL	O
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
fct_cmp	*((*(void),*(void))->(int))
=	O
NULL	O
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
nr_free	long
=	O
0	int
;	O
}	O
void	O
hurd_ihash_destroy	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)))->(void)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
)	O
{	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup	*((*(void),*(void))->(void))
)	O
{	O
hurd_ihash_cleanup_t	*((*(void),*(void))->(void))
cleanup	*((*(void),*(void))->(void))
=	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup	*((*(void),*(void))->(void))
;	O
void	O
*	O
cleanup_data	*(void)
=	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup_data	*(void)
;	O
HURD_IHASH_ITERATE	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
value	*(void)
)	O
(	O
*	O
cleanup	*((*(void),*(void))->(void))
)	O
(	O
value	*(void)
,	O
cleanup_data	*(void)
)	O
;	O
}	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
>	O
0	int
)	O
free	(*(void))->(void)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
)	O
;	O
}	O
error_t	int
hurd_ihash_create	(*(*(struct(long,*(struct`),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long))),long)->(int)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
*	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
intptr_t	long
locp_offs	long
)	O
{	O
*	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
hurd_ihash	struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long)
)	O
)	O
;	O
if	O
(	O
*	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
hurd_ihash_init	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long)->(void)
(	O
*	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
locp_offs	long
)	O
;	O
return	O
0	int
;	O
}	O
void	O
hurd_ihash_free	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)))->(void)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
)	O
{	O
hurd_ihash_destroy	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)))->(void)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
)	O
;	O
free	(*(void))->(void)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
)	O
;	O
}	O
void	O
hurd_ihash_set_cleanup	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),*((*(void),*(void))->(void)),*(void))->(void)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_cleanup_t	*((*(void),*(void))->(void))
cleanup	*((*(void),*(void))->(void))
,	O
void	O
*	O
cleanup_data	*(void)
)	O
{	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup	*((*(void),*(void))->(void))
=	O
cleanup	*((*(void),*(void))->(void))
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup_data	*(void)
=	O
cleanup_data	*(void)
;	O
}	O
void	O
hurd_ihash_set_gki	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),*((*(void))->(long)),*((*(void),*(void))->(int)))->(void)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_fct_hash_t	*((*(void))->(long))
fct_hash	*((*(void))->(long))
,	O
hurd_ihash_fct_cmp_t	*((*(void),*(void))->(int))
fct_cmp	*((*(void),*(void))->(int))
)	O
{	O
assert	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
==	O
0	int
||	O
!	O
"called after insertion"	*(char)
)	O
;	O
assert	O
(	O
fct_hash	*((*(void))->(long))
)	O
;	O
assert	O
(	O
fct_cmp	*((*(void),*(void))->(int))
)	O
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
fct_hash	*((*(void))->(long))
=	O
fct_hash	*((*(void))->(long))
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
fct_cmp	*((*(void),*(void))->(int))
=	O
fct_cmp	*((*(void),*(void))->(int))
;	O
}	O
void	O
hurd_ihash_set_max_load	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),int)->(void)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
unsigned	O
int	O
max_load	int
)	O
{	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
max_load	int
=	O
max_load	int
;	O
}	O
static	O
inline	O
int	O
add_one	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,*(void))->(int)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_key_t	long
key	long
,	O
hurd_ihash_value_t	*(void)
value	*(void)
)	O
{	O
unsigned	O
int	O
idx	int
;	O
idx	int
=	O
find_index	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
key	long
)	O
;	O
if	O
(	O
index_valid	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),int,long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
idx	int
,	O
key	long
)	O
)	O
locp_remove	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),*(*(void)))->(void)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
&	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
idx	int
]	O
.	O
value	*(void)
)	O
;	O
if	O
(	O
index_empty	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),int)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
idx	int
)	O
)	O
{	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
nr_items	long
++	O
;	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
idx	int
]	O
.	O
value	*(void)
==	O
_HURD_IHASH_EMPTY	O
)	O
{	O
assert	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
nr_free	long
>	O
0	int
)	O
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
nr_free	long
--	O
;	O
}	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
idx	int
]	O
.	O
value	*(void)
=	O
value	*(void)
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
idx	int
]	O
.	O
key	long
=	O
key	long
;	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
locp_offset	long
!=	O
HURD_IHASH_NO_LOCP	O
)	O
*	O
(	O
(	O
hurd_ihash_locp_t	*(*(void))
*	O
)	O
(	O
(	O
(	O
char	O
*	O
)	O
value	*(void)
)	O
+	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
locp_offset	long
)	O
)	O
=	O
&	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
idx	int
]	O
.	O
value	*(void)
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
error_t	int
hurd_ihash_locp_add	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),*(*(void)),long,*(void))->(int)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_locp_t	*(*(void))
locp	*(*(void))
,	O
hurd_ihash_key_t	long
key	long
,	O
hurd_ihash_value_t	*(void)
value	*(void)
)	O
{	O
struct	O
_hurd_ihash_item	struct(*(void),long)
*	O
item	*(void)
=	O
(	O
struct	O
_hurd_ihash_item	struct(*(void),long)
*	O
)	O
locp	*(*(void))
;	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
==	O
0	int
||	O
item	*(void)
==	O
NULL	O
||	O
(	O
hurd_ihash_value_valid	(*(void))->(int)
(	O
item	*(void)
->	O
value	*(void)
)	O
&&	O
!	O
compare	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
item	*(void)
->	O
key	long
,	O
key	long
)	O
)	O
||	O
hurd_ihash_get_effective_load	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)))->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
)	O
>	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
max_load	int
)	O
return	O
hurd_ihash_add	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,*(void))->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
key	long
,	O
value	*(void)
)	O
;	O
if	O
(	O
!	O
hurd_ihash_value_valid	(*(void))->(int)
(	O
item	*(void)
->	O
value	*(void)
)	O
)	O
{	O
item	*(void)
->	O
key	long
=	O
key	long
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
nr_items	long
+=	O
1	int
;	O
if	O
(	O
item	*(void)
->	O
value	*(void)
==	O
_HURD_IHASH_EMPTY	O
)	O
{	O
assert	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
nr_free	long
>	O
0	int
)	O
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
nr_free	long
-=	O
1	int
;	O
}	O
}	O
else	O
{	O
assert	O
(	O
compare	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
item	*(void)
->	O
key	long
,	O
key	long
)	O
)	O
;	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup	*((*(void),*(void))->(void))
)	O
(	O
*	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup	*((*(void),*(void))->(void))
)	O
(	O
locp	*(*(void))
,	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
cleanup_data	*(void)
)	O
;	O
}	O
item	*(void)
->	O
value	*(void)
=	O
value	*(void)
;	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
locp_offset	long
!=	O
HURD_IHASH_NO_LOCP	O
)	O
*	O
(	O
(	O
hurd_ihash_locp_t	*(*(void))
*	O
)	O
(	O
(	O
(	O
char	O
*	O
)	O
value	*(void)
)	O
+	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
locp_offset	long
)	O
)	O
=	O
locp	*(*(void))
;	O
return	O
0	int
;	O
}	O
error_t	int
hurd_ihash_add	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,*(void))->(int)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_key_t	long
key	long
,	O
hurd_ihash_value_t	*(void)
item	*(void)
)	O
{	O
struct	O
hurd_ihash	struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long)
old_ht	struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long)
=	O
*	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
;	O
int	O
was_added	int
;	O
int	O
fatal	int
=	O
0	int
;	O
unsigned	O
int	O
i	int
;	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
)	O
{	O
if	O
(	O
hurd_ihash_get_effective_load	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)))->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
)	O
<=	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
max_load	int
)	O
add_one	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,*(void))->(int)
:	O
if	O
(	O
add_one	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,*(void))->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
key	long
,	O
item	*(void)
)	O
)	O
return	O
0	int
;	O
}	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
nr_items	long
=	O
0	int
;	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
==	O
0	int
)	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
=	O
HURD_IHASH_MIN_SIZE	int
;	O
else	O
if	O
(	O
hurd_ihash_get_load	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)))->(int)
(	O
&	O
old_ht	struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long)
)	O
>	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
max_load	int
)	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
<<=	O
1	int
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
nr_free	long
=	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
;	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
=	O
calloc	(long,long)->(*(void))
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
,	O
sizeof	O
(	O
struct	O
_hurd_ihash_item	struct(*(void),long)
)	O
)	O
;	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
==	O
NULL	O
)	O
{	O
*	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
=	O
old_ht	struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long)
;	O
if	O
(	O
fatal	int
||	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
==	O
0	int
)	O
return	O
ENOMEM	int
;	O
fatal	int
=	O
1	int
;	O
goto	O
add_one	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,*(void))->(int)
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
old_ht	struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long)
.	O
size	long
;	O
i	int
++	O
)	O
if	O
(	O
!	O
index_empty	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),int)->(int)
(	O
&	O
old_ht	struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long)
,	O
i	int
)	O
)	O
{	O
was_added	int
=	O
add_one	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,*(void))->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
old_ht	struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long)
.	O
items	*(struct(*(void),long))
[	O
i	int
]	O
.	O
key	long
,	O
old_ht	struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long)
.	O
items	*(struct(*(void),long))
[	O
i	int
]	O
.	O
value	*(void)
)	O
;	O
assert	O
(	O
was_added	int
)	O
;	O
}	O
was_added	int
=	O
add_one	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,*(void))->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
key	long
,	O
item	*(void)
)	O
;	O
assert	O
(	O
was_added	int
)	O
;	O
if	O
(	O
old_ht	struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long)
.	O
size	long
>	O
0	int
)	O
free	(*(void))->(void)
(	O
old_ht	struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long)
.	O
items	*(struct(*(void),long))
)	O
;	O
return	O
0	int
;	O
}	O
hurd_ihash_value_t	*(void)
hurd_ihash_find	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long)->(*(void))
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_key_t	long
key	long
)	O
{	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
==	O
0	int
)	O
return	O
NULL	O
;	O
else	O
{	O
int	O
idx	int
=	O
find_index	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
key	long
)	O
;	O
return	O
index_valid	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),int,long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
idx	int
,	O
key	long
)	O
?	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
idx	int
]	O
.	O
value	*(void)
:	O
NULL	O
;	O
}	O
}	O
hurd_ihash_value_t	*(void)
hurd_ihash_locp_find	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long,*(*(*(void))))->(*(void))
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_key_t	long
key	long
,	O
hurd_ihash_locp_t	*(*(void))
*	O
slot	*(*(*(void)))
)	O
{	O
int	O
idx	int
;	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
==	O
0	int
)	O
{	O
*	O
slot	*(*(*(void)))
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
idx	int
=	O
find_index	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
key	long
)	O
;	O
*	O
slot	*(*(*(void)))
=	O
&	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
idx	int
]	O
.	O
value	*(void)
;	O
return	O
index_valid	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),int,long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
idx	int
,	O
key	long
)	O
?	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
idx	int
]	O
.	O
value	*(void)
:	O
NULL	O
;	O
}	O
int	O
hurd_ihash_remove	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long)->(int)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_key_t	long
key	long
)	O
{	O
if	O
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
size	long
!=	O
0	int
)	O
{	O
int	O
idx	int
=	O
find_index	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
key	long
)	O
;	O
if	O
(	O
index_valid	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),int,long)->(int)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
idx	int
,	O
key	long
)	O
)	O
{	O
locp_remove	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),*(*(void)))->(void)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
&	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
->	O
items	*(struct(*(void),long))
[	O
idx	int
]	O
.	O
value	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
hurd_ihash_locp_remove	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),*(*(void)))->(void)
(	O
hurd_ihash_t	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
hurd_ihash_locp_t	*(*(void))
locp	*(*(void))
)	O
{	O
locp_remove	(*(struct(long,*(struct(*`,long)),long,long,int,*((*`,*`)->(void)),*(void),*((*`)->(long)),*((*`,*`)->(int)),long)),*(*(void)))->(void)
(	O
ht	*(struct(long,*(struct(*(void),long)),long,long,int,*((*(void),*(void))->(void)),*(void),*((*(void))->(long)),*((*(void),*(void))->(int)),long))
,	O
locp	*(*(void))
)	O
;	O
}	O
