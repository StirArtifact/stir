static	O
inline	O
struct	O
pgrp	O
*	O
new_pgrp	(int,*(struct))->(*(struct))
(	O
pid_t	int
pgid	int
,	O
struct	O
session	O
*	O
sess	*(struct)
)	O
{	O
struct	O
pgrp	O
*	O
pg	*(struct)
;	O
pg	*(struct)
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
pgrp	O
)	O
)	O
;	O
if	O
(	O
!	O
pg	*(struct)
)	O
return	O
NULL	O
;	O
pg	*(struct)
->	O
pg_plist	O
=	O
0	int
;	O
pg	*(struct)
->	O
pg_pgid	O
=	O
pgid	int
;	O
pg	*(struct)
->	O
pg_orphcnt	O
=	O
0	int
;	O
pg	*(struct)
->	O
pg_session	O
=	O
sess	*(struct)
;	O
pg	*(struct)
->	O
pg_next	O
=	O
sess	*(struct)
->	O
s_pgrps	O
;	O
if	O
(	O
pg	*(struct)
->	O
pg_next	O
)	O
pg	*(struct)
->	O
pg_next	O
->	O
pg_prevp	O
=	O
&	O
pg	*(struct)
->	O
pg_next	O
;	O
sess	*(struct)
->	O
s_pgrps	O
=	O
pg	*(struct)
;	O
pg	*(struct)
->	O
pg_prevp	O
=	O
&	O
sess	*(struct)
->	O
s_pgrps	O
;	O
add_pgrp_to_hash	()->(int)
(	O
pg	*(struct)
)	O
;	O
return	O
pg	*(struct)
;	O
}	O
static	O
inline	O
struct	O
session	O
*	O
new_session	(*(struct))->(*(struct))
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
struct	O
session	O
*	O
sess	*(struct)
;	O
sess	*(struct)
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
session	O
)	O
)	O
;	O
if	O
(	O
!	O
sess	*(struct)
)	O
return	O
NULL	O
;	O
sess	*(struct)
->	O
s_sid	O
=	O
p	*(struct)
->	O
p_pid	O
;	O
sess	*(struct)
->	O
s_pgrps	O
=	O
0	int
;	O
sess	*(struct)
->	O
s_sessionid	O
=	O
MACH_PORT_NULL	O
;	O
add_session_to_hash	()->(int)
(	O
sess	*(struct)
)	O
;	O
return	O
sess	*(struct)
;	O
}	O
static	O
inline	O
void	O
free_session	(*(struct))->(void)
(	O
struct	O
session	O
*	O
s	*(struct)
)	O
{	O
if	O
(	O
s	*(struct)
->	O
s_sessionid	O
)	O
mach_port_mod_refs	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
s	*(struct)
->	O
s_sessionid	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
-	O
1	int
)	O
;	O
remove_session_from_hash	()->(int)
(	O
s	*(struct)
)	O
;	O
free	()->(int)
(	O
s	*(struct)
)	O
;	O
}	O
static	O
inline	O
void	O
free_pgrp	(*(struct))->(void)
(	O
struct	O
pgrp	O
*	O
pg	*(struct)
)	O
{	O
*	O
pg	*(struct)
->	O
pg_prevp	O
=	O
pg	*(struct)
->	O
pg_next	O
;	O
if	O
(	O
pg	*(struct)
->	O
pg_next	O
)	O
pg	*(struct)
->	O
pg_next	O
->	O
pg_prevp	O
=	O
pg	*(struct)
->	O
pg_prevp	O
;	O
if	O
(	O
!	O
pg	*(struct)
->	O
pg_session	O
->	O
s_pgrps	O
)	O
free_session	(*(struct))->(void)
(	O
pg	*(struct)
->	O
pg_session	O
)	O
;	O
remove_pgrp_from_hash	()->(int)
(	O
pg	*(struct)
)	O
;	O
free	()->(int)
(	O
pg	*(struct)
)	O
;	O
}	O
kern_return_t	O
S_proc_setsid	(*(struct))->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
struct	O
session	O
*	O
sess	*(struct)
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_pgid	O
==	O
p	*(struct)
->	O
p_pid	O
||	O
pgrp_find	()->(int)
(	O
p	*(struct)
->	O
p_pid	O
)	O
)	O
return	O
EPERM	O
;	O
leave_pgrp	()->(int)
(	O
p	*(struct)
)	O
;	O
sess	*(struct)
=	O
new_session	(*(struct))->(*(struct))
(	O
p	*(struct)
)	O
;	O
p	*(struct)
->	O
p_pgrp	O
=	O
new_pgrp	(int,*(struct))->(*(struct))
(	O
p	*(struct)
->	O
p_pid	O
,	O
sess	*(struct)
)	O
;	O
join_pgrp	()->(int)
(	O
p	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
boot_setsid	(*(struct))->(void)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
struct	O
session	O
*	O
sess	*(struct)
;	O
sess	*(struct)
=	O
new_session	(*(struct))->(*(struct))
(	O
p	*(struct)
)	O
;	O
p	*(struct)
->	O
p_pgrp	O
=	O
new_pgrp	(int,*(struct))->(*(struct))
(	O
p	*(struct)
->	O
p_pid	O
,	O
sess	*(struct)
)	O
;	O
assert	()->(int)
(	O
p	*(struct)
->	O
p_pgrp	O
)	O
;	O
join_pgrp	()->(int)
(	O
p	*(struct)
)	O
;	O
return	O
;	O
}	O
kern_return_t	O
S_proc_getsid	(*(struct),int,*(int))->(int)
(	O
struct	O
proc	O
*	O
callerp	*(struct)
,	O
pid_t	int
pid	int
,	O
pid_t	int
*	O
sid	*(int)
)	O
{	O
struct	O
proc	O
*	O
p	*(struct)
=	O
pid_find	()->(int)
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
ESRCH	O
;	O
*	O
sid	*(int)
=	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sid	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getsessionpids	(*(struct),int,*(*(int)),*(long))->(int)
(	O
struct	O
proc	O
*	O
callerp	*(struct)
,	O
pid_t	int
sid	*(int)
,	O
pid_t	int
*	O
*	O
pids	*(*(int))
,	O
size_t	long
*	O
npidsp	*(long)
)	O
{	O
int	O
count	int
;	O
struct	O
pgrp	O
*	O
pg	*(struct)
;	O
struct	O
proc	O
*	O
p	*(struct)
;	O
struct	O
session	O
*	O
s	*(struct)
;	O
pid_t	int
*	O
pp	*(int)
=	O
*	O
pids	*(*(int))
;	O
u_int	int
npids	int
=	O
*	O
npidsp	*(long)
;	O
s	*(struct)
=	O
session_find	()->(int)
(	O
sid	*(int)
)	O
;	O
if	O
(	O
!	O
s	*(struct)
)	O
return	O
ESRCH	O
;	O
count	int
=	O
0	int
;	O
for	O
(	O
pg	*(struct)
=	O
s	*(struct)
->	O
s_pgrps	O
;	O
pg	*(struct)
;	O
pg	*(struct)
=	O
pg	*(struct)
->	O
pg_next	O
)	O
for	O
(	O
p	*(struct)
=	O
pg	*(struct)
->	O
pg_plist	O
;	O
p	*(struct)
;	O
p	*(struct)
=	O
p	*(struct)
->	O
p_gnext	O
)	O
{	O
if	O
(	O
++	O
count	int
<=	O
npids	int
)	O
*	O
pp	*(int)
++	O
=	O
p	*(struct)
->	O
p_pid	O
;	O
}	O
if	O
(	O
count	int
>	O
npids	int
)	O
{	O
*	O
pids	*(*(int))
=	O
mmap	()->(int)
(	O
0	int
,	O
count	int
*	O
sizeof	O
(	O
pid_t	int
)	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
pids	*(*(int))
==	O
MAP_FAILED	O
)	O
return	O
errno	O
;	O
pp	*(int)
=	O
*	O
pids	*(*(int))
;	O
for	O
(	O
pg	*(struct)
=	O
s	*(struct)
->	O
s_pgrps	O
;	O
pg	*(struct)
;	O
pg	*(struct)
=	O
pg	*(struct)
->	O
pg_next	O
)	O
for	O
(	O
p	*(struct)
=	O
pg	*(struct)
->	O
pg_plist	O
;	O
p	*(struct)
;	O
p	*(struct)
=	O
p	*(struct)
->	O
p_gnext	O
)	O
*	O
pp	*(int)
++	O
=	O
p	*(struct)
->	O
p_pid	O
;	O
}	O
*	O
npidsp	*(long)
=	O
count	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getsessionpgids	(*(struct),int,*(*(int)),*(long))->(int)
(	O
struct	O
proc	O
*	O
callerp	*(struct)
,	O
pid_t	int
sid	*(int)
,	O
pid_t	int
*	O
*	O
pgids	*(*(int))
,	O
size_t	long
*	O
npgidsp	*(long)
)	O
{	O
int	O
count	int
;	O
struct	O
pgrp	O
*	O
pg	*(struct)
;	O
struct	O
session	O
*	O
s	*(struct)
;	O
pid_t	int
*	O
pp	*(int)
=	O
*	O
pgids	*(*(int))
;	O
int	O
npgids	int
=	O
*	O
npgidsp	*(long)
;	O
s	*(struct)
=	O
session_find	()->(int)
(	O
sid	*(int)
)	O
;	O
if	O
(	O
!	O
s	*(struct)
)	O
return	O
ESRCH	O
;	O
count	int
=	O
0	int
;	O
for	O
(	O
pg	*(struct)
=	O
s	*(struct)
->	O
s_pgrps	O
;	O
pg	*(struct)
;	O
pg	*(struct)
=	O
pg	*(struct)
->	O
pg_next	O
)	O
if	O
(	O
++	O
count	int
<=	O
npgids	int
)	O
*	O
pp	*(int)
++	O
=	O
pg	*(struct)
->	O
pg_pgid	O
;	O
if	O
(	O
count	int
>	O
npgids	int
)	O
{	O
*	O
pgids	*(*(int))
=	O
mmap	()->(int)
(	O
0	int
,	O
count	int
*	O
sizeof	O
(	O
pid_t	int
)	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
pgids	*(*(int))
==	O
MAP_FAILED	O
)	O
return	O
errno	O
;	O
pp	*(int)
=	O
*	O
pgids	*(*(int))
;	O
for	O
(	O
pg	*(struct)
=	O
s	*(struct)
->	O
s_pgrps	O
;	O
pg	*(struct)
;	O
pg	*(struct)
=	O
pg	*(struct)
->	O
pg_next	O
)	O
*	O
pp	*(int)
++	O
=	O
pg	*(struct)
->	O
pg_pgid	O
;	O
}	O
*	O
npgidsp	*(long)
=	O
count	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getpgrppids	(*(struct),int,*(*(int)),*(long))->(int)
(	O
struct	O
proc	O
*	O
callerp	*(struct)
,	O
pid_t	int
pgid	int
,	O
pid_t	int
*	O
*	O
pids	*(*(int))
,	O
size_t	long
*	O
npidsp	*(long)
)	O
{	O
struct	O
proc	O
*	O
p	*(struct)
;	O
struct	O
pgrp	O
*	O
pg	*(struct)
;	O
pid_t	int
*	O
pp	*(int)
=	O
*	O
pids	*(*(int))
;	O
unsigned	O
int	O
npids	int
=	O
*	O
npidsp	*(long)
,	O
count	int
;	O
if	O
(	O
pgid	int
==	O
0	int
)	O
pg	*(struct)
=	O
callerp	*(struct)
->	O
p_pgrp	O
;	O
else	O
{	O
pg	*(struct)
=	O
pgrp_find	()->(int)
(	O
pgid	int
)	O
;	O
if	O
(	O
!	O
pg	*(struct)
)	O
return	O
ESRCH	O
;	O
}	O
count	int
=	O
0	int
;	O
for	O
(	O
p	*(struct)
=	O
pg	*(struct)
->	O
pg_plist	O
;	O
p	*(struct)
;	O
p	*(struct)
=	O
p	*(struct)
->	O
p_gnext	O
)	O
if	O
(	O
!	O
p	*(struct)
->	O
p_important	O
&&	O
++	O
count	int
<=	O
npids	int
)	O
*	O
pp	*(int)
++	O
=	O
p	*(struct)
->	O
p_pid	O
;	O
if	O
(	O
count	int
>	O
npids	int
)	O
{	O
*	O
pids	*(*(int))
=	O
mmap	()->(int)
(	O
0	int
,	O
count	int
*	O
sizeof	O
(	O
pid_t	int
)	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
pids	*(*(int))
==	O
MAP_FAILED	O
)	O
return	O
errno	O
;	O
pp	*(int)
=	O
*	O
pids	*(*(int))
;	O
for	O
(	O
p	*(struct)
=	O
pg	*(struct)
->	O
pg_plist	O
;	O
p	*(struct)
;	O
p	*(struct)
=	O
p	*(struct)
->	O
p_gnext	O
)	O
if	O
(	O
!	O
p	*(struct)
->	O
p_important	O
)	O
*	O
pp	*(int)
++	O
=	O
p	*(struct)
->	O
p_pid	O
;	O
}	O
*	O
npidsp	*(long)
=	O
count	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getsidport	(*(struct),*(int),*(int))->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
mach_port_t	O
*	O
sessport	*(int)
,	O
mach_msg_type_name_t	O
*	O
sessport_type	*(int)
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
!	O
p	*(struct)
->	O
p_pgrp	O
)	O
*	O
sessport	*(int)
=	O
MACH_PORT_NULL	O
;	O
else	O
{	O
if	O
(	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sessionid	O
==	O
MACH_PORT_NULL	O
)	O
err	O
=	O
mach_port_allocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sessionid	O
)	O
;	O
*	O
sessport	*(int)
=	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sessionid	O
;	O
}	O
*	O
sessport_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
return	O
err	O
;	O
}	O
kern_return_t	O
S_proc_setpgrp	(*(struct),int,int)->(int)
(	O
struct	O
proc	O
*	O
callerp	*(struct)
,	O
pid_t	int
pid	int
,	O
pid_t	int
pgid	int
)	O
{	O
struct	O
proc	O
*	O
p	*(struct)
;	O
struct	O
pgrp	O
*	O
pg	*(struct)
;	O
if	O
(	O
!	O
callerp	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
p	*(struct)
=	O
pid	int
?	O
pid_find	()->(int)
(	O
pid	int
)	O
:	O
callerp	*(struct)
;	O
if	O
(	O
!	O
p	*(struct)
||	O
(	O
p	*(struct)
!=	O
callerp	*(struct)
&&	O
p	*(struct)
->	O
p_parent	O
!=	O
callerp	*(struct)
)	O
)	O
return	O
ESRCH	O
;	O
if	O
(	O
p	*(struct)
->	O
p_parent	O
==	O
callerp	*(struct)
&&	O
p	*(struct)
->	O
p_exec	O
)	O
return	O
EACCES	O
;	O
if	O
(	O
!	O
pgid	int
)	O
pgid	int
=	O
p	*(struct)
->	O
p_pid	O
;	O
pg	*(struct)
=	O
pgrp_find	()->(int)
(	O
pgid	int
)	O
;	O
if	O
(	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sid	O
==	O
p	*(struct)
->	O
p_pid	O
||	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_session	O
!=	O
callerp	*(struct)
->	O
p_pgrp	O
->	O
pg_session	O
||	O
(	O
(	O
pgid	int
!=	O
p	*(struct)
->	O
p_pid	O
&&	O
(	O
!	O
pg	*(struct)
||	O
pg	*(struct)
->	O
pg_session	O
!=	O
callerp	*(struct)
->	O
p_pgrp	O
->	O
pg_session	O
)	O
)	O
)	O
)	O
return	O
EPERM	O
;	O
if	O
(	O
p	*(struct)
->	O
p_pgrp	O
!=	O
pg	*(struct)
)	O
{	O
struct	O
pgrp	O
*	O
new	*(struct)
=	O
pg	*(struct)
?	O
pg	*(struct)
:	O
new_pgrp	(int,*(struct))->(*(struct))
(	O
pgid	int
,	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_session	O
)	O
;	O
leave_pgrp	()->(int)
(	O
p	*(struct)
)	O
;	O
p	*(struct)
->	O
p_pgrp	O
=	O
new	*(struct)
;	O
join_pgrp	()->(int)
(	O
p	*(struct)
)	O
;	O
}	O
else	O
nowait_msg_proc_newids	()->(int)
(	O
p	*(struct)
->	O
p_msgport	O
,	O
p	*(struct)
->	O
p_task	O
,	O
p	*(struct)
->	O
p_parent	O
->	O
p_pid	O
,	O
pg	*(struct)
->	O
pg_pgid	O
,	O
!	O
pg	*(struct)
->	O
pg_orphcnt	O
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getpgrp	(*(struct),int,*(int))->(int)
(	O
struct	O
proc	O
*	O
callerp	*(struct)
,	O
pid_t	int
pid	int
,	O
pid_t	int
*	O
pgid	int
)	O
{	O
struct	O
proc	O
*	O
p	*(struct)
=	O
pid_find	()->(int)
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
ESRCH	O
;	O
if	O
(	O
p	*(struct)
->	O
p_pgrp	O
)	O
*	O
pgid	int
=	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_pgid	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_mark_exec	(*(struct))->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
p	*(struct)
->	O
p_exec	O
=	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
leave_pgrp	()->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
struct	O
pgrp	O
*	O
pg	*(struct)
=	O
p	*(struct)
->	O
p_pgrp	O
;	O
*	O
p	*(struct)
->	O
p_gprevp	O
=	O
p	*(struct)
->	O
p_gnext	O
;	O
if	O
(	O
p	*(struct)
->	O
p_gnext	O
)	O
p	*(struct)
->	O
p_gnext	O
->	O
p_gprevp	O
=	O
p	*(struct)
->	O
p_gprevp	O
;	O
if	O
(	O
!	O
pg	*(struct)
->	O
pg_plist	O
)	O
free_pgrp	(*(struct))->(void)
(	O
pg	*(struct)
)	O
;	O
else	O
if	O
(	O
p	*(struct)
->	O
p_parent	O
->	O
p_pgrp	O
!=	O
pg	*(struct)
&&	O
p	*(struct)
->	O
p_parent	O
->	O
p_pgrp	O
->	O
pg_session	O
==	O
pg	*(struct)
->	O
pg_session	O
&&	O
!	O
--	O
pg	*(struct)
->	O
pg_orphcnt	O
)	O
{	O
struct	O
proc	O
*	O
ip	*(struct)
;	O
int	O
dosignal	int
=	O
0	int
;	O
for	O
(	O
ip	*(struct)
=	O
pg	*(struct)
->	O
pg_plist	O
;	O
ip	*(struct)
;	O
ip	*(struct)
=	O
ip	*(struct)
->	O
p_gnext	O
)	O
{	O
if	O
(	O
ip	*(struct)
->	O
p_stopped	O
)	O
dosignal	int
=	O
1	int
;	O
if	O
(	O
ip	*(struct)
->	O
p_msgport	O
!=	O
MACH_PORT_NULL	O
)	O
nowait_msg_proc_newids	()->(int)
(	O
ip	*(struct)
->	O
p_msgport	O
,	O
ip	*(struct)
->	O
p_task	O
,	O
ip	*(struct)
->	O
p_parent	O
->	O
p_pid	O
,	O
ip	*(struct)
->	O
p_pid	O
,	O
1	int
)	O
;	O
}	O
if	O
(	O
dosignal	int
)	O
for	O
(	O
ip	*(struct)
=	O
pg	*(struct)
->	O
pg_plist	O
;	O
ip	*(struct)
;	O
ip	*(struct)
=	O
ip	*(struct)
->	O
p_gnext	O
)	O
{	O
send_signal	()->(int)
(	O
ip	*(struct)
->	O
p_msgport	O
,	O
SIGHUP	O
,	O
ip	*(struct)
->	O
p_task	O
)	O
;	O
send_signal	()->(int)
(	O
ip	*(struct)
->	O
p_msgport	O
,	O
SIGCONT	O
,	O
ip	*(struct)
->	O
p_task	O
)	O
;	O
}	O
}	O
}	O
void	O
join_pgrp	()->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
struct	O
pgrp	O
*	O
pg	*(struct)
=	O
p	*(struct)
->	O
p_pgrp	O
;	O
struct	O
proc	O
*	O
tp	*(struct)
;	O
int	O
origorphcnt	int
;	O
p	*(struct)
->	O
p_gnext	O
=	O
pg	*(struct)
->	O
pg_plist	O
;	O
p	*(struct)
->	O
p_gprevp	O
=	O
&	O
pg	*(struct)
->	O
pg_plist	O
;	O
if	O
(	O
pg	*(struct)
->	O
pg_plist	O
)	O
pg	*(struct)
->	O
pg_plist	O
->	O
p_gprevp	O
=	O
&	O
p	*(struct)
->	O
p_gnext	O
;	O
pg	*(struct)
->	O
pg_plist	O
=	O
p	*(struct)
;	O
origorphcnt	int
=	O
!	O
!	O
pg	*(struct)
->	O
pg_orphcnt	O
;	O
if	O
(	O
p	*(struct)
->	O
p_parent	O
->	O
p_pgrp	O
!=	O
pg	*(struct)
&&	O
p	*(struct)
->	O
p_parent	O
->	O
p_pgrp	O
->	O
pg_session	O
==	O
pg	*(struct)
->	O
pg_session	O
)	O
pg	*(struct)
->	O
pg_orphcnt	O
++	O
;	O
if	O
(	O
origorphcnt	int
!=	O
!	O
!	O
pg	*(struct)
->	O
pg_orphcnt	O
)	O
{	O
for	O
(	O
tp	*(struct)
=	O
pg	*(struct)
->	O
pg_plist	O
;	O
tp	*(struct)
;	O
tp	*(struct)
=	O
tp	*(struct)
->	O
p_gnext	O
)	O
if	O
(	O
tp	*(struct)
->	O
p_msgport	O
!=	O
MACH_PORT_NULL	O
)	O
nowait_msg_proc_newids	()->(int)
(	O
tp	*(struct)
->	O
p_msgport	O
,	O
tp	*(struct)
->	O
p_task	O
,	O
tp	*(struct)
->	O
p_parent	O
->	O
p_pid	O
,	O
pg	*(struct)
->	O
pg_pgid	O
,	O
!	O
pg	*(struct)
->	O
pg_orphcnt	O
)	O
;	O
}	O
else	O
if	O
(	O
p	*(struct)
->	O
p_msgport	O
!=	O
MACH_PORT_NULL	O
)	O
nowait_msg_proc_newids	()->(int)
(	O
p	*(struct)
->	O
p_msgport	O
,	O
p	*(struct)
->	O
p_task	O
,	O
p	*(struct)
->	O
p_parent	O
->	O
p_pid	O
,	O
pg	*(struct)
->	O
pg_pgid	O
,	O
!	O
pg	*(struct)
->	O
pg_orphcnt	O
)	O
;	O
}	O
