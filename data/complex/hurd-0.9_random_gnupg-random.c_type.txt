static	O
int	O
is_initialized	int
;	O
static	O
byte	char
*	O
rndpool	*(char)
;	O
static	O
byte	char
*	O
keypool	*(char)
;	O
static	O
size_t	long
pool_readpos	long
;	O
static	O
size_t	long
pool_writepos	long
;	O
static	O
int	O
pool_filled	int
;	O
static	O
int	O
pool_balance	int
;	O
static	O
int	O
just_mixed	int
;	O
static	O
int	O
did_initial_extra_seeding	int
;	O
static	O
char	O
*	O
seed_file_name	*(char)
;	O
static	O
int	O
allow_seed_file_update	int
;	O
static	O
int	O
secure_alloc	int
;	O
static	O
int	O
quick_test	int
;	O
static	O
int	O
faked_rng	int
;	O
int	O
read_pool	(*(char),long,int)->(int)
(	O
byte	char
*	O
buffer	*(char)
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
;	O
static	O
void	O
add_randomness	(*(void),long,int)->(void)
(	O
const	O
void	O
*	O
buffer	*(char)
,	O
size_t	long
length	long
,	O
int	O
source	int
)	O
;	O
static	O
void	O
random_poll	()->(void)
(	O
void	O
)	O
;	O
static	O
int	O
read_random_source	(int,long,int)->(int)
(	O
int	O
requester	int
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
;	O
static	O
int	O
gather_faked	(*((*(void),long,int)->(void)),int,long,int)->(int)
(	O
void	O
(	O
*	O
add	*((*(void),long,int)->(void))
)	O
(	O
const	O
void	O
*	O
,	O
size_t	long
,	O
int	O
)	O
,	O
int	O
requester	int
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
;	O
static	O
struct	O
{	O
ulong	long
mixrnd	long
;	O
ulong	long
mixkey	long
;	O
ulong	long
slowpolls	long
;	O
ulong	long
fastpolls	long
;	O
ulong	long
getbytes1	long
;	O
ulong	long
ngetbytes1	long
;	O
ulong	long
getbytes2	long
;	O
ulong	long
ngetbytes2	long
;	O
ulong	long
addbytes	long
;	O
ulong	long
naddbytes	long
;	O
}	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
;	O
static	O
void	O
initialize	()->(void)
(	O
void	O
)	O
{	O
rndpool	*(char)
=	O
secure_alloc	int
?	O
m_alloc_secure_clear	O
(	O
POOLSIZE	O
+	O
BLOCKLEN	int
)	O
:	O
m_alloc_clear	O
(	O
POOLSIZE	O
+	O
BLOCKLEN	int
)	O
;	O
keypool	*(char)
=	O
secure_alloc	int
?	O
m_alloc_secure_clear	O
(	O
POOLSIZE	O
+	O
BLOCKLEN	int
)	O
:	O
m_alloc_clear	O
(	O
POOLSIZE	O
+	O
BLOCKLEN	int
)	O
;	O
is_initialized	int
=	O
1	int
;	O
}	O
static	O
void	O
burn_stack	(int)->(void)
(	O
int	O
bytes	int
)	O
{	O
char	O
buf	array(char)
[	O
128	int
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
buf	array(char)
,	O
0	int
,	O
sizeof	O
buf	array(char)
)	O
;	O
bytes	int
-=	O
sizeof	O
buf	array(char)
;	O
if	O
(	O
bytes	int
>	O
0	int
)	O
burn_stack	(int)->(void)
(	O
bytes	int
)	O
;	O
}	O
void	O
random_dump_stats	()->(void)
(	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"random usage: poolsize=%d mixed=%lu polls=%lu/%lu added=%lu/%lu\n"	*(char)
"              outmix=%lu getlvl1=%lu/%lu getlvl2=%lu/%lu\n"	*(char)
,	O
POOLSIZE	O
,	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
mixrnd	long
,	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
slowpolls	long
,	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
fastpolls	long
,	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
naddbytes	long
,	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
addbytes	long
,	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
mixkey	long
,	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
ngetbytes1	long
,	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
getbytes1	long
,	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
ngetbytes2	long
,	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
getbytes2	long
)	O
;	O
}	O
void	O
secure_random_alloc	()->(void)
(	O
)	O
{	O
secure_alloc	int
=	O
1	int
;	O
}	O
int	O
quick_random_gen	(int)->(int)
(	O
int	O
onoff	int
)	O
{	O
int	O
last	int
;	O
read_random_source	(int,long,int)->(int)
(	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
last	int
=	O
quick_test	int
;	O
if	O
(	O
onoff	int
!=	O
-	O
1	int
)	O
quick_test	int
=	O
onoff	int
;	O
return	O
faked_rng	int
?	O
1	int
:	O
last	int
;	O
}	O
void	O
randomize_buffer	(*(char),long,int)->(void)
(	O
byte	char
*	O
buffer	*(char)
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
{	O
byte	char
*	O
p	*(char)
=	O
get_random_bits	(long,int,int)->(*(char))
(	O
length	long
*	O
8	int
,	O
level	int
,	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buffer	*(char)
,	O
p	*(char)
,	O
length	long
)	O
;	O
m_free	O
(	O
p	*(char)
)	O
;	O
}	O
int	O
random_is_faked	()->(int)
(	O
)	O
{	O
if	O
(	O
!	O
is_initialized	int
)	O
initialize	()->(void)
(	O
)	O
;	O
return	O
faked_rng	int
||	O
quick_test	int
;	O
}	O
byte	char
*	O
get_random_bits	(long,int,int)->(*(char))
(	O
size_t	long
nbits	long
,	O
int	O
level	int
,	O
int	O
secure	int
)	O
{	O
byte	char
*	O
buf	array(char)
,	O
*	O
p	*(char)
;	O
size_t	long
nbytes	long
=	O
(	O
nbits	long
+	O
7	int
)	O
/	O
8	int
;	O
if	O
(	O
quick_test	int
&&	O
level	int
>	O
1	int
)	O
level	int
=	O
1	int
;	O
MASK_LEVEL	O
(	O
level	int
)	O
;	O
if	O
(	O
level	int
==	O
1	int
)	O
{	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
getbytes1	long
+=	O
nbytes	long
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
ngetbytes1	long
++	O
;	O
}	O
else	O
if	O
(	O
level	int
>=	O
2	int
)	O
{	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
getbytes2	long
+=	O
nbytes	long
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
ngetbytes2	long
++	O
;	O
}	O
buf	array(char)
=	O
secure	int
&&	O
secure_alloc	int
?	O
m_alloc_secure	O
(	O
nbytes	long
)	O
:	O
m_alloc	O
(	O
nbytes	long
)	O
;	O
for	O
(	O
p	*(char)
=	O
buf	array(char)
;	O
nbytes	long
>	O
0	int
;	O
)	O
{	O
size_t	long
n	long
=	O
nbytes	long
>	O
POOLSIZE	O
?	O
POOLSIZE	O
:	O
nbytes	long
;	O
n	long
=	O
read_pool	(*(char),long,int)->(int)
(	O
p	*(char)
,	O
n	long
,	O
level	int
)	O
;	O
nbytes	long
-=	O
n	long
;	O
p	*(char)
+=	O
n	long
;	O
}	O
return	O
buf	array(char)
;	O
}	O
static	O
void	O
mix_pool	(*(char))->(void)
(	O
byte	char
*	O
pool	*(char)
)	O
{	O
byte	char
*	O
hashbuf	*(char)
=	O
pool	*(char)
+	O
POOLSIZE	O
;	O
byte	char
*	O
p	*(char)
,	O
*	O
pend	*(char)
;	O
int	O
i	int
,	O
n	long
;	O
RMD160_CONTEXT	struct(int,int,int,int,int,int,array(char),int)
md	struct(int,int,int,int,int,int,array(char),int)
;	O
rmd160_init	(*(struct(int,int,int,int,int,int,array(char),int)))->(void)
(	O
&	O
md	struct(int,int,int,int,int,int,array(char),int)
)	O
;	O
pend	*(char)
=	O
pool	*(char)
+	O
POOLSIZE	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hashbuf	*(char)
,	O
pend	*(char)
-	O
DIGESTLEN	int
,	O
DIGESTLEN	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hashbuf	*(char)
+	O
DIGESTLEN	int
,	O
pool	*(char)
,	O
BLOCKLEN	int
-	O
DIGESTLEN	int
)	O
;	O
rmd160_mixblock	(*(struct(int,int,int,int,int,int,array(char),int)),*(char))->(void)
(	O
&	O
md	struct(int,int,int,int,int,int,array(char),int)
,	O
hashbuf	*(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
pool	*(char)
,	O
hashbuf	*(char)
,	O
DIGESTLEN	int
)	O
;	O
p	*(char)
=	O
pool	*(char)
;	O
for	O
(	O
n	long
=	O
1	int
;	O
n	long
<	O
POOLBLOCKS	int
;	O
n	long
++	O
)	O
{	O
if	O
(	O
p	*(char)
+	O
BLOCKLEN	int
<	O
pend	*(char)
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hashbuf	*(char)
,	O
p	*(char)
,	O
BLOCKLEN	int
)	O
;	O
else	O
{	O
byte	char
*	O
pp	*(char)
=	O
p	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
BLOCKLEN	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pp	*(char)
>=	O
pend	*(char)
)	O
pp	*(char)
=	O
pool	*(char)
;	O
hashbuf	*(char)
[	O
i	int
]	O
=	O
*	O
pp	*(char)
++	O
;	O
}	O
}	O
rmd160_mixblock	(*(struct(int,int,int,int,int,int,array(char),int)),*(char))->(void)
(	O
&	O
md	struct(int,int,int,int,int,int,array(char),int)
,	O
hashbuf	*(char)
)	O
;	O
p	*(char)
+=	O
DIGESTLEN	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(char)
,	O
hashbuf	*(char)
,	O
DIGESTLEN	int
)	O
;	O
}	O
burn_stack	(int)->(void)
(	O
200	int
)	O
;	O
}	O
void	O
set_random_seed_file	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
seed_file_name	*(char)
)	O
BUG	O
(	O
)	O
;	O
seed_file_name	*(char)
=	O
m_strdup	O
(	O
name	*(char)
)	O
;	O
}	O
static	O
int	O
read_seed_file	()->(int)
(	O
)	O
{	O
int	O
fd	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
byte	char
buffer	*(char)
[	O
POOLSIZE	O
]	O
;	O
int	O
n	long
;	O
if	O
(	O
!	O
seed_file_name	*(char)
)	O
return	O
0	int
;	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
seed_file_name	*(char)
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
&&	O
errno	O
==	O
ENOENT	int
)	O
{	O
allow_seed_file_update	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
log_info	O
(	O
_	O
(	O
"can't open `%s': %s\n"	*(char)
)	O
,	O
seed_file_name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
log_info	O
(	O
_	O
(	O
"can't stat `%s': %s\n"	*(char)
)	O
,	O
seed_file_name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
log_info	O
(	O
_	O
(	O
"`%s' is not a regular file - ignored\n"	*(char)
)	O
,	O
seed_file_name	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
{	O
log_info	O
(	O
_	O
(	O
"note: random_seed file is empty\n"	*(char)
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
allow_seed_file_update	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
!=	O
POOLSIZE	O
)	O
{	O
log_info	O
(	O
_	O
(	O
"warning: invalid size of random_seed file - not used\n"	*(char)
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
do	O
{	O
n	long
=	O
read	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
buffer	*(char)
,	O
POOLSIZE	O
)	O
;	O
}	O
while	O
(	O
n	long
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
n	long
!=	O
POOLSIZE	O
)	O
{	O
log_fatal	O
(	O
_	O
(	O
"can't read `%s': %s\n"	*(char)
)	O
,	O
seed_file_name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
add_randomness	(*(void),long,int)->(void)
(	O
buffer	*(char)
,	O
POOLSIZE	O
,	O
0	int
)	O
;	O
{	O
pid_t	int
x	int
=	O
getpid	()->(int)
(	O
)	O
;	O
add_randomness	(*(void),long,int)->(void)
(	O
&	O
x	int
,	O
sizeof	O
(	O
x	int
)	O
,	O
0	int
)	O
;	O
}	O
{	O
time_t	long
x	int
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
add_randomness	(*(void),long,int)->(void)
(	O
&	O
x	int
,	O
sizeof	O
(	O
x	int
)	O
,	O
0	int
)	O
;	O
}	O
{	O
clock_t	long
x	int
=	O
clock	()->(long)
(	O
)	O
;	O
add_randomness	(*(void),long,int)->(void)
(	O
&	O
x	int
,	O
sizeof	O
(	O
x	int
)	O
,	O
0	int
)	O
;	O
}	O
read_random_source	(int,long,int)->(int)
(	O
0	int
,	O
16	int
,	O
0	int
)	O
;	O
allow_seed_file_update	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
void	O
update_random_seed_file	()->(void)
(	O
)	O
{	O
ulong	long
*	O
sp	*(long)
,	O
*	O
dp	*(long)
;	O
int	O
fd	int
,	O
i	int
;	O
if	O
(	O
!	O
seed_file_name	*(char)
||	O
!	O
is_initialized	int
||	O
!	O
pool_filled	int
)	O
return	O
;	O
if	O
(	O
!	O
allow_seed_file_update	int
)	O
{	O
log_info	O
(	O
_	O
(	O
"note: random_seed file not updated\n"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
,	O
dp	*(long)
=	O
(	O
ulong	long
*	O
)	O
keypool	*(char)
,	O
sp	*(long)
=	O
(	O
ulong	long
*	O
)	O
rndpool	*(char)
;	O
i	int
<	O
POOLWORDS	O
;	O
i	int
++	O
,	O
dp	*(long)
++	O
,	O
sp	*(long)
++	O
)	O
{	O
*	O
dp	*(long)
=	O
*	O
sp	*(long)
+	O
ADD_VALUE	int
;	O
}	O
mix_pool	(*(char))->(void)
(	O
rndpool	*(char)
)	O
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
mixrnd	long
++	O
;	O
mix_pool	(*(char))->(void)
(	O
keypool	*(char)
)	O
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
mixkey	long
++	O
;	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
seed_file_name	*(char)
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
log_info	O
(	O
_	O
(	O
"can't create `%s': %s\n"	*(char)
)	O
,	O
seed_file_name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
;	O
}	O
do	O
{	O
i	int
=	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
keypool	*(char)
,	O
POOLSIZE	O
)	O
;	O
}	O
while	O
(	O
i	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
i	int
!=	O
POOLSIZE	O
)	O
{	O
log_info	O
(	O
_	O
(	O
"can't write `%s': %s\n"	*(char)
)	O
,	O
seed_file_name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
close	*((*(void))->(int))
(	O
fd	int
)	O
)	O
log_info	O
(	O
_	O
(	O
"can't close `%s': %s\n"	*(char)
)	O
,	O
seed_file_name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
int	O
readable_pool	(long,int)->(int)
(	O
size_t	long
length	long
,	O
int	O
level	int
)	O
{	O
size_t	long
needed	long
=	O
0	int
;	O
size_t	long
my_balance	long
=	O
pool_balance	int
;	O
size_t	long
available	long
=	O
(	O
gatherwpos	int
-	O
gatherrpos	int
+	O
GATHERBUFSIZE	int
)	O
%	O
GATHERBUFSIZE	int
;	O
if	O
(	O
length	long
>	O
POOLSIZE	O
)	O
length	long
=	O
POOLSIZE	O
;	O
if	O
(	O
level	int
<	O
2	int
)	O
return	O
length	long
;	O
if	O
(	O
!	O
pool_filled	int
)	O
{	O
if	O
(	O
read_seed_file	()->(int)
(	O
)	O
)	O
pool_filled	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
did_initial_extra_seeding	int
)	O
{	O
needed	long
=	O
length	long
;	O
if	O
(	O
needed	long
<	O
POOLSIZE	O
/	O
2	int
)	O
needed	long
=	O
POOLSIZE	O
/	O
2	int
;	O
my_balance	long
=	O
needed	long
;	O
if	O
(	O
!	O
pool_filled	int
&&	O
pool_writepos	long
+	O
needed	long
<	O
POOLSIZE	O
)	O
{	O
needed	long
+=	O
(	O
POOLSIZE	O
-	O
pool_writepos	long
+	O
needed	long
+	O
POOLSIZE	O
/	O
5	int
-	O
1	int
)	O
/	O
(	O
POOLSIZE	O
/	O
5	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
pool_filled	int
)	O
needed	long
+=	O
(	O
POOLSIZE	O
-	O
pool_writepos	long
+	O
needed	long
+	O
POOLSIZE	O
/	O
5	int
-	O
1	int
)	O
/	O
(	O
POOLSIZE	O
/	O
5	int
)	O
;	O
}	O
if	O
(	O
available	long
<	O
needed	long
)	O
return	O
0	int
;	O
return	O
available	long
+	O
my_balance	long
-	O
needed	long
;	O
}	O
int	O
read_pool	(*(char),long,int)->(int)
(	O
byte	char
*	O
buffer	*(char)
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
{	O
int	O
i	int
;	O
ulong	long
*	O
sp	*(long)
,	O
*	O
dp	*(long)
;	O
if	O
(	O
length	long
>	O
POOLSIZE	O
)	O
{	O
length	long
=	O
POOLSIZE	O
;	O
}	O
if	O
(	O
!	O
pool_filled	int
)	O
{	O
if	O
(	O
read_seed_file	()->(int)
(	O
)	O
)	O
pool_filled	int
=	O
1	int
;	O
}	O
if	O
(	O
level	int
==	O
2	int
&&	O
!	O
did_initial_extra_seeding	int
)	O
{	O
size_t	long
needed	long
;	O
pool_balance	int
=	O
0	int
;	O
needed	long
=	O
length	long
-	O
pool_balance	int
;	O
if	O
(	O
needed	long
<	O
POOLSIZE	O
/	O
2	int
)	O
needed	long
=	O
POOLSIZE	O
/	O
2	int
;	O
else	O
if	O
(	O
needed	long
>	O
POOLSIZE	O
)	O
BUG	O
(	O
)	O
;	O
needed	long
=	O
read_random_source	(int,long,int)->(int)
(	O
3	int
,	O
needed	long
,	O
2	int
)	O
;	O
if	O
(	O
!	O
needed	long
)	O
return	O
0	int
;	O
pool_balance	int
+=	O
needed	long
;	O
did_initial_extra_seeding	int
=	O
1	int
;	O
}	O
if	O
(	O
level	int
==	O
2	int
&&	O
pool_balance	int
<	O
length	long
)	O
{	O
size_t	long
needed	long
;	O
if	O
(	O
pool_balance	int
<	O
0	int
)	O
pool_balance	int
=	O
0	int
;	O
needed	long
=	O
length	long
-	O
pool_balance	int
;	O
if	O
(	O
needed	long
>	O
POOLSIZE	O
)	O
BUG	O
(	O
)	O
;	O
needed	long
=	O
read_random_source	(int,long,int)->(int)
(	O
3	int
,	O
needed	long
,	O
2	int
)	O
;	O
pool_balance	int
+=	O
needed	long
;	O
}	O
if	O
(	O
level	int
==	O
2	int
)	O
while	O
(	O
!	O
pool_filled	int
)	O
random_poll	()->(void)
(	O
)	O
;	O
fast_random_poll	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
level	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
,	O
dp	*(long)
=	O
(	O
ulong	long
*	O
)	O
keypool	*(char)
,	O
sp	*(long)
=	O
(	O
ulong	long
*	O
)	O
rndpool	*(char)
;	O
i	int
<	O
POOLWORDS	O
;	O
i	int
++	O
,	O
dp	*(long)
++	O
,	O
sp	*(long)
++	O
)	O
*	O
dp	*(long)
=	O
*	O
sp	*(long)
+	O
ADD_VALUE	int
;	O
mix_pool	(*(char))->(void)
(	O
rndpool	*(char)
)	O
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
mixrnd	long
++	O
;	O
mix_pool	(*(char))->(void)
(	O
keypool	*(char)
)	O
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
mixkey	long
++	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buffer	*(char)
,	O
keypool	*(char)
,	O
length	long
)	O
;	O
return	O
length	long
;	O
}	O
else	O
{	O
int	O
amount	int
;	O
if	O
(	O
!	O
just_mixed	int
)	O
{	O
mix_pool	(*(char))->(void)
(	O
rndpool	*(char)
)	O
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
mixrnd	long
++	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
,	O
dp	*(long)
=	O
(	O
ulong	long
*	O
)	O
keypool	*(char)
,	O
sp	*(long)
=	O
(	O
ulong	long
*	O
)	O
rndpool	*(char)
;	O
i	int
<	O
POOLWORDS	O
;	O
i	int
++	O
,	O
dp	*(long)
++	O
,	O
sp	*(long)
++	O
)	O
*	O
dp	*(long)
=	O
*	O
sp	*(long)
+	O
ADD_VALUE	int
;	O
mix_pool	(*(char))->(void)
(	O
rndpool	*(char)
)	O
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
mixrnd	long
++	O
;	O
mix_pool	(*(char))->(void)
(	O
keypool	*(char)
)	O
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
mixkey	long
++	O
;	O
if	O
(	O
level	int
==	O
2	int
&&	O
length	long
>	O
pool_balance	int
)	O
length	long
=	O
pool_balance	int
;	O
amount	int
=	O
length	long
;	O
while	O
(	O
length	long
--	O
)	O
{	O
*	O
buffer	*(char)
++	O
=	O
keypool	*(char)
[	O
pool_readpos	long
++	O
]	O
;	O
if	O
(	O
pool_readpos	long
>=	O
POOLSIZE	O
)	O
pool_readpos	long
=	O
0	int
;	O
pool_balance	int
--	O
;	O
}	O
if	O
(	O
pool_balance	int
<	O
0	int
)	O
pool_balance	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
keypool	*(char)
,	O
0	int
,	O
POOLSIZE	O
)	O
;	O
return	O
amount	int
;	O
}	O
}	O
static	O
void	O
add_randomness	(*(void),long,int)->(void)
(	O
const	O
void	O
*	O
buffer	*(char)
,	O
size_t	long
length	long
,	O
int	O
source	int
)	O
{	O
const	O
byte	char
*	O
p	*(char)
=	O
buffer	*(char)
;	O
if	O
(	O
!	O
is_initialized	int
)	O
initialize	()->(void)
(	O
)	O
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
addbytes	long
+=	O
length	long
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
naddbytes	long
++	O
;	O
while	O
(	O
length	long
--	O
)	O
{	O
rndpool	*(char)
[	O
pool_writepos	long
++	O
]	O
=	O
*	O
p	*(char)
++	O
;	O
if	O
(	O
pool_writepos	long
>=	O
POOLSIZE	O
)	O
{	O
if	O
(	O
source	int
>	O
1	int
)	O
pool_filled	int
=	O
1	int
;	O
pool_writepos	long
=	O
0	int
;	O
mix_pool	(*(char))->(void)
(	O
rndpool	*(char)
)	O
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
mixrnd	long
++	O
;	O
just_mixed	int
=	O
!	O
length	long
;	O
}	O
}	O
}	O
static	O
void	O
random_poll	()->(void)
(	O
)	O
{	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
slowpolls	long
++	O
;	O
read_random_source	(int,long,int)->(int)
(	O
2	int
,	O
POOLSIZE	O
/	O
5	int
,	O
1	int
)	O
;	O
}	O
void	O
fast_random_poll	()->(void)
(	O
)	O
{	O
static	O
void	O
(	O
*	O
fnc	*((*((*(void),long,int)->(void)),int)->(void))
)	O
(	O
void	O
(	O
*	O
)	O
(	O
const	O
void	O
*	O
,	O
size_t	long
,	O
int	O
)	O
,	O
int	O
)	O
=	O
NULL	O
;	O
static	O
int	O
initialized	int
=	O
0	int
;	O
rndstats	struct(long,long,long,long,long,long,long,long,long,long)
.	O
fastpolls	long
++	O
;	O
if	O
(	O
!	O
initialized	int
)	O
{	O
if	O
(	O
!	O
is_initialized	int
)	O
initialize	()->(void)
(	O
)	O
;	O
initialized	int
=	O
1	int
;	O
fnc	*((*((*(void),long,int)->(void)),int)->(void))
=	O
dynload_getfnc_fast_random_poll	O
(	O
)	O
;	O
}	O
if	O
(	O
fnc	*((*((*(void),long,int)->(void)),int)->(void))
)	O
{	O
(	O
*	O
fnc	*((*((*(void),long,int)->(void)),int)->(void))
)	O
(	O
add_randomness	(*(void),long,int)->(void)
,	O
1	int
)	O
;	O
return	O
;	O
}	O
{	O
struct	O
timeval	struct(long,long)
tv	struct(long,long)
;	O
if	O
(	O
gettimeofday	(*(struct(long,long)),*(void))->(int)
(	O
&	O
tv	struct(long,long)
,	O
NULL	O
)	O
)	O
BUG	O
(	O
)	O
;	O
add_randomness	(*(void),long,int)->(void)
(	O
&	O
tv	struct(long,long)
.	O
tv_sec	long
,	O
sizeof	O
(	O
tv	struct(long,long)
.	O
tv_sec	long
)	O
,	O
1	int
)	O
;	O
add_randomness	(*(void),long,int)->(void)
(	O
&	O
tv	struct(long,long)
.	O
tv_usec	long
,	O
sizeof	O
(	O
tv	struct(long,long)
.	O
tv_usec	long
)	O
,	O
1	int
)	O
;	O
}	O
{	O
struct	O
rusage	struct(struct(long,long),struct(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long))
buf	array(char)
;	O
getrusage	(enum(int,int,int),*(struct(struct(long,long),struct(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long),union(long,long))))->(int)
(	O
RUSAGE_SELF	int
,	O
&	O
buf	array(char)
)	O
;	O
add_randomness	(*(void),long,int)->(void)
(	O
&	O
buf	array(char)
,	O
sizeof	O
buf	array(char)
,	O
1	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
buf	array(char)
,	O
0	int
,	O
sizeof	O
buf	array(char)
)	O
;	O
}	O
{	O
time_t	long
x	int
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
add_randomness	(*(void),long,int)->(void)
(	O
&	O
x	int
,	O
sizeof	O
(	O
x	int
)	O
,	O
1	int
)	O
;	O
}	O
{	O
clock_t	long
x	int
=	O
clock	()->(long)
(	O
)	O
;	O
add_randomness	(*(void),long,int)->(void)
(	O
&	O
x	int
,	O
sizeof	O
(	O
x	int
)	O
,	O
1	int
)	O
;	O
}	O
}	O
static	O
int	O
read_random_source	(int,long,int)->(int)
(	O
int	O
requester	int
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
{	O
static	O
int	O
(	O
*	O
fnc	*((*((*(void),long,int)->(void)),int)->(void))
)	O
(	O
void	O
(	O
*	O
)	O
(	O
const	O
void	O
*	O
,	O
size_t	long
,	O
int	O
)	O
,	O
int	O
,	O
size_t	long
,	O
int	O
)	O
=	O
NULL	O
;	O
int	O
got	int
;	O
if	O
(	O
!	O
fnc	*((*((*(void),long,int)->(void)),int)->(void))
)	O
{	O
if	O
(	O
!	O
is_initialized	int
)	O
initialize	()->(void)
(	O
)	O
;	O
fnc	*((*((*(void),long,int)->(void)),int)->(void))
=	O
dynload_getfnc_gather_random	O
(	O
)	O
;	O
if	O
(	O
!	O
fnc	*((*((*(void),long,int)->(void)),int)->(void))
)	O
{	O
faked_rng	int
=	O
1	int
;	O
fnc	*((*((*(void),long,int)->(void)),int)->(void))
=	O
gather_faked	(*((*(void),long,int)->(void)),int,long,int)->(int)
;	O
}	O
if	O
(	O
!	O
requester	int
&&	O
!	O
length	long
&&	O
!	O
level	int
)	O
return	O
0	int
;	O
}	O
got	int
=	O
(	O
*	O
fnc	*((*((*(void),long,int)->(void)),int)->(void))
)	O
(	O
add_randomness	(*(void),long,int)->(void)
,	O
requester	int
,	O
length	long
,	O
level	int
)	O
;	O
if	O
(	O
got	int
<	O
0	int
)	O
log_fatal	O
(	O
"No way to gather entropy for the RNG\n"	*(char)
)	O
;	O
return	O
got	int
;	O
}	O
static	O
int	O
gather_faked	(*((*(void),long,int)->(void)),int,long,int)->(int)
(	O
void	O
(	O
*	O
add	*((*(void),long,int)->(void))
)	O
(	O
const	O
void	O
*	O
,	O
size_t	long
,	O
int	O
)	O
,	O
int	O
requester	int
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
{	O
static	O
int	O
initialized	int
=	O
0	int
;	O
size_t	long
n	long
;	O
char	O
*	O
buffer	*(char)
,	O
*	O
p	*(char)
;	O
if	O
(	O
!	O
initialized	int
)	O
{	O
log_info	O
(	O
_	O
(	O
"WARNING: using insecure random number generator!!\n"	*(char)
)	O
)	O
;	O
tty_printf	O
(	O
_	O
(	O
"The random number generator is only a kludge to let\n"	*(char)
"it run - it is in no way a strong RNG!\n\n"	*(char)
"DON'T USE ANY DATA GENERATED BY THIS PROGRAM!!\n\n"	*(char)
)	O
)	O
;	O
initialized	int
=	O
1	int
;	O
srand	(int)->(void)
(	O
make_timestamp	O
(	O
)	O
*	O
getpid	()->(int)
(	O
)	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"WAITING FOR %i bytes.\n"	*(char)
,	O
length	long
)	O
;	O
p	*(char)
=	O
buffer	*(char)
=	O
m_alloc	O
(	O
length	long
)	O
;	O
n	long
=	O
length	long
;	O
while	O
(	O
n	long
--	O
)	O
*	O
p	*(char)
++	O
=	O
(	O
(	O
unsigned	O
)	O
(	O
1	int
+	O
(	O
int	O
)	O
(	O
256.0	int
*	O
rand	()->(int)
(	O
)	O
/	O
(	O
RAND_MAX	int
+	O
1.0	int
)	O
)	O
)	O
-	O
1	int
)	O
;	O
add_randomness	(*(void),long,int)->(void)
(	O
buffer	*(char)
,	O
length	long
,	O
requester	int
)	O
;	O
m_free	O
(	O
buffer	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
