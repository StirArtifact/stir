object	O
siSuniversal_error_handler	int
;	O
object	O
sSterminal_interrupt	int
;	O
void	O
assert_error	(*(char),int,*(char),*(char))->(void)
(	O
const	O
char	O
*	O
a	*(char)
,	O
unsigned	O
l	int
,	O
const	O
char	O
*	O
f	*(char)
,	O
const	O
char	O
*	O
n	*(char)
)	O
{	O
if	O
(	O
!	O
raw_image	O
)	O
FEerror	()->(int)
(	O
"The assertion ~a on line ~a of ~a in function ~a failed"	*(char)
,	O
4	int
,	O
make_simple_string	()->(int)
(	O
a	*(char)
)	O
,	O
make_fixnum	()->(int)
(	O
l	int
)	O
,	O
make_simple_string	()->(int)
(	O
f	*(char)
)	O
,	O
make_simple_string	()->(int)
(	O
n	*(char)
)	O
)	O
;	O
else	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"The assertion %s on line %d of %s in function %s failed"	*(char)
,	O
a	*(char)
,	O
l	int
,	O
f	*(char)
,	O
n	*(char)
)	O
;	O
exit	(int)->(void)
(	O
-	O
1	int
)	O
;	O
}	O
}	O
void	O
terminal_interrupt	(int)->(void)
(	O
int	O
correctable	int
)	O
{	O
signals_allowed	O
=	O
sig_normal	O
;	O
ifuncall1	()->(int)
(	O
sSterminal_interrupt	int
,	O
correctable	int
?	O
Ct	O
:	O
Cnil	O
)	O
;	O
}	O
static	O
object	O
ihs_function_name	(int)->(int)
(	O
object	O
x	int
)	O
{	O
object	O
y	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_symbol	O
:	O
return	O
(	O
x	int
)	O
;	O
case	O
t_cons	O
:	O
y	O
=	O
x	int
->	O
c	enum
.	O
c_car	O
;	O
if	O
(	O
y	O
==	O
sLlambda	O
)	O
return	O
(	O
sLlambda	O
)	O
;	O
if	O
(	O
y	O
==	O
sLlambda_closure	O
)	O
return	O
(	O
sLlambda_closure	O
)	O
;	O
if	O
(	O
y	O
==	O
sLlambda_block	O
||	O
y	O
==	O
sSlambda_block_expanded	O
)	O
{	O
x	int
=	O
x	int
->	O
c	enum
.	O
c_cdr	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_cons	O
)	O
return	O
(	O
sLlambda_block	O
)	O
;	O
return	O
(	O
x	int
->	O
c	enum
.	O
c_car	O
)	O
;	O
}	O
if	O
(	O
y	O
==	O
sLlambda_block_closure	O
)	O
{	O
x	int
=	O
x	int
->	O
c	enum
.	O
c_cdr	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_cons	O
)	O
return	O
(	O
sLlambda_block_closure	O
)	O
;	O
x	int
=	O
x	int
->	O
c	enum
.	O
c_cdr	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_cons	O
)	O
return	O
(	O
sLlambda_block_closure	O
)	O
;	O
x	int
=	O
x	int
->	O
c	enum
.	O
c_cdr	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_cons	O
)	O
return	O
(	O
sLlambda_block_closure	O
)	O
;	O
x	int
=	O
x	int
->	O
c	enum
.	O
c_cdr	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_cons	O
)	O
return	O
(	O
sLlambda_block_closure	O
)	O
;	O
return	O
(	O
x	int
->	O
c	enum
.	O
c_car	O
)	O
;	O
}	O
if	O
(	O
y	O
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
return	O
y	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
case	O
t_afun	O
:	O
case	O
t_closure	O
:	O
case	O
t_cfun	O
:	O
case	O
t_sfun	O
:	O
case	O
t_vfun	O
:	O
case	O
t_cclosure	O
:	O
case	O
t_gfun	O
:	O
return	O
(	O
x	int
->	O
cf	O
.	O
cf_name	O
)	O
;	O
default	O
:	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
object	O
ihs_top_function_name	(int)->(int)
(	O
ihs_ptr	O
h	int
)	O
{	O
object	O
x	int
;	O
while	O
(	O
h	int
>=	O
ihs_org	O
)	O
{	O
x	int
=	O
ihs_function_name	(int)->(int)
(	O
h	int
->	O
ihs_function	O
)	O
;	O
if	O
(	O
x	int
!=	O
Cnil	O
)	O
return	O
(	O
x	int
)	O
;	O
h	int
--	O
;	O
}	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
object	O
Icall_gen_error_handler	(int,int,int,int,int)->(int)
(	O
object	O
ci	int
,	O
object	O
cs	int
,	O
object	O
en	int
,	O
object	O
es	int
,	O
ufixnum	O
n	*(char)
,	O
...	O
)	O
{	O
object	O
*	O
b	O
;	O
ufixnum	O
i	int
;	O
va_list	O
ap	O
;	O
n	*(char)
+=	O
5	int
;	O
b	O
=	O
alloca	(long)->(*(void))
(	O
n	*(char)
*	O
sizeof	O
(	O
*	O
b	O
)	O
)	O
;	O
b	O
[	O
0	int
]	O
=	O
en	int
;	O
b	O
[	O
1	int
]	O
=	O
ci	int
;	O
b	O
[	O
2	int
]	O
=	O
ihs_top_function_name	(int)->(int)
(	O
ihs_top	O
)	O
;	O
b	O
[	O
3	int
]	O
=	O
cs	int
;	O
b	O
[	O
4	int
]	O
=	O
es	int
;	O
va_start	O
(	O
ap	O
,	O
n	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
5	int
;	O
i	int
<	O
n	*(char)
;	O
i	int
++	O
)	O
b	O
[	O
i	int
]	O
=	O
va_arg	()->(int)
(	O
ap	O
,	O
object	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
return	O
IapplyVector	()->(int)
(	O
sSuniversal_error_handler	O
,	O
n	*(char)
,	O
b	O
)	O
;	O
}	O
static	O
ihs_ptr	O
get_ihs_ptr	(int)->(int)
(	O
object	O
x	int
)	O
{	O
ihs_ptr	O
p	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_fixnum	O
)	O
goto	O
ILLEGAL	O
;	O
p	O
=	O
ihs_org	O
+	O
fix	()->(int)
(	O
x	int
)	O
;	O
p	O
=	O
p	O
<	O
ihs_org	O
?	O
ihs_org	O
:	O
p	O
;	O
p	O
=	O
p	O
>	O
ihs_top	O
?	O
ihs_top	O
:	O
p	O
;	O
return	O
p	O
;	O
ILLEGAL	O
:	O
FEerror	()->(int)
(	O
"~S is an illegal ihs index."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
return	O
(	O
NULL	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"IHS-TOP"	*(char)
,	O
object	O
,	O
fSihs_top	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
ihs_top	O
-	O
ihs_org	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"IHS-FUN"	*(char)
,	O
object	O
,	O
fSihs_fun	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
x0	O
=	O
get_ihs_ptr	(int)->(int)
(	O
x0	O
)	O
->	O
ihs_function	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"IHS-VS"	*(char)
,	O
object	O
,	O
fSihs_vs	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
x0	O
=	O
make_fixnum	()->(int)
(	O
get_ihs_ptr	(int)->(int)
(	O
x0	O
)	O
->	O
ihs_base	O
-	O
vs_org	O
)	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
static	O
frame_ptr	O
get_frame_ptr	(int)->(int)
(	O
object	O
x	int
)	O
{	O
frame_ptr	O
p	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_fixnum	O
)	O
goto	O
ILLEGAL	O
;	O
p	O
=	O
frs_org	O
+	O
fix	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
fix	()->(int)
(	O
x	int
)	O
==	O
0	int
)	O
return	O
p	O
;	O
p	O
=	O
p	O
<	O
frs_org	O
?	O
frs_org	O
:	O
p	O
;	O
p	O
=	O
p	O
>	O
frs_top	O
?	O
frs_top	O
:	O
p	O
;	O
return	O
p	O
;	O
ILLEGAL	O
:	O
FEerror	()->(int)
(	O
"~S is an illegal frs index."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
return	O
NULL	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"FRS-TOP"	*(char)
,	O
object	O
,	O
fSfrs_top	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
(	O
make_fixnum	()->(int)
(	O
frs_top	O
-	O
frs_org	O
)	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"FRS-VS"	*(char)
,	O
object	O
,	O
fSfrs_vs	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
x0	O
=	O
make_fixnum	()->(int)
(	O
get_frame_ptr	(int)->(int)
(	O
x0	O
)	O
->	O
frs_lex	O
-	O
vs_org	O
)	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"FRS-BDS"	*(char)
,	O
object	O
,	O
fSfrs_bds	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
x0	O
=	O
make_fixnum	()->(int)
(	O
get_frame_ptr	(int)->(int)
(	O
x0	O
)	O
->	O
frs_bds_top	O
-	O
bds_org	O
)	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"FRS-CLASS"	*(char)
,	O
object	O
,	O
fSfrs_class	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
enum	O
fr_class	O
c	enum
;	O
c	enum
=	O
get_frame_ptr	(int)->(int)
(	O
x0	O
)	O
->	O
frs_class	O
;	O
if	O
(	O
c	enum
==	O
FRS_CATCH	O
)	O
x0	O
=	O
sKcatch	O
;	O
else	O
if	O
(	O
c	enum
==	O
FRS_PROTECT	O
)	O
x0	O
=	O
sKprotect	O
;	O
else	O
if	O
(	O
c	enum
==	O
FRS_CATCHALL	O
)	O
x0	O
=	O
sKcatchall	O
;	O
else	O
FEerror	()->(int)
(	O
"Unknown frs class was detected."	*(char)
,	O
0	int
)	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"FRS-TAG"	*(char)
,	O
object	O
,	O
fSfrs_tag	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
x0	O
=	O
get_frame_ptr	(int)->(int)
(	O
x0	O
)	O
->	O
frs_val	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"FRS-IHS"	*(char)
,	O
object	O
,	O
fSfrs_ihs	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
x0	O
=	O
make_fixnum	()->(int)
(	O
get_frame_ptr	(int)->(int)
(	O
x0	O
)	O
->	O
frs_ihs	O
-	O
ihs_org	O
)	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
static	O
bds_ptr	O
get_bds_ptr	(int)->(int)
(	O
object	O
x	int
)	O
{	O
bds_ptr	O
p	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_fixnum	O
)	O
goto	O
ILLEGAL	O
;	O
p	O
=	O
bds_org	O
+	O
fix	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
0	int
==	O
fix	()->(int)
(	O
x	int
)	O
)	O
return	O
p	O
;	O
p	O
=	O
p	O
<	O
bds_org	O
?	O
bds_org	O
:	O
p	O
;	O
p	O
=	O
p	O
>	O
bds_top	O
?	O
bds_top	O
:	O
p	O
;	O
return	O
p	O
;	O
ILLEGAL	O
:	O
FEerror	()->(int)
(	O
"~S is an illegal bds index."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
return	O
NULL	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"BDS-TOP"	*(char)
,	O
object	O
,	O
fSbds_top	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
(	O
make_fixnum	()->(int)
(	O
bds_top	O
-	O
bds_org	O
)	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"BDS-VAR"	*(char)
,	O
object	O
,	O
fSbds_var	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
x0	O
=	O
get_bds_ptr	(int)->(int)
(	O
x0	O
)	O
->	O
bds_sym	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"BDS-VAL"	*(char)
,	O
object	O
,	O
fSbds_val	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
x0	O
=	O
get_bds_ptr	(int)->(int)
(	O
x0	O
)	O
->	O
bds_val	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
static	O
object	O
*	O
get_vs_ptr	(int)->(*(int))
(	O
object	O
x	int
)	O
{	O
object	O
*	O
p	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_fixnum	O
)	O
goto	O
ILLEGAL	O
;	O
p	O
=	O
vs_org	O
+	O
fix	()->(int)
(	O
x	int
)	O
;	O
p	O
=	O
p	O
<	O
vs_org	O
?	O
vs_org	O
:	O
p	O
;	O
p	O
=	O
p	O
>=	O
vs_top	O
?	O
vs_top	O
-	O
1	int
:	O
p	O
;	O
return	O
p	O
;	O
ILLEGAL	O
:	O
FEerror	()->(int)
(	O
"~S is an illegal vs index."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
return	O
NULL	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"VS-TOP"	*(char)
,	O
object	O
,	O
fSvs_top	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
""	*(char)
)	O
{	O
object	O
x	int
;	O
x	int
=	O
(	O
make_fixnum	()->(int)
(	O
vs_top	O
-	O
vs_org	O
)	O
)	O
;	O
RETURN1	()->(int)
(	O
x	int
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"VS"	*(char)
,	O
object	O
,	O
fSvs	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
x0	O
=	O
*	O
get_vs_ptr	(int)->(*(int))
(	O
x0	O
)	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"SCH-FRS-BASE"	*(char)
,	O
object	O
,	O
fSsch_frs_base	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
,	O
object	O
x1	O
)	O
,	O
""	*(char)
)	O
{	O
frame_ptr	O
x	int
;	O
ihs_ptr	O
y	O
;	O
y	O
=	O
get_ihs_ptr	(int)->(int)
(	O
x1	O
)	O
;	O
for	O
(	O
x	int
=	O
get_frame_ptr	(int)->(int)
(	O
x0	O
)	O
;	O
x	int
<=	O
frs_top	O
&&	O
x	int
->	O
frs_ihs	O
<	O
y	O
;	O
x	int
++	O
)	O
;	O
if	O
(	O
x	int
>	O
frs_top	O
)	O
x0	O
=	O
Cnil	O
;	O
else	O
x0	O
=	O
make_fixnum	()->(int)
(	O
x	int
-	O
frs_org	O
)	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
DEFUNM_NEW	()->(int)
(	O
"INTERNAL-SUPER-GO"	*(char)
,	O
object	O
,	O
fSinternal_super_go	O
,	O
SI	O
,	O
3	int
,	O
3	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
tag	O
,	O
object	O
x1	O
,	O
object	O
x2	O
)	O
,	O
""	*(char)
)	O
{	O
frame_ptr	O
fr	O
;	O
fr	O
=	O
frs_sch	()->(int)
(	O
tag	O
)	O
;	O
if	O
(	O
fr	O
==	O
NULL	O
)	O
FEerror	()->(int)
(	O
"The tag ~S is missing."	*(char)
,	O
1	int
,	O
tag	O
)	O
;	O
if	O
(	O
x2	O
==	O
Cnil	O
)	O
tag	O
=	O
x1	O
;	O
else	O
tag	O
=	O
MMcons	()->(int)
(	O
tag	O
,	O
x1	O
)	O
;	O
unwind	()->(int)
(	O
fr	O
,	O
tag	O
)	O
;	O
RETURN0	O
;	O
}	O
DEF_ORDINARY	()->(int)
(	O
"UNIVERSAL-ERROR-HANDLER"	*(char)
,	O
sSuniversal_error_handler	O
,	O
SI	O
,	O
"Redefined in lisp, this is the function called by the internal error handling mechanism.  Args:  (error-name correctable function-name    continue-format-string error-format-string    &rest args)"	*(char)
)	O
;	O
DEFUN_NEW	()->(int)
(	O
"UNIVERSAL-ERROR-HANDLER"	*(char)
,	O
object	O
,	O
fSuniversal_error_handler	O
,	O
SI	O
,	O
5	int
,	O
F_ARG_LIMIT	O
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
,	O
object	O
x1	O
,	O
object	O
x2	O
,	O
object	O
x3	O
,	O
object	O
error_fmt_string	O
)	O
,	O
""	*(char)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
error_fmt_string	O
->	O
st	O
.	O
st_fillp	O
;	O
i	int
++	O
)	O
fputc	()->(int)
(	O
error_fmt_string	O
->	O
st	O
.	O
st_self	O
[	O
i	int
]	O
,	O
stdout	O
)	O
;	O
printf	O
(	O
"\nLisp initialization failed.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
void	O
check_arg_failed	(int)->(void)
(	O
int	O
n	*(char)
)	O
{	O
if	O
(	O
n	*(char)
<	O
vs_top	O
-	O
vs_base	O
)	O
FEtoo_many_arguments	()->(int)
(	O
vs_base	O
,	O
vs_top	O
)	O
;	O
else	O
FEtoo_few_arguments	()->(int)
(	O
vs_base	O
,	O
vs_top	O
)	O
;	O
}	O
void	O
too_few_arguments	()->(void)
(	O
void	O
)	O
{	O
FEtoo_few_arguments	()->(int)
(	O
vs_base	O
,	O
vs_top	O
)	O
;	O
}	O
void	O
too_many_arguments	()->(void)
(	O
void	O
)	O
{	O
FEtoo_many_arguments	()->(int)
(	O
vs_base	O
,	O
vs_top	O
)	O
;	O
}	O
void	O
ck_larg_at_least	(int,int)->(void)
(	O
int	O
n	*(char)
,	O
object	O
x	int
)	O
{	O
for	O
(	O
;	O
n	*(char)
>	O
0	int
;	O
n	*(char)
--	O
,	O
x	int
=	O
x	int
->	O
c	enum
.	O
c_cdr	O
)	O
if	O
(	O
endp	()->(int)
(	O
x	int
)	O
)	O
FEerror	()->(int)
(	O
"APPLY sent too few arguments to LAMBDA."	*(char)
,	O
0	int
)	O
;	O
}	O
void	O
ck_larg_exactly	(int,int)->(void)
(	O
int	O
n	*(char)
,	O
object	O
x	int
)	O
{	O
for	O
(	O
;	O
n	*(char)
>	O
0	int
;	O
n	*(char)
--	O
,	O
x	int
=	O
x	int
->	O
c	enum
.	O
c_cdr	O
)	O
if	O
(	O
endp	()->(int)
(	O
x	int
)	O
)	O
FEerror	()->(int)
(	O
"APPLY sent too few arguments to LAMBDA."	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
x	int
)	O
)	O
FEerror	()->(int)
(	O
"APPLY sent too many arguments to LAMBDA."	*(char)
,	O
0	int
)	O
;	O
}	O
void	O
invalid_macro_call	()->(void)
(	O
void	O
)	O
{	O
FEinvalid_macro_call	()->(int)
(	O
)	O
;	O
}	O
object	O
wrong_type_argument	(int,int)->(int)
(	O
object	O
typ	int
,	O
object	O
obj	int
)	O
{	O
FEwrong_type_argument	()->(int)
(	O
typ	int
,	O
obj	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
void	O
illegal_declare	(int)->(void)
(	O
object	O
form	int
)	O
{	O
FEinvalid_form	()->(int)
(	O
"~S is an illegal declaration form."	*(char)
,	O
form	int
)	O
;	O
}	O
void	O
not_a_string_or_symbol	(int)->(void)
(	O
object	O
x	int
)	O
{	O
FEerror	()->(int)
(	O
"~S is not a string or symbol."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
}	O
void	O
not_a_symbol	(int)->(void)
(	O
object	O
obj	int
)	O
{	O
FEwrong_type_argument	()->(int)
(	O
sLsymbol	O
,	O
obj	int
)	O
;	O
}	O
int	O
not_a_variable	(int)->(int)
(	O
object	O
obj	int
)	O
{	O
FEinvalid_variable	()->(int)
(	O
"~S is not a variable."	*(char)
,	O
obj	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
void	O
illegal_index	(int,int)->(void)
(	O
object	O
x	int
,	O
object	O
i	int
)	O
{	O
FEerror	()->(int)
(	O
"~S is an illegal index to ~S."	*(char)
,	O
2	int
,	O
i	int
,	O
x	int
)	O
;	O
}	O
void	O
check_stream	(int)->(void)
(	O
object	O
strm	int
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
strm	int
)	O
!=	O
t_stream	O
)	O
FEwrong_type_argument	()->(int)
(	O
sLstream	O
,	O
strm	int
)	O
;	O
}	O
void	O
vfun_wrong_number_of_args	(int)->(void)
(	O
object	O
x	int
)	O
{	O
FEerror	()->(int)
(	O
"Expected ~S args but received ~S args"	*(char)
,	O
2	int
,	O
x	int
,	O
make_fixnum	()->(int)
(	O
VFUN_NARGS	O
)	O
)	O
;	O
}	O
void	O
check_arg_range	(int,int)->(void)
(	O
int	O
n	*(char)
,	O
int	O
m	int
)	O
{	O
object	O
x	int
,	O
x1	O
;	O
x	int
=	O
make_fixnum	()->(int)
(	O
n	*(char)
)	O
;	O
x1	O
=	O
make_fixnum	()->(int)
(	O
VFUN_NARGS	O
)	O
;	O
if	O
(	O
VFUN_NARGS	O
<	O
n	*(char)
)	O
Icall_error_handler	()->(int)
(	O
sKtoo_few_arguments	O
,	O
make_simple_string	()->(int)
(	O
"Needed at least ~D args, but received ~d"	*(char)
)	O
,	O
2	int
,	O
x	int
,	O
x1	O
)	O
;	O
else	O
if	O
(	O
VFUN_NARGS	O
>	O
m	int
)	O
Icall_error_handler	()->(int)
(	O
sKtoo_many_arguments	O
,	O
make_simple_string	()->(int)
(	O
"Needed no more than ~D args, but received ~d"	*(char)
)	O
,	O
2	int
,	O
x	int
,	O
x1	O
)	O
;	O
}	O
DEF_ORDINARY	()->(int)
(	O
"TERMINAL-INTERRUPT"	*(char)
,	O
sSterminal_interrupt	int
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"WRONG-TYPE-ARGUMENT"	*(char)
,	O
sKwrong_type_argument	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"TOO-FEW-ARGUMENTS"	*(char)
,	O
sKtoo_few_arguments	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"TOO-MANY-ARGUMENTS"	*(char)
,	O
sKtoo_many_arguments	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"UNEXPECTED-KEYWORD"	*(char)
,	O
sKunexpected_keyword	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"INVALID-FORM"	*(char)
,	O
sKinvalid_form	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"UNBOUND-VARIABLE"	*(char)
,	O
sKunbound_variable	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"INVALID-VARIABLE"	*(char)
,	O
sKinvalid_variable	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"UNDEFINED-FUNCTION"	*(char)
,	O
sKundefined_function	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"INVALID-FUNCTION"	*(char)
,	O
sKinvalid_function	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PACKAGE-ERROR"	*(char)
,	O
sKpackage_error	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"DATUM"	*(char)
,	O
sKdatum	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"EXPECTED-TYPE"	*(char)
,	O
sKexpected_type	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PACKAGE"	*(char)
,	O
sKpackage	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FORMAT-CONTROL"	*(char)
,	O
sKformat_control	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FORMAT-ARGUMENTS"	*(char)
,	O
sKformat_arguments	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CATCH"	*(char)
,	O
sKcatch	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PROTECT"	*(char)
,	O
sKprotect	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CATCHALL"	*(char)
,	O
sKcatchall	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
void	O
gcl_init_error	()->(void)
(	O
void	O
)	O
{	O
null_string	O
=	O
make_simple_string	()->(int)
(	O
""	*(char)
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
null_string	O
)	O
;	O
}	O
