struct	O
move_data	struct(float,float,float,float,float,float,float,int,int,float,float,float,float,float,float,float,float,float,array(int),int,int,float)
move	*(int)
[	O
BOARDMAX	O
]	O
;	O
struct	O
move_reason	struct(int,int,int)
move_reasons	array(struct(int,int,int))
[	O
MAX_MOVE_REASONS	int
]	O
;	O
int	O
next_reason	int
;	O
int	O
conn_worm1	array(int)
[	O
MAX_CONNECTIONS	O
]	O
;	O
int	O
conn_worm2	array(int)
[	O
MAX_CONNECTIONS	O
]	O
;	O
int	O
next_connection	int
;	O
int	O
semeai_target1	array(int)
[	O
MAX_POTENTIAL_SEMEAI	int
]	O
;	O
int	O
semeai_target2	array(int)
[	O
MAX_POTENTIAL_SEMEAI	int
]	O
;	O
static	O
int	O
next_semeai	int
;	O
Reason_set	struct(int,int,int,int)
either_data	array(struct(int,int,int,int))
[	O
MAX_EITHER	int
]	O
;	O
int	O
next_either	int
;	O
Reason_set	struct(int,int,int,int)
all_data	array(struct(int,int,int,int))
[	O
MAX_ALL	int
]	O
;	O
int	O
next_all	int
;	O
int	O
eyes	array(int)
[	O
MAX_EYES	O
]	O
;	O
int	O
eyecolor	array(int)
[	O
MAX_EYES	O
]	O
;	O
int	O
next_eye	int
;	O
int	O
lunch_dragon	array(int)
[	O
MAX_LUNCHES	O
]	O
;	O
int	O
lunch_worm	array(int)
[	O
MAX_LUNCHES	O
]	O
;	O
int	O
next_lunch	int
;	O
int	O
replacement_map	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
current_color	int
;	O
static	O
int	O
known_good_attack_threats	array(array(int))
[	O
BOARDMAX	O
]	O
[	O
MAX_ATTACK_THREATS	int
]	O
;	O
static	O
int	O
known_safe_moves	array(int)
[	O
BOARDMAX	O
]	O
;	O
typedef	O
int	O
(	O
*	O
discard_condition_fn_ptr	*((int,int)->(int))
)	O
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
;	O
struct	O
discard_rule	struct(array(int),*((int,int)->(int)),int,array(char))
{	O
int	O
reason_type	array(int)
[	O
MAX_REASONS	int
]	O
;	O
discard_condition_fn_ptr	*((int,int)->(int))
condition	*((int,int)->(int))
;	O
int	O
flags	int
;	O
char	O
trace_message	*(char)
[	O
MAX_TRACE_LENGTH	int
]	O
;	O
}	O
;	O
void	O
clear_move_reasons	()->(void)
(	O
void	O
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
next_reason	int
=	O
0	int
;	O
next_connection	int
=	O
0	int
;	O
next_semeai	int
=	O
0	int
;	O
next_either	int
=	O
0	int
;	O
next_all	int
=	O
0	int
;	O
next_eye	int
=	O
0	int
;	O
next_lunch	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
move	*(int)
[	O
pos	int
]	O
.	O
value	*(char)
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
final_value	float
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
territorial_value	array(float)
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
strategical_value	float
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
maxpos_shape	float
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
numpos_shape	int
=	O
0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
maxneg_shape	float
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
numneg_shape	int
=	O
0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
followup_value	*(float)
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
influence_followup_value	float
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
reverse_followup_value	float
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
secondary_value	float
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
max_value	float
=	O
HUGE_MOVE_VALUE	O
;	O
move	*(int)
[	O
pos	int
]	O
.	O
min_territory	float
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
max_territory	float
=	O
HUGE_MOVE_VALUE	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
=	O
-	O
1	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
=	O
0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
worthwhile_threat	int
=	O
0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
randomness_scaling	float
=	O
1.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
random_number	float
=	O
gg_drand	()->(double)
(	O
)	O
;	O
replacement_map	array(int)
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
known_safe_moves	array(int)
[	O
pos	int
]	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_ATTACK_THREATS	int
;	O
k	int
++	O
)	O
known_good_attack_threats	array(array(int))
[	O
pos	int
]	O
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
}	O
}	O
int	O
find_connection	(int,int)->(int)
(	O
int	O
worm1	int
,	O
int	O
worm2	int
)	O
{	O
int	O
k	int
;	O
if	O
(	O
worm1	int
>	O
worm2	int
)	O
{	O
int	O
tmp	int
=	O
worm1	int
;	O
worm1	int
=	O
worm2	int
;	O
worm2	int
=	O
tmp	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
next_connection	int
;	O
k	int
++	O
)	O
if	O
(	O
conn_worm1	array(int)
[	O
k	int
]	O
==	O
worm1	int
&&	O
conn_worm2	array(int)
[	O
k	int
]	O
==	O
worm2	int
)	O
return	O
k	int
;	O
gg_assert	O
(	O
next_connection	int
<	O
MAX_CONNECTIONS	O
)	O
;	O
conn_worm1	array(int)
[	O
next_connection	int
]	O
=	O
worm1	int
;	O
conn_worm2	array(int)
[	O
next_connection	int
]	O
=	O
worm2	int
;	O
next_connection	int
++	O
;	O
return	O
next_connection	int
-	O
1	int
;	O
}	O
static	O
int	O
find_either_data	(int,int,int,int)->(int)
(	O
int	O
reason1	int
,	O
int	O
what1	int
,	O
int	O
reason2	int
,	O
int	O
what2	int
)	O
{	O
int	O
k	int
;	O
if	O
(	O
what1	int
>	O
what2	int
)	O
{	O
int	O
tmp	int
=	O
what1	int
;	O
what1	int
=	O
what2	int
;	O
what2	int
=	O
tmp	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
next_either	int
;	O
k	int
++	O
)	O
if	O
(	O
either_data	array(struct(int,int,int,int))
[	O
k	int
]	O
.	O
reason1	int
==	O
reason1	int
&&	O
either_data	array(struct(int,int,int,int))
[	O
k	int
]	O
.	O
what1	int
==	O
what1	int
&&	O
either_data	array(struct(int,int,int,int))
[	O
k	int
]	O
.	O
reason2	int
==	O
reason2	int
&&	O
either_data	array(struct(int,int,int,int))
[	O
k	int
]	O
.	O
what2	int
==	O
what2	int
)	O
return	O
k	int
;	O
gg_assert	O
(	O
next_either	int
<	O
MAX_EITHER	int
)	O
;	O
either_data	array(struct(int,int,int,int))
[	O
next_either	int
]	O
.	O
reason1	int
=	O
reason1	int
;	O
either_data	array(struct(int,int,int,int))
[	O
next_either	int
]	O
.	O
what1	int
=	O
what1	int
;	O
either_data	array(struct(int,int,int,int))
[	O
next_either	int
]	O
.	O
reason2	int
=	O
reason2	int
;	O
either_data	array(struct(int,int,int,int))
[	O
next_either	int
]	O
.	O
what2	int
=	O
what2	int
;	O
next_either	int
++	O
;	O
return	O
next_either	int
-	O
1	int
;	O
}	O
static	O
int	O
find_all_data	(int,int,int,int)->(int)
(	O
int	O
reason1	int
,	O
int	O
what1	int
,	O
int	O
reason2	int
,	O
int	O
what2	int
)	O
{	O
int	O
k	int
;	O
if	O
(	O
what1	int
>	O
what2	int
)	O
{	O
int	O
tmp	int
=	O
what1	int
;	O
what1	int
=	O
what2	int
;	O
what2	int
=	O
tmp	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
next_all	int
;	O
k	int
++	O
)	O
if	O
(	O
all_data	array(struct(int,int,int,int))
[	O
k	int
]	O
.	O
reason1	int
==	O
reason1	int
&&	O
all_data	array(struct(int,int,int,int))
[	O
k	int
]	O
.	O
what1	int
==	O
what1	int
&&	O
all_data	array(struct(int,int,int,int))
[	O
k	int
]	O
.	O
reason2	int
==	O
reason2	int
&&	O
all_data	array(struct(int,int,int,int))
[	O
k	int
]	O
.	O
what2	int
==	O
what2	int
)	O
return	O
k	int
;	O
gg_assert	O
(	O
next_all	int
<	O
MAX_ALL	int
)	O
;	O
all_data	array(struct(int,int,int,int))
[	O
next_all	int
]	O
.	O
reason1	int
=	O
reason1	int
;	O
all_data	array(struct(int,int,int,int))
[	O
next_all	int
]	O
.	O
what1	int
=	O
what1	int
;	O
all_data	array(struct(int,int,int,int))
[	O
next_all	int
]	O
.	O
reason2	int
=	O
reason2	int
;	O
all_data	array(struct(int,int,int,int))
[	O
next_all	int
]	O
.	O
what2	int
=	O
what2	int
;	O
next_all	int
++	O
;	O
return	O
next_all	int
-	O
1	int
;	O
}	O
static	O
int	O
find_pair_data	(int,int)->(int)
(	O
int	O
what1	int
,	O
int	O
what2	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
next_either	int
;	O
k	int
++	O
)	O
if	O
(	O
either_data	array(struct(int,int,int,int))
[	O
k	int
]	O
.	O
what1	int
==	O
what1	int
&&	O
either_data	array(struct(int,int,int,int))
[	O
k	int
]	O
.	O
what2	int
==	O
what2	int
)	O
return	O
k	int
;	O
gg_assert	O
(	O
next_either	int
<	O
MAX_EITHER	int
)	O
;	O
either_data	array(struct(int,int,int,int))
[	O
next_either	int
]	O
.	O
what1	int
=	O
what1	int
;	O
either_data	array(struct(int,int,int,int))
[	O
next_either	int
]	O
.	O
what2	int
=	O
what2	int
;	O
next_either	int
++	O
;	O
return	O
next_either	int
-	O
1	int
;	O
}	O
static	O
int	O
get_pos	(int,int)->(int)
(	O
int	O
reason	array(int)
,	O
int	O
what	int
)	O
{	O
switch	O
(	O
reason	array(int)
)	O
{	O
case	O
ATTACK_MOVE	int
:	O
case	O
DEFEND_MOVE	int
:	O
case	O
ATTACK_THREAT	O
:	O
case	O
DEFEND_THREAT	O
:	O
case	O
ATTACK_MOVE_GOOD_KO	int
:	O
case	O
ATTACK_MOVE_BAD_KO	int
:	O
case	O
DEFEND_MOVE_GOOD_KO	int
:	O
case	O
DEFEND_MOVE_BAD_KO	int
:	O
return	O
what	int
;	O
case	O
SEMEAI_MOVE	int
:	O
case	O
SEMEAI_THREAT	O
:	O
case	O
STRATEGIC_ATTACK_MOVE	int
:	O
case	O
STRATEGIC_DEFEND_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE	int
:	O
case	O
OWL_DEFEND_MOVE	int
:	O
case	O
OWL_ATTACK_THREAT	O
:	O
case	O
OWL_DEFEND_THREAT	O
:	O
case	O
OWL_PREVENT_THREAT	int
:	O
case	O
UNCERTAIN_OWL_ATTACK	int
:	O
case	O
UNCERTAIN_OWL_DEFENSE	int
:	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
return	O
what	int
;	O
case	O
EITHER_MOVE	int
:	O
return	O
either_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
what1	int
;	O
case	O
ALL_MOVE	int
:	O
return	O
all_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
what1	int
;	O
case	O
CONNECT_MOVE	int
:	O
case	O
CUT_MOVE	int
:	O
return	O
conn_worm1	array(int)
[	O
what	int
]	O
;	O
case	O
ANTISUJI_MOVE	int
:	O
case	O
EXPAND_TERRITORY_MOVE	int
:	O
case	O
EXPAND_MOYO_MOVE	int
:	O
case	O
INVASION_MOVE	int
:	O
case	O
MY_ATARI_ATARI_MOVE	int
:	O
case	O
YOUR_ATARI_ATARI_MOVE	int
:	O
return	O
NO_MOVE	O
;	O
case	O
OWL_ATTACK_MOVE_GAIN	int
:	O
case	O
OWL_DEFEND_MOVE_LOSS	int
:	O
return	O
either_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
what1	int
;	O
default	O
:	O
gg_assert	O
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
void	O
add_lunch	(int,int)->(void)
(	O
int	O
eater	int
,	O
int	O
food	int
)	O
{	O
int	O
k	int
;	O
int	O
dragon1	int
=	O
dragon	int
[	O
eater	int
]	O
.	O
origin	int
;	O
int	O
worm1	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
food	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
eater	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
food	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
next_lunch	int
;	O
k	int
++	O
)	O
if	O
(	O
(	O
lunch_dragon	array(int)
[	O
k	int
]	O
==	O
dragon1	int
)	O
&&	O
(	O
lunch_worm	array(int)
[	O
k	int
]	O
==	O
worm1	int
)	O
)	O
return	O
;	O
gg_assert	O
(	O
next_lunch	int
<	O
MAX_LUNCHES	O
)	O
;	O
lunch_dragon	array(int)
[	O
next_lunch	int
]	O
=	O
dragon1	int
;	O
lunch_worm	array(int)
[	O
next_lunch	int
]	O
=	O
worm1	int
;	O
next_lunch	int
++	O
;	O
return	O
;	O
}	O
static	O
void	O
add_move_reason	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
type	char
,	O
int	O
what	int
)	O
{	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
stackp	int
==	O
0	int
)	O
{	O
ASSERT1	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
type	char
&&	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
==	O
what	int
)	O
return	O
;	O
}	O
if	O
(	O
k	int
>=	O
MAX_REASONS	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Move reason at %1m (type=%d, what=%d) dropped because list full.\n"	*(char)
,	O
pos	int
,	O
type	char
,	O
what	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
next_reason	int
>=	O
MAX_MOVE_REASONS	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Move reason at %1m (type=%d, what=%d) dropped because global list full.\n"	*(char)
,	O
pos	int
,	O
type	char
,	O
what	int
)	O
;	O
return	O
;	O
}	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
=	O
next_reason	int
;	O
move_reasons	array(struct(int,int,int))
[	O
next_reason	int
]	O
.	O
type	char
=	O
type	char
;	O
move_reasons	array(struct(int,int,int))
[	O
next_reason	int
]	O
.	O
what	int
=	O
what	int
;	O
move_reasons	array(struct(int,int,int))
[	O
next_reason	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
ACTIVE	int
;	O
next_reason	int
++	O
;	O
}	O
static	O
void	O
remove_move_reason	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
type	char
,	O
int	O
what	int
)	O
{	O
int	O
k	int
;	O
int	O
n	int
=	O
-	O
1	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
type	char
&&	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
==	O
what	int
)	O
n	int
=	O
k	int
;	O
}	O
if	O
(	O
n	int
==	O
-	O
1	int
)	O
return	O
;	O
k	int
--	O
;	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
n	int
]	O
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
=	O
-	O
1	int
;	O
}	O
int	O
move_reason_known	(int,int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
type	char
,	O
int	O
what	int
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
type	char
&&	O
(	O
what	int
<	O
0	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
==	O
what	int
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
attack_move_reason_known	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
ASSERT1	O
(	O
what	int
<	O
0	int
||	O
IS_STONE	O
(	O
board	*(char)
[	O
what	int
]	O
)	O
,	O
what	int
)	O
;	O
what	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
what	int
]	O
.	O
origin	int
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
ATTACK_MOVE	int
,	O
what	int
)	O
)	O
return	O
WIN	int
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
ATTACK_MOVE_GOOD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_A	int
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
ATTACK_MOVE_BAD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_B	int
;	O
return	O
0	int
;	O
}	O
int	O
defense_move_reason_known	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
ASSERT1	O
(	O
what	int
<	O
0	int
||	O
IS_STONE	O
(	O
board	*(char)
[	O
what	int
]	O
)	O
,	O
what	int
)	O
;	O
what	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
what	int
]	O
.	O
origin	int
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
DEFEND_MOVE	int
,	O
what	int
)	O
)	O
return	O
WIN	int
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
DEFEND_MOVE_GOOD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_A	int
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
DEFEND_MOVE_BAD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_B	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
tactical_move_vs_whole_dragon_known	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
return	O
(	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
what	int
]	O
.	O
size	int
==	O
dragon	int
[	O
what	int
]	O
.	O
size	int
)	O
&&	O
(	O
attack_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
what	int
)	O
||	O
defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
what	int
)	O
)	O
)	O
;	O
}	O
int	O
owl_attack_move_reason_known	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
OWL_ATTACK_MOVE	int
,	O
what	int
)	O
)	O
return	O
WIN	int
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
OWL_ATTACK_MOVE_GOOD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_A	int
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
OWL_ATTACK_MOVE_BAD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_B	int
;	O
return	O
0	int
;	O
}	O
int	O
owl_defense_move_reason_known	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
OWL_DEFEND_MOVE	int
,	O
what	int
)	O
)	O
return	O
WIN	int
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
OWL_DEFEND_MOVE_GOOD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_A	int
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
OWL_DEFEND_MOVE_BAD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_B	int
;	O
return	O
0	int
;	O
}	O
int	O
owl_move_reason_known	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
return	O
(	O
owl_attack_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
what	int
)	O
||	O
owl_defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
what	int
)	O
)	O
;	O
}	O
static	O
int	O
owl_move_vs_worm_known	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
return	O
owl_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
dragon	int
[	O
what	int
]	O
.	O
origin	int
)	O
;	O
}	O
int	O
semeai_move_reason_known	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
return	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
SEMEAI_MOVE	int
,	O
what	int
)	O
;	O
}	O
static	O
int	O
concerns_inessential_worm	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
pos	int
)	O
;	O
return	O
DRAGON2	O
(	O
what	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
||	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
what	int
]	O
.	O
inessential	int
;	O
}	O
static	O
int	O
concerns_inessential_dragon	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
pos	int
)	O
;	O
return	O
DRAGON2	O
(	O
what	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
;	O
}	O
static	O
int	O
move_is_marked_unsafe	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
what	int
)	O
;	O
return	O
(	O
!	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
&&	O
!	O
adjacent_to_nondead_stone	(int,int)->(int)
(	O
pos	int
,	O
current_color	int
)	O
)	O
;	O
}	O
static	O
int	O
concerns_noncritical_dragon	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
pos	int
)	O
;	O
return	O
(	O
dragon	int
[	O
what	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
CRITICAL	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
what	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
;	O
}	O
static	O
int	O
either_worm_attackable	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
pos	int
)	O
;	O
return	O
(	O
either_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
reason1	int
==	O
ATTACK_STRING	int
&&	O
either_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
reason2	int
==	O
ATTACK_STRING	int
&&	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
either_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
what1	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
||	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
either_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
what2	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
)	O
)	O
;	O
}	O
static	O
int	O
one_of_both_attackable	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
pos	int
)	O
;	O
return	O
(	O
all_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
reason1	int
==	O
DEFEND_STRING	int
&&	O
all_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
reason2	int
==	O
DEFEND_STRING	int
&&	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
all_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
what1	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
||	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
all_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
what2	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
)	O
)	O
;	O
}	O
void	O
add_attack_move	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
ww	int
,	O
int	O
code	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
ww	int
)	O
;	O
ww	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ww	int
]	O
.	O
origin	int
;	O
if	O
(	O
code	int
==	O
WIN	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
ATTACK_MOVE	int
,	O
ww	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_A	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
ATTACK_MOVE_GOOD_KO	int
,	O
ww	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_B	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
ATTACK_MOVE_BAD_KO	int
,	O
ww	int
)	O
;	O
}	O
void	O
add_defense_move	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
ww	int
,	O
int	O
code	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
ww	int
)	O
;	O
ww	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ww	int
]	O
.	O
origin	int
;	O
if	O
(	O
code	int
==	O
WIN	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
DEFEND_MOVE	int
,	O
ww	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_A	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
DEFEND_MOVE_GOOD_KO	int
,	O
ww	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_B	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
DEFEND_MOVE_BAD_KO	int
,	O
ww	int
)	O
;	O
}	O
void	O
add_attack_threat_move	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
ww	int
,	O
int	O
code	int
)	O
{	O
UNUSED	O
(	O
code	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
ww	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
ATTACK_THREAT	O
,	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ww	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
remove_attack_threat_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
ww	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
ww	int
)	O
;	O
remove_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
ATTACK_THREAT	O
,	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ww	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
add_defense_threat_move	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
ww	int
,	O
int	O
code	int
)	O
{	O
UNUSED	O
(	O
code	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
ww	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
DEFEND_THREAT	O
,	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ww	int
]	O
.	O
origin	int
)	O
;	O
}	O
int	O
get_attack_threats	(int,int,array(int))->(int)
(	O
int	O
pos	int
,	O
int	O
max_strings	int
,	O
int	O
strings	array(int)
[	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
num_strings	int
;	O
num_strings	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_THREAT	O
)	O
strings	array(int)
[	O
num_strings	int
++	O
]	O
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
num_strings	int
==	O
max_strings	int
)	O
break	O
;	O
}	O
return	O
num_strings	int
;	O
}	O
int	O
get_defense_threats	(int,int,array(int))->(int)
(	O
int	O
pos	int
,	O
int	O
max_strings	int
,	O
int	O
strings	array(int)
[	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
num_strings	int
;	O
num_strings	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_THREAT	O
)	O
strings	array(int)
[	O
num_strings	int
++	O
]	O
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
num_strings	int
==	O
max_strings	int
)	O
break	O
;	O
}	O
return	O
num_strings	int
;	O
}	O
int	O
get_biggest_owl_target	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
k	int
;	O
int	O
biggest_target	int
=	O
-	O
1	int
;	O
float	O
target_size	float
=	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
OWL_ATTACK_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
case	O
OWL_ATTACK_THREAT	O
:	O
case	O
OWL_DEFEND_MOVE	int
:	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
case	O
OWL_DEFEND_THREAT	O
:	O
case	O
OWL_PREVENT_THREAT	int
:	O
if	O
(	O
dragon	int
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
>	O
target_size	float
)	O
{	O
biggest_target	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
target_size	float
=	O
dragon	int
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
;	O
}	O
break	O
;	O
}	O
}	O
return	O
biggest_target	int
;	O
}	O
void	O
add_connection_move	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
w1	int
,	O
int	O
w2	int
)	O
{	O
int	O
connection	int
;	O
ASSERT_ON_BOARD1	O
(	O
w1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
w2	int
)	O
;	O
ASSERT1	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w1	int
]	O
.	O
color	int
==	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w2	int
]	O
.	O
color	int
,	O
w1	int
)	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w1	int
]	O
.	O
origin	int
==	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w2	int
]	O
.	O
origin	int
)	O
return	O
;	O
connection	int
=	O
find_connection	(int,int)->(int)
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w1	int
]	O
.	O
origin	int
,	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w2	int
]	O
.	O
origin	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
CONNECT_MOVE	int
,	O
connection	int
)	O
;	O
}	O
void	O
add_cut_move	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
w1	int
,	O
int	O
w2	int
)	O
{	O
int	O
connection	int
;	O
ASSERT_ON_BOARD1	O
(	O
w1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
w2	int
)	O
;	O
ASSERT1	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w1	int
]	O
.	O
color	int
==	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w2	int
]	O
.	O
color	int
,	O
w1	int
)	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w1	int
]	O
.	O
origin	int
==	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w2	int
]	O
.	O
origin	int
)	O
return	O
;	O
connection	int
=	O
find_connection	(int,int)->(int)
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w1	int
]	O
.	O
origin	int
,	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w2	int
]	O
.	O
origin	int
)	O
;	O
if	O
(	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w1	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w1	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
||	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w2	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
w2	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
)	O
return	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
CUT_MOVE	int
,	O
connection	int
)	O
;	O
}	O
void	O
add_antisuji_move	(int)->(void)
(	O
int	O
pos	int
)	O
{	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
ANTISUJI_MOVE	int
,	O
0	int
)	O
;	O
}	O
void	O
add_semeai_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
SEMEAI_MOVE	int
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
}	O
static	O
void	O
add_potential_semeai_move	(int,int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
type	char
,	O
int	O
dr1	int
,	O
int	O
dr2	int
)	O
{	O
ASSERT1	O
(	O
ON_BOARD	O
(	O
dr1	int
)	O
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
ON_BOARD	O
(	O
dr2	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
next_semeai	int
>=	O
MAX_POTENTIAL_SEMEAI	int
)	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Potential semeai move at %1m dropped as list was full\n"	*(char)
,	O
pos	int
)	O
;	O
else	O
{	O
semeai_target1	array(int)
[	O
next_semeai	int
]	O
=	O
dr1	int
;	O
semeai_target2	array(int)
[	O
next_semeai	int
]	O
=	O
dr2	int
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
type	char
,	O
next_semeai	int
)	O
;	O
next_semeai	int
++	O
;	O
}	O
}	O
void	O
add_potential_semeai_attack	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr1	int
,	O
int	O
dr2	int
)	O
{	O
add_potential_semeai_move	(int,int,int,int)->(void)
(	O
pos	int
,	O
POTENTIAL_SEMEAI_ATTACK	int
,	O
dr1	int
,	O
dr2	int
)	O
;	O
}	O
void	O
add_potential_semeai_defense	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr1	int
,	O
int	O
dr2	int
)	O
{	O
add_potential_semeai_move	(int,int,int,int)->(void)
(	O
pos	int
,	O
POTENTIAL_SEMEAI_DEFENSE	int
,	O
dr1	int
,	O
dr2	int
)	O
;	O
}	O
void	O
add_semeai_threat	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
SEMEAI_THREAT	O
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
add_either_move	(int,int,int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
reason1	int
,	O
int	O
target1	int
,	O
int	O
reason2	int
,	O
int	O
target2	int
)	O
{	O
int	O
what1	int
=	O
0	int
;	O
int	O
what2	int
=	O
0	int
;	O
int	O
index	(*(char),int)->(*(char))
;	O
ASSERT_ON_BOARD1	O
(	O
target1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
target2	int
)	O
;	O
if	O
(	O
reason1	int
==	O
reason2	int
&&	O
target1	int
==	O
target2	int
)	O
return	O
;	O
gg_assert	O
(	O
reason1	int
==	O
ATTACK_STRING	int
)	O
;	O
gg_assert	O
(	O
reason2	int
==	O
ATTACK_STRING	int
)	O
;	O
switch	O
(	O
reason1	int
)	O
{	O
case	O
ATTACK_STRING	int
:	O
{	O
what1	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target1	int
]	O
.	O
origin	int
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target1	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target1	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
return	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
reason2	int
)	O
{	O
case	O
ATTACK_STRING	int
:	O
{	O
what2	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target2	int
]	O
.	O
origin	int
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target2	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target2	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
return	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
index	(*(char),int)->(*(char))
=	O
find_either_data	(int,int,int,int)->(int)
(	O
reason1	int
,	O
what1	int
,	O
reason2	int
,	O
what2	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
EITHER_MOVE	int
,	O
index	(*(char),int)->(*(char))
)	O
;	O
}	O
void	O
add_all_move	(int,int,int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
reason1	int
,	O
int	O
target1	int
,	O
int	O
reason2	int
,	O
int	O
target2	int
)	O
{	O
int	O
what1	int
=	O
0	int
;	O
int	O
what2	int
=	O
0	int
;	O
int	O
index	(*(char),int)->(*(char))
;	O
ASSERT_ON_BOARD1	O
(	O
target1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
target2	int
)	O
;	O
if	O
(	O
reason1	int
==	O
reason2	int
&&	O
target1	int
==	O
target2	int
)	O
return	O
;	O
gg_assert	O
(	O
reason1	int
==	O
DEFEND_STRING	int
)	O
;	O
gg_assert	O
(	O
reason2	int
==	O
DEFEND_STRING	int
)	O
;	O
switch	O
(	O
reason1	int
)	O
{	O
case	O
DEFEND_STRING	int
:	O
what1	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target1	int
]	O
.	O
origin	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
reason2	int
)	O
{	O
case	O
DEFEND_STRING	int
:	O
what2	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target2	int
]	O
.	O
origin	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
index	(*(char),int)->(*(char))
=	O
find_all_data	(int,int,int,int)->(int)
(	O
reason1	int
,	O
what1	int
,	O
reason2	int
,	O
what2	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
ALL_MOVE	int
,	O
index	(*(char),int)->(*(char))
)	O
;	O
}	O
void	O
add_loss_move	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
target1	int
,	O
int	O
target2	int
)	O
{	O
int	O
what1	int
=	O
dragon	int
[	O
target1	int
]	O
.	O
origin	int
;	O
int	O
what2	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target2	int
]	O
.	O
origin	int
;	O
int	O
index	(*(char),int)->(*(char))
=	O
find_pair_data	(int,int)->(int)
(	O
what1	int
,	O
what2	int
)	O
;	O
ASSERT1	O
(	O
target2	int
!=	O
NO_MOVE	O
,	O
pos	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
OWL_DEFEND_MOVE_LOSS	int
,	O
index	(*(char),int)->(*(char))
)	O
;	O
}	O
void	O
add_expand_territory_move	(int)->(void)
(	O
int	O
pos	int
)	O
{	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
EXPAND_TERRITORY_MOVE	int
,	O
0	int
)	O
;	O
}	O
void	O
add_expand_moyo_move	(int)->(void)
(	O
int	O
pos	int
)	O
{	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
EXPAND_MOYO_MOVE	int
,	O
0	int
)	O
;	O
}	O
void	O
add_invasion_move	(int)->(void)
(	O
int	O
pos	int
)	O
{	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
INVASION_MOVE	int
,	O
0	int
)	O
;	O
}	O
void	O
add_shape_value	(int,float)->(void)
(	O
int	O
pos	int
,	O
float	O
value	*(char)
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	*(char)
>	O
0.0	int
)	O
{	O
if	O
(	O
value	*(char)
>	O
move	*(int)
[	O
pos	int
]	O
.	O
maxpos_shape	float
)	O
move	*(int)
[	O
pos	int
]	O
.	O
maxpos_shape	float
=	O
value	*(char)
;	O
move	*(int)
[	O
pos	int
]	O
.	O
numpos_shape	int
+=	O
1	int
;	O
}	O
else	O
if	O
(	O
value	*(char)
<	O
0.0	int
)	O
{	O
value	*(char)
=	O
-	O
value	*(char)
;	O
if	O
(	O
value	*(char)
>	O
move	*(int)
[	O
pos	int
]	O
.	O
maxneg_shape	float
)	O
move	*(int)
[	O
pos	int
]	O
.	O
maxneg_shape	float
=	O
value	*(char)
;	O
move	*(int)
[	O
pos	int
]	O
.	O
numneg_shape	int
+=	O
1	int
;	O
}	O
}	O
void	O
add_worthwhile_threat_move	(int)->(void)
(	O
int	O
pos	int
)	O
{	O
move	*(int)
[	O
pos	int
]	O
.	O
worthwhile_threat	int
=	O
1	int
;	O
}	O
void	O
add_strategical_attack_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
STRATEGIC_ATTACK_MOVE	int
,	O
dr	int
)	O
;	O
}	O
void	O
add_strategical_defense_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
STRATEGIC_DEFEND_MOVE	int
,	O
dr	int
)	O
;	O
}	O
void	O
add_owl_attack_move	(int,int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr	int
,	O
int	O
kworm	int
,	O
int	O
code	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
if	O
(	O
code	int
==	O
WIN	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
OWL_ATTACK_MOVE	int
,	O
dr	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_A	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
OWL_ATTACK_MOVE_GOOD_KO	int
,	O
dr	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_B	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
OWL_ATTACK_MOVE_BAD_KO	int
,	O
dr	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
GAIN	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
kworm	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
OWL_ATTACK_MOVE_GAIN	int
,	O
find_pair_data	(int,int)->(int)
(	O
dr	int
,	O
kworm	int
)	O
)	O
;	O
}	O
}	O
void	O
add_owl_defense_move	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr	int
,	O
int	O
code	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
if	O
(	O
code	int
==	O
WIN	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
OWL_DEFEND_MOVE	int
,	O
dr	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_A	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
OWL_DEFEND_MOVE_GOOD_KO	int
,	O
dr	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_B	int
)	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
OWL_DEFEND_MOVE_BAD_KO	int
,	O
dr	int
)	O
;	O
}	O
void	O
add_owl_attack_threat_move	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr	int
,	O
int	O
code	int
)	O
{	O
UNUSED	O
(	O
code	int
)	O
;	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
OWL_ATTACK_THREAT	O
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
add_worthwhile_threat_move	(int)->(void)
(	O
pos	int
)	O
;	O
}	O
void	O
add_owl_uncertain_defense_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
UNCERTAIN_OWL_DEFENSE	int
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
add_owl_uncertain_attack_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
UNCERTAIN_OWL_ATTACK	int
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
add_owl_defense_threat_move	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr	int
,	O
int	O
code	int
)	O
{	O
UNUSED	O
(	O
code	int
)	O
;	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
OWL_DEFEND_THREAT	O
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
add_worthwhile_threat_move	(int)->(void)
(	O
pos	int
)	O
;	O
}	O
void	O
add_my_atari_atari_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
size	int
)	O
{	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
MY_ATARI_ATARI_MOVE	int
,	O
size	int
)	O
;	O
}	O
void	O
add_your_atari_atari_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
size	int
)	O
{	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
YOUR_ATARI_ATARI_MOVE	int
,	O
size	int
)	O
;	O
}	O
void	O
add_owl_prevent_threat_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	(int,int,int)->(void)
(	O
pos	int
,	O
OWL_PREVENT_THREAT	int
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
add_followup_value	(int,float)->(void)
(	O
int	O
pos	int
,	O
float	O
value	*(char)
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	*(char)
>	O
move	*(int)
[	O
pos	int
]	O
.	O
followup_value	*(float)
)	O
move	*(int)
[	O
pos	int
]	O
.	O
followup_value	*(float)
=	O
value	*(char)
;	O
}	O
void	O
add_reverse_followup_value	(int,float)->(void)
(	O
int	O
pos	int
,	O
float	O
value	*(char)
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	*(char)
>	O
move	*(int)
[	O
pos	int
]	O
.	O
reverse_followup_value	float
)	O
move	*(int)
[	O
pos	int
]	O
.	O
reverse_followup_value	float
=	O
value	*(char)
;	O
}	O
int	O
set_minimum_move_value	(int,float)->(int)
(	O
int	O
pos	int
,	O
float	O
value	*(char)
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	*(char)
>	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
)	O
{	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
=	O
value	*(char)
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
set_maximum_move_value	(int,float)->(void)
(	O
int	O
pos	int
,	O
float	O
value	*(char)
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	*(char)
<	O
move	*(int)
[	O
pos	int
]	O
.	O
max_value	float
)	O
move	*(int)
[	O
pos	int
]	O
.	O
max_value	float
=	O
value	*(char)
;	O
}	O
void	O
set_minimum_territorial_value	(int,float)->(void)
(	O
int	O
pos	int
,	O
float	O
value	*(char)
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	*(char)
>	O
move	*(int)
[	O
pos	int
]	O
.	O
min_territory	float
)	O
move	*(int)
[	O
pos	int
]	O
.	O
min_territory	float
=	O
value	*(char)
;	O
}	O
void	O
set_maximum_territorial_value	(int,float)->(void)
(	O
int	O
pos	int
,	O
float	O
value	*(char)
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	*(char)
<	O
move	*(int)
[	O
pos	int
]	O
.	O
max_territory	float
)	O
move	*(int)
[	O
pos	int
]	O
.	O
max_territory	float
=	O
value	*(char)
;	O
}	O
void	O
add_replacement_move	(int,int,int)->(void)
(	O
int	O
from	int
,	O
int	O
to	int
,	O
int	O
color	int
)	O
{	O
int	O
cc	int
;	O
int	O
pos	int
;	O
int	O
dummy	int
;	O
ASSERT_ON_BOARD1	O
(	O
from	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
to	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
from	int
]	O
!=	O
EMPTY	int
)	O
return	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
to	int
]	O
==	O
EMPTY	int
,	O
to	int
)	O
;	O
cc	int
=	O
replacement_map	array(int)
[	O
to	int
]	O
;	O
if	O
(	O
unconditionally_meaningless_move	(int,int,*(int))->(int)
(	O
to	int
,	O
color	int
,	O
&	O
dummy	int
)	O
)	O
{	O
return	O
;	O
}	O
if	O
(	O
replacement_map	array(int)
[	O
from	int
]	O
!=	O
NO_MOVE	O
)	O
{	O
int	O
dd	int
=	O
replacement_map	array(int)
[	O
from	int
]	O
;	O
if	O
(	O
0	int
)	O
{	O
ASSERT1	O
(	O
dd	int
==	O
to	int
||	O
to	int
==	O
replacement_map	array(int)
[	O
dd	int
]	O
,	O
from	int
)	O
;	O
}	O
return	O
;	O
}	O
TRACE	O
(	O
"Move at %1m is replaced by %1m.\n"	*(char)
,	O
from	int
,	O
to	int
)	O
;	O
if	O
(	O
cc	int
==	O
from	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"Cyclic point redistribution detected.\n"	*(char)
)	O
;	O
ASSERT1	O
(	O
0	int
,	O
from	int
)	O
;	O
}	O
if	O
(	O
cc	int
!=	O
NO_MOVE	O
)	O
replacement_map	array(int)
[	O
from	int
]	O
=	O
cc	int
;	O
else	O
replacement_map	array(int)
[	O
from	int
]	O
=	O
to	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
replacement_map	array(int)
[	O
pos	int
]	O
==	O
from	int
)	O
replacement_map	array(int)
[	O
pos	int
]	O
=	O
replacement_map	array(int)
[	O
from	int
]	O
;	O
}	O
}	O
void	O
get_saved_worms	(int,array(char))->(void)
(	O
int	O
pos	int
,	O
signed	O
char	O
saved	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
saved	array(char)
,	O
0	int
,	O
sizeof	O
(	O
saved	array(char)
[	O
0	int
]	O
)	O
*	O
BOARDMAX	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
int	O
what	int
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
what	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE	int
)	O
mark_string	(int,array(char),char)->(void)
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
what	int
]	O
.	O
origin	int
,	O
saved	array(char)
,	O
1	int
)	O
;	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_LOSS	int
)	O
{	O
int	O
origin	int
=	O
dragon	int
[	O
what	int
]	O
.	O
origin	int
;	O
int	O
kworm	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
what	int
]	O
.	O
origin	int
;	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
ii	int
]	O
)	O
&&	O
dragon	int
[	O
ii	int
]	O
.	O
origin	int
==	O
origin	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ii	int
]	O
.	O
origin	int
!=	O
kworm	int
)	O
mark_string	(int,array(char),char)->(void)
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ii	int
]	O
.	O
origin	int
,	O
saved	array(char)
,	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
mark_changed_dragon	(int,int,int,int,int,array(char),array(float),*(float))->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
affected	int
,	O
int	O
affected2	int
,	O
int	O
move_reason_type	int
,	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
,	O
float	O
strength	array(float)
[	O
BOARDMAX	O
]	O
,	O
float	O
*	O
effective_size	float
)	O
{	O
int	O
ii	int
;	O
signed	O
char	O
new_status	char
=	O
INFLUENCE_SAVED_STONE	int
;	O
int	O
result_to_beat	int
=	O
0	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
affected	int
]	O
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
=	O
0.0	int
;	O
switch	O
(	O
move_reason_type	int
)	O
{	O
case	O
OWL_ATTACK_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
ASSERT1	O
(	O
board	*(char)
[	O
affected	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
new_status	char
=	O
0	int
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
=	O
dragon	int
[	O
affected	int
]	O
.	O
effective_size	float
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE	int
:	O
ASSERT1	O
(	O
board	*(char)
[	O
affected	int
]	O
==	O
color	int
,	O
pos	int
)	O
;	O
result_to_beat	int
=	O
WIN	int
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
ASSERT1	O
(	O
board	*(char)
[	O
affected	int
]	O
==	O
color	int
,	O
pos	int
)	O
;	O
result_to_beat	int
=	O
KO_A	int
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
ASSERT1	O
(	O
board	*(char)
[	O
affected	int
]	O
==	O
color	int
,	O
pos	int
)	O
;	O
result_to_beat	int
=	O
KO_B	int
;	O
break	O
;	O
case	O
OWL_ATTACK_MOVE_GAIN	int
:	O
ASSERT1	O
(	O
board	*(char)
[	O
affected	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
new_status	char
=	O
0	int
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
affected2	int
]	O
.	O
effective_size	float
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_LOSS	int
:	O
ASSERT1	O
(	O
board	*(char)
[	O
affected	int
]	O
==	O
color	int
,	O
pos	int
)	O
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
=	O
dragon	int
[	O
affected	int
]	O
.	O
effective_size	float
-	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
affected2	int
]	O
.	O
effective_size	float
;	O
result_to_beat	int
=	O
WIN	int
;	O
break	O
;	O
case	O
SEMEAI_MOVE	int
:	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
affected	int
]	O
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
affected	int
]	O
==	O
color	int
)	O
result_to_beat	int
=	O
WIN	int
;	O
else	O
{	O
new_status	char
=	O
0	int
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
=	O
dragon	int
[	O
affected	int
]	O
.	O
effective_size	float
;	O
}	O
break	O
;	O
default	O
:	O
ASSERT1	O
(	O
0	int
,	O
pos	int
)	O
;	O
}	O
if	O
(	O
move_reason_type	int
==	O
OWL_ATTACK_MOVE_GAIN	int
)	O
mark_changed_string	(int,array(char),array(float),char)->(void)
(	O
affected2	int
,	O
safe_stones	array(char)
,	O
strength	array(float)
,	O
new_status	char
)	O
;	O
else	O
{	O
for	O
(	O
ii	int
=	O
first_worm_in_dragon	(int)->(int)
(	O
affected	int
)	O
;	O
ii	int
!=	O
NO_MOVE	O
;	O
ii	int
=	O
next_worm_in_dragon	(int)->(int)
(	O
ii	int
)	O
)	O
if	O
(	O
new_status	char
==	O
0	int
)	O
mark_changed_string	(int,array(char),array(float),char)->(void)
(	O
ii	int
,	O
safe_stones	array(char)
,	O
strength	array(float)
,	O
new_status	char
)	O
;	O
else	O
{	O
int	O
worm_is_safe	int
=	O
0	int
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ii	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
==	O
NO_MOVE	O
||	O
defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
ii	int
)	O
)	O
worm_is_safe	int
=	O
1	int
;	O
else	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
"mark-changed-dragon"	*(char)
,	O
ii	int
)	O
)	O
{	O
if	O
(	O
REVERSE_RESULT	O
(	O
attack	(int,*(int))->(int)
(	O
ii	int
,	O
NULL	O
)	O
)	O
>=	O
result_to_beat	int
)	O
worm_is_safe	int
=	O
1	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
worm_is_safe	int
||	O
move_reason_type	int
==	O
SEMEAI_MOVE	int
)	O
{	O
mark_changed_string	(int,array(char),array(float),char)->(void)
(	O
ii	int
,	O
safe_stones	array(char)
,	O
strength	array(float)
,	O
new_status	char
)	O
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
+=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ii	int
]	O
.	O
effective_size	float
;	O
}	O
}	O
if	O
(	O
move_reason_type	int
==	O
OWL_DEFEND_MOVE_LOSS	int
)	O
{	O
new_status	char
=	O
0	int
;	O
mark_changed_string	(int,array(char),array(float),char)->(void)
(	O
affected2	int
,	O
safe_stones	array(char)
,	O
strength	array(float)
,	O
new_status	char
)	O
;	O
}	O
}	O
}	O
void	O
mark_changed_string	(int,array(char),array(float),char)->(void)
(	O
int	O
affected	int
,	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
,	O
float	O
strength	array(float)
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
new_status	char
)	O
{	O
float	O
new_strength	float
;	O
int	O
ii	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
affected	int
]	O
)	O
,	O
affected	int
)	O
;	O
if	O
(	O
new_status	char
==	O
0	int
)	O
new_strength	float
=	O
0.0	int
;	O
else	O
{	O
gg_assert	O
(	O
new_status	char
==	O
INFLUENCE_SAVED_STONE	int
)	O
;	O
new_strength	float
=	O
DEFAULT_STRENGTH	int
;	O
}	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
ii	int
]	O
==	O
board	*(char)
[	O
affected	int
]	O
&&	O
same_string	(int,int)->(int)
(	O
ii	int
,	O
affected	int
)	O
)	O
{	O
strength	array(float)
[	O
ii	int
]	O
=	O
new_strength	float
;	O
safe_stones	array(char)
[	O
ii	int
]	O
=	O
new_status	char
;	O
}	O
}	O
void	O
get_saved_dragons	(int,array(char))->(void)
(	O
int	O
pos	int
,	O
signed	O
char	O
saved	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
saved	array(char)
,	O
0	int
,	O
sizeof	O
(	O
saved	array(char)
[	O
0	int
]	O
)	O
*	O
BOARDMAX	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
int	O
what	int
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
what	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE	int
)	O
mark_dragon	(int,array(char),char)->(void)
(	O
what	int
,	O
saved	array(char)
,	O
1	int
)	O
;	O
}	O
}	O
void	O
mark_safe_stones	(int,int,array(char),array(char),array(char))->(void)
(	O
int	O
color	int
,	O
int	O
move_pos	int
,	O
const	O
signed	O
char	O
saved_dragons	array(char)
[	O
BOARDMAX	O
]	O
,	O
const	O
signed	O
char	O
saved_worms	array(char)
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
||	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
)	O
safe_stones	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
else	O
safe_stones	array(char)
[	O
pos	int
]	O
=	O
SAFE_STONE	int
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
||	O
!	O
saved_worms	array(char)
[	O
pos	int
]	O
)	O
)	O
||	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
safe_stones	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
else	O
if	O
(	O
saved_dragons	array(char)
[	O
pos	int
]	O
)	O
safe_stones	array(char)
[	O
pos	int
]	O
=	O
OWL_SAVED_STONE	int
;	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
)	O
safe_stones	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
else	O
safe_stones	array(char)
[	O
pos	int
]	O
=	O
SAFE_STONE	int
;	O
}	O
else	O
safe_stones	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
safe_stones	array(char)
[	O
move_pos	int
]	O
=	O
move	*(int)
[	O
move_pos	int
]	O
.	O
move_safety	int
&&	O
safe_move	(int,int)->(int)
(	O
move_pos	int
,	O
color	int
)	O
==	O
WIN	int
;	O
}	O
int	O
list_move_reasons	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(int)
(	O
FILE	struct
*	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
move_pos	int
)	O
{	O
int	O
m	int
;	O
int	O
n	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
reason1	int
;	O
int	O
reason2	int
;	O
int	O
aa	int
=	O
NO_MOVE	O
;	O
int	O
bb	int
=	O
NO_MOVE	O
;	O
int	O
worm1	int
=	O
-	O
1	int
;	O
int	O
worm2	int
=	O
-	O
1	int
;	O
int	O
num_move_reasons	int
=	O
0	int
;	O
gprintf	(*(char))->(int)
(	O
"\nMove reasons:\n"	*(char)
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
for	O
(	O
m	int
=	O
board_size	int
-	O
1	int
;	O
m	int
>=	O
0	int
;	O
m	int
--	O
)	O
{	O
pos	int
=	O
POS	O
(	O
m	int
,	O
n	int
)	O
;	O
if	O
(	O
move_pos	int
!=	O
NO_MOVE	O
&&	O
move_pos	int
!=	O
pos	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
num_move_reasons	int
++	O
;	O
switch	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
ATTACK_MOVE	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m attacks %1m%s\n"	*(char)
,	O
pos	int
,	O
aa	int
,	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
?	O
" (defenseless)"	*(char)
:	O
""	*(char)
)	O
;	O
break	O
;	O
case	O
ATTACK_MOVE_GOOD_KO	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m attacks %1m%s with good ko\n"	*(char)
,	O
pos	int
,	O
aa	int
,	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
?	O
" (defenseless)"	*(char)
:	O
""	*(char)
)	O
;	O
break	O
;	O
case	O
ATTACK_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m attacks %1m%s with bad ko\n"	*(char)
,	O
pos	int
,	O
aa	int
,	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
?	O
" (defenseless)"	*(char)
:	O
""	*(char)
)	O
;	O
break	O
;	O
case	O
DEFEND_MOVE	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m defends %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
DEFEND_MOVE_GOOD_KO	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m defends %1m with good ko\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
DEFEND_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m defends %1m with bad ko\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
ATTACK_THREAT	O
:	O
case	O
DEFEND_THREAT	O
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_THREAT	O
)	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m threatens to attack %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_THREAT	O
)	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m threatens to defend %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
UNCERTAIN_OWL_DEFENSE	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
board	*(char)
[	O
aa	int
]	O
==	O
current_color	int
)	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%1m found alive but not certainly, %1m defends it again\n"	*(char)
,	O
aa	int
,	O
pos	int
)	O
;	O
else	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%1m found dead but not certainly, %1m attacks it again\n"	*(char)
,	O
aa	int
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
CONNECT_MOVE	int
:	O
case	O
CUT_MOVE	int
:	O
worm1	int
=	O
conn_worm1	array(int)
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
;	O
worm2	int
=	O
conn_worm2	array(int)
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
CONNECT_MOVE	int
)	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m connects %1m and %1m\n"	*(char)
,	O
pos	int
,	O
worm1	int
,	O
worm2	int
)	O
;	O
else	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m cuts %1m and %1m\n"	*(char)
,	O
pos	int
,	O
worm1	int
,	O
worm2	int
)	O
;	O
break	O
;	O
case	O
ANTISUJI_MOVE	int
:	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m is an antisuji\n"	*(char)
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
SEMEAI_MOVE	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m wins semeai for %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
SEMEAI_THREAT	O
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m threatens to win semeai for %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
EITHER_MOVE	int
:	O
reason1	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
reason1	int
;	O
reason2	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
reason2	int
;	O
worm1	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
worm2	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m either %s %1m or %s %1m\n"	*(char)
,	O
pos	int
,	O
reason1	int
==	O
ATTACK_STRING	int
?	O
"attacks"	*(char)
:	O
"defends"	*(char)
,	O
worm1	int
,	O
reason2	int
==	O
ATTACK_STRING	int
?	O
"attacks"	*(char)
:	O
"defends"	*(char)
,	O
worm2	int
)	O
;	O
break	O
;	O
case	O
ALL_MOVE	int
:	O
reason1	int
=	O
all_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
reason1	int
;	O
reason2	int
=	O
all_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
reason2	int
;	O
worm1	int
=	O
all_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
worm2	int
=	O
all_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m both %s %1m and %s %1m\n"	*(char)
,	O
pos	int
,	O
reason1	int
==	O
ATTACK_STRING	int
?	O
"attacks"	*(char)
:	O
"defends"	*(char)
,	O
worm1	int
,	O
reason2	int
==	O
ATTACK_STRING	int
?	O
"attacks"	*(char)
:	O
"defends"	*(char)
,	O
worm2	int
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_MOVE	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m owl-attacks %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m owl-attacks %1m with good ko\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m owl-attacks %1m with bad ko\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_MOVE_GAIN	int
:	O
aa	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
bb	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m owl-attacks %1m (captures %1m)\n"	*(char)
,	O
pos	int
,	O
aa	int
,	O
bb	int
)	O
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m owl-defends %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m owl-defends %1m with good ko\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m owl-defends %1m with bad ko\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_LOSS	int
:	O
aa	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
bb	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m owl-defends %1m (loses %1m)\n"	*(char)
,	O
pos	int
,	O
aa	int
,	O
bb	int
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_THREAT	O
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m owl-threatens to attack %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_DEFEND_THREAT	O
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m owl-threatens to defend %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_PREVENT_THREAT	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m owl-prevents a threat to attack or defend %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
EXPAND_TERRITORY_MOVE	int
:	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m expands territory\n"	*(char)
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
EXPAND_MOYO_MOVE	int
:	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m expands moyo\n"	*(char)
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
INVASION_MOVE	int
:	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m is an invasion\n"	*(char)
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
STRATEGIC_ATTACK_MOVE	int
:	O
case	O
STRATEGIC_DEFEND_MOVE	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
STRATEGIC_ATTACK_MOVE	int
)	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m strategically attacks %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
else	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m strategically defends %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
MY_ATARI_ATARI_MOVE	int
:	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m captures something\n"	*(char)
,	O
pos	int
)	O
;	O
case	O
YOUR_ATARI_ATARI_MOVE	int
:	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m defends against combination attack\n"	*(char)
,	O
pos	int
)	O
;	O
}	O
}	O
if	O
(	O
k	int
>	O
0	int
&&	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
==	O
0	int
)	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Move at %1m strategically or tactically unsafe\n"	*(char)
,	O
pos	int
)	O
;	O
}	O
return	O
num_move_reasons	int
;	O
}	O
static	O
struct	O
discard_rule	struct(array(int),*((int,int)->(int)),int,array(char))
discard_rules	array(struct(array(int),*((int,int)->(int)),int,array(char)))
[	O
]	O
=	O
{	O
{	O
{	O
ATTACK_MOVE	int
,	O
ATTACK_MOVE_GOOD_KO	int
,	O
ATTACK_MOVE_BAD_KO	int
,	O
ATTACK_THREAT	O
,	O
DEFEND_MOVE	int
,	O
DEFEND_MOVE_GOOD_KO	int
,	O
DEFEND_MOVE_BAD_KO	int
,	O
DEFEND_THREAT	O
,	O
-	O
1	int
}	O
,	O
owl_move_vs_worm_known	(int,int)->(int)
,	O
TERRITORY_REDUNDANT	int
,	O
"  %1m: 0.0 - (threat of) attack/defense of %1m (owl attack/defense as well)\n"	*(char)
}	O
,	O
{	O
{	O
SEMEAI_MOVE	int
,	O
SEMEAI_THREAT	O
,	O
-	O
1	int
}	O
,	O
owl_move_reason_known	(int,int)->(int)
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - (threat to) win semeai involving %1m (owl move as well)\n"	*(char)
}	O
,	O
{	O
{	O
SEMEAI_MOVE	int
,	O
SEMEAI_THREAT	O
,	O
-	O
1	int
}	O
,	O
tactical_move_vs_whole_dragon_known	(int,int)->(int)
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - (threat to) win semeai involving %1m (tactical move as well)\n"	*(char)
}	O
,	O
{	O
{	O
EITHER_MOVE	int
,	O
-	O
1	int
}	O
,	O
either_worm_attackable	(int,int)->(int)
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - 'attack either' is redundant at %1m (direct att./def. as well)\n"	*(char)
}	O
,	O
{	O
{	O
ALL_MOVE	int
,	O
-	O
1	int
}	O
,	O
one_of_both_attackable	(int,int)->(int)
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - 'defend both' is redundant at %1m (direct att./def. as well)\n"	*(char)
}	O
,	O
{	O
{	O
ATTACK_THREAT	O
,	O
DEFEND_THREAT	O
,	O
-	O
1	int
}	O
,	O
concerns_inessential_worm	(int,int)->(int)
,	O
TERRITORY_REDUNDANT	int
,	O
"  %1m: 0.0 - attack/defense threat of %1m (inessential)\n"	*(char)
}	O
,	O
{	O
{	O
OWL_ATTACK_THREAT	O
,	O
UNCERTAIN_OWL_DEFENSE	int
,	O
-	O
1	int
}	O
,	O
concerns_inessential_dragon	(int,int)->(int)
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - (uncertain) owl attack/defense of %1m (inessential)\n"	*(char)
}	O
,	O
{	O
{	O
ATTACK_MOVE	int
,	O
ATTACK_MOVE_GOOD_KO	int
,	O
ATTACK_MOVE_BAD_KO	int
,	O
DEFEND_MOVE	int
,	O
DEFEND_MOVE_GOOD_KO	int
,	O
DEFEND_MOVE_BAD_KO	int
,	O
-	O
1	int
}	O
,	O
move_is_marked_unsafe	(int,int)->(int)
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - tactical move vs %1m (unsafe move)\n"	*(char)
}	O
,	O
{	O
{	O
OWL_ATTACK_MOVE	int
,	O
OWL_ATTACK_MOVE_GOOD_KO	int
,	O
OWL_ATTACK_MOVE_BAD_KO	int
,	O
OWL_DEFEND_MOVE	int
,	O
OWL_DEFEND_MOVE_GOOD_KO	int
,	O
OWL_DEFEND_MOVE_BAD_KO	int
,	O
-	O
1	int
}	O
,	O
concerns_noncritical_dragon	(int,int)->(int)
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - owl move vs %1m (non-critical)\n"	*(char)
}	O
,	O
{	O
{	O
-	O
1	int
}	O
,	O
NULL	O
,	O
0	int
,	O
""	*(char)
}	O
}	O
;	O
void	O
discard_redundant_move_reasons	(int)->(void)
(	O
int	O
pos	int
)	O
{	O
int	O
k1	int
,	O
k2	int
;	O
int	O
l	int
;	O
for	O
(	O
k1	int
=	O
0	int
;	O
!	O
(	O
discard_rules	array(struct(array(int),*((int,int)->(int)),int,array(char)))
[	O
k1	int
]	O
.	O
reason_type	array(int)
[	O
0	int
]	O
==	O
-	O
1	int
)	O
;	O
k1	int
++	O
)	O
{	O
for	O
(	O
k2	int
=	O
0	int
;	O
!	O
(	O
discard_rules	array(struct(array(int),*((int,int)->(int)),int,array(char)))
[	O
k1	int
]	O
.	O
reason_type	array(int)
[	O
k2	int
]	O
==	O
-	O
1	int
)	O
;	O
k2	int
++	O
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
MAX_REASONS	int
;	O
l	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
l	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
discard_rules	array(struct(array(int),*((int,int)->(int)),int,array(char)))
[	O
k1	int
]	O
.	O
reason_type	array(int)
[	O
k2	int
]	O
)	O
&&	O
(	O
discard_rules	array(struct(array(int),*((int,int)->(int)),int,array(char)))
[	O
k1	int
]	O
.	O
condition	*((int,int)->(int))
(	O
pos	int
,	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
)	O
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
discard_rules	array(struct(array(int),*((int,int)->(int)),int,array(char)))
[	O
k1	int
]	O
.	O
trace_message	*(char)
,	O
pos	int
,	O
get_pos	(int,int)->(int)
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
,	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
)	O
)	O
;	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
|=	O
discard_rules	array(struct(array(int),*((int,int)->(int)),int,array(char)))
[	O
k1	int
]	O
.	O
flags	int
;	O
}	O
}	O
}	O
}	O
}	O
int	O
is_antisuji_move	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ANTISUJI_MOVE	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
scale_randomness	(int,float)->(void)
(	O
int	O
pos	int
,	O
float	O
scaling	float
)	O
{	O
if	O
(	O
scaling	float
>	O
move	*(int)
[	O
pos	int
]	O
.	O
randomness_scaling	float
)	O
move	*(int)
[	O
pos	int
]	O
.	O
randomness_scaling	float
=	O
scaling	float
;	O
}	O
void	O
register_good_attack_threat	(int,int)->(void)
(	O
int	O
move	*(int)
,	O
int	O
target	int
)	O
{	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
move	*(int)
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
target	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
color	int
)	O
,	O
move	*(int)
)	O
;	O
target	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
origin	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_ATTACK_THREATS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
known_good_attack_threats	array(array(int))
[	O
move	*(int)
]	O
[	O
k	int
]	O
==	O
target	int
)	O
break	O
;	O
if	O
(	O
known_good_attack_threats	array(array(int))
[	O
move	*(int)
]	O
[	O
k	int
]	O
==	O
NO_MOVE	O
)	O
{	O
known_good_attack_threats	array(array(int))
[	O
move	*(int)
]	O
[	O
k	int
]	O
=	O
target	int
;	O
break	O
;	O
}	O
}	O
}	O
int	O
is_known_good_attack_threat	(int,int)->(int)
(	O
int	O
move	*(int)
,	O
int	O
target	int
)	O
{	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
move	*(int)
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
target	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
color	int
)	O
,	O
move	*(int)
)	O
;	O
target	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
origin	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_ATTACK_THREATS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
known_good_attack_threats	array(array(int))
[	O
move	*(int)
]	O
[	O
k	int
]	O
==	O
target	int
)	O
return	O
1	int
;	O
if	O
(	O
known_good_attack_threats	array(array(int))
[	O
move	*(int)
]	O
[	O
k	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
register_known_safe_move	(int)->(void)
(	O
int	O
move	*(int)
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
move	*(int)
)	O
;	O
known_safe_moves	array(int)
[	O
move	*(int)
]	O
=	O
1	int
;	O
}	O
int	O
is_known_safe_move	(int)->(int)
(	O
int	O
move	*(int)
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
move	*(int)
)	O
;	O
return	O
known_safe_moves	array(int)
[	O
move	*(int)
]	O
;	O
}	O
