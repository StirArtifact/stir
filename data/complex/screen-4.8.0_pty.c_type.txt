extern	O
int	O
eff_uid	int
;	O
static	O
char	O
PtyName	array(char)
[	O
32	int
]	O
,	O
TtyName	array(char)
[	O
32	int
]	O
;	O
static	O
void	O
initmaster	(int)->(void)
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
int	O
pty_preopen	int
=	O
0	int
;	O
static	O
void	O
initmaster	(int)->(void)
(	O
f	int
)	O
int	O
f	int
;	O
{	O
tcflush	(int,int)->(int)
(	O
f	int
,	O
TCIOFLUSH	int
)	O
;	O
}	O
void	O
InitPTY	(int)->(void)
(	O
f	int
)	O
int	O
f	int
;	O
{	O
if	O
(	O
f	int
<	O
0	int
)	O
return	O
;	O
}	O
int	O
OpenPTY	(*(*(char)))->(int)
(	O
ttyn	*(*(char))
)	O
char	O
*	O
*	O
ttyn	*(*(char))
;	O
{	O
register	O
int	O
f	int
;	O
char	O
*	O
m	union(struct(int,int,int,int,int,array(char),array(char),array(char)),struct(array(char),int,int,int,int,array(char),int,int,array(char),int,int),struct(array(char),int),struct(array(char),int,array(char),int,array(char),array(char)),array(char))
,	O
*	O
ptsname	(int)->(*(char))
(	O
)	O
;	O
int	O
unlockpt	(int)->(int)
__P	O
(	O
(	O
int	O
)	O
)	O
,	O
grantpt	(int)->(int)
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
int	O
getpt	()->(int)
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
sigret_t	void
(	O
*	O
sigcld	*((int)->(void))
)	O
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
PtyName	array(char)
,	O
"/dev/ptmx"	*(char)
)	O
;	O
if	O
(	O
(	O
f	int
=	O
getpt	()->(int)
(	O
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
sigcld	*((int)->(void))
=	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
if	O
(	O
(	O
m	union(struct(int,int,int,int,int,array(char),array(char),array(char)),struct(array(char),int,int,int,int,array(char),int,int,array(char),int,int),struct(array(char),int),struct(array(char),int,array(char),int,array(char),array(char)),array(char))
=	O
ptsname	(int)->(*(char))
(	O
f	int
)	O
)	O
==	O
NULL	O
||	O
grantpt	(int)->(int)
(	O
f	int
)	O
||	O
unlockpt	(int)->(int)
(	O
f	int
)	O
)	O
{	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
sigcld	*((int)->(void))
)	O
;	O
close	*((*(void))->(int))
(	O
f	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
sigcld	*((int)->(void))
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
m	union(struct(int,int,int,int,int,array(char),array(char),array(char)),struct(array(char),int,int,int,int,array(char),int,int,array(char),int,int),struct(array(char),int),struct(array(char),int,array(char),int,array(char),array(char)),array(char))
)	O
<	O
sizeof	O
(	O
TtyName	array(char)
)	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
TtyName	array(char)
,	O
m	union(struct(int,int,int,int,int,array(char),array(char),array(char)),struct(array(char),int,int,int,int,array(char),int,int,array(char),int,int),struct(array(char),int),struct(array(char),int,array(char),int,array(char),array(char)),array(char))
)	O
;	O
else	O
{	O
close	*((*(void))->(int))
(	O
f	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
initmaster	(int)->(void)
(	O
f	int
)	O
;	O
*	O
ttyn	*(*(char))
=	O
TtyName	array(char)
;	O
return	O
f	int
;	O
}	O
char	O
*	O
GetPtsPathOrSymlink	(int)->(*(char))
(	O
int	O
fd	int
)	O
{	O
int	O
ret	int
;	O
char	O
*	O
tty_name	*(char)
;	O
static	O
char	O
tty_symlink	array(char)
[	O
MAX_PTS_SYMLINK	O
]	O
;	O
errno	O
=	O
0	int
;	O
tty_name	*(char)
=	O
ttyname	(int)->(*(char))
(	O
fd	int
)	O
;	O
if	O
(	O
!	O
tty_name	*(char)
&&	O
errno	O
==	O
ENODEV	int
)	O
{	O
ret	int
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
tty_symlink	array(char)
,	O
MAX_PTS_SYMLINK	O
,	O
"/proc/self/fd/%d"	*(char)
,	O
fd	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
||	O
ret	int
>=	O
MAX_PTS_SYMLINK	O
)	O
return	O
NULL	O
;	O
errno	O
=	O
ENODEV	int
;	O
return	O
tty_symlink	array(char)
;	O
}	O
return	O
tty_name	*(char)
;	O
}	O
