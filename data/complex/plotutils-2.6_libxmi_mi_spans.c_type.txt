static	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
miNewSpanGroup	(int)->(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
(	O
miPixel	int
pixel	int
)	O
;	O
static	O
int	O
miUniquifySpansX	(*(struct(int,*(struct(int,int)),*(int))),*(struct(int,int)),*(int))->(int)
(	O
const	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
spans	*(struct(int,*(struct(int,int)),*(int)))
,	O
miPoint	struct(int,int)
*	O
newPoints	*(struct(int,int))
,	O
unsigned	O
int	O
*	O
newWidths	*(int)
)	O
;	O
static	O
void	O
miAddSpansToSpanGroup	(*(struct(int,*(struct(int,int)),*(int))),*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))->(void)
(	O
const	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
spans	*(struct(int,*(struct(int,int)),*(int)))
,	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
)	O
;	O
static	O
void	O
miDeleteSpanGroup	(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))->(void)
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
)	O
;	O
static	O
void	O
miQuickSortSpansX	(*(struct(int,int)),*(int),int)->(void)
(	O
miPoint	struct(int,int)
*	O
points	*(struct(int,int))
,	O
unsigned	O
int	O
*	O
widths	*(int)
,	O
int	O
numSpans	int
)	O
;	O
static	O
void	O
miSubtractSpans	(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)),*(struct(int,*(struct(int,int)),*(int))))->(void)
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
,	O
const	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
sub	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
static	O
void	O
miUniquifySpanGroup	(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))->(void)
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
)	O
;	O
miPaintedSet	struct
*	O
miNewPaintedSet	()->(*(struct))
(	O
void	O
)	O
{	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
;	O
paintedSet	*(struct)
=	O
(	O
miPaintedSet	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPaintedSet	struct
)	O
)	O
;	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
=	O
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
*	O
)	O
NULL	O
;	O
paintedSet	*(struct)
->	O
size	int
=	O
0	int
;	O
paintedSet	*(struct)
->	O
ngroups	int
=	O
0	int
;	O
return	O
paintedSet	*(struct)
;	O
}	O
void	O
miAddSpansToPaintedSet	O
(	O
const	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
spans	*(struct(int,*(struct(int,int)),*(int)))
,	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
)	O
{	O
bool	enum(int,int)
found	enum(int,int)
=	O
false	int
;	O
int	O
i	int
;	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
;	O
if	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
==	O
0	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
paintedSet	*(struct)
->	O
ngroups	int
;	O
i	int
++	O
)	O
{	O
miPixel	int
stored_pixel	int
;	O
stored_pixel	int
=	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
[	O
i	int
]	O
->	O
pixel	int
;	O
if	O
(	O
MI_SAME_PIXEL	O
(	O
pixel	int
,	O
stored_pixel	int
)	O
)	O
{	O
found	enum(int,int)
=	O
true	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
found	enum(int,int)
)	O
{	O
if	O
(	O
paintedSet	*(struct)
->	O
ngroups	int
==	O
paintedSet	*(struct)
->	O
size	int
)	O
{	O
int	O
old_size	int
=	O
paintedSet	*(struct)
->	O
size	int
;	O
int	O
new_size	int
=	O
2	int
*	O
(	O
old_size	int
+	O
8	int
)	O
;	O
if	O
(	O
old_size	int
==	O
0	int
)	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
=	O
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
*	O
)	O
mi_xmalloc	O
(	O
new_size	int
*	O
sizeof	O
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
)	O
)	O
;	O
else	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
=	O
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
*	O
)	O
mi_xrealloc	O
(	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
,	O
new_size	int
*	O
sizeof	O
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
)	O
)	O
;	O
paintedSet	*(struct)
->	O
size	int
=	O
new_size	int
;	O
}	O
i	int
=	O
paintedSet	*(struct)
->	O
ngroups	int
;	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
[	O
i	int
]	O
=	O
miNewSpanGroup	(int)->(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
(	O
pixel	int
)	O
;	O
paintedSet	*(struct)
->	O
ngroups	int
++	O
;	O
}	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
=	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
[	O
i	int
]	O
;	O
miAddSpansToSpanGroup	(*(struct(int,*(struct(int,int)),*(int))),*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))->(void)
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
,	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
paintedSet	*(struct)
->	O
ngroups	int
;	O
i	int
++	O
)	O
{	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
otherGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
;	O
otherGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
=	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
[	O
i	int
]	O
;	O
if	O
(	O
otherGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
==	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
)	O
continue	O
;	O
miSubtractSpans	(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)),*(struct(int,*(struct(int,int)),*(int))))->(void)
(	O
otherGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
,	O
spans	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
}	O
}	O
void	O
miClearPaintedSet	(*(struct))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
)	O
{	O
int	O
i	int
;	O
if	O
(	O
paintedSet	*(struct)
==	O
(	O
miPaintedSet	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
paintedSet	*(struct)
->	O
ngroups	int
;	O
i	int
++	O
)	O
miDeleteSpanGroup	(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))->(void)
(	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
paintedSet	*(struct)
->	O
size	int
>	O
0	int
)	O
free	(*(void))->(void)
(	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
)	O
;	O
paintedSet	*(struct)
->	O
size	int
=	O
0	int
;	O
paintedSet	*(struct)
->	O
ngroups	int
=	O
0	int
;	O
}	O
void	O
miDeletePaintedSet	(*(struct))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
)	O
{	O
int	O
i	int
;	O
if	O
(	O
paintedSet	*(struct)
==	O
(	O
miPaintedSet	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
paintedSet	*(struct)
->	O
ngroups	int
;	O
i	int
++	O
)	O
miDeleteSpanGroup	(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))->(void)
(	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
paintedSet	*(struct)
->	O
size	int
>	O
0	int
)	O
free	(*(void))->(void)
(	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
)	O
;	O
free	(*(void))->(void)
(	O
paintedSet	*(struct)
)	O
;	O
}	O
void	O
miUniquifyPaintedSet	O
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
)	O
{	O
int	O
i	int
;	O
if	O
(	O
paintedSet	*(struct)
==	O
(	O
miPaintedSet	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
paintedSet	*(struct)
->	O
ngroups	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
[	O
i	int
]	O
->	O
count	int
>	O
0	int
)	O
{	O
miUniquifySpanGroup	(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))->(void)
(	O
paintedSet	*(struct)
->	O
groups	*(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
[	O
i	int
]	O
)	O
;	O
}	O
}	O
}	O
static	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
miNewSpanGroup	(int)->(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))
(	O
miPixel	int
pixel	int
)	O
{	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
=	O
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
)	O
)	O
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
pixel	int
=	O
pixel	int
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
size	int
=	O
0	int
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
=	O
0	int
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
=	O
(	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
)	O
NULL	O
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymin	int
=	O
INT_MAX	O
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymax	int
=	O
INT_MIN	O
;	O
return	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
;	O
}	O
static	O
void	O
miAddSpansToSpanGroup	(*(struct(int,*(struct(int,int)),*(int))),*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))->(void)
(	O
const	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
spans	*(struct(int,*(struct(int,int)),*(int)))
,	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
)	O
{	O
int	O
ymin	int
,	O
ymax	int
;	O
if	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
size	int
==	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
)	O
{	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
size	int
=	O
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
size	int
+	O
8	int
)	O
*	O
2	int
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
=	O
(	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
)	O
mi_xrealloc	O
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
,	O
sizeof	O
(	O
Spans	struct(int,*(struct(int,int)),*(int))
)	O
*	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
size	int
)	O
;	O
}	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
[	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
]	O
=	O
*	O
spans	*(struct(int,*(struct(int,int)),*(int)))
;	O
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
)	O
++	O
;	O
ymin	int
=	O
YMIN	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
if	O
(	O
ymin	int
<	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymin	int
)	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymin	int
=	O
ymin	int
;	O
ymax	int
=	O
YMAX	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
if	O
(	O
ymax	int
>	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymax	int
)	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymax	int
=	O
ymax	int
;	O
}	O
static	O
void	O
miDeleteSpanGroup	(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))->(void)
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
)	O
{	O
int	O
i	int
;	O
if	O
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
==	O
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
)	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
;	O
i	int
++	O
)	O
{	O
free	(*(void))->(void)
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
points	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
widths	*(int)
)	O
;	O
}	O
if	O
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
)	O
free	(*(void))->(void)
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
free	(*(void))->(void)
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
)	O
;	O
}	O
static	O
void	O
miSubtractSpans	(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)),*(struct(int,*(struct(int,int)),*(int))))->(void)
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
,	O
const	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
sub	*(struct(int,*(struct(int,int)),*(int)))
)	O
{	O
int	O
i	int
,	O
subCount	int
,	O
spansCount	int
;	O
int	O
ymin	int
,	O
ymax	int
,	O
xmin	int
,	O
xmax	int
;	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
spans	*(struct(int,*(struct(int,int)),*(int)))
;	O
miPoint	struct(int,int)
*	O
subPt	*(struct(int,int))
,	O
*	O
spansPt	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
subWid	*(int)
,	O
*	O
spansWid	*(int)
;	O
int	O
extra	int
;	O
bool	enum(int,int)
gross_change	enum(int,int)
=	O
false	int
;	O
if	O
(	O
sub	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
==	O
0	int
)	O
return	O
;	O
ymin	int
=	O
YMIN	O
(	O
sub	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
ymax	int
=	O
YMAX	O
(	O
sub	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
spans	*(struct(int,*(struct(int,int)),*(int)))
=	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
;	O
for	O
(	O
i	int
=	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
,	O
spans	*(struct(int,*(struct(int,int)),*(int)))
++	O
)	O
{	O
if	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
YMIN	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
)	O
<=	O
ymax	int
&&	O
ymin	int
<=	O
YMAX	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
)	O
)	O
{	O
subCount	int
=	O
sub	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
;	O
subPt	*(struct(int,int))
=	O
sub	*(struct(int,*(struct(int,int)),*(int)))
->	O
points	*(struct(int,int))
;	O
subWid	*(int)
=	O
sub	*(struct(int,*(struct(int,int)),*(int)))
->	O
widths	*(int)
;	O
spansCount	int
=	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
;	O
spansPt	*(struct(int,int))
=	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
points	*(struct(int,int))
;	O
spansWid	*(int)
=	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
widths	*(int)
;	O
extra	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
spansCount	int
&&	O
spansPt	*(struct(int,int))
->	O
y	int
<	O
subPt	*(struct(int,int))
->	O
y	int
)	O
{	O
spansPt	*(struct(int,int))
++	O
;	O
spansWid	*(int)
++	O
;	O
spansCount	int
--	O
;	O
}	O
if	O
(	O
!	O
spansCount	int
)	O
break	O
;	O
while	O
(	O
subCount	int
&&	O
subPt	*(struct(int,int))
->	O
y	int
<	O
spansPt	*(struct(int,int))
->	O
y	int
)	O
{	O
subPt	*(struct(int,int))
++	O
;	O
subWid	*(int)
++	O
;	O
subCount	int
--	O
;	O
}	O
if	O
(	O
!	O
subCount	int
)	O
break	O
;	O
if	O
(	O
subPt	*(struct(int,int))
->	O
y	int
==	O
spansPt	*(struct(int,int))
->	O
y	int
)	O
{	O
xmin	int
=	O
subPt	*(struct(int,int))
->	O
x	int
;	O
xmax	int
=	O
xmin	int
+	O
(	O
int	O
)	O
(	O
*	O
subWid	*(int)
)	O
;	O
if	O
(	O
xmin	int
>=	O
spansPt	*(struct(int,int))
->	O
x	int
+	O
(	O
int	O
)	O
(	O
*	O
spansWid	*(int)
)	O
||	O
spansPt	*(struct(int,int))
->	O
x	int
>=	O
xmax	int
)	O
{	O
;	O
}	O
else	O
if	O
(	O
xmin	int
<=	O
spansPt	*(struct(int,int))
->	O
x	int
)	O
{	O
if	O
(	O
xmax	int
>=	O
spansPt	*(struct(int,int))
->	O
x	int
+	O
(	O
int	O
)	O
(	O
*	O
spansWid	*(int)
)	O
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
spansPt	*(struct(int,int))
,	O
spansPt	*(struct(int,int))
+	O
1	int
,	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
(	O
spansCount	int
-	O
1	int
)	O
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
spansWid	*(int)
,	O
spansWid	*(int)
+	O
1	int
,	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
(	O
spansCount	int
-	O
1	int
)	O
)	O
;	O
spansPt	*(struct(int,int))
--	O
;	O
spansWid	*(int)
--	O
;	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
--	O
;	O
extra	int
++	O
;	O
gross_change	enum(int,int)
=	O
true	int
;	O
}	O
else	O
{	O
*	O
spansWid	*(int)
=	O
*	O
spansWid	*(int)
-	O
(	O
unsigned	O
int	O
)	O
(	O
xmax	int
-	O
spansPt	*(struct(int,int))
->	O
x	int
)	O
;	O
spansPt	*(struct(int,int))
->	O
x	int
=	O
xmax	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
xmax	int
>=	O
spansPt	*(struct(int,int))
->	O
x	int
+	O
(	O
int	O
)	O
*	O
spansWid	*(int)
)	O
*	O
spansWid	*(int)
=	O
(	O
unsigned	O
int	O
)	O
(	O
xmin	int
-	O
spansPt	*(struct(int,int))
->	O
x	int
)	O
;	O
else	O
{	O
if	O
(	O
extra	int
==	O
0	int
)	O
{	O
miPoint	struct(int,int)
*	O
newPt	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
newwid	*(int)
;	O
newPt	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xrealloc	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
points	*(struct(int,int))
,	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
+	O
EXTRA	int
)	O
*	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
)	O
;	O
spansPt	*(struct(int,int))
=	O
newPt	*(struct(int,int))
+	O
(	O
spansPt	*(struct(int,int))
-	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
points	*(struct(int,int))
)	O
;	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
points	*(struct(int,int))
=	O
newPt	*(struct(int,int))
;	O
newwid	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xrealloc	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
widths	*(int)
,	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
+	O
EXTRA	int
)	O
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
spansWid	*(int)
=	O
newwid	*(int)
+	O
(	O
spansWid	*(int)
-	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
widths	*(int)
)	O
;	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
widths	*(int)
=	O
newwid	*(int)
;	O
extra	int
=	O
EXTRA	int
;	O
}	O
memmove	(*(void),*(void),long)->(*(void))
(	O
spansPt	*(struct(int,int))
+	O
1	int
,	O
spansPt	*(struct(int,int))
,	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
spansCount	int
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
spansWid	*(int)
+	O
1	int
,	O
spansWid	*(int)
,	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
spansCount	int
)	O
;	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
++	O
;	O
extra	int
--	O
;	O
*	O
spansWid	*(int)
=	O
(	O
unsigned	O
int	O
)	O
(	O
xmin	int
-	O
spansPt	*(struct(int,int))
->	O
x	int
)	O
;	O
spansWid	*(int)
++	O
;	O
spansPt	*(struct(int,int))
++	O
;	O
*	O
spansWid	*(int)
=	O
*	O
spansWid	*(int)
-	O
(	O
unsigned	O
int	O
)	O
(	O
xmax	int
-	O
spansPt	*(struct(int,int))
->	O
x	int
)	O
;	O
spansPt	*(struct(int,int))
->	O
x	int
=	O
xmax	int
;	O
}	O
}	O
}	O
spansPt	*(struct(int,int))
++	O
;	O
spansWid	*(int)
++	O
;	O
spansCount	int
--	O
;	O
}	O
}	O
}	O
if	O
(	O
gross_change	enum(int,int)
)	O
{	O
ymax	int
=	O
INT_MIN	O
;	O
ymin	int
=	O
INT_MAX	O
;	O
spans	*(struct(int,*(struct(int,int)),*(int)))
=	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
;	O
for	O
(	O
i	int
=	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
,	O
spans	*(struct(int,*(struct(int,int)),*(int)))
++	O
)	O
{	O
int	O
ymin_spans	int
,	O
ymax_spans	int
;	O
if	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
==	O
0	int
)	O
continue	O
;	O
ymin_spans	int
=	O
YMIN	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
ymax_spans	int
=	O
YMAX	O
(	O
spans	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
if	O
(	O
ymin_spans	int
<	O
ymin	int
)	O
ymin	int
=	O
ymin_spans	int
;	O
if	O
(	O
ymax_spans	int
>	O
ymax	int
)	O
ymax	int
=	O
ymax_spans	int
;	O
}	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymin	int
=	O
ymin	int
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymax	int
=	O
ymax	int
;	O
}	O
}	O
static	O
void	O
miUniquifySpanGroup	(*(struct(int,*(struct(int,*`,*`)),int,int,int,int)))->(void)
(	O
SpanGroup	struct(int,*(struct(int,*(struct(int,int)),*(int))),int,int,int,int)
*	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
)	O
{	O
int	O
i	int
;	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
spans	*(struct(int,*(struct(int,int)),*(int)))
;	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
;	O
int	O
*	O
ysizes	*(int)
;	O
int	O
ymin	int
,	O
ylength	int
;	O
miPoint	struct(int,int)
*	O
points	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
widths	*(int)
;	O
int	O
count	int
;	O
if	O
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymin	int
>	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymax	int
)	O
{	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
=	O
0	int
;	O
return	O
;	O
}	O
ymin	int
=	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymin	int
;	O
ylength	int
=	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
ymax	int
-	O
ymin	int
+	O
1	int
;	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
=	O
(	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
)	O
mi_xmalloc	O
(	O
ylength	int
*	O
sizeof	O
(	O
Spans	struct(int,*(struct(int,int)),*(int))
)	O
)	O
;	O
ysizes	*(int)
=	O
(	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
ylength	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ylength	int
;	O
i	int
++	O
)	O
{	O
ysizes	*(int)
[	O
i	int
]	O
=	O
0	int
;	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
count	int
=	O
0	int
;	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
points	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
NULL	O
;	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
widths	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
NULL	O
;	O
}	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
spans	*(struct(int,*(struct(int,int)),*(int)))
=	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
;	O
i	int
<	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
;	O
i	int
++	O
,	O
spans	*(struct(int,*(struct(int,int)),*(int)))
++	O
)	O
{	O
int	O
j	int
,	O
index	(*(char),int)->(*(char))
;	O
for	O
(	O
j	int
=	O
0	int
,	O
points	*(struct(int,int))
=	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
points	*(struct(int,int))
,	O
widths	*(int)
=	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
widths	*(int)
;	O
j	int
<	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
;	O
j	int
++	O
,	O
points	*(struct(int,int))
++	O
,	O
widths	*(int)
++	O
)	O
{	O
index	(*(char),int)->(*(char))
=	O
points	*(struct(int,int))
->	O
y	int
-	O
ymin	int
;	O
if	O
(	O
index	(*(char),int)->(*(char))
>=	O
0	int
&&	O
index	(*(char),int)->(*(char))
<	O
ylength	int
)	O
{	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
newspans	*(struct(int,*(struct(int,int)),*(int)))
=	O
&	O
(	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
index	(*(char),int)->(*(char))
]	O
)	O
;	O
if	O
(	O
newspans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
==	O
ysizes	*(int)
[	O
index	(*(char),int)->(*(char))
]	O
)	O
{	O
ysizes	*(int)
[	O
index	(*(char),int)->(*(char))
]	O
=	O
(	O
ysizes	*(int)
[	O
index	(*(char),int)->(*(char))
]	O
+	O
8	int
)	O
*	O
2	int
;	O
newspans	*(struct(int,*(struct(int,int)),*(int)))
->	O
points	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xrealloc	O
(	O
newspans	*(struct(int,*(struct(int,int)),*(int)))
->	O
points	*(struct(int,int))
,	O
ysizes	*(int)
[	O
index	(*(char),int)->(*(char))
]	O
*	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
)	O
;	O
newspans	*(struct(int,*(struct(int,int)),*(int)))
->	O
widths	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xrealloc	O
(	O
newspans	*(struct(int,*(struct(int,int)),*(int)))
->	O
widths	*(int)
,	O
ysizes	*(int)
[	O
index	(*(char),int)->(*(char))
]	O
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
}	O
newspans	*(struct(int,*(struct(int,int)),*(int)))
->	O
points	*(struct(int,int))
[	O
newspans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
]	O
=	O
*	O
points	*(struct(int,int))
;	O
newspans	*(struct(int,*(struct(int,int)),*(int)))
->	O
widths	*(int)
[	O
newspans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
]	O
=	O
*	O
widths	*(int)
;	O
(	O
newspans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
)	O
++	O
;	O
}	O
}	O
count	int
+=	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
;	O
}	O
free	(*(void))->(void)
(	O
ysizes	*(int)
)	O
;	O
points	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
count	int
*	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
)	O
;	O
widths	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
count	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ylength	int
;	O
i	int
++	O
)	O
{	O
int	O
ycount	int
=	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
count	int
;	O
if	O
(	O
ycount	int
>	O
0	int
)	O
{	O
if	O
(	O
ycount	int
>	O
1	int
)	O
{	O
miQuickSortSpansX	(*(struct(int,int)),*(int),int)->(void)
(	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
points	*(struct(int,int))
,	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
widths	*(int)
,	O
ycount	int
)	O
;	O
count	int
+=	O
miUniquifySpansX	(*(struct(int,*(struct(int,int)),*(int))),*(struct(int,int)),*(int))->(int)
(	O
&	O
(	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
)	O
,	O
&	O
(	O
points	*(struct(int,int))
[	O
count	int
]	O
)	O
,	O
&	O
(	O
widths	*(int)
[	O
count	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
points	*(struct(int,int))
[	O
count	int
]	O
=	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
points	*(struct(int,int))
[	O
0	int
]	O
;	O
widths	*(int)
[	O
count	int
]	O
=	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
widths	*(int)
[	O
0	int
]	O
;	O
count	int
++	O
;	O
}	O
free	(*(void))->(void)
(	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
points	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
widths	*(int)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
yspans	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
;	O
i	int
++	O
)	O
{	O
free	(*(void))->(void)
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
points	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
[	O
i	int
]	O
.	O
widths	*(int)
)	O
;	O
}	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
count	int
=	O
1	int
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
[	O
0	int
]	O
.	O
points	*(struct(int,int))
=	O
points	*(struct(int,int))
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
[	O
0	int
]	O
.	O
widths	*(int)
=	O
widths	*(int)
;	O
spanGroup	*(struct(int,*(struct(int,*(struct`),*(int))),int,int,int,int))
->	O
group	*(struct(int,*(struct(int,int)),*(int)))
[	O
0	int
]	O
.	O
count	int
=	O
count	int
;	O
}	O
static	O
void	O
miQuickSortSpansX	(*(struct(int,int)),*(int),int)->(void)
(	O
miPoint	struct(int,int)
*	O
points	*(struct(int,int))
,	O
unsigned	O
int	O
*	O
widths	*(int)
,	O
int	O
numSpans	int
)	O
{	O
int	O
x	int
;	O
int	O
i	int
,	O
j	int
,	O
m	int
;	O
miPoint	struct(int,int)
*	O
r	*(struct(int,int))
;	O
do	O
{	O
if	O
(	O
numSpans	int
<	O
9	int
)	O
{	O
int	O
xprev	int
;	O
xprev	int
=	O
points	*(struct(int,int))
[	O
0	int
]	O
.	O
x	int
;	O
i	int
=	O
1	int
;	O
do	O
{	O
x	int
=	O
points	*(struct(int,int))
[	O
i	int
]	O
.	O
x	int
;	O
if	O
(	O
xprev	int
>	O
x	int
)	O
{	O
miPoint	struct(int,int)
tpt	struct(int,int)
;	O
unsigned	O
int	O
tw	int
;	O
int	O
k	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
x	int
>=	O
points	*(struct(int,int))
[	O
j	int
]	O
.	O
x	int
;	O
j	int
++	O
)	O
{	O
}	O
tpt	struct(int,int)
=	O
points	*(struct(int,int))
[	O
i	int
]	O
;	O
tw	int
=	O
widths	*(int)
[	O
i	int
]	O
;	O
for	O
(	O
k	int
=	O
i	int
;	O
k	int
!=	O
j	int
;	O
k	int
--	O
)	O
{	O
points	*(struct(int,int))
[	O
k	int
]	O
=	O
points	*(struct(int,int))
[	O
k	int
-	O
1	int
]	O
;	O
widths	*(int)
[	O
k	int
]	O
=	O
widths	*(int)
[	O
k	int
-	O
1	int
]	O
;	O
}	O
points	*(struct(int,int))
[	O
j	int
]	O
=	O
tpt	struct(int,int)
;	O
widths	*(int)
[	O
j	int
]	O
=	O
tw	int
;	O
x	int
=	O
points	*(struct(int,int))
[	O
i	int
]	O
.	O
x	int
;	O
}	O
xprev	int
=	O
x	int
;	O
i	int
++	O
;	O
}	O
while	O
(	O
i	int
!=	O
numSpans	int
)	O
;	O
return	O
;	O
}	O
m	int
=	O
numSpans	int
/	O
2	int
;	O
if	O
(	O
points	*(struct(int,int))
[	O
m	int
]	O
.	O
x	int
>	O
points	*(struct(int,int))
[	O
0	int
]	O
.	O
x	int
)	O
ExchangeSpans	O
(	O
m	int
,	O
0	int
)	O
;	O
if	O
(	O
points	*(struct(int,int))
[	O
m	int
]	O
.	O
x	int
>	O
points	*(struct(int,int))
[	O
numSpans	int
-	O
1	int
]	O
.	O
x	int
)	O
ExchangeSpans	O
(	O
m	int
,	O
numSpans	int
-	O
1	int
)	O
;	O
if	O
(	O
points	*(struct(int,int))
[	O
m	int
]	O
.	O
x	int
>	O
points	*(struct(int,int))
[	O
0	int
]	O
.	O
x	int
)	O
ExchangeSpans	O
(	O
m	int
,	O
0	int
)	O
;	O
x	int
=	O
points	*(struct(int,int))
[	O
0	int
]	O
.	O
x	int
;	O
i	int
=	O
0	int
;	O
j	int
=	O
numSpans	int
;	O
do	O
{	O
r	*(struct(int,int))
=	O
&	O
(	O
points	*(struct(int,int))
[	O
i	int
]	O
)	O
;	O
do	O
{	O
r	*(struct(int,int))
++	O
;	O
i	int
++	O
;	O
}	O
while	O
(	O
i	int
!=	O
numSpans	int
&&	O
r	*(struct(int,int))
->	O
x	int
<	O
x	int
)	O
;	O
r	*(struct(int,int))
=	O
&	O
(	O
points	*(struct(int,int))
[	O
j	int
]	O
)	O
;	O
do	O
{	O
r	*(struct(int,int))
--	O
;	O
j	int
--	O
;	O
}	O
while	O
(	O
x	int
<	O
r	*(struct(int,int))
->	O
x	int
)	O
;	O
if	O
(	O
i	int
<	O
j	int
)	O
ExchangeSpans	O
(	O
i	int
,	O
j	int
)	O
;	O
}	O
while	O
(	O
i	int
<	O
j	int
)	O
;	O
ExchangeSpans	O
(	O
0	int
,	O
j	int
)	O
;	O
if	O
(	O
numSpans	int
-	O
j	int
-	O
1	int
>	O
1	int
)	O
miQuickSortSpansX	(*(struct(int,int)),*(int),int)->(void)
(	O
&	O
points	*(struct(int,int))
[	O
j	int
+	O
1	int
]	O
,	O
&	O
widths	*(int)
[	O
j	int
+	O
1	int
]	O
,	O
numSpans	int
-	O
j	int
-	O
1	int
)	O
;	O
numSpans	int
=	O
j	int
;	O
}	O
while	O
(	O
numSpans	int
>	O
1	int
)	O
;	O
}	O
void	O
miQuickSortSpansY	O
(	O
miPoint	struct(int,int)
*	O
points	*(struct(int,int))
,	O
unsigned	O
int	O
*	O
widths	*(int)
,	O
int	O
numSpans	int
)	O
{	O
int	O
y	int
;	O
int	O
i	int
,	O
j	int
,	O
m	int
;	O
miPoint	struct(int,int)
*	O
r	*(struct(int,int))
;	O
if	O
(	O
numSpans	int
<=	O
1	int
)	O
return	O
;	O
do	O
{	O
if	O
(	O
numSpans	int
<	O
9	int
)	O
{	O
int	O
yprev	int
;	O
yprev	int
=	O
points	*(struct(int,int))
[	O
0	int
]	O
.	O
y	int
;	O
i	int
=	O
1	int
;	O
do	O
{	O
y	int
=	O
points	*(struct(int,int))
[	O
i	int
]	O
.	O
y	int
;	O
if	O
(	O
yprev	int
>	O
y	int
)	O
{	O
miPoint	struct(int,int)
tpt	struct(int,int)
;	O
unsigned	O
int	O
tw	int
;	O
int	O
k	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
y	int
>=	O
points	*(struct(int,int))
[	O
j	int
]	O
.	O
y	int
;	O
j	int
++	O
)	O
{	O
}	O
tpt	struct(int,int)
=	O
points	*(struct(int,int))
[	O
i	int
]	O
;	O
tw	int
=	O
widths	*(int)
[	O
i	int
]	O
;	O
for	O
(	O
k	int
=	O
i	int
;	O
k	int
!=	O
j	int
;	O
k	int
--	O
)	O
{	O
points	*(struct(int,int))
[	O
k	int
]	O
=	O
points	*(struct(int,int))
[	O
k	int
-	O
1	int
]	O
;	O
widths	*(int)
[	O
k	int
]	O
=	O
widths	*(int)
[	O
k	int
-	O
1	int
]	O
;	O
}	O
points	*(struct(int,int))
[	O
j	int
]	O
=	O
tpt	struct(int,int)
;	O
widths	*(int)
[	O
j	int
]	O
=	O
tw	int
;	O
y	int
=	O
points	*(struct(int,int))
[	O
i	int
]	O
.	O
y	int
;	O
}	O
yprev	int
=	O
y	int
;	O
i	int
++	O
;	O
}	O
while	O
(	O
i	int
!=	O
numSpans	int
)	O
;	O
return	O
;	O
}	O
m	int
=	O
numSpans	int
/	O
2	int
;	O
if	O
(	O
points	*(struct(int,int))
[	O
m	int
]	O
.	O
y	int
>	O
points	*(struct(int,int))
[	O
0	int
]	O
.	O
y	int
)	O
ExchangeSpans	O
(	O
m	int
,	O
0	int
)	O
;	O
if	O
(	O
points	*(struct(int,int))
[	O
m	int
]	O
.	O
y	int
>	O
points	*(struct(int,int))
[	O
numSpans	int
-	O
1	int
]	O
.	O
y	int
)	O
ExchangeSpans	O
(	O
m	int
,	O
numSpans	int
-	O
1	int
)	O
;	O
if	O
(	O
points	*(struct(int,int))
[	O
m	int
]	O
.	O
y	int
>	O
points	*(struct(int,int))
[	O
0	int
]	O
.	O
y	int
)	O
ExchangeSpans	O
(	O
m	int
,	O
0	int
)	O
;	O
y	int
=	O
points	*(struct(int,int))
[	O
0	int
]	O
.	O
y	int
;	O
i	int
=	O
0	int
;	O
j	int
=	O
numSpans	int
;	O
do	O
{	O
r	*(struct(int,int))
=	O
&	O
(	O
points	*(struct(int,int))
[	O
i	int
]	O
)	O
;	O
do	O
{	O
r	*(struct(int,int))
++	O
;	O
i	int
++	O
;	O
}	O
while	O
(	O
i	int
!=	O
numSpans	int
&&	O
r	*(struct(int,int))
->	O
y	int
<	O
y	int
)	O
;	O
r	*(struct(int,int))
=	O
&	O
(	O
points	*(struct(int,int))
[	O
j	int
]	O
)	O
;	O
do	O
{	O
r	*(struct(int,int))
--	O
;	O
j	int
--	O
;	O
}	O
while	O
(	O
y	int
<	O
r	*(struct(int,int))
->	O
y	int
)	O
;	O
if	O
(	O
i	int
<	O
j	int
)	O
ExchangeSpans	O
(	O
i	int
,	O
j	int
)	O
;	O
}	O
while	O
(	O
i	int
<	O
j	int
)	O
;	O
ExchangeSpans	O
(	O
0	int
,	O
j	int
)	O
;	O
if	O
(	O
numSpans	int
-	O
j	int
-	O
1	int
>	O
1	int
)	O
miQuickSortSpansY	O
(	O
&	O
points	*(struct(int,int))
[	O
j	int
+	O
1	int
]	O
,	O
&	O
widths	*(int)
[	O
j	int
+	O
1	int
]	O
,	O
numSpans	int
-	O
j	int
-	O
1	int
)	O
;	O
numSpans	int
=	O
j	int
;	O
}	O
while	O
(	O
numSpans	int
>	O
1	int
)	O
;	O
}	O
static	O
int	O
miUniquifySpansX	(*(struct(int,*(struct(int,int)),*(int))),*(struct(int,int)),*(int))->(int)
(	O
const	O
Spans	struct(int,*(struct(int,int)),*(int))
*	O
spans	*(struct(int,*(struct(int,int)),*(int)))
,	O
miPoint	struct(int,int)
*	O
newPoints	*(struct(int,int))
,	O
unsigned	O
int	O
*	O
newWidths	*(int)
)	O
{	O
int	O
newx1	int
,	O
newx2	int
,	O
oldpt	int
,	O
i	int
,	O
y	int
;	O
miPoint	struct(int,int)
*	O
oldPoints	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
oldWidths	*(int)
,	O
*	O
startNewWidths	*(int)
;	O
startNewWidths	*(int)
=	O
newWidths	*(int)
;	O
oldPoints	*(struct(int,int))
=	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
points	*(struct(int,int))
;	O
oldWidths	*(int)
=	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
widths	*(int)
;	O
y	int
=	O
oldPoints	*(struct(int,int))
->	O
y	int
;	O
newx1	int
=	O
oldPoints	*(struct(int,int))
->	O
x	int
;	O
newx2	int
=	O
newx1	int
+	O
(	O
int	O
)	O
(	O
*	O
oldWidths	*(int)
)	O
;	O
for	O
(	O
i	int
=	O
spans	*(struct(int,*(struct(int,int)),*(int)))
->	O
count	int
-	O
1	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
{	O
oldPoints	*(struct(int,int))
++	O
;	O
oldWidths	*(int)
++	O
;	O
oldpt	int
=	O
oldPoints	*(struct(int,int))
->	O
x	int
;	O
if	O
(	O
oldpt	int
>	O
newx2	int
)	O
{	O
newPoints	*(struct(int,int))
->	O
x	int
=	O
newx1	int
;	O
newPoints	*(struct(int,int))
->	O
y	int
=	O
y	int
;	O
*	O
newWidths	*(int)
=	O
(	O
unsigned	O
int	O
)	O
(	O
newx2	int
-	O
newx1	int
)	O
;	O
newPoints	*(struct(int,int))
++	O
;	O
newWidths	*(int)
++	O
;	O
newx1	int
=	O
oldpt	int
;	O
newx2	int
=	O
oldpt	int
+	O
(	O
int	O
)	O
(	O
*	O
oldWidths	*(int)
)	O
;	O
}	O
else	O
{	O
oldpt	int
=	O
oldpt	int
+	O
(	O
int	O
)	O
(	O
*	O
oldWidths	*(int)
)	O
;	O
if	O
(	O
oldpt	int
>	O
newx2	int
)	O
newx2	int
=	O
oldpt	int
;	O
}	O
}	O
newPoints	*(struct(int,int))
->	O
x	int
=	O
newx1	int
;	O
*	O
newWidths	*(int)
=	O
(	O
unsigned	O
int	O
)	O
(	O
newx2	int
-	O
newx1	int
)	O
;	O
newPoints	*(struct(int,int))
->	O
y	int
=	O
y	int
;	O
return	O
(	O
int	O
)	O
(	O
(	O
newWidths	*(int)
-	O
startNewWidths	*(int)
)	O
+	O
1	int
)	O
;	O
}	O
